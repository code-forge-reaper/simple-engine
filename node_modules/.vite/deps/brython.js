import {
  __commonJS
} from "./chunk-BUSYA2B4.js";

// node_modules/.pnpm/brython@3.14.0/node_modules/brython/brython.js
var require_brython = __commonJS({
  "node_modules/.pnpm/brython@3.14.0/node_modules/brython/brython.js"(exports, module) {
    var __BRYTHON__ = globalThis.__BRYTHON__ || {};
    try {
      eval("async function* f(){}");
    } catch (err) {
      console.warn("Your browser is not fully supported. If you are using Microsoft Edge, please upgrade to the latest version");
    }
    (function($B2) {
      $B2.isWebWorker = "undefined" !== typeof WorkerGlobalScope && "function" === typeof importScripts && navigator instanceof WorkerNavigator;
      $B2.isNode = typeof process !== "undefined" && process.release.name === "node" && process.__nwjs !== 1;
      var _window = globalThis;
      _window.location ||= { href: "", origin: "", pathname: "" };
      _window.navigator ||= { userLanguage: "" };
      _window.document ||= {
        getElementsByTagName: () => [{ src: "http://localhost/" }],
        currentScript: { src: "http://localhost/" },
        querySelectorAll: () => []
      };
      _window.HTMLElement ||= class HTMLElement {
      };
      _window.MutationObserver ||= function() {
        this.observe = () => {
        };
      };
      _window.customElements ||= { define: () => {
      } };
      var href = _window.location.href;
      $B2.protocol = href.split(":")[0];
      $B2.BigInt = _window.BigInt;
      $B2.indexedDB = _window.indexedDB;
      if ($B2.brython_path === void 0) {
        var this_url;
        if ($B2.isWebWorker) {
          this_url = _window.location.href;
          if (this_url.startsWith("blob:")) {
            this_url = this_url.substr(5);
          }
        } else {
          this_url = document.currentScript.src;
        }
        var elts = this_url.split("/");
        elts.pop();
        $B2.brython_path = elts.join("/") + "/";
      } else {
        if (!$B2.brython_path.endsWith("/")) {
          $B2.brython_path += "/";
        }
      }
      var parts_re = new RegExp("(.*?)://(.*?)/(.*)"), mo = parts_re.exec($B2.brython_path);
      if (mo) {
        $B2.full_url = { protocol: mo[1], host: mo[2], address: mo[3] };
        if (["http", "https"].includes(mo[1])) {
          $B2.domain = mo[1] + "://" + mo[2];
        }
      }
      var path = _window.location.origin + _window.location.pathname, path_elts = path.split("/");
      path_elts.pop();
      $B2.script_dir = path_elts.join("/");
      mo = parts_re.exec($B2.script_dir);
      if (mo) {
        if (["http", "https"].includes(mo[1])) {
          $B2.script_domain = mo[1] + "://" + mo[2];
        }
      } else {
        var parts_re_root = new RegExp("(.*?)://(.*?)"), mo = parts_re_root.exec($B2.script_dir);
        if (mo && ["http", "https"].includes(mo[1])) {
          $B2.script_domain = $B2.script_dir;
        }
      }
      $B2.strip_host = function(url) {
        try {
          var parsed_url = new URL(url);
          return parsed_url.pathname.substr(1) + parsed_url.search + parsed_url.hash;
        } catch {
          console.log(Error().stack);
          throw Error("not a url: " + url);
        }
      };
      var href = $B2.script_path = _window.location.href.split("#")[0], href_elts = href.split("/");
      href_elts.pop();
      if ($B2.isWebWorker || $B2.isNode) {
        href_elts.pop();
      }
      $B2.curdir = href_elts.join("/");
      $B2.webworkers = {};
      $B2.file_cache = {};
      $B2.url2name = {};
      $B2.scripts = {};
      $B2.import_info = {};
      $B2.imported = {};
      $B2.precompiled = {};
      $B2.frame_obj = null;
      $B2.builtins = /* @__PURE__ */ Object.create(null);
      $B2.builtins_scope = { id: "__builtins__", module: "__builtins__", binding: {} };
      $B2.language = _window.navigator.userLanguage || _window.navigator.language;
      $B2.locale = "C";
      var date = /* @__PURE__ */ new Date();
      var formatter = new Intl.DateTimeFormat($B2.language, { timeZoneName: "short" }), short = formatter.format(date);
      formatter = new Intl.DateTimeFormat($B2.language, { timeZoneName: "long" });
      var long = formatter.format(date);
      var ix = 0, minlen = Math.min(short.length, long.length);
      while (ix < minlen && short[ix] == long[ix]) {
        ix++;
      }
      $B2.tz_name = long.substr(ix).trim();
      $B2.PyCF_ONLY_AST = 1024;
      $B2.PyCF_TYPE_COMMENTS = 4096;
      $B2.CO_FUTURE_ANNOTATIONS = 16777216;
      $B2.PyCF_ALLOW_INCOMPLETE_INPUT = 16384;
      $B2.COMPILER_FLAGS = { OPTIMIZED: 1, NEWLOCALS: 2, VARARGS: 4, VARKEYWORDS: 8, NESTED: 16, GENERATOR: 32, NOFREE: 64, COROUTINE: 128, ITERABLE_COROUTINE: 256, ASYNC_GENERATOR: 512 };
      var DEF_GLOBAL = 1, DEF_LOCAL = 2, DEF_PARAM = 2 << 1, DEF_NONLOCAL = 2 << 2, USE = 2 << 3, DEF_FREE = 2 << 4, DEF_FREE_CLASS = 2 << 5, DEF_IMPORT = 2 << 6, DEF_ANNOT = 2 << 7, DEF_COMP_ITER = 2 << 8, DEF_TYPE_PARAM = 2 << 9, DEF_COMP_CELL = 2 << 10;
      var DEF_BOUND = DEF_LOCAL | DEF_PARAM | DEF_IMPORT;
      var SCOPE_OFFSET = 12, SCOPE_OFF = SCOPE_OFFSET, SCOPE_MASK = DEF_GLOBAL | DEF_LOCAL | DEF_PARAM | DEF_NONLOCAL;
      var LOCAL = 1, GLOBAL_EXPLICIT = 2, GLOBAL_IMPLICIT = 3, FREE = 4, CELL = 5;
      var TYPE_CLASS = 1, TYPE_FUNCTION = 0, TYPE_MODULE = 2;
      $B2.SYMBOL_FLAGS = {
        DEF_GLOBAL,
        DEF_LOCAL,
        DEF_PARAM,
        DEF_NONLOCAL,
        USE,
        DEF_FREE,
        DEF_FREE_CLASS,
        DEF_IMPORT,
        DEF_ANNOT,
        DEF_COMP_ITER,
        DEF_TYPE_PARAM,
        DEF_COMP_CELL,
        DEF_BOUND,
        SCOPE_OFFSET,
        SCOPE_OFF,
        SCOPE_MASK,
        LOCAL,
        GLOBAL_EXPLICIT,
        GLOBAL_IMPLICIT,
        FREE,
        CELL,
        TYPE_CLASS,
        TYPE_FUNCTION,
        TYPE_MODULE
      };
      $B2.max_int = Math.pow(2, 53) - 1;
      $B2.min_int = -$B2.max_int;
      $B2.int_max_str_digits = 4300;
      $B2.str_digits_check_threshold = 640;
      $B2.max_array_size = 2 ** 32 - 1;
      $B2.recursion_limit = 900;
      $B2.op2method = { operations: { "**": "pow", "//": "floordiv", "<<": "lshift", ">>": "rshift", "+": "add", "-": "sub", "*": "mul", "/": "truediv", "%": "mod", "@": "matmul" }, augmented_assigns: { "//=": "ifloordiv", ">>=": "irshift", "<<=": "ilshift", "**=": "ipow", "+=": "iadd", "-=": "isub", "*=": "imul", "/=": "itruediv", "%=": "imod", "&=": "iand", "|=": "ior", "^=": "ixor", "@=": "imatmul" }, binary: { "&": "and", "|": "or", "~": "invert", "^": "xor" }, comparisons: { "<": "lt", ">": "gt", "<=": "le", ">=": "ge", "==": "eq", "!=": "ne" }, boolean: { "or": "or", "and": "and", "in": "in", "not": "not", "is": "is" }, subset: function() {
        var res = {}, keys = [];
        if (arguments[0] == "all") {
          keys = Object.keys($B2.op2method);
          keys.splice(keys.indexOf("subset"), 1);
        } else {
          for (var arg of arguments) {
            keys.push(arg);
          }
        }
        for (var key2 of keys) {
          var ops = $B2.op2method[key2];
          if (ops === void 0) {
            throw Error(key2);
          }
          for (var attr in ops) {
            res[attr] = ops[attr];
          }
        }
        return res;
      } };
      $B2.method_to_op = {};
      for (var category in $B2.op2method) {
        for (var op in $B2.op2method[category]) {
          var method = `__${$B2.op2method[category][op]}__`;
          $B2.method_to_op[method] = op;
        }
      }
      $B2.special_string_repr = { 8: "\\x08", 9: "\\t", 10: "\\n", 11: "\\x0b", 12: "\\x0c", 13: "\\r", 92: "\\\\", 160: "\\xa0" };
      $B2.$py_next_hash = Math.pow(2, 53) - 1;
      $B2.$py_UUID = Math.floor(Math.random() * 2 ** 50);
      $B2.lambda_magic = Math.random().toString(36).substr(2, 8);
      const func_attrs = [
        "__module__",
        "__name__",
        "__qualname__",
        "__file__",
        "__defaults__",
        "__kwdefaults__",
        "__doc__",
        "arg_names",
        "args_vararg",
        "args_kwarg",
        "positional_length",
        "lineno",
        "flags",
        "free_vars",
        "kwonlyargs_length",
        "posonlyargs_length",
        "varnames",
        "__annotations__",
        "__type_params__",
        "method_class"
      ];
      var i = 0;
      $B2.func_attrs = {};
      for (var func_attr of func_attrs) {
        $B2.func_attrs[func_attr] = i++;
      }
      $B2.set_func_names = function(klass, module2) {
        klass.__module__ = module2;
        for (var attr in klass) {
          if (typeof klass[attr] == "function") {
            $B2.add_function_infos(klass, attr);
          }
        }
      };
      $B2.add_function_infos = function(klass, attr) {
        var module2 = klass.__module__;
        $B2.set_function_infos(
          klass[attr],
          { __doc__: klass[attr].__doc__ || "", __module__: module2, __name__: attr, __qualname__: klass.__qualname__ + "." + attr, __defaults__: [], __kwdefaults__: {} }
        );
        if (klass[attr].$type == "classmethod") {
          klass[attr].__class__ = $B2.method;
        }
      };
      $B2.set_function_infos = function(f, attrs) {
        f.$function_infos = f.$function_infos ?? [];
        for (var key2 in attrs) {
          if ($B2.func_attrs[key2] === void 0) {
            throw Error("no function attribute " + key2);
          }
          f.$function_infos[$B2.func_attrs[key2]] = attrs[key2];
        }
      };
      $B2.set_function_attr = function(func, attr, value2) {
        if ($B2.func_attrs[attr] === void 0) {
          throw Error("no function attribute " + attr);
        }
        func.$function_infos[$B2.func_attrs[attr]] = value2;
      };
      var has_storage = typeof Storage !== "undefined";
      if (has_storage) {
        $B2.has_local_storage = false;
        try {
          if (localStorage) {
            $B2.local_storage = localStorage;
            $B2.has_local_storage = true;
          }
        } catch (err) {
        }
        $B2.has_session_storage = false;
        try {
          if (sessionStorage) {
            $B2.session_storage = sessionStorage;
            $B2.has_session_storage = true;
          }
        } catch (err) {
        }
      } else {
        $B2.has_local_storage = false;
        $B2.has_session_storage = false;
      }
      $B2.globals = function() {
        return $B2.frame_obj.frame[3];
      };
      $B2.$options = {};
      $B2.builtins_repr_check = function(builtin2, args) {
        var $ = $B2.args("__repr__", 1, { self: null }, ["self"], args, {}, null, null), self2 = $.self;
        if (!$B2.$isinstance(self2, builtin2)) {
          var _b_2 = $B2.builtins;
          throw _b_2.TypeError.$factory(`descriptor '__repr__' requires a '${builtin2.__name__}' object but received a '${$B2.class_name(self2)}'`);
        }
      };
      $B2.update_VFS = function(scripts) {
        $B2.VFS = $B2.VFS || {};
        var vfs_timestamp = scripts.$timestamp;
        if (vfs_timestamp !== void 0) {
          delete scripts.$timestamp;
        }
        for (var script in scripts) {
          if ($B2.VFS.hasOwnProperty(script)) {
            console.warn("Virtual File System: duplicate entry " + script);
          }
          $B2.VFS[script] = scripts[script];
          $B2.VFS[script].timestamp = vfs_timestamp;
        }
        $B2.stdlib_module_names = Object.keys($B2.VFS);
      };
      $B2.add_files = function(files) {
        $B2.files = $B2.files || {};
        for (var file in files) {
          $B2.files[file] = files[file];
        }
      };
      $B2.has_file = function(file) {
        return $B2.files && $B2.files.hasOwnProperty(file);
      };
      $B2.show_tokens = function(src, mode) {
        for (var token of $B2.tokenizer(src, "<string>", mode || "file")) {
          console.log(token.type, $B2.builtins.repr(token.string), `[${token.lineno}.${token.col_offset}-${token.end_lineno}.${token.end_col_offset}]`, token.line);
        }
      };
      function from_py(src, script_id) {
        if (!$B2.options_parsed) {
          $B2.parse_options();
        }
        script_id = script_id || "python_script_" + $B2.UUID();
        var filename = $B2.script_path + "#" + script_id;
        $B2.url2name[filename] = script_id;
        $B2.imported[script_id] = {};
        var root = __BRYTHON__.py2js({ src, filename }, script_id, script_id, __BRYTHON__.builtins_scope);
        return root.to_js();
      }
      $B2.getPythonModule = function(name2) {
        return $B2.imported[name2];
      };
      $B2.pythonToAST = function(python_code, filename, mode) {
        let parser = new $B2.Parser(python_code, filename ?? "test", mode ?? "file");
        return $B2._PyPegen.run_parser(parser);
      };
      $B2.python_to_js = function(src, script_id) {
        return "(function() {\n" + from_py(src, script_id) + "\nreturn locals}())";
      };
      $B2.pythonToJS = $B2.python_to_js;
      var fakeScript = $B2.fakeScript = function(filename) {
        this.options = {};
      };
      fakeScript.prototype.getAttribute = function(key2) {
        return this.options[key2] ?? null;
      };
      fakeScript.prototype.dispatchEvent = function() {
      };
      $B2.runPythonSource = function(src, options) {
        var script_id;
        if (options) {
          if (typeof options == "string") {
            script_id = options;
          } else if (options.constructor === Object) {
            if (options.hasOwnProperty("id")) {
              script_id = options.id;
              delete options.id;
            }
          } else {
            console.debug("invalid options argument:", options);
          }
        }
        var script = new fakeScript(), url = $B2.script_path = globalThis.location.href.split("#")[0];
        if (options) {
          for (var [key2, value2] of Object.entries(options)) {
            script.options[key2] = value2;
          }
        }
        script_id = script_id ?? "python_script_" + $B2.UUID();
        $B2.run_script(script, src, script_id, url, true);
        return $B2.imported[script_id];
      };
      $B2.importPythonModule = function(name2, options) {
        return $B2.runPythonSource("import " + name2, options);
      };
    })(__BRYTHON__);
    __BRYTHON__.ast_classes = { Add: "", And: "", AnnAssign: "target,annotation,value?,simple", Assert: "test,msg?", Assign: "targets*,value,type_comment?", AsyncFor: "target,iter,body*,orelse*,type_comment?", AsyncFunctionDef: "name,args,body*,decorator_list*,returns?,type_comment?,type_params*", AsyncWith: "items*,body*,type_comment?", Attribute: "value,attr,ctx", AugAssign: "target,op,value", Await: "value", BinOp: "left,op,right", BitAnd: "", BitOr: "", BitXor: "", BoolOp: "op,values*", Break: "", Call: "func,args*,keywords*", ClassDef: "name,bases*,keywords*,body*,decorator_list*,type_params*", Compare: "left,ops*,comparators*", Constant: "value,kind?", Continue: "", Del: "", Delete: "targets*", Dict: "keys*,values*", DictComp: "key,value,generators*", Div: "", Eq: "", ExceptHandler: "type?,name?,body*", Expr: "value", Expression: "body", FloorDiv: "", For: "target,iter,body*,orelse*,type_comment?", FormattedValue: "value,conversion,format_spec?", FunctionDef: "name,args,body*,decorator_list*,returns?,type_comment?,type_params*", FunctionType: "argtypes*,returns", GeneratorExp: "elt,generators*", Global: "names*", Gt: "", GtE: "", If: "test,body*,orelse*", IfExp: "test,body,orelse", Import: "names*", ImportFrom: "module?,names*,level?", In: "", Interactive: "body*", Interpolation: "value,str,conversion,format_spec?", Invert: "", Is: "", IsNot: "", JoinedStr: "values*", LShift: "", Lambda: "args,body", List: "elts*,ctx", ListComp: "elt,generators*", Load: "", Lt: "", LtE: "", MatMult: "", Match: "subject,cases*", MatchAs: "pattern?,name?", MatchClass: "cls,patterns*,kwd_attrs*,kwd_patterns*", MatchMapping: "keys*,patterns*,rest?", MatchOr: "patterns*", MatchSequence: "patterns*", MatchSingleton: "value", MatchStar: "name?", MatchValue: "value", Mod: "", Module: "body*,type_ignores*", Mult: "", Name: "id,ctx", NamedExpr: "target,value", Nonlocal: "names*", Not: "", NotEq: "", NotIn: "", Or: "", ParamSpec: "name,default_value?", Pass: "", Pow: "", RShift: "", Raise: "exc?,cause?", Return: "value?", Set: "elts*", SetComp: "elt,generators*", Slice: "lower?,upper?,step?", Starred: "value,ctx", Store: "", Sub: "", Subscript: "value,slice,ctx", TemplateStr: "values*", Try: "body*,handlers*,orelse*,finalbody*", TryStar: "body*,handlers*,orelse*,finalbody*", Tuple: "elts*,ctx", TypeAlias: "name,type_params*,value", TypeIgnore: "lineno,tag", TypeVar: "name,bound?,default_value?", TypeVarTuple: "name,default_value?", UAdd: "", USub: "", UnaryOp: "op,operand", While: "test,body*,orelse*", With: "items*,body*,type_comment?", Yield: "value?", YieldFrom: "value", alias: "name,asname?", arg: "arg,annotation?,type_comment?", arguments: "posonlyargs*,args*,vararg?,kwonlyargs*,kw_defaults*,kwarg?,defaults*", boolop: ["And", "Or"], cmpop: ["Eq", "NotEq", "Lt", "LtE", "Gt", "GtE", "Is", "IsNot", "In", "NotIn"], comprehension: "target,iter,ifs*,is_async", excepthandler: ["ExceptHandler"], expr: ["BoolOp", "NamedExpr", "BinOp", "UnaryOp", "Lambda", "IfExp", "Dict", "Set", "ListComp", "SetComp", "DictComp", "GeneratorExp", "Await", "Yield", "YieldFrom", "Compare", "Call", "FormattedValue", "Interpolation", "JoinedStr", "TemplateStr", "Constant", "Attribute", "Subscript", "Starred", "Name", "List", "Tuple", "Slice"], expr_context: ["Load", "Store", "Del"], keyword: "arg?,value", match_case: "pattern,guard?,body*", mod: ["Module", "Interactive", "Expression", "FunctionType"], operator: ["Add", "Sub", "Mult", "MatMult", "Div", "Mod", "Pow", "LShift", "RShift", "BitOr", "BitXor", "BitAnd", "FloorDiv"], pattern: ["MatchValue", "MatchSingleton", "MatchSequence", "MatchMapping", "MatchClass", "MatchStar", "MatchAs", "MatchOr"], stmt: ["FunctionDef", "AsyncFunctionDef", "ClassDef", "Return", "Delete", "Assign", "TypeAlias", "AugAssign", "AnnAssign", "For", "AsyncFor", "While", "If", "With", "AsyncWith", "Match", "Raise", "Try", "TryStar", "Assert", "Import", "ImportFrom", "Global", "Nonlocal", "Expr", "Pass", "Break", "Continue"], type_ignore: ["TypeIgnore"], type_param: ["TypeVar", "ParamSpec", "TypeVarTuple"], unaryop: ["Invert", "Not", "UAdd", "USub"], withitem: "context_expr,optional_vars?" };
    (function($B2) {
      $B2.stdlib = {};
      var pylist = ["VFS_import", "__future__", "_aio", "_ast_unparse", "_codecs", "_codecs_jp", "_collections", "_collections_abc", "_colorize", "_compat_pickle", "_compression", "_contextvars", "_csv", "_dummy_thread", "_frozen_importlib", "_functools", "_imp", "_io", "_markupbase", "_multibytecodec", "_operator", "_py_abc", "_py_warnings", "_pydatetime", "_pydecimal", "_queue", "_signal", "_socket", "_sre", "_strptime", "_struct", "_sysconfigdata", "_sysconfigdata_0_brython_", "_testcapi", "_thread", "_threading_local", "_typing", "_weakref", "_weakrefset", "abc", "annotationlib", "antigravity", "argparse", "ast", "asyncio", "atexit", "base64", "bdb", "binascii", "bisect", "browser.ajax", "browser.highlight", "browser.idbcache", "browser.indexed_db", "browser.local_storage", "browser.markdown", "browser.object_storage", "browser.session_storage", "browser.svg", "browser.template", "browser.timer", "browser.ui", "browser.webcomponent", "browser.websocket", "browser.worker", "calendar", "cmath", "cmd", "code", "codecs", "codeop", "colorsys", "configparser", "contextlib", "contextvars", "copy", "copyreg", "csv", "dataclasses", "datetime", "decimal", "difflib", "doctest", "enum", "errno", "external_import", "faulthandler", "fnmatch", "formatter", "fractions", "functools", "gc", "genericpath", "getopt", "getpass", "gettext", "glob", "gzip", "heapq", "hmac", "imp", "inspect", "interpreter", "io", "ipaddress", "itertools", "keyword", "linecache", "locale", "mimetypes", "ntpath", "numbers", "opcode", "operator", "optparse", "os", "pathlib", "pdb", "pickle", "pkgutil", "platform", "posixpath", "pprint", "profile", "pwd", "py_compile", "pyclbr", "pydoc", "queue", "quopri", "random", "re", "re1", "reprlib", "rlcompleter", "secrets", "select", "selectors", "shlex", "shutil", "signal", "site", "site-packages.__future__", "site-packages.docs", "site-packages.header", "site-packages.test_sp", "socket", "sre_compile", "sre_constants", "sre_parse", "stat", "statistics", "string", "stringprep", "struct", "subprocess", "symtable", "sys", "sysconfig", "tabnanny", "tarfile", "tb", "tempfile", "test.namespace_pkgs.module_and_namespace_package.a_test", "textwrap", "this", "threading", "time", "timeit", "token", "tokenize", "traceback", "turtle", "types", "typing", "uuid", "warnings", "weakref", "webbrowser", "zipfile", "zipimport", "zlib"];
      for (var i = 0; i < pylist.length; i++) {
        $B2.stdlib[pylist[i]] = ["py"];
      }
      var js = ["_ajax", "_ast", "_base64", "_binascii", "_io_classes", "_json", "_jsre", "_locale", "_multiprocessing", "_posixsubprocess", "_profile", "_random", "_sre", "_sre_utils", "_string", "_svg", "_symtable", "_tokenize", "_webcomponent", "_webworker", "_zlib_utils", "aes", "array", "builtins", "dis", "encoding_cp932", "hashlib", "hmac-md5", "hmac-ripemd160", "hmac-sha1", "hmac-sha224", "hmac-sha256", "hmac-sha3", "hmac-sha384", "hmac-sha512", "html_parser", "marshal", "math", "md5", "modulefinder", "pbkdf2", "posix", "pyexpat", "python_re", "rabbit", "rabbit-legacy", "rc4", "ripemd160", "sha1", "sha224", "sha256", "sha3", "sha384", "sha512", "tripledes", "unicodedata", "xml_helpers", "xml_parser"];
      for (var i = 0; i < js.length; i++) {
        $B2.stdlib[js[i]] = ["js"];
      }
      var pkglist = ["_pyrepl", "browser", "browser.widgets", "collections", "compression", "compression._common", "compression.zstd", "concurrent", "concurrent.futures", "email", "email.mime", "encodings", "html", "http", "importlib", "importlib.metadata", "importlib.resources", "json", "logging", "multiprocessing", "multiprocessing.dummy", "pyexpat_utils", "site-packages.foobar", "site-packages.simpleaio", "site-packages.ui", "test", "test.encoded_modules", "test.leakers", "test.namespace_pkgs.not_a_namespace_pkg.foo", "test.support", "test.test_email", "test.test_importlib", "test.test_importlib.builtin", "test.test_importlib.extension", "test.test_importlib.frozen", "test.test_importlib.import_", "test.test_importlib.source", "test.test_json", "test.tracedmodules", "unittest", "unittest.test", "unittest.test.testmock", "urllib"];
      for (var i = 0; i < pkglist.length; i++) {
        $B2.stdlib[pkglist[i]] = ["py", true];
      }
      $B2.stdlib_module_names = Object.keys($B2.stdlib);
    })(__BRYTHON__);
    var $B = __BRYTHON__;
    $B.unicode = { "No_digits": [178, 179, 185, [4969, 9], 6618, 8304, [8308, 6], [8320, 10], [9312, 9], [9332, 9], [9352, 9], 9450, [9461, 9], 9471, [10102, 9], [10112, 9], [10122, 9], [68160, 4], [69216, 9], [69714, 9], [127232, 11]], "Lo_numeric": [13317, 13443, 14378, 15181, 19968, 19971, 19975, 19977, 20004, 20061, 20108, 20116, 20118, 20140, 20159, 20160, 20191, 20200, 20237, 20336, 20457, 20486, 20740, 20806, [20841, 3, 2], 21313, [21315, 3], 21324, [21441, 4], 22235, 22769, 22777, 24186, 24318, 24319, [24332, 3], 24336, 25296, 25342, 25420, 26578, 27934, 28422, 29590, 30334, 30357, 31213, 32902, 33836, 36014, 36019, 36144, 37390, 38057, 38433, 38470, 38476, 38520, 38646, 63851, 63859, 63864, 63922, 63953, 63955, 63997, 131073, 131172, 131298, 131361, 133418, 133507, 133516, 133532, 133866, 133885, 133913, 140176, 141720, 146203, 156269, 194704] };
    $B.digits_starts = [48, 1632, 1776, 1984, 2406, 2534, 2662, 2790, 2918, 3046, 3174, 3302, 3430, 3558, 3664, 3792, 3872, 4160, 4240, 6112, 6160, 6470, 6608, 6784, 6800, 6992, 7088, 7232, 7248, 42528, 43216, 43264, 43472, 43504, 43600, 44016, 65296, 66720, 68912, 68928, 69734, 69872, 69942, 70096, 70384, 70736, 70864, 71248, 71360, 71376, 71386, 71472, 71904, 72016, 72688, 72784, 73040, 73120, 73184, 73552, 90416, 92768, 92864, 93008, 93552, 118e3, 120782, 120792, 120802, 120812, 120822, 123200, 123632, 124144, 124401, 125264, 130032];
    $B.unicode_casefold = { 223: [115, 115], 304: [105, 775], 329: [700, 110], 496: [106, 780], 912: [953, 776, 769], 944: [965, 776, 769], 1415: [1381, 1410], 7830: [104, 817], 7831: [116, 776], 7832: [119, 778], 7833: [121, 778], 7834: [97, 702], 7838: [223], 8016: [965, 787], 8018: [965, 787, 768], 8020: [965, 787, 769], 8022: [965, 787, 834], 8064: [7936, 953], 8065: [7937, 953], 8066: [7938, 953], 8067: [7939, 953], 8068: [7940, 953], 8069: [7941, 953], 8070: [7942, 953], 8071: [7943, 953], 8072: [8064], 8073: [8065], 8074: [8066], 8075: [8067], 8076: [8068], 8077: [8069], 8078: [8070], 8079: [8071], 8080: [7968, 953], 8081: [7969, 953], 8082: [7970, 953], 8083: [7971, 953], 8084: [7972, 953], 8085: [7973, 953], 8086: [7974, 953], 8087: [7975, 953], 8088: [8080], 8089: [8081], 8090: [8082], 8091: [8083], 8092: [8084], 8093: [8085], 8094: [8086], 8095: [8087], 8096: [8032, 953], 8097: [8033, 953], 8098: [8034, 953], 8099: [8035, 953], 8100: [8036, 953], 8101: [8037, 953], 8102: [8038, 953], 8103: [8039, 953], 8104: [8096], 8105: [8097], 8106: [8098], 8107: [8099], 8108: [8100], 8109: [8101], 8110: [8102], 8111: [8103], 8114: [8048, 953], 8115: [945, 953], 8116: [940, 953], 8118: [945, 834], 8119: [945, 834, 953], 8124: [8115], 8130: [8052, 953], 8131: [951, 953], 8132: [942, 953], 8134: [951, 834], 8135: [951, 834, 953], 8140: [8131], 8146: [953, 776, 768], 8147: [912], 8150: [953, 834], 8151: [953, 776, 834], 8162: [965, 776, 768], 8163: [944], 8164: [961, 787], 8166: [965, 834], 8167: [965, 776, 834], 8178: [8060, 953], 8179: [969, 953], 8180: [974, 953], 8182: [969, 834], 8183: [969, 834, 953], 8188: [8179], 64256: [102, 102], 64257: [102, 105], 64258: [102, 108], 64259: [102, 102, 105], 64260: [102, 102, 108], 64261: [64262], 64262: [115, 116], 64275: [1396, 1398], 64276: [1396, 1381], 64277: [1396, 1387], 64278: [1406, 1398], 64279: [1396, 1389] };
    $B.unicode_bidi_whitespace = [9, 10, 11, 12, 13, 28, 29, 30, 31, 32, 133, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8287, 12288];
    __BRYTHON__.implementation = [3, 14, 0, "dev", 0];
    __BRYTHON__.version_info = [3, 14, 0, "final", 0];
    __BRYTHON__.compiled_date = "2025-10-11 17:14:35.766098";
    __BRYTHON__.timestamp = 1760195675765;
    __BRYTHON__.builtin_module_names = ["_ajax", "_ast", "_base64", "_binascii", "_io_classes", "_json", "_jsre", "_locale", "_multiprocessing", "_posixsubprocess", "_profile", "_random", "_sre", "_sre_utils", "_string", "_svg", "_symtable", "_tokenize", "_webcomponent", "_webworker", "_zlib_utils", "_zlib_utils1", "_zlib_utils_kozh", "array", "builtins", "dis", "encoding_cp932", "encoding_cp932_v2", "hashlib", "html_parser", "marshal", "math", "modulefinder", "posix", "pyexpat", "python_re", "python_re_new", "unicodedata", "xml_helpers", "xml_parser", "xml_parser_backup"];
    (function($B2) {
      const tokens = [
        "ENDMARKER",
        "NAME",
        "NUMBER",
        "STRING",
        "NEWLINE",
        "INDENT",
        "DEDENT",
        "LPAR",
        "RPAR",
        "LSQB",
        "RSQB",
        "COLON",
        "COMMA",
        "SEMI",
        "PLUS",
        "MINUS",
        "STAR",
        "SLASH",
        "VBAR",
        "AMPER",
        "LESS",
        "GREATER",
        "EQUAL",
        "DOT",
        "PERCENT",
        "LBRACE",
        "RBRACE",
        "EQEQUAL",
        "NOTEQUAL",
        "LESSEQUAL",
        "GREATEREQUAL",
        "TILDE",
        "CIRCUMFLEX",
        "LEFTSHIFT",
        "RIGHTSHIFT",
        "DOUBLESTAR",
        "PLUSEQUAL",
        "MINEQUAL",
        "STAREQUAL",
        "SLASHEQUAL",
        "PERCENTEQUAL",
        "AMPEREQUAL",
        "VBAREQUAL",
        "CIRCUMFLEXEQUAL",
        "LEFTSHIFTEQUAL",
        "RIGHTSHIFTEQUAL",
        "DOUBLESTAREQUAL",
        "DOUBLESLASH",
        "DOUBLESLASHEQUAL",
        "AT",
        "ATEQUAL",
        "RARROW",
        "ELLIPSIS",
        "COLONEQUAL",
        "EXCLAMATION",
        "OP",
        "TYPE_IGNORE",
        "TYPE_COMMENT",
        "SOFT_KEYWORD",
        "FSTRING_START",
        "FSTRING_MIDDLE",
        "FSTRING_END",
        "TSTRING_START",
        "TSTRING_MIDDLE",
        "TSTRING_END",
        "COMMENT",
        "NL",
        "ERRORTOKEN",
        "ENCODING",
        "N_TOKENS"
      ];
      $B2.py_tokens = {};
      var pos2 = 0;
      for (var tok of tokens) {
        $B2.py_tokens[tok] = pos2++;
      }
      $B2.py_tokens["NT_OFFSET"] = 256;
      $B2.EXACT_TOKEN_TYPES = { "!": "EXCLAMATION", "!=": "NOTEQUAL", "%": "PERCENT", "%=": "PERCENTEQUAL", "&": "AMPER", "&=": "AMPEREQUAL", "(": "LPAR", ")": "RPAR", "*": "STAR", "**": "DOUBLESTAR", "**=": "DOUBLESTAREQUAL", "*=": "STAREQUAL", "+": "PLUS", "+=": "PLUSEQUAL", ",": "COMMA", "-": "MINUS", "-=": "MINEQUAL", "->": "RARROW", ".": "DOT", "...": "ELLIPSIS", "/": "SLASH", "//": "DOUBLESLASH", "//=": "DOUBLESLASHEQUAL", "/=": "SLASHEQUAL", ":": "COLON", ":=": "COLONEQUAL", ";": "SEMI", "<": "LESS", "<<": "LEFTSHIFT", "<<=": "LEFTSHIFTEQUAL", "<=": "LESSEQUAL", "=": "EQUAL", "==": "EQEQUAL", ">": "GREATER", ">=": "GREATEREQUAL", ">>": "RIGHTSHIFT", ">>=": "RIGHTSHIFTEQUAL", "@": "AT", "@=": "ATEQUAL", "[": "LSQB", "]": "RSQB", "^": "CIRCUMFLEX", "^=": "CIRCUMFLEXEQUAL", "{": "LBRACE", "|": "VBAR", "|=": "VBAREQUAL", "}": "RBRACE", "~": "TILDE" };
      function ISTERMINAL(x) {
        return x < NT_OFFSET;
      }
      function ISNONTERMINAL(x) {
        return x >= NT_OFFSET;
      }
      function ISEOF(x) {
        return x == ENDMARKER;
      }
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      function is_whitespace(char) {
        return " \n\r	\f".includes(char);
      }
      var unprintable_re = new RegExp("\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}|\\p{Zl}|\\p{Zp}|\\p{Zs}", "u");
      const Other_ID_Start = [6277, 6278, 8472, 8494, 12443, 12444].map(
        (x) => String.fromCodePoint(x)
      );
      function is_ID_Start(char) {
        return new RegExp("\\p{Letter}", "u").test(char) || new RegExp("\\p{Nl}", "u").test(char) || char == "_" || Other_ID_Start.includes(char);
      }
      const Other_ID_Continue = [183, 903, 4969, 4976, 4977, 6618, 8204, 8205, 12539, 65381].map((x) => String.fromCodePoint(x));
      function is_ID_Continue(char) {
        return is_ID_Start(char) || new RegExp("\\p{Mn}|\\p{Mc}|\\p{Nd}|\\p{Pc}", "u").test(char) || Other_ID_Continue.includes(char);
      }
      $B2.is_XID_Start = function(cp) {
        let char = String.fromCodePoint(cp);
        if (!is_ID_Start(char)) {
          return false;
        }
        var norm = char.normalize("NFKC");
        if (!is_ID_Start(norm[0])) {
          return false;
        }
        for (let char2 of norm.substr(1)) {
          if (!is_ID_Continue(char2)) {
            return false;
          }
        }
        return true;
      };
      $B2.is_XID_Continue = function(cp) {
        let char = String.fromCodePoint(cp);
        if (!is_ID_Continue(char)) {
          return false;
        }
        var norm = char.normalize("NFKC");
        for (let char2 of norm.substr(1)) {
          if (!is_ID_Continue(char2)) {
            return false;
          }
        }
        return true;
      };
      $B2.in_unicode_category = function(category, cp) {
        if (isNaN(cp)) {
          return false;
        }
        try {
          var re = new RegExp("\\p{" + category + "}", "u");
          return re.test(String.fromCodePoint(cp));
        } catch (err) {
          return in_unicode_category(category, cp);
        }
      };
      function in_unicode_category(category, cp) {
        var table = $B2.unicode[category], start = 0, end = table.length - 1, len = table.length, ix = Math.floor(len / 2), nb = 0;
        var first = table[start], item2 = typeof first == "number" ? first : first[0];
        if (cp < item2) {
          return false;
        }
        var last = table[end];
        if (typeof last == "number") {
          if (cp > last) {
            return false;
          }
        } else if (last[0] + last[1] < cp) {
          return false;
        }
        while (true) {
          nb++;
          if (nb > 100) {
            console.log("infinite loop for", cp);
            alert();
          }
          item2 = table[ix];
          if (typeof item2 != "number") {
            item2 = item2[0];
          }
          if (item2 == cp) {
            return true;
          } else if (item2 > cp) {
            end = ix;
          } else {
            start = ix;
          }
          len = Math.floor((end - start) / 2);
          if (end - start == 1) {
            break;
          }
          ix = start + len;
        }
        var step = table[start][2];
        if (step === void 0) {
          return table[start][0] + table[start][1] > cp;
        }
        return table[start][0] + step * table[start][1] > cp && (cp - table[start][0]) % step == 0;
      }
      const FT_START = { f: "FSTRING_START", t: "TSTRING_START" }, FT_MIDDLE = { f: "FSTRING_MIDDLE", t: "TSTRING_MIDDLE" }, FT_END = { f: "FSTRING_END", t: "TSTRING_END" };
      function ord(char) {
        if (char.length == 1) {
          return char.charCodeAt(0);
        }
        var code = 65536;
        code += (char.charCodeAt(0) & 1023) << 10;
        code += char.charCodeAt(1) & 1023;
        return code;
      }
      function $last(array) {
        return array[array.length - 1];
      }
      function raise_error(err_type, filename, lineno, col_offset, end_lineno, end_col_offset, line, message) {
        var exc = err_type.$factory(message);
        exc.filename = filename;
        exc.lineno = lineno;
        exc.offset = col_offset;
        exc.end_lineno = end_lineno;
        exc.end_offset = end_col_offset;
        exc.text = line;
        var args1 = [filename, lineno, col_offset, line.trimRight(), end_lineno, end_col_offset];
        exc.args = $B2.fast_tuple([message, $B2.fast_tuple(args1)]);
        throw exc;
      }
      var ops = ".,:;+-*/%~^|&=<>[](){}@", op2 = ["**", "//", ">>", "<<"], augm_op = "+-*/%^|&=<>@", closing = { "}": "{", "]": "[", ")": "(" };
      function ErrorToken(err_type, filename, lineno, col_offset, end_lineno, end_col_offset, line, message) {
        var token = Token2("ERRORTOKEN", "", lineno, col_offset, end_lineno, end_col_offset, line);
        token.message = message;
        return token;
      }
      function ErrorTokenKnownToken() {
        var args = Array.from(arguments);
        args.$error_token_known_token = true;
        return args;
      }
      function Token2(type, string, lineno, col_offset, end_lineno, end_col_offset, line) {
        var res = { type, string, line, lineno, col_offset, end_lineno, end_col_offset };
        res.type = res.num_type = $B2.py_tokens[type];
        if (type == "OP") {
          res.num_type = $B2.py_tokens[$B2.EXACT_TOKEN_TYPES[string]];
        } else if (type == "ENCODING") {
          res.parser_ignored = true;
        } else if (type == "NL" || type == "COMMENT") {
          res.parser_ignored = true;
        }
        res.bytes = res.string;
        return res;
      }
      function get_comment(parser, src, pos2, line_num, line_start, token_name, line) {
        var start = pos2, ix;
        var t = [];
        while (true) {
          if (pos2 >= src.length || (ix = "\r\n".indexOf(src[pos2])) > -1) {
            if (parser && parser.flags & $B2.PyCF_TYPE_COMMENTS) {
              var comment = src.substring(start - 1, pos2), mo = /^#\s*type\s*:(.*)/.exec(comment);
              if (mo) {
                var is_type_ignore = false;
                if (mo[1].startsWith("ignore")) {
                  if (mo[1].length == 6) {
                    is_type_ignore = true;
                  } else {
                    var char = mo[1][6];
                    if (char.charCodeAt(0) <= 128 && /[a-zA-Z0-9]/.exec(char) === null) {
                      is_type_ignore = true;
                    }
                  }
                }
                if (is_type_ignore) {
                  t.push(Token2("TYPE_IGNORE", comment, line_num, start - line_start, line_num, pos2 - line_start + 1, line));
                } else {
                  t.push(Token2("TYPE_COMMENT", comment, line_num, start - line_start, line_num, pos2 - line_start + 1, line));
                }
                return { t, pos: pos2 };
              }
            }
            t.push(Token2("COMMENT", src.substring(start - 1, pos2), line_num, start - line_start, line_num, pos2 - line_start + 1, line));
            if (ix !== void 0) {
              var nb = 1;
              if (src[pos2] == "\r" && src[pos2 + 1] == "\n") {
                nb++;
              } else if (src[pos2] === void 0) {
                nb = 0;
              }
              t.push(Token2(token_name, src.substr(pos2, nb), line_num, pos2 - line_start + 1, line_num, pos2 - line_start + nb + 1, line));
              if (src[pos2] === void 0) {
                t.push(Token2("NEWLINE", "\n", line_num, pos2 - line_start + 1, line_num, pos2 - line_start + 2, ""));
              }
              pos2 += nb;
            }
            return { t, pos: pos2 };
          }
          pos2++;
        }
      }
      function test_num(num_type, char) {
        switch (num_type) {
          case "":
            return $B2.in_unicode_category("Nd", ord(char));
          case "x":
            return "0123456789abcdef".includes(char.toLowerCase());
          case "b":
            return "01".includes(char);
          case "o":
            return "01234567".includes(char);
          default:
            throw Error("unknown num type " + num_type);
        }
      }
      function nesting_level(token_modes) {
        var ix = token_modes.length - 1;
        while (ix >= 0) {
          var mode = token_modes[ix];
          if (mode.nesting !== void 0) {
            return mode.nesting;
          }
          ix--;
        }
      }
      $B2.tokenizer = function(src, filename, mode, parser) {
        var string_prefix = /^(r|u|R|U|f|F|t|T||fr|Fr|fR|FR|rf|rF|Rf|RF||tr|Tr|tR|TR|rt|rT|Rt|RT)$/, bytes_prefix = /^(b|B|br|Br|bR|BR|rb|rB|Rb|RB)$/, t = [];
        if (mode != "eval" && !src.endsWith("\n")) {
          src += "\n";
        }
        var lines = src.split("\n"), linenum = 0, line_at = {};
        for (let i2 = 0, len = src.length; i2 < len; i2++) {
          line_at[i2] = linenum;
          if (src[i2] == "\n") {
            linenum++;
          }
        }
        function get_line_at(pos3) {
          return lines[line_at[pos3]] + "\n";
        }
        var state = "line_start", char, cp, mo, pos2 = 0, quote, triple_quote, escaped = false, string_start, string, prefix, name2, number, num_type, comment, indent, indent_before_continuation = 0, indents = [], braces = [], line, line_num = 0, line_start = 1, token_modes = ["regular"], token_mode = "regular", save_mode = token_mode, format_specifier, ft_type, ft_buffer, ft_start, ft_expr_start, ft_escape, ft_format_spec;
        if (parser) {
          parser.braces = braces;
        }
        t.push(Token2("ENCODING", "utf-8", 0, 0, 0, 0, ""));
        while (pos2 < src.length) {
          char = src[pos2];
          cp = src.charCodeAt(pos2);
          if (cp >= 55296 && cp <= 56319) {
            cp = ord(src.substr(pos2, 2));
            char = src.substr(pos2, 2);
            pos2++;
          }
          pos2++;
          if (token_mode != save_mode) {
            if (token_mode == "ft") {
              ft_buffer = "";
              ft_escape = false;
            } else if (token_mode == "format_specifier") {
              format_specifier = "";
            }
          }
          save_mode = token_mode;
          if (token_mode == "ft") {
            if (char == token_mode.quote) {
              if (ft_escape) {
                ft_buffer += "\\" + char;
                ft_escape = false;
                continue;
              }
              if (token_mode.triple_quote) {
                if (src.substr(pos2, 2) != token_mode.quote.repeat(2)) {
                  ft_buffer += char;
                  continue;
                }
                char = token_mode.quote.repeat(3);
                pos2 += 2;
              }
              if (ft_buffer.length > 0) {
                t.push(Token2(FT_MIDDLE[ft_type], ft_buffer, line_num, ft_start, line_num, ft_start + ft_buffer.length, line));
              }
              t.push(Token2(FT_END[ft_type], char, line_num, pos2 - line_start, line_num, pos2 - line_start + 1, line));
              token_modes.pop();
              token_mode = $B2.last(token_modes);
              state = null;
              continue;
            } else if (char == "{") {
              if (src.charAt(pos2) == "{") {
                ft_buffer += char;
                pos2++;
                continue;
              } else {
                if (ft_buffer.length > 0) {
                  t.push(Token2(FT_MIDDLE[ft_type], ft_buffer, line_num, ft_start, line_num, ft_start + ft_buffer.length, line));
                }
                token_mode = "regular_within_ft";
                ft_expr_start = pos2 - line_start;
                state = null;
                token_modes.push(token_mode);
              }
            } else if (char == "}") {
              if (src.charAt(pos2) == "}") {
                ft_buffer += char;
                pos2++;
                continue;
              } else {
                t.push(Token2("OP", char, line_num, pos2 - line_start, line_num, pos2 - line_start + 1, line));
                continue;
              }
            } else if (char == "\\") {
              if (token_mode.raw) {
                ft_buffer += char + char;
              } else {
                if (ft_escape) {
                  ft_buffer += "\\" + char;
                }
                ft_escape = !ft_escape;
              }
              continue;
            } else {
              if (ft_escape) {
                ft_buffer += "\\";
              }
              ft_buffer += char;
              ft_escape = false;
              if (char == "\n") {
                line_num++;
              }
              continue;
            }
          } else if (token_mode == "format_specifier") {
            if (char == quote) {
              if (format_specifier.length > 0) {
                t.push(Token2(FT_MIDDLE[ft_type], format_specifier, line_num, ft_start, line_num, ft_start + format_specifier.length, line));
                token_modes.pop();
                token_mode = $B2.last(token_modes);
                continue;
              }
            } else if (char == "{") {
              t.push(Token2(FT_MIDDLE[ft_type], format_specifier, line_num, ft_start, line_num, ft_start + format_specifier.length, line));
              token_mode = "regular_within_ft";
              ft_expr_start = pos2 - line_start;
              state = null;
              token_modes.push(token_mode);
            } else if (char == "}") {
              t.push(Token2(FT_MIDDLE[ft_type], format_specifier, line_num, ft_start, line_num, ft_start + format_specifier.length, line));
              t.push(Token2("OP", char, line_num, pos2 - line_start, line_num, pos2 - line_start + 1, line));
              if (braces.length == 0 || $B2.last(braces).char !== "{") {
                throw Error("wrong braces");
              }
              braces.pop();
              token_modes.pop();
              token_mode = $B2.last(token_modes);
              continue;
            } else {
              format_specifier += char;
              continue;
            }
          }
          switch (state) {
            case "line_start":
              line = get_line_at(pos2 - 1);
              line_start = pos2;
              line_num++;
              if (mo = /^\f?(\r\n|\r|\n)/.exec(src.substr(pos2 - 1))) {
                t.push(Token2("NL", mo[0], line_num, 0, line_num, mo[0].length, line));
                pos2 += mo[0].length - 1;
                continue;
              } else if (char == "#") {
                comment = get_comment(parser, src, pos2, line_num, line_start, "NL", line);
                for (var item2 of comment.t) {
                  t.push(item2);
                }
                pos2 = comment.pos;
                state = "line_start";
                continue;
              }
              indent = 0;
              if (char == " ") {
                indent = 1;
              } else if (char == "	") {
                indent = 8;
              }
              if (indent) {
                var broken = false;
                while (pos2 < src.length) {
                  if (broken && indent > 0 && " 	".includes(src[pos2])) {
                    t.push(ErrorToken(
                      _b_2.IndentationError,
                      filename,
                      line_num,
                      pos2 - line_start,
                      line_num,
                      pos2 - line_start + 1,
                      line,
                      "unindent does not match any outer indentation level"
                    ));
                    return t;
                  }
                  if (src[pos2] == " ") {
                    indent++;
                  } else if (src[pos2] == "	") {
                    indent += 8;
                  } else if (src[pos2] == "\\" && src[pos2 + 1] == "\n") {
                    pos2++;
                    line_start = pos2 + 2;
                    line_num++;
                    line = get_line_at(pos2 + 2);
                    broken = true;
                  } else {
                    break;
                  }
                  pos2++;
                }
                if (pos2 == src.length) {
                  line_num--;
                  break;
                }
                if (src[pos2] == "#") {
                  comment = get_comment(parser, src, pos2 + 1, line_num, line_start, "NL", line);
                  for (var item2 of comment.t) {
                    t.push(item2);
                  }
                  pos2 = comment.pos;
                  continue;
                } else if (src[pos2] == "\\") {
                  if (/^\f?(\r\n|\r|\n)/.exec(src[pos2 + 1])) {
                    line_num++;
                    pos2++;
                    continue;
                  } else {
                    t.push(ErrorToken(_b_2.SyntaxError, filename, line_num, pos2 + 2 - line_start, line_num, pos2 + 3 - line_start, line, "unexpected character after line continuation character"));
                    return t;
                  }
                } else if (mo = /^\f?(\r\n|\r|\n)/.exec(src.substr(pos2))) {
                  t.push(Token2("NL", "", line_num, pos2 - line_start + 1, line_num, pos2 - line_start + 1 + mo[0].length, line));
                  pos2 += mo[0].length;
                  continue;
                }
                if (indents.length == 0 || indent > $last(indents)) {
                  indents.push(indent);
                  t.push(Token2("INDENT", "", line_num, 0, line_num, indent, line));
                } else if (indent < $last(indents)) {
                  var ix = indents.indexOf(indent);
                  if (ix == -1) {
                    var message = "unindent does not match any outer indentation level";
                    t.push(ErrorToken(_b_2.IndentationError, filename, line_num, 0, line_num, 0, line, message));
                    return t;
                  }
                  for (var i = indents.length - 1; i > ix; i--) {
                    indents.pop();
                    t.push(Token2("DEDENT", "", line_num, indent, line_num, indent, line));
                  }
                }
                state = null;
              } else {
                while (indents.length > 0) {
                  indents.pop();
                  t.push(Token2("DEDENT", "", line_num, indent, line_num, indent, line));
                }
                state = null;
                pos2--;
              }
              break;
            case null:
              switch (char) {
                case '"':
                case "'":
                  quote = char;
                  triple_quote = src[pos2] == char && src[pos2 + 1] == char;
                  string_start = [line_num, pos2 - line_start, line_start];
                  if (triple_quote) {
                    pos2 += 2;
                  }
                  escaped = false;
                  state = "STRING";
                  string = "";
                  prefix = "";
                  break;
                case "#":
                  var token_name = braces.length > 0 ? "NL" : "NEWLINE";
                  comment = get_comment(parser, src, pos2, line_num, line_start, token_name, line);
                  for (var item2 of comment.t) {
                    t.push(item2);
                  }
                  pos2 = comment.pos;
                  if (braces.length == 0) {
                    state = "line_start";
                  } else {
                    state = null;
                    line_num++;
                    line_start = pos2 + 1;
                    line = get_line_at(pos2);
                  }
                  break;
                case "0":
                  state = "NUMBER";
                  number = char;
                  num_type = "";
                  if (src[pos2] && "xbo".includes(src[pos2].toLowerCase())) {
                    number += src[pos2];
                    num_type = src[pos2].toLowerCase();
                    pos2++;
                  } else if (src[pos2]) {
                    var pos1 = pos2;
                    while (pos1 < src.length) {
                      if (src[pos1].match(/\d/)) {
                        if (src[pos1] == "0") {
                          pos1++;
                          continue;
                        }
                        let msg2 = "leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers";
                        t.push(ErrorToken(_b_2.SyntaxError, filename, line_num, pos2 - line_start - number.length, line_num, pos2 - line_start, line, msg2));
                        return t;
                      } else {
                        break;
                      }
                    }
                  }
                  break;
                case ".":
                  if (src[pos2] && $B2.in_unicode_category("Nd", ord(src[pos2]))) {
                    state = "NUMBER";
                    num_type = "";
                    number = char;
                  } else {
                    var op = char;
                    while (src[pos2] == char) {
                      pos2++;
                      op += char;
                    }
                    var dot_pos = pos2 - line_start - op.length + 1;
                    while (op.length >= 3) {
                      t.push(Token2("OP", "...", line_num, dot_pos, line_num, dot_pos + 3, line));
                      op = op.substr(3);
                    }
                    for (var i = 0; i < op.length; i++) {
                      t.push(Token2("OP", ".", line_num, dot_pos, line_num, dot_pos + 1, line));
                      dot_pos++;
                    }
                  }
                  break;
                case "\\":
                  var mo = /^\f?(\r\n|\r|\n)/.exec(src.substr(pos2));
                  if (mo) {
                    if (pos2 == src.length - 1) {
                      var msg = "unexpected EOF while parsing";
                      raise_error(_b_2.SyntaxError, filename, line_num, pos2 - line_start, line_num, pos2 - line_start + 1, line, msg);
                    }
                    line_num++;
                    pos2 += mo[0].length;
                    line_start = pos2 + 1;
                    line = get_line_at(pos2);
                  } else {
                    pos2++;
                    var msg = "unexpected character after line continuation character";
                    raise_error(_b_2.SyntaxError, filename, line_num, pos2 - line_start, line_num, pos2 - line_start + 1, line, msg);
                  }
                  break;
                case "\n":
                case "\r":
                  var token_name = braces.length > 0 ? "NL" : "NEWLINE";
                  mo = /^\f?(\r\n|\r|\n)/.exec(src.substr(pos2 - 1));
                  t.push(Token2(token_name, mo[0], line_num, pos2 - line_start, line_num, pos2 - line_start + mo[0].length, line));
                  pos2 += mo[0].length - 1;
                  if (token_name == "NEWLINE") {
                    state = "line_start";
                  } else {
                    line_num++;
                    line_start = pos2 + 1;
                    line = get_line_at(pos2);
                  }
                  break;
                default:
                  if ($B2.is_XID_Start(ord(char))) {
                    state = "NAME";
                    name2 = char;
                  } else if ($B2.in_unicode_category("Nd", ord(char))) {
                    state = "NUMBER";
                    num_type = "";
                    number = char;
                  } else if (ops.includes(char)) {
                    if (token_mode == "regular_within_ft" && (char == ":" || char == "}")) {
                      if (char == ":") {
                        if (nesting_level(token_modes) == braces.length - 1) {
                          let colon = Token2("OP", char, line_num, pos2 - line_start - op.length + 1, line_num, pos2 - line_start + 1, line);
                          colon.metadata = src.substr(
                            line_start + ft_expr_start,
                            pos2 - line_start - ft_expr_start - 1
                          );
                          t.push(colon);
                          token_modes.pop();
                          token_mode = "format_specifier";
                          token_modes.push(token_mode);
                          continue;
                        }
                      } else {
                        let closing_brace = Token2("OP", char, line_num, pos2 - line_start - op.length + 1, line_num, pos2 - line_start + 1, line);
                        closing_brace.metadata = src.substring(
                          line_start + ft_expr_start,
                          pos2 - 1
                        );
                        t.push(closing_brace);
                        token_modes.pop();
                        token_mode = token_modes[token_modes.length - 1];
                        if (braces.length == 0 || $B2.last(braces).char !== "{") {
                          t.push(Error("wrong braces"));
                          return t;
                        }
                        braces.pop();
                        continue;
                      }
                    }
                    var op = char;
                    if (op2.includes(char + src[pos2])) {
                      op = char + src[pos2];
                      pos2++;
                    }
                    if (src[pos2] == "=" && (op.length == 2 || augm_op.includes(op))) {
                      op += src[pos2];
                      pos2++;
                    } else if (char == "-" && src[pos2] == ">" || char == ":" && src[pos2] == "=") {
                      op += src[pos2];
                      pos2++;
                    }
                    if ("[({".includes(char)) {
                      braces.push({ char, pos: pos2, line_num, line_start, line });
                    } else if ("])}".includes(char)) {
                      if (braces.length && $last(braces).char == closing[char]) {
                        braces.pop();
                      } else {
                        braces.push({ char, pos: pos2, line_num, line_start, line });
                      }
                    }
                    t.push(Token2("OP", op, line_num, pos2 - line_start - op.length + 1, line_num, pos2 - line_start + 1, line));
                  } else if (char == "!") {
                    if (src[pos2] == "=") {
                      t.push(Token2("OP", "!=", line_num, pos2 - line_start, line_num, pos2 - line_start + 2, line));
                      pos2++;
                    } else {
                      let token = Token2("OP", char, line_num, pos2 - line_start, line_num, pos2 - line_start + 1, line);
                      token.metadata = src.substring(
                        line_start + ft_start + 2,
                        pos2 - 1
                      );
                      t.push(token);
                    }
                  } else if (char == " " || char == "	") {
                  } else {
                    var cp = char.codePointAt(0), err_msg = "invalid";
                    if (unprintable_re.exec(char)) {
                      err_msg += " non-printable";
                    }
                    var unicode = cp.toString(16).toUpperCase();
                    while (unicode.length < 4) {
                      unicode = "0" + unicode;
                    }
                    err_msg += ` character '${char}' (U+${unicode})`;
                    if (char == "$" || char == "`") {
                      err_msg = "invalid syntax";
                    }
                    var err_token = Token2("ERRORTOKEN", char, line_num, pos2 - line_start, line_num, pos2 - line_start + 1, line);
                    t.push(ErrorTokenKnownToken(_b_2.SyntaxError, filename, err_token, err_msg));
                    return t;
                  }
              }
              break;
            case "NAME":
              if ($B2.is_XID_Continue(ord(char))) {
                name2 += char;
              } else if (char == '"' || char == "'") {
                if (string_prefix.exec(name2) || bytes_prefix.exec(name2)) {
                  state = "STRING";
                  quote = char;
                  triple_quote = src[pos2] == quote && src[pos2 + 1] == quote;
                  prefix = name2;
                  if (triple_quote) {
                    pos2 += 2;
                  }
                  var is_ft = false;
                  if (prefix.toLowerCase().includes("f")) {
                    is_ft = true;
                    ft_type = "f";
                  } else if (prefix.toLowerCase().includes("t")) {
                    is_ft = true;
                    ft_type = "t";
                  }
                  if (is_ft) {
                    token_mode = new String("ft");
                    ft_start = pos2 - line_start - name2.length;
                    token_mode.nesting = braces.length;
                    token_mode.quote = quote;
                    token_mode.triple_quote = triple_quote;
                    token_mode.raw = prefix.toLowerCase().includes("r");
                    token_modes.push(token_mode);
                    var s = triple_quote ? quote.repeat(3) : quote;
                    var end_col = ft_start + name2.length + s.length;
                    t.push(Token2(FT_START[ft_type], prefix + s, line_num, ft_start, line_num, end_col, line));
                    continue;
                  }
                  escaped = false;
                  string_start = [line_num, pos2 - line_start - name2.length, line_start];
                  string = "";
                } else {
                  t.push(Token2("NAME", name2, line_num, pos2 - line_start - name2.length, line_num, pos2 - line_start, line));
                  state = null;
                  pos2--;
                }
              } else {
                t.push(Token2("NAME", name2, line_num, pos2 - line_start - name2.length, line_num, pos2 - line_start, line));
                state = null;
                pos2--;
              }
              break;
            case "STRING":
              switch (char) {
                case quote:
                  if (!escaped) {
                    var string_line = line;
                    if (line_num > string_start[0]) {
                      string_line = src.substring(
                        string_start[2] - 1,
                        pos2 + 2
                      );
                    }
                    var full_string;
                    if (!triple_quote) {
                      full_string = prefix + quote + string + quote;
                      t.push(Token2("STRING", full_string, string_start[0], string_start[1], line_num, pos2 - line_start + 1, string_line));
                      state = null;
                    } else if (char + src.substr(pos2, 2) == quote.repeat(3)) {
                      full_string = prefix + quote.repeat(3) + string + quote.repeat(3);
                      t.push(Token2("STRING", full_string, string_start[0], string_start[1], line_num, pos2 - line_start + 3, string_line));
                      pos2 += 2;
                      state = null;
                    } else {
                      string += char;
                    }
                  } else {
                    string += char;
                  }
                  escaped = false;
                  break;
                case "\r":
                case "\n":
                  if (!escaped && !triple_quote) {
                    var msg;
                    if (token_mode == "regular_within_fstring") {
                      msg = "f-string: missing '}'";
                    } else {
                      var msg = `unterminated string literal (detected at line ${line_num})`, line_num = string_start[0], col_offset = string_start[1];
                    }
                    t.push(ErrorToken(_b_2.SyntaxError, filename, line_num, col_offset, line_num, col_offset, line, msg));
                    return t;
                  }
                  string += char;
                  line_num++;
                  line_start = pos2 + 1;
                  if (char == "\r" && src[pos2] == "\n") {
                    string += src[pos2];
                    line_start++;
                    pos2++;
                  }
                  line = get_line_at(pos2);
                  escaped = false;
                  break;
                case "\\":
                  string += char;
                  escaped = !escaped;
                  break;
                default:
                  escaped = false;
                  string += char;
                  break;
              }
              break;
            case "NUMBER":
              if (test_num(num_type, char)) {
                number += char;
              } else if (char == "_" && !number.endsWith(".")) {
                if (number.endsWith("_")) {
                  throw SyntaxError("consecutive _ in number");
                } else if (src[pos2] === void 0 || !test_num(num_type, src[pos2])) {
                  t.push(Token2("NUMBER", number, line_num, pos2 - line_start - number.length, line_num, pos2 - line_start, line));
                  state = null;
                  pos2--;
                } else {
                  number += char;
                }
              } else if (char == "." && !number.includes(char)) {
                number += char;
              } else if (char.toLowerCase() == "e" && !number.toLowerCase().includes("e")) {
                if ("+-".includes(src[pos2]) || $B2.in_unicode_category("Nd", ord(src[pos2]))) {
                  number += char;
                } else {
                  t.push(Token2("NUMBER", number, line_num, pos2 - line_start - number.length, line_num, pos2 - line_start, line));
                  state = null;
                  pos2--;
                }
              } else if ((char == "+" || char == "-") && number.toLowerCase().endsWith("e")) {
                number += char;
              } else if (char.toLowerCase() == "j") {
                number += char;
                t.push(Token2("NUMBER", number, line_num, pos2 - line_start - number.length + 1, line_num, pos2 - line_start + 1, line));
                state = null;
              } else if (char.match(new RegExp("\\p{Letter}", "u"))) {
                raise_error(_b_2.SyntaxError, filename, line_num, pos2 - line_start, line_num, pos2 - line_start, line, "invalid decimal literal");
                return t;
              } else {
                t.push(Token2("NUMBER", number, line_num, pos2 - line_start - number.length, line_num, pos2 - line_start, line));
                state = null;
                pos2--;
              }
              break;
          }
        }
        switch (state) {
          case "line_start":
            line_num++;
            break;
          case "NAME":
            t.push(Token2("NAME", name2, line_num, pos2 - line_start - name2.length + 1, line_num, pos2 - line_start + 1, line));
            break;
          case "NUMBER":
            t.push(Token2("NUMBER", number, line_num, pos2 - line_start - number.length + 1, line_num, pos2 - line_start + 1, line));
            break;
          case "STRING":
            line_num = string_start[0];
            line = lines[line_num - 1];
            var msg = `unterminated ${triple_quote ? "triple-quoted " : ""}string literal (detected at line ${line_num})`, col_offset = string_start[1];
            t.push(ErrorToken(_b_2.SyntaxError, filename, line_num, col_offset, line_num, col_offset, line, msg));
            return t;
        }
        if (!src.endsWith("\n") && state != line_start) {
          t.push(Token2("NEWLINE", "", line_num, pos2 - line_start + 1, line_num, pos2 - line_start + 1, line + "\n"));
          line_num++;
        }
        while (indents.length > 0) {
          indents.pop();
          t.push(Token2("DEDENT", "", line_num, 0, line_num, 0, ""));
        }
        t.push(Token2("ENDMARKER", "", line_num, 0, line_num, 0, ""));
        return t;
      };
    })(__BRYTHON__);
    (function($B2) {
      var binary_ops = { "+": "Add", "-": "Sub", "*": "Mult", "/": "Div", "//": "FloorDiv", "%": "Mod", "**": "Pow", "<<": "LShift", ">>": "RShift", "|": "BitOr", "^": "BitXor", "&": "BitAnd", "@": "MatMult" };
      var boolean_ops = { "and": "And", "or": "Or" };
      var comparison_ops = { "==": "Eq", "!=": "NotEq", "<": "Lt", "<=": "LtE", ">": "Gt", ">=": "GtE", "is": "Is", "is_not": "IsNot", "in": "In", "not_in": "NotIn" };
      var unary_ops = { unary_inv: "Invert", unary_pos: "UAdd", unary_neg: "USub", unary_not: "Not" };
      var op_types = $B2.op_types = [binary_ops, boolean_ops, comparison_ops, unary_ops];
      var _b_2 = $B2.builtins;
      var ast = $B2.ast = {};
      for (var kl in $B2.ast_classes) {
        var args = $B2.ast_classes[kl], body = "";
        if (typeof args == "string") {
          if (args.length > 0) {
            for (var arg of args.split(",")) {
              if (arg.endsWith("*")) {
                arg = arg.substr(0, arg.length - 1);
                body += ` this.${arg} = $B.$list(${arg} === undefined ? [] : ${arg})
`;
              } else if (arg.endsWith("?")) {
                arg = arg.substr(0, arg.length - 1);
                body += ` this.${arg} = ${arg}
`;
              } else {
                body += ` this.${arg} = ${arg}
`;
              }
            }
          }
          var arg_list = args.replace(/[*?]/g, "").split(",");
          ast[kl] = Function(...arg_list, body);
          ast[kl]._fields = args.split(",");
        } else {
          ast[kl] = args.map((x) => ast[x]);
        }
        ast[kl].$name = kl;
      }
      $B2.ast_js_to_py = function(obj) {
        $B2.create_python_ast_classes();
        if (obj === void 0) {
          return _b_2.None;
        } else if (Array.isArray(obj)) {
          return $B2.$list(obj.map($B2.ast_js_to_py));
        } else {
          var class_name = obj.constructor.$name, py_class = $B2.python_ast_classes[class_name], py_ast_obj = { __class__: py_class };
          if (py_class === void 0) {
            return obj;
          }
          for (var field of py_class._fields) {
            py_ast_obj[field] = $B2.ast_js_to_py(obj[field]);
          }
          py_ast_obj._attributes = $B2.fast_tuple([]);
          for (var loc of ["lineno", "col_offset", "end_lineno", "end_col_offset"]) {
            if (obj[loc] !== void 0) {
              py_ast_obj[loc] = obj[loc];
              py_ast_obj._attributes.push(loc);
            }
          }
          return py_ast_obj;
        }
      };
      $B2.ast_py_to_js = function(obj) {
        if (obj === void 0 || obj === _b_2.None) {
          return void 0;
        } else if (Array.isArray(obj)) {
          return obj.map($B2.ast_py_to_js);
        } else if (typeof obj == "string") {
          return obj;
        } else {
          var class_name = $B2.class_name(obj), js_class = $B2.ast[class_name];
          if (js_class === void 0) {
            return obj;
          }
          var js_ast_obj = new js_class();
          for (var field of js_class._fields) {
            if (field.endsWith("?") || field.endsWith("*")) {
              field = field.substr(0, field.length - 1);
            }
            js_ast_obj[field] = $B2.ast_py_to_js(obj[field]);
          }
          for (var loc of ["lineno", "col_offset", "end_lineno", "end_col_offset"]) {
            if (obj[loc] !== void 0) {
              js_ast_obj[loc] = obj[loc];
            }
          }
          return js_ast_obj;
        }
      };
      $B2.create_python_ast_classes = function() {
        if ($B2.python_ast_classes) {
          return;
        }
        $B2.python_ast_classes = {};
        for (var klass in $B2.ast_classes) {
          $B2.python_ast_classes[klass] = (function(kl2) {
            var _fields, raw_fields;
            if (typeof $B2.ast_classes[kl2] == "string") {
              if ($B2.ast_classes[kl2] == "") {
                raw_fields = _fields = [];
              } else {
                raw_fields = $B2.ast_classes[kl2].split(",");
                _fields = raw_fields.map((x) => x.endsWith("*") || x.endsWith("?") ? x.substr(0, x.length - 1) : x);
              }
            }
            var cls = $B2.make_class(kl2), $defaults = {}, slots = {}, nb_args = 0;
            if (raw_fields) {
              for (let i2 = 0, len = _fields.length; i2 < len; i2++) {
                let f = _fields[i2], rf = raw_fields[i2];
                nb_args++;
                slots[f] = null;
                if (rf.endsWith("*")) {
                  $defaults[f] = [];
                } else if (rf.endsWith("?")) {
                  $defaults[f] = _b_2.None;
                }
              }
            }
            cls.__match_args__ = $B2.fast_tuple(Object.keys(slots));
            cls.$factory = function() {
              var $ = $B2.args(klass, nb_args, $B2.clone(slots), Object.keys(slots), arguments, $B2.clone($defaults), null, "kw");
              var res = { __class__: cls, _attributes: $B2.fast_tuple([]) };
              for (let key2 in $) {
                if (key2 == "kw") {
                  for (let item2 of _b_2.dict.$iter_items($.kw)) {
                    res[item2.key] = item2.value;
                  }
                } else {
                  res[key2] = $[key2];
                }
              }
              if (klass == "Constant") {
                res.value = $B2.AST.$convert($.value);
              }
              return res;
            };
            if (_fields) {
              cls._fields = _fields;
            }
            cls.__mro__ = [$B2.AST, _b_2.object];
            cls.__module__ = "ast";
            cls.__dict__ = $B2.empty_dict();
            if (raw_fields) {
              for (let i2 = 0, len = raw_fields.length; i2 < len; i2++) {
                var raw_field = raw_fields[i2];
                if (raw_field.endsWith("?")) {
                  _b_2.dict.$setitem(cls.__dict__, _fields[i2], _b_2.None);
                }
              }
            }
            return cls;
          })(klass);
        }
      };
      var op2ast_class = $B2.op2ast_class = {}, ast_types = [ast.BinOp, ast.BoolOp, ast.Compare, ast.UnaryOp];
      for (var i = 0; i < 4; i++) {
        for (var op in op_types[i]) {
          op2ast_class[op] = [ast_types[i], ast[op_types[i][op]]];
        }
      }
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      var _window;
      if ($B2.isNode) {
        _window = { location: { href: "", origin: "", pathname: "" } };
      } else {
        _window = self;
      }
      $B2.parser = {};
      $B2.clone = function(obj) {
        var res = {};
        for (var attr in obj) {
          res[attr] = obj[attr];
        }
        return res;
      };
      $B2.last = function(table) {
        if (table === void 0) {
          console.log($B2.make_frames_stack());
        }
        return table[table.length - 1];
      };
      var ast = $B2.ast;
      function get_line(filename, lineno) {
        var src = $B2.file_cache[filename], line = _b_2.None;
        if (src !== void 0) {
          var lines = src.split("\n");
          line = lines[lineno - 1];
        }
        return line;
      }
      var VALID_FUTURES = ["nested_scopes", "generators", "division", "absolute_import", "with_statement", "print_function", "unicode_literals", "barry_as_FLUFL", "generator_stop", "annotations"];
      $B2.future_features = function(mod, filename) {
        var features = 0;
        var i2 = 0;
        if (mod.body[0] instanceof $B2.ast.Expr) {
          if (mod.body[0].value instanceof $B2.ast.Constant && typeof mod.body[0].value.value == "string") {
            i2++;
          }
        }
        while (i2 < mod.body.length) {
          var child = mod.body[i2];
          if (child instanceof $B2.ast.ImportFrom && child.module == "__future__") {
            for (var alias of child.names) {
              var name2 = alias.name;
              if (name2 == "braces") {
                raise_error_known_location(_b_2.SyntaxError, filename, alias.lineno, alias.col_offset, alias.end_lineno, alias.end_col_offset, get_line(filename, child.lineno), "not a chance");
              } else if (name2 == "annotations") {
                features |= $B2.CO_FUTURE_ANNOTATIONS;
              } else if (VALID_FUTURES.indexOf(name2) == -1) {
                raise_error_known_location(_b_2.SyntaxError, filename, alias.lineno, alias.col_offset, alias.end_lineno, alias.end_col_offset, get_line(filename, child.lineno), `future feature ${name2} is not defined`);
              }
            }
            i2++;
          } else {
            break;
          }
        }
        return { features };
      };
      $B2.format_indent = function(js, indent) {
        var indentation = "  ", lines = js.split("\n"), level = indent, res = "", last_is_closing_brace = false, last_is_backslash = false, last_is_var_and_comma = false;
        for (var i2 = 0, len = lines.length; i2 < len; i2++) {
          var line = lines[i2], add_closing_brace = false, add_spaces = true;
          if (last_is_backslash) {
            add_spaces = false;
          } else if (last_is_var_and_comma) {
            line = "    " + line.trim();
          } else {
            line = line.trim();
          }
          if (add_spaces && last_is_closing_brace && (line.startsWith("else") || line.startsWith("catch") || line.startsWith("finally"))) {
            res = res.substr(0, res.length - 1);
            add_spaces = false;
          }
          last_is_closing_brace = line.endsWith("}");
          if (line.startsWith("}")) {
            level--;
          } else if (line.endsWith("}")) {
            line = line.substr(0, line.length - 1);
            add_closing_brace = true;
          }
          if (level < 0) {
            if ($B2.get_option("debug") > 2) {
              console.log("wrong js indent");
              console.log(res);
            }
            level = 0;
          }
          try {
            res += (add_spaces ? indentation.repeat(level) : "") + line + "\n";
          } catch (err) {
            console.log(res);
            throw err;
          }
          if (line.endsWith("{")) {
            level++;
          } else if (add_closing_brace) {
            level--;
            if (level < 0) {
              level = 0;
            }
            try {
              res += indentation.repeat(level) + "}\n";
            } catch (err) {
              console.log(res);
              throw err;
            }
          }
          last_is_backslash = line.endsWith("\\");
          last_is_var_and_comma = line.endsWith(",") && (line.startsWith("var ") || last_is_var_and_comma);
        }
        return res;
      };
      function get_docstring(node) {
        var doc_string = _b_2.None;
        if (node.body.length > 0) {
          var firstchild = node.body[0];
          if (firstchild instanceof $B2.ast.Constant && typeof firstchild.value == "string") {
            doc_string = firstchild.value;
          }
        }
        return doc_string;
      }
      var s_escaped = `abfnrtvxuU"0123456789'\\`, is_escaped = {};
      for (var i = 0; i < s_escaped.length; i++) {
        is_escaped[s_escaped.charAt(i)] = true;
      }
      function SurrogatePair(value2) {
        value2 = value2 - 65536;
        return String.fromCharCode(55296 | value2 >> 10) + String.fromCharCode(56320 | value2 & 1023);
      }
      function test_escape(text, antislash_pos) {
        var seq_end, mo;
        mo = /^[0-7]{1,3}/.exec(text.substr(antislash_pos + 1));
        if (mo) {
          return [String.fromCharCode(parseInt(mo[0], 8)), 1 + mo[0].length];
        }
        switch (text[antislash_pos + 1]) {
          case "x":
            mo = /^[0-9A-F]{0,2}/i.exec(text.substr(antislash_pos + 2));
            if (mo[0].length != 2) {
              seq_end = antislash_pos + mo[0].length + 1;
              $token.value.start[1] = seq_end;
              throw Error(
                `(unicode error) 'unicodeescape' codec can't decode bytes in position ${antislash_pos}-${seq_end}: truncated \\xXX escape`
              );
            } else {
              return [String.fromCharCode(parseInt(mo[0], 16)), 2 + mo[0].length];
            }
            break;
          case "u":
            mo = /^[0-9A-F]{0,4}/i.exec(text.substr(antislash_pos + 2));
            if (mo[0].length != 4) {
              seq_end = antislash_pos + mo[0].length + 1;
              $token.value.start[1] = seq_end;
              throw Error(
                `(unicode error) 'unicodeescape' codec can't decode bytes in position ${antislash_pos}-${seq_end}: truncated \\uXXXX escape`
              );
            } else {
              return [String.fromCharCode(parseInt(mo[0], 16)), 2 + mo[0].length];
            }
            break;
          case "U":
            mo = /^[0-9A-F]{0,8}/i.exec(text.substr(antislash_pos + 2));
            if (mo[0].length != 8) {
              seq_end = antislash_pos + mo[0].length + 1;
              $token.value.start[1] = seq_end;
              throw Error(
                `(unicode error) 'unicodeescape' codec can't decode bytes in position ${antislash_pos}-${seq_end}: truncated \\uXXXX escape`
              );
            } else {
              let value2 = parseInt(mo[0], 16);
              if (value2 > 1114111) {
                throw Error("invalid unicode escape " + mo[0]);
              } else if (value2 >= 65536) {
                return [SurrogatePair(value2), 2 + mo[0].length];
              } else {
                return [String.fromCharCode(value2), 2 + mo[0].length];
              }
            }
        }
      }
      $B2.test_escape = test_escape;
      function unindent(src) {
        var lines = src.split("\n"), line, global_indent, indent, first, unindented_lines = [];
        var min_indent;
        for (var line of lines) {
          if (/^\s*$/.exec(line)) {
            continue;
          }
          indent = line.match(/^\s*/)[0].length;
          if (indent == 0) {
            return src;
          }
          if (min_indent === void 0) {
            min_indent = indent;
          }
          if (indent < min_indent) {
            min_indent = indent;
          }
        }
        for (var line of lines) {
          if (/^\s*$/.exec(line)) {
            unindented_lines.push(line);
          } else {
            unindented_lines.push(line.substr(min_indent));
          }
        }
        return unindented_lines.join("\n");
      }
      var $token = {};
      $B2.parse_time = 0;
      $B2.py2js = function(src, module2, locals_id, parent_scope) {
        if (typeof module2 == "object") {
          module2 = module2.__name__;
        }
        parent_scope = parent_scope || $B2.builtins_scope;
        var filename, imported;
        if (typeof src == "object") {
          filename = src.filename;
          imported = src.imported;
          src = src.src;
        }
        src = src.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        var locals_is_module = Array.isArray(locals_id);
        if (locals_is_module) {
          locals_id = locals_id[0];
        }
        var t0 = globalThis.performance.now();
        var parser = new $B2.Parser(src, filename, "file"), _ast = $B2._PyPegen.run_parser(parser);
        $B2.parse_time += globalThis.performance.now() - t0;
        var future = $B2.future_features(_ast, filename);
        var symtable = $B2._PySymtable_Build(_ast, filename, future);
        var js_obj = $B2.js_from_root({ ast: _ast, symtable, filename, src, imported });
        var js_from_ast = js_obj.js;
        return {
          _ast,
          imports: js_obj.imports,
          to_js: function() {
            return js_from_ast;
          }
        };
      };
      $B2.parse_options = function(options) {
        if (options === void 0) {
          options = {};
        } else if (typeof options == "number") {
          options = { debug: options };
        } else if (typeof options !== "object") {
          console.warn("ignoring invalid argument passed to brython():", options);
          options = {};
        }
        let options_lowered = {};
        for (const [key2, value2] of Object.entries(options)) {
          options_lowered[key2.toLowerCase()] = value2;
        }
        options = options_lowered;
        $B2.debug = options.debug === void 0 ? 1 : options.debug;
        _b_2.__debug__ = $B2.debug > 0;
        options.python_extension = options.python_extension || ".py";
        if ($B2.$options.args) {
          $B2.__ARGV = $B2.$options.args;
        } else {
          $B2.__ARGV = _b_2.list.$factory([]);
        }
        $B2.options_parsed = true;
        return options;
      };
      if (!($B2.isWebWorker || $B2.isNode)) {
        var startup_observer = new MutationObserver(function(mutations) {
          for (var mutation of mutations) {
            for (var addedNode of mutation.addedNodes) {
              addPythonScript(addedNode);
            }
          }
        });
        startup_observer.observe(document.documentElement, { childList: true, subtree: true });
      }
      var brython_options = $B2.brython_options = {};
      var python_scripts = [];
      if (!$B2.isWebWorker) {
        python_scripts = python_scripts.concat(Array.from(
          document.querySelectorAll('script[type="text/python"]')
        )).concat(
          Array.from(
            document.querySelectorAll('script[type="text/python3"]')
          )
        );
        var onload;
        addEventListener(
          "DOMContentLoaded",
          function(ev) {
            if (ev.target.body) {
              onload = ev.target.body.onload;
            }
            if (!onload) {
              ev.target.body.onload = function() {
                return brython();
              };
            } else {
              ev.target.body.onload = function() {
                onload();
                if (!status.brython_called) {
                  brython();
                }
              };
            }
          }
        );
        class BrythonOptions extends HTMLElement {
          constructor() {
            super();
          }
          connectedCallback() {
            for (var attr of this.getAttributeNames()) {
              brython_options[attr] = convert_option(attr, this.getAttribute(attr));
            }
          }
        }
        customElements.define("brython-options", BrythonOptions);
      }
      var defined_ids = {}, script_to_id = /* @__PURE__ */ new Map(), id_to_script = {};
      function addPythonScript(addedNode) {
        if (addedNode.tagName == "SCRIPT" && (addedNode.type == "text/python" || addedNode.type == "text/python3")) {
          python_scripts.push(addedNode);
        }
      }
      var status = { brython_called: false, first_unnamed_script: true };
      $B2.dispatch_load_event = function(script) {
        script.dispatchEvent(new Event("load"));
      };
      function injectPythonScript(addedNode) {
        if (addedNode.tagName == "SCRIPT" && addedNode.type == "text/python") {
          set_script_id(addedNode);
          run_scripts([addedNode]);
        }
      }
      function set_script_id(script) {
        if (script_to_id.has(script)) {
        } else if (script.id) {
          if (defined_ids[script.id]) {
            throw Error("Brython error : Found 2 scripts with the same id '" + script.id + "'");
          } else {
            defined_ids[script.id] = true;
          }
          script_to_id.set(script, script.id);
        } else {
          if (script.className === "webworker") {
            throw _b_2.AttributeError.$factory(
              "webworker script has no attribute 'id'"
            );
          }
          if (status.first_unnamed_script) {
            script_to_id.set(script, "__main__");
            status.first_unnamed_script = false;
          } else {
            script_to_id.set(script, "__main__" + $B2.UUID());
          }
        }
        var id = script_to_id.get(script);
        id_to_script[id] = script;
        return id;
      }
      var brython = $B2.parser.brython = function(options) {
        $B2.$options = $B2.parse_options(options);
        if (!($B2.isWebWorker || $B2.isNode)) {
          if (!status.brython_called) {
            status.brython_called = true;
            startup_observer.disconnect();
            var inject_observer = new MutationObserver(function(mutations) {
              for (var mutation of mutations) {
                for (var addedNode of mutation.addedNodes) {
                  injectPythonScript(addedNode);
                }
              }
            });
            inject_observer.observe(document.documentElement, { childList: true, subtree: true });
          }
        } else if ($B2.isNode) {
          return;
        }
        for (var python_script of python_scripts) {
          set_script_id(python_script);
        }
        var scripts = [];
        var kk = Object.keys(_window);
        var ids = $B2.get_page_option("ids");
        if (ids !== void 0) {
          if (!Array.isArray(ids)) {
            throw _b_2.ValueError.$factory("ids is not a list");
          }
          if (ids.length == 0) {
          }
          for (var id of ids) {
            var script = document.querySelector(`script[id="${id}"]`);
            if (script) {
              set_script_id(script);
              scripts.push(script);
            } else {
              console.log(`no script with id '${id}'`);
              throw _b_2.KeyError.$factory(`no script with id '${id}'`);
            }
          }
        } else if ($B2.isWebWorker) {
        } else {
          scripts = python_scripts.slice();
        }
        run_scripts(scripts);
      };
      function convert_option(option, value2) {
        if (option == "debug") {
          if (typeof value2 == "string" && value2.match(/^\d+$/)) {
            return parseInt(value2);
          } else if (typeof value2 == "number") {
            return value2;
          } else {
            if (value2 !== null && value2 !== void 0) {
              console.debug(`Invalid value for debug: ${value2}`);
            }
          }
        } else if (option == "cache" || option == "indexeddb" || option == "static_stdlib_import") {
          if (value2 == "1" || value2.toLowerCase() == "true") {
            return true;
          } else if (value2 == "0" || value2.toLowerCase() == "false") {
            return false;
          } else {
            console.debug(`Invalid value for ${option}: ${value2}`);
          }
        } else if (option == "ids" || option == "pythonpath" || option == "args") {
          if (typeof value2 == "string") {
            if (value2.trim().length == 0) {
              return [];
            }
            return value2.trim().split(/\s+/);
          }
        } else if (option == "js_tab") {
          if (/\d+/.test(value2)) {
            var res = parseInt(value2);
            if (res < 1 || res > 4) {
              console.log(`Warning: option "js_tab" must be between 1 and 4, got ${res}`);
              res = 2;
            }
            return res;
          }
          console.warn("illegal value for js_tab", value2);
        }
        return value2;
      }
      const default_option = { args: [], cache: false, debug: 1, indexeddb: true, python_extension: ".py", static_stdlib_import: true, js_tab: 2 };
      $B2.get_filename = function() {
        if ($B2.count_frames() > 0) {
          return $B2.get_frame_at(0).__file__;
        }
      };
      $B2.get_filename_for_import = function() {
        var filename = $B2.get_filename();
        if ($B2.import_info[filename] === void 0) {
          $B2.make_import_paths(filename);
        }
        return filename;
      };
      $B2.get_page_option = function(option) {
        option = option.toLowerCase();
        if ($B2.$options.hasOwnProperty(option)) {
          return $B2.$options[option];
        } else if (brython_options.hasOwnProperty(option)) {
          return brython_options[option];
        } else {
          return default_option[option];
        }
      };
      $B2.get_option = function(option, err) {
        var filename = $B2.script_filename;
        if (err && err.filename) {
          filename = err.filename;
        } else if (err && err.$frame_obj) {
          filename = $B2.get_frame_at(0, err.$frame_obj).__file__;
        } else {
          filename = $B2.get_filename() ?? filename;
        }
        return $B2.get_option_from_filename(option, filename);
      };
      $B2.get_option_from_filename = function(option, filename) {
        if (filename === void 0 || !$B2.scripts[filename]) {
          return $B2.get_page_option(option);
        }
        var value2 = $B2.scripts[filename].getAttribute(option);
        if (value2 !== null) {
          return convert_option(option, value2);
        } else {
          return $B2.get_page_option(option);
        }
      };
      function run_scripts(_scripts) {
        var webworkers = _scripts.filter((script2) => script2.className === "webworker"), scripts = _scripts.filter((script2) => script2.className !== "webworker");
        var module_name, filename;
        if (scripts.length > 0 || $B2.isWebWorker) {
          if ($B2.get_page_option("indexedDB") && $B2.has_indexedDB && $B2.hasOwnProperty("VFS")) {
            $B2.tasks.push([$B2.idb_open]);
          }
        }
        var src;
        for (var worker of webworkers) {
          if (worker.src) {
            $B2.tasks.push([$B2.ajax_load_script, { script: worker, name: worker.id, url: worker.src, is_ww: true }]);
          } else {
            $B2.webworkers[worker.id] = worker;
            filename = $B2.script_filename = $B2.strip_host(
              $B2.script_path + "#" + worker.id
            );
            var source = worker.innerText || worker.textContent;
            source = unindent(source);
            source = source.replace(/^\n/, "");
            $B2.url2name[filename] = worker.id;
            $B2.file_cache[filename] = source;
            $B2.scripts[filename] = worker;
            $B2.dispatch_load_event(worker);
          }
        }
        for (var script of scripts) {
          module_name = script_to_id.get(script);
          if (script.src) {
            $B2.tasks.push([$B2.ajax_load_script, { script, name: module_name, url: script.src, id: script.id }]);
          } else {
            filename = $B2.script_filename = $B2.strip_host(
              $B2.script_path + "#" + module_name
            );
            src = script.innerHTML || script.textContent;
            src = unindent(src);
            src = src.replace(/^\n/, "");
            if (src.endsWith("\n")) {
              src = src.substr(0, src.length - 1);
            }
            $B2.tasks.push([$B2.run_script, script, src, module_name, $B2.script_path, true]);
          }
        }
        $B2.loop();
      }
      $B2.run_script = function(script, src, name2, url, run_loop) {
        var filename = $B2.script_filename = $B2.strip_host(url + "#" + name2);
        var script_elts = url.split("/");
        script_elts.pop();
        $B2.script_dir = script_elts.join("/");
        $B2.file_cache[filename] = src;
        $B2.url2name[filename] = name2;
        $B2.scripts[filename] = script;
        $B2.make_import_paths(filename);
        _b_2.__debug__ = $B2.get_option("debug") > 0;
        var root, js;
        try {
          root = $B2.py2js({ src, filename }, name2, name2);
          js = root.to_js();
          if ($B2.get_option_from_filename("debug", filename) > 1) {
            console.log(js);
          }
        } catch (err) {
          return $B2.handle_error($B2.exception(err));
        }
        var _script = { __doc__: get_docstring(root._ast), js, __name__: name2, __file__: url, script_element: script };
        $B2.tasks.push(["execute", _script]);
        if (run_loop) {
          $B2.loop();
        }
      };
      $B2.brython = brython;
    })(__BRYTHON__);
    globalThis.brython = __BRYTHON__.brython;
    if (__BRYTHON__.isNode) {
      global.__BRYTHON__ = __BRYTHON__;
      module.exports = { __BRYTHON__ };
    }
    (function($B2) {
      var _b_2 = $B2.builtins;
      if ($B2.VFS_timestamp && $B2.VFS_timestamp > $B2.timestamp) {
        $B2.timestamp = $B2.VFS_timestamp;
      }
      function idb_load(evt, module2) {
        var res = evt.target.result;
        var debug = $B2.get_page_option("debug");
        if (res === void 0 || res.timestamp != $B2.timestamp || $B2.VFS[module2] && res.source_ts !== $B2.VFS[module2].timestamp) {
          if ($B2.VFS[module2] !== void 0) {
            var elts = $B2.VFS[module2], ext = elts[0], source = elts[1];
            if (ext == ".py") {
              var is_package = elts.length == 4, __package__;
              if (is_package) {
                __package__ = module2;
              } else {
                var parts = module2.split(".");
                parts.pop();
                __package__ = parts.join(".");
              }
              $B2.imported[module2] = $B2.module.$factory(module2, "", __package__);
              $B2.url2name[module2] = module2;
              try {
                $B2.py2js({ src: source, filename: module2 }, module2, module2);
              } catch (err) {
                $B2.handle_error(err);
              }
              delete $B2.imported[module2];
              if (debug > 1) {
                console.log("precompile", module2);
              }
            } else {
              console.log("bizarre", module2, ext);
            }
          } else {
          }
        } else {
          if (res.is_package) {
            $B2.precompiled[module2] = [res.content];
          } else {
            $B2.precompiled[module2] = res.content;
          }
          if (res.imports.length > 0) {
            if (debug > 1) {
              console.log(module2, "imports", res.imports);
            }
            var subimports = res.imports.split(",");
            for (var i = 0; i < subimports.length; i++) {
              var subimport = subimports[i];
              if (subimport.startsWith(".")) {
                var url_elts = module2.split("."), nb_dots = 0;
                while (subimport.startsWith(".")) {
                  nb_dots++;
                  subimport = subimport.substr(1);
                }
                let elts2 = url_elts.slice(0, nb_dots);
                if (subimport) {
                  elts2 = elts2.concat([subimport]);
                }
                subimport = elts2.join(".");
              }
              if (!$B2.imported.hasOwnProperty(subimport) && !$B2.precompiled.hasOwnProperty(subimport)) {
                if ($B2.VFS.hasOwnProperty(subimport)) {
                  let submodule = $B2.VFS[subimport], source2 = submodule[1];
                  if (submodule[0] == ".py") {
                    $B2.tasks.splice(0, 0, [idb_get, subimport]);
                  } else {
                    add_jsmodule(subimport, source2);
                  }
                }
              }
            }
          }
        }
        loop();
      }
      function idb_get(module2) {
        var db = $B2.idb_cx.result, tx = db.transaction("modules", "readonly");
        try {
          var store = tx.objectStore("modules"), req = store.get(module2);
          req.onsuccess = function(evt) {
            idb_load(evt, module2);
          };
        } catch (err) {
          console.info("error", err);
        }
      }
      function remove_outdated(db, outdated, callback) {
        var tx = db.transaction("modules", "readwrite"), store = tx.objectStore("modules");
        if (outdated.length > 0) {
          let module2 = outdated.pop(), req = store.delete(module2);
          req.onsuccess = /* @__PURE__ */ (function(mod) {
            return function() {
              if ($B2.get_page_option("debug") > 1) {
                console.info("delete outdated", mod);
              }
              report_remove_outdated(mod);
              remove_outdated(db, outdated, callback);
            };
          })(module2);
        } else {
          report_close();
          callback();
        }
      }
      $B2.idb_open_promise = function() {
        return new Promise(function(resolve, reject) {
          $B2.idb_name = "brython-cache";
          var idb_cx = $B2.idb_cx = indexedDB.open($B2.idb_name);
          idb_cx.onsuccess = function() {
            var db = idb_cx.result;
            var tx = db.transaction("modules", "readwrite"), store = tx.objectStore("modules"), record, outdated = [];
            var openCursor = store.openCursor();
            openCursor.onerror = function() {
              reject("open cursor error");
            };
            openCursor.onsuccess = function(evt) {
              var cursor = evt.target.result;
              if (cursor) {
                record = cursor.value;
                if (record.timestamp == $B2.timestamp) {
                  if (!$B2.VFS || !$B2.VFS[record.name] || $B2.VFS[record.name].timestamp == record.source_ts) {
                    if (record.is_package) {
                      $B2.precompiled[record.name] = [record.content];
                    } else {
                      $B2.precompiled[record.name] = record.content;
                    }
                  } else {
                    outdated.push(record.name);
                  }
                } else {
                  outdated.push(record.name);
                }
                cursor.continue();
              } else {
                remove_outdated(db, outdated, resolve);
              }
            };
          };
          idb_cx.onupgradeneeded = function() {
            var db = idb_cx.result, store = db.createObjectStore("modules", { "keyPath": "name" });
            store.onsuccess = resolve;
          };
          idb_cx.onerror = function() {
            $B2.idb_cx = null;
            $B2.idb_name = null;
            $B2.$options.indexeddb = false;
            reject("could not open indexedDB database");
          };
        });
      };
      $B2.idb_open = function() {
        $B2.idb_name = "brython-cache";
        var idb_cx = $B2.idb_cx = indexedDB.open($B2.idb_name);
        idb_cx.onsuccess = function() {
          var db = idb_cx.result;
          if ($B2.get_page_option("debug") > 1) {
            console.info("using indexedDB for stdlib modules cache");
          }
          var tx = db.transaction("modules", "readwrite"), store = tx.objectStore("modules"), record, outdated = [];
          var openCursor = store.openCursor();
          openCursor.onerror = function(evt) {
            console.log("open cursor error", evt);
          };
          openCursor.onsuccess = function(evt) {
            var cursor = evt.target.result;
            if (cursor) {
              record = cursor.value;
              if (record.timestamp == $B2.timestamp) {
                if (!$B2.VFS || !$B2.VFS[record.name] || $B2.VFS[record.name].timestamp == record.source_ts) {
                  if (record.is_package) {
                    $B2.precompiled[record.name] = [record.content];
                  } else {
                    $B2.precompiled[record.name] = record.content;
                  }
                  if ($B2.get_page_option("debug") > 1) {
                    console.info("load from cache", record.name);
                  }
                } else {
                  outdated.push(record.name);
                }
              } else {
                outdated.push(record.name);
              }
              cursor.continue();
            } else {
              if ($B2.get_page_option("debug") > 1) {
                console.log("done");
              }
              remove_outdated(db, outdated, loop);
            }
          };
        };
        idb_cx.onupgradeneeded = function() {
          console.info("upgrade needed");
          var db = idb_cx.result, store = db.createObjectStore("modules", { "keyPath": "name" });
          store.onsuccess = loop;
        };
        idb_cx.onerror = function() {
          console.info("could not open indexedDB database");
          $B2.idb_cx = null;
          $B2.idb_name = null;
          $B2.$options.indexeddb = false;
          loop();
        };
        idb_cx.onversionchange = function() {
          console.log("version change");
        };
      };
      $B2.ajax_load_script = function(s) {
        var script = s.script, url = s.url, name2 = s.name, rel_path = url.substr($B2.script_dir.length + 1);
        if ($B2.files && $B2.files.hasOwnProperty(rel_path)) {
          var src = atob($B2.files[rel_path].content);
          if (s.is_ww) {
            $B2.webworkers[name2] = script;
            var filename = $B2.script_filename = $B2.strip_host(url);
            $B2.file_cache[filename] = src;
            $B2.dispatch_load_event(script);
          }
          $B2.tasks.splice(0, 0, [$B2.run_script, script, src, name2, url, true]);
          loop();
        } else if ($B2.protocol != "file") {
          var filename = $B2.script_filename = $B2.strip_host(url);
          $B2.scripts[filename] = script;
          var req = new XMLHttpRequest(), cache = $B2.get_option("cache"), qs = cache ? "" : (url.search(/\?/) > -1 ? "&" : "?") + Date.now();
          req.open("GET", url + qs, true);
          req.onreadystatechange = function() {
            if (this.readyState == 4) {
              if (this.status == 200) {
                var src2 = this.responseText;
                if (s.is_ww) {
                  $B2.webworkers[name2] = script;
                  $B2.file_cache[filename] = src2;
                  $B2.dispatch_load_event(script);
                } else {
                  $B2.tasks.splice(0, 0, [$B2.run_script, script, src2, name2, url, true]);
                }
                loop();
              } else if (this.status == 404) {
                throw Error(url + " not found");
              }
            }
          };
          req.send();
        } else {
          throw _b_2.IOError.$factory("can't load external script at " + script.url + " (Ajax calls not supported with protocol file:///)");
        }
      };
      function add_jsmodule(module2, source) {
        source += "\nvar $locals_" + module2.replace(/\./g, "_") + " = $module";
        $B2.precompiled[module2] = source;
      }
      $B2.inImported = function(module2) {
        if ($B2.imported.hasOwnProperty(module2)) {
        } else if (__BRYTHON__.VFS && __BRYTHON__.VFS.hasOwnProperty(module2)) {
          var elts = __BRYTHON__.VFS[module2];
          var ext = elts[0], source = elts[1];
          if (ext == ".py") {
            if ($B2.idb_cx) {
              $B2.tasks.splice(0, 0, [idb_get, module2]);
            }
          } else {
            add_jsmodule(module2, source);
          }
        } else {
          console.log("bizarre", module2);
        }
        loop();
      };
      function report_remove_outdated(mod) {
        if (!$B2.isWebWorker) {
          document.dispatchEvent(new CustomEvent("precompile", { detail: `remove outdated ${mod} from cache` }));
        }
      }
      function report_close() {
        if (!$B2.isWebWorker) {
          document.dispatchEvent(new CustomEvent("precompile", { detail: "close" }));
        }
      }
      function report_done() {
        if (!$B2.isWebWorker) {
          document.dispatchEvent(new CustomEvent("brython_done", { detail: _b_2.dict.$from_js($B2.$options) }));
        }
      }
      var loop = $B2.loop = function() {
        if ($B2.tasks.length == 0) {
          report_done();
          return;
        }
        var task = $B2.tasks.shift(), func = task[0], args = task.slice(1);
        if (func == "execute") {
          let script = task[1], script_id = script.__name__.replace(/\./g, "_"), module2 = $B2.module.$factory(script.__name__);
          module2.__file__ = script.__file__;
          module2.__doc__ = script.__doc__;
          $B2.imported[script_id] = module2;
          try {
            var modobj = new Function(script.js + `
return locals`)();
            for (var key2 in modobj) {
              if (!key2.startsWith("$")) {
                module2[key2] = modobj[key2];
              }
            }
            $B2.dispatch_load_event(script.script_element);
          } catch (err) {
            if (err.__class__ === void 0) {
              if (err.$py_exc) {
                err = err.$py_exc;
              } else {
                if ($B2.get_option("debug") > 2) {
                  console.log("JS error stack", err.stack);
                }
                var stack = err.$stack, frame_obj = err.$frame_obj, linenums = err.$linenums;
                var lineNumber = err.lineNumber;
                if (lineNumber !== void 0) {
                  console.log("around line", lineNumber);
                  console.log(script.js.split("\n").slice(lineNumber - 4, lineNumber).join("\n"));
                }
                $B2.print_stack();
                err = _b_2.RuntimeError.$factory(err + "");
                err.$stack = stack;
                err.$frame_obj = frame_obj;
                err.$linenums = linenums;
              }
            }
            $B2.handle_error(err);
          }
          loop();
        } else {
          try {
            func.apply(null, args);
          } catch (err) {
            $B2.handle_error(err);
          }
        }
      };
      $B2.tasks = [];
      $B2.has_indexedDB = self.indexedDB !== void 0;
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins, _window = globalThis, isWebWorker = "undefined" !== typeof WorkerGlobalScope && "function" === typeof importScripts && navigator instanceof WorkerNavigator;
      function missing_required_kwonly(fname, args) {
        var plural = args.length == 1 ? "" : "s", arg_list;
        args = args.map((x) => `'${x}'`);
        if (args.length == 1) {
          arg_list = args[0];
        } else if (args.length == 2) {
          arg_list = args[0] + " and " + args[1];
        } else {
          arg_list = args.slice(0, args.length - 1).join(", ") + ", and " + args[args.length - 1];
        }
        throw _b_2.TypeError.$factory(fname + `() missing ${args.length} required keyword-only argument${plural}: ` + arg_list);
      }
      function missing_required_pos(fname, args) {
        var plural = args.length == 1 ? "" : "s", arg_list;
        args = args.map((x) => `'${x}'`);
        if (args.length == 1) {
          arg_list = args[0];
        } else if (args.length == 2) {
          arg_list = args[0] + " and " + args[1];
        } else {
          arg_list = args.slice(0, args.length - 1).join(", ") + ", and " + args[args.length - 1];
        }
        throw _b_2.TypeError.$factory(fname + `() missing ${args.length} required positional argument${plural}: ` + arg_list);
      }
      function multiple_values(fname, arg) {
        throw _b_2.TypeError.$factory(fname + `() got multiple values for argument '${arg}'`);
      }
      function pos_only_passed_as_keyword(fname, arg) {
        return _b_2.TypeError.$factory(fname + `() got some positional-only arguments passed as keyword arguments: '${arg}'`);
      }
      function too_many_pos_args(fname, kwarg, arg_names, nb_kwonly, defaults, args, slots) {
        var nb_pos = args.length, last = $B2.last(args);
        if (last !== null && last !== void 0 && last.$kw) {
          if (!kwarg) {
            var kw = $B2.parse_kwargs(last.$kw, fname);
            for (var k in kw) {
              if (!slots.hasOwnProperty(k)) {
                var suggestion = $B2.offer_suggestions_for_unexpected_keyword_error(arg_names, k);
                throw unexpected_keyword(fname, k, suggestion);
              }
            }
          }
          nb_pos--;
        }
        var nb_def = defaults.length;
        var expected = arg_names.length - nb_kwonly, plural = expected == 1 ? "" : "s";
        if (nb_def) {
          expected = `from ${expected - nb_def} to ${expected}`;
          plural = "s";
        }
        var verb = nb_pos == 1 ? "was" : "were";
        return _b_2.TypeError.$factory(fname + `() takes ${expected} positional argument${plural} but ${nb_pos} ${verb} given`);
      }
      function unexpected_keyword(fname, k, suggestion) {
        var msg = `${fname}() got an unexpected keyword argument '${k}'`;
        if (suggestion !== _b_2.None) {
          msg += `. Did you mean: '${suggestion}'?`;
        }
        return _b_2.TypeError.$factory(msg);
      }
      var empty = {};
      function args0(f, args) {
        var arg_names = f.$infos.arg_names, code = f.$infos.__code__, slots = {};
        for (var arg_name of arg_names) {
          slots[arg_name] = empty;
        }
        return $B2.parse_args(
          args,
          f.$infos.__name__,
          code.co_argcount,
          slots,
          arg_names,
          f.$infos.__defaults__,
          f.$infos.__kwdefaults__,
          f.$infos.vararg,
          f.$infos.kwarg,
          code.co_posonlyargcount,
          code.co_kwonlyargcount
        );
      }
      function args0_NEW(fct, args) {
        const LAST_ARGS = args[args.length - 1];
        const HAS_KW = LAST_ARGS !== void 0 && LAST_ARGS !== null && LAST_ARGS.$kw !== void 0;
        let ARGS_POS_COUNT = args.length, ARGS_NAMED = null;
        if (HAS_KW) {
          --ARGS_POS_COUNT;
          ARGS_NAMED = LAST_ARGS.$kw;
        }
        const result = {};
        const $INFOS = fct.$infos, $CODE = $INFOS.__code__, PARAMS_NAMES = $INFOS.arg_names, PARAMS_POS_COUNT = $CODE.co_argcount, PARAMS_NAMED_COUNT = $CODE.co_kwonlyargcount, PARAMS_VARARGS_NAME = $INFOS.vararg, PARAMS_KWARGS_NAME = $INFOS.kwarg, PARAMS_POS_DEFAULTS = $INFOS.__defaults__, PARAMS_POS_DEFAULTS_COUNT = PARAMS_POS_DEFAULTS.length, PARAMS_POS_DEFAULTS_OFFSET = PARAMS_POS_COUNT - PARAMS_POS_DEFAULTS_COUNT;
        const min = Math.min(ARGS_POS_COUNT, PARAMS_POS_COUNT);
        let offset = 0;
        for (; offset < min; ++offset) {
          result[PARAMS_NAMES[offset]] = args[offset];
        }
        if (PARAMS_VARARGS_NAME !== null) {
          result[PARAMS_VARARGS_NAME] = $B2.fast_tuple(
            Array.prototype.slice.call(args, PARAMS_POS_COUNT, ARGS_POS_COUNT)
          );
        } else if (ARGS_POS_COUNT > PARAMS_POS_COUNT) {
          args0(fct, args);
          throw new Error("Too much positional arguments given (args0 should have raised an error) !");
        }
        if (ARGS_NAMED === null) {
          if (offset < PARAMS_POS_DEFAULTS_OFFSET) {
            args0(fct, args);
            throw new Error("Not enough positional arguments given (args0 should have raised an error) !");
          }
          for (let i = offset - PARAMS_POS_DEFAULTS_OFFSET; i < PARAMS_POS_DEFAULTS_COUNT; ++i) {
            result[PARAMS_NAMES[offset++]] = PARAMS_POS_DEFAULTS[i];
          }
          if (PARAMS_KWARGS_NAME !== null) {
            result[PARAMS_KWARGS_NAME] = $B2.empty_dict();
          }
          if (PARAMS_NAMED_COUNT === 0) {
            return result;
          }
          const kwargs_defaults_values = fct.$kwdefaults_values;
          const nb_named_defaults = kwargs_defaults_values.length;
          if (nb_named_defaults < PARAMS_NAMED_COUNT) {
            args0(fct, args);
            throw new Error("Named argument expected (args0 should have raised an error) !");
          }
          for (let i = 0; i < nb_named_defaults; ++i) {
            result[PARAMS_NAMES[offset++]] = kwargs_defaults_values[i];
          }
          return result;
        }
        const kwargs_defaults = fct.$kwdefaults;
        const PARAMS_POSONLY_COUNT = $CODE.co_posonlyargcount;
        if (offset < PARAMS_POSONLY_COUNT) {
          if (offset < PARAMS_POS_DEFAULTS_OFFSET) {
            args0(fct, args);
            throw new Error("Not enough positional parameters given (args0 should have raised an error) !");
          }
          const max = PARAMS_POS_DEFAULTS_COUNT - (PARAMS_POS_COUNT - PARAMS_POSONLY_COUNT);
          for (let i = offset - PARAMS_POS_DEFAULTS_OFFSET; i < max; ++i) {
            result[PARAMS_NAMES[offset++]] = PARAMS_POS_DEFAULTS[i];
          }
        }
        if (PARAMS_KWARGS_NAME === null) {
          let nb_named_args2 = 0;
          let kargs2 = ARGS_NAMED[0];
          for (let argname in kargs2) {
            result[argname] = kargs2[argname];
            ++nb_named_args2;
          }
          for (let id = 1, len = ARGS_NAMED.length; id < len; ++id) {
            kargs2 = ARGS_NAMED[id];
            for (let argname of $B2.make_js_iterator($B2.$getattr(kargs2.__class__, "keys")(kargs2))) {
              if (typeof argname !== "string") {
                $B2.args0_old(fct, args);
                throw new Error("Non string key passed in **kargs");
              }
              result[argname] = $B2.$getitem(kargs2, argname);
              ++nb_named_args2;
            }
          }
          let found2 = 0;
          let ioffset2 = offset;
          for (; ioffset2 < PARAMS_POS_DEFAULTS_OFFSET; ++ioffset2) {
            const key2 = PARAMS_NAMES[ioffset2];
            if (key2 in result) {
              continue;
            }
            args0(fct, args);
            throw new Error("Missing a named arguments (args0 should have raised an error) !");
          }
          for (; ioffset2 < PARAMS_POS_COUNT; ++ioffset2) {
            const key2 = PARAMS_NAMES[ioffset2];
            if (key2 in result) {
              continue;
            }
            result[key2] = PARAMS_POS_DEFAULTS[ioffset2 - PARAMS_POS_DEFAULTS_OFFSET];
            ++found2;
          }
          for (; ioffset2 < PARAMS_NAMES.length; ++ioffset2) {
            const key2 = PARAMS_NAMES[ioffset2];
            if (key2 in result) {
              continue;
            }
            if (!kwargs_defaults.has(key2)) {
              args0(fct, args);
              throw new Error("Missing a named arguments (args0 should have raised an error) !");
            }
            result[key2] = kwargs_defaults.get(key2);
            ++found2;
          }
          if (found2 + nb_named_args2 !== PARAMS_NAMES.length - offset) {
            args0(fct, args);
            throw new Error("Inexistant or duplicate named arguments (args0 should have raised an error) !");
          }
          return result;
        }
        const extra = {};
        const HAS_PARAMS = fct.$hasParams;
        let nb_named_args = 0;
        let nb_extra_args = 0;
        let kargs = ARGS_NAMED[0];
        for (let argname in kargs) {
          if (HAS_PARAMS.has(argname)) {
            result[argname] = kargs[argname];
            ++nb_named_args;
          } else {
            extra[argname] = kargs[argname];
            ++nb_extra_args;
          }
        }
        for (let id = 1, len = ARGS_NAMED.length; id < len; ++id) {
          kargs = ARGS_NAMED[id];
          for (let argname of $B2.make_js_iterator($B2.$getattr(kargs.__class__, "keys")(kargs))) {
            if (typeof argname !== "string") {
              $B2.args0_old(fct, args);
              throw new Error("Non string key passed in **kargs");
            }
            if (HAS_PARAMS.has(argname)) {
              result[argname] = $B2.$getitem(kargs, argname);
              ++nb_named_args;
            } else {
              extra[argname] = $B2.$getitem(kargs, argname);
              ++nb_extra_args;
            }
          }
        }
        let found = 0;
        let ioffset = offset;
        for (; ioffset < PARAMS_POS_DEFAULTS_OFFSET; ++ioffset) {
          const key2 = PARAMS_NAMES[ioffset];
          if (key2 in result) {
            continue;
          }
          args0(fct, args);
          throw new Error("Missing a named arguments (args0 should have raised an error) !");
        }
        for (; ioffset < PARAMS_POS_COUNT; ++ioffset) {
          const key2 = PARAMS_NAMES[ioffset];
          if (key2 in result) {
            continue;
          }
          result[key2] = PARAMS_POS_DEFAULTS[ioffset - PARAMS_POS_DEFAULTS_OFFSET];
          ++found;
        }
        for (; ioffset < PARAMS_NAMES.length; ++ioffset) {
          const key2 = PARAMS_NAMES[ioffset];
          if (key2 in result) {
            continue;
          }
          if (!kwargs_defaults.has(key2)) {
            args0(fct, args);
            throw new Error("Missing a named arguments (args0 should have raised an error) !");
          }
          result[key2] = kwargs_defaults.get(key2);
          ++found;
        }
        if (found + nb_named_args !== PARAMS_NAMES.length - offset) {
          args0(fct, args);
          throw new Error("Inexistant or duplicate named arguments (args0 should have raised an error) !");
        }
        if (Object.keys(extra).length !== nb_extra_args) {
          args0(fct, args);
          throw new Error("Duplicate name given to **kargs parameter (args0 should have raised an error) !");
        }
        result[PARAMS_KWARGS_NAME] = _b_2.dict.$from_js(extra);
        return result;
      }
      $B2.args0_old = args0;
      $B2.args0 = args0_NEW;
      $B2.args = function(fname, argcount, slots, var_names, args, $dobj, vararg, kwarg, nb_posonly) {
        var nb_posonly = nb_posonly || 0, nb_kwonly = var_names.length - argcount, defaults = [], kwdefaults = { $jsobj: {} };
        for (var i = 0, len = var_names.length; i < len; i++) {
          var var_name = var_names[i];
          if ($dobj.hasOwnProperty(var_name)) {
            if (i < argcount) {
              defaults.push($dobj[var_name]);
            } else {
              kwdefaults.$jsobj[var_name] = $dobj[var_name];
            }
          }
        }
        for (var k in slots) {
          slots[k] = empty;
        }
        return $B2.parse_args(args, fname, argcount, slots, var_names, defaults, kwdefaults, vararg, kwarg, nb_posonly, nb_kwonly);
      };
      $B2.single_arg = function(fname, arg, args) {
        var slots = {};
        slots[arg] = null;
        var $ = $B2.args(fname, 1, slots, [arg], args, {}, null, null);
        return $[arg];
      };
      $B2.parse_args = function(args, fname, argcount, slots, arg_names, defaults, kwdefaults, vararg, kwarg, nb_posonly, nb_kwonly) {
        var nb_passed = args.length, nb_passed_pos = nb_passed, nb_expected = arg_names.length, nb_pos_or_kw = nb_expected - nb_kwonly, posonly_set = {}, nb_def = defaults.length, varargs = [], extra_kw = {}, kw;
        for (var i = 0; i < nb_passed; i++) {
          var arg = args[i];
          if (arg && arg.__class__ === $B2.generator) {
            slots.$has_generators = true;
          }
          if (arg && arg.$kw) {
            nb_passed_pos--;
            kw = $B2.parse_kwargs(arg.$kw, fname);
          } else {
            var arg_name = arg_names[i];
            if (arg_name !== void 0) {
              if (i >= nb_pos_or_kw) {
                if (vararg) {
                  varargs.push(arg);
                } else {
                  throw too_many_pos_args(
                    fname,
                    kwarg,
                    arg_names,
                    nb_kwonly,
                    defaults,
                    args,
                    slots
                  );
                }
              } else {
                if (i < nb_posonly) {
                  posonly_set[arg_name] = true;
                }
                slots[arg_name] = arg;
              }
            } else if (vararg) {
              varargs.push(arg);
            } else {
              throw too_many_pos_args(
                fname,
                kwarg,
                arg_names,
                nb_kwonly,
                defaults,
                args,
                slots
              );
            }
          }
        }
        for (var j2 = nb_passed_pos; j2 < nb_pos_or_kw; j2++) {
          var arg_name = arg_names[j2];
          if (kw && kw.hasOwnProperty(arg_name)) {
            if (j2 < nb_posonly) {
              if (!kwarg) {
                throw pos_only_passed_as_keyword(fname, arg_name);
              }
            } else {
              slots[arg_name] = kw[arg_name];
              kw[arg_name] = empty;
            }
          }
          if (slots[arg_name] === empty) {
            var def_value = defaults[j2 - (nb_pos_or_kw - nb_def)];
            if (def_value !== void 0) {
              slots[arg_name] = def_value;
              if (j2 < nb_posonly) {
                if (kw && kw.hasOwnProperty(arg_name) && kwarg) {
                  extra_kw[arg_name] = kw[arg_name];
                  kw[arg_name] = empty;
                }
              }
            } else {
              var missing_pos = arg_names.slice(j2, nb_pos_or_kw - nb_def);
              throw missing_required_pos(fname, missing_pos);
            }
          }
        }
        var missing_kwonly = [];
        for (var i = nb_pos_or_kw; i < nb_expected; i++) {
          var arg_name = arg_names[i];
          if (kw && kw.hasOwnProperty(arg_name)) {
            slots[arg_name] = kw[arg_name];
            kw[arg_name] = empty;
          } else {
            var kw_def = _b_2.dict.$get_string(kwdefaults, arg_name);
            if (kw_def !== _b_2.dict.$missing) {
              slots[arg_name] = kw_def;
            } else {
              missing_kwonly.push(arg_name);
            }
          }
        }
        if (missing_kwonly.length > 0) {
          throw missing_required_kwonly(fname, missing_kwonly);
        }
        if (!kwarg) {
          for (var k in kw) {
            if (!slots.hasOwnProperty(k)) {
              var suggestion = $B2.offer_suggestions_for_unexpected_keyword_error(
                arg_names,
                k
              );
              throw unexpected_keyword(fname, k, suggestion);
            }
          }
        }
        for (var k in kw) {
          if (kw[k] === empty) {
            continue;
          }
          if (!slots.hasOwnProperty(k)) {
            if (kwarg) {
              extra_kw[k] = kw[k];
            }
          } else if (slots[k] !== empty) {
            if (posonly_set[k] && kwarg) {
              extra_kw[k] = kw[k];
            } else {
              throw multiple_values(fname, k);
            }
          } else {
            slots[k] = kw[k];
          }
        }
        if (kwarg) {
          slots[kwarg] = _b_2.dict.$from_js(extra_kw);
        }
        if (vararg) {
          slots[vararg] = $B2.fast_tuple(varargs);
        }
        return slots;
      };
      $B2.parse_kwargs = function(kw_args, fname) {
        var kwa = kw_args[0];
        for (var i = 1, len = kw_args.length; i < len; i++) {
          var kw_arg = kw_args[i], key2, value2;
          if (kw_arg.__class__ === _b_2.dict) {
            for (var entry of _b_2.dict.$iter_items(kw_arg)) {
              key2 = entry.key;
              if (typeof key2 !== "string") {
                throw _b_2.TypeError.$factory(fname + "() keywords must be strings");
              } else if (kwa[key2] !== void 0) {
                throw _b_2.TypeError.$factory(fname + "() got multiple values for argument '" + key2 + "'");
              } else {
                kwa[key2] = entry.value;
              }
            }
          } else {
            var cls = $B2.get_class(kw_arg);
            try {
              var keys_method = $B2.$call1($B2.$getattr(cls, "keys"));
            } catch (err) {
              throw _b_2.TypeError.$factory(`${fname} argument after ** must be a mapping, not ${$B2.class_name(kw_arg)}`);
            }
            var keys_iter = $B2.make_js_iterator(keys_method(kw_arg)), getitem;
            for (var k of keys_iter) {
              if (typeof k !== "string") {
                throw _b_2.TypeError.$factory(fname + "() keywords must be strings");
              }
              if (kwa[k] !== void 0) {
                throw _b_2.TypeError.$factory(fname + "() got multiple values for argument '" + k + "'");
              }
              if (!getitem) {
                try {
                  getitem = $B2.$getattr(cls, "__getitem__");
                } catch (err) {
                  throw _b_2.TypeError.$factory(
                    `'${$B2.class_name(kw_arg)}' object is not subscriptable`
                  );
                }
              }
              kwa[k] = getitem(kw_arg, k);
            }
          }
        }
        return kwa;
      };
      $B2.check_nb_args = function(name2, expected, args) {
        var len = args.length, last = args[len - 1];
        if (last && last.$kw) {
          var kw = last.$kw;
          if (kw[1]) {
            if (_b_2.len(kw[1]) == 0) {
              len--;
            }
          }
        }
        if (len != expected) {
          if (expected == 0) {
            throw _b_2.TypeError.$factory(name2 + "() takes no argument (" + len + " given)");
          } else {
            throw _b_2.TypeError.$factory(name2 + "() takes exactly " + expected + " argument" + (expected < 2 ? "" : "s") + " (" + len + " given)");
          }
        }
      };
      $B2.check_no_kw = function(name2, x, y) {
        if (x === void 0) {
          console.log("x undef", name2, x, y);
        }
        if (x.$kw && x.$kw[0] && Object.keys(x.$kw[0]).length > 0 || y !== void 0 && y.$kw) {
          throw _b_2.TypeError.$factory(name2 + "() takes no keyword arguments");
        }
      };
      $B2.check_nb_args_no_kw = function(name2, expected, args) {
        var len = args.length, last = args[len - 1];
        if (last && last.$kw) {
          if (last.$kw.length == 2 && Object.keys(last.$kw[0]).length == 0) {
            len--;
          } else {
            throw _b_2.TypeError.$factory(name2 + "() takes no keyword arguments");
          }
        }
        if (len != expected) {
          if (expected == 0) {
            throw _b_2.TypeError.$factory(name2 + "() takes no argument (" + len + " given)");
          } else {
            throw _b_2.TypeError.$factory(name2 + "() takes exactly " + expected + " argument" + (expected < 2 ? "" : "s") + " (" + len + " given)");
          }
        }
      };
      $B2.get_class = function(obj) {
        if (obj === null) {
          return $B2.imported.javascript.NullType;
        }
        if (obj === void 0) {
          return $B2.imported.javascript.UndefinedType;
        }
        var klass = obj.__class__ || obj.$tp_class;
        if (klass === void 0) {
          switch (typeof obj) {
            case "number":
              if (Number.isInteger(obj)) {
                return _b_2.int;
              }
              break;
            case "string":
              return _b_2.str;
            case "boolean":
              return _b_2.bool;
            case "function":
              if (!obj.$js_func) {
                return $B2.function;
              }
            case "object":
              if (Array.isArray(obj)) {
                return $B2.js_array;
              } else if (obj instanceof $B2.str_dict) {
                return _b_2.dict;
              } else if (typeof Node !== "undefined" && obj instanceof Node) {
                if (obj.tagName) {
                  return $B2.imported["browser.html"][obj.tagName] || $B2.DOMNode;
                }
                return $B2.DOMNode;
              } else if (obj instanceof Event) {
                return $B2.DOMEvent;
              }
              break;
          }
        }
        if (klass === void 0) {
          return $B2.get_jsobj_class(obj);
        }
        return klass;
      };
      $B2.class_name = function(obj) {
        var klass = $B2.get_class(obj);
        if (klass === $B2.JSObj) {
          return "Javascript " + obj.constructor.name;
        } else {
          return klass.__name__;
        }
      };
      $B2.unpack_mapping = function(func, obj) {
        var items = [];
        if ($B2.$isinstance(obj, _b_2.dict)) {
          for (var item2 of _b_2.dict.$iter_items(obj)) {
            if (!$B2.$isinstance(item2.key, _b_2.str)) {
              throw _b_2.TypeError.$factory("keywords must be strings");
            }
            items.push(item2);
          }
          return items;
        }
        var klass = $B2.get_class(obj);
        var getitem = $B2.$getattr(klass, "__getitem__", null);
        if (getitem === null) {
          throw _b_2.TypeError.$factory(`'${$B2.class_name(obj)}' object is not subscriptable`);
        }
        getitem = $B2.$call(getitem);
        var key_func = $B2.$getattr(klass, "keys", null);
        if (key_func === null) {
          var f = `${func.$infos.__module__}.${func.$infos.__name__}`;
          throw _b_2.TypeError.$factory(`${f}() argument after ** must be a mapping, not ${$B2.class_name(obj)}`);
        }
        var keys = $B2.$call($B2.$getattr(klass, "keys"))(obj);
        for (var key2 of $B2.make_js_iterator(keys)) {
          if (!$B2.$isinstance(key2, _b_2.str)) {
            throw _b_2.TypeError.$factory("keywords must be strings");
          }
          items.push({ key: key2, value: getitem(obj, key2) });
        }
        return items;
      };
      $B2.make_js_iterator = function(iterator, frame, lineno) {
        var set_lineno = $B2.set_lineno;
        if (frame === void 0) {
          if (!$B2.frame_obj) {
            set_lineno = function() {
            };
          } else {
            frame = $B2.frame_obj.frame;
            lineno = frame.$lineno;
          }
        }
        if (iterator.__class__ === _b_2.range) {
          var obj = { ix: iterator.start };
          if (iterator.step > 0) {
            return {
              [Symbol.iterator]() {
                return this;
              },
              next() {
                set_lineno(frame, lineno);
                if (obj.ix >= iterator.stop) {
                  return { done: true, value: null };
                }
                var value2 = obj.ix;
                obj.ix += iterator.step;
                return { done: false, value: value2 };
              }
            };
          } else {
            return {
              [Symbol.iterator]() {
                return this;
              },
              next() {
                set_lineno(frame, lineno);
                if (obj.ix <= iterator.stop) {
                  return { done: true, value: null };
                }
                var value2 = obj.ix;
                obj.ix += iterator.step;
                return { done: false, value: value2 };
              }
            };
          }
        }
        if (iterator[Symbol.iterator] && !iterator.$is_js_array) {
          var it = iterator[Symbol.iterator]();
          return {
            [Symbol.iterator]() {
              return this;
            },
            next() {
              set_lineno(frame, lineno);
              return it.next();
            }
          };
        }
        var next_func = $B2.$getattr(_b_2.iter(iterator), "__next__", null);
        if (next_func !== null) {
          next_func = $B2.$call(next_func);
          return {
            [Symbol.iterator]() {
              return this;
            },
            next() {
              set_lineno(frame, lineno);
              try {
                var value2 = next_func();
                return { done: false, value: value2 };
              } catch (err) {
                if ($B2.is_exc(err, [_b_2.StopIteration])) {
                  return { done: true, value: null };
                }
                if (iterator.$inum) {
                  $B2.set_inum(iterator.$inum);
                }
                throw err;
              }
            }
          };
        }
      };
      $B2.unpacker = function(obj, nb_targets, has_starred) {
        var inum_rank = 3;
        if (has_starred) {
          var nb_after_starred = arguments[3];
          inum_rank++;
        }
        var inum = arguments[inum_rank];
        var t = _b_2.list.$factory(obj), right_length = t.length, left_length = nb_targets + (has_starred ? nb_after_starred - 1 : 0);
        if (!has_starred && right_length < nb_targets || has_starred && right_length < nb_targets - 1) {
          $B2.set_inum(inum);
          var exc = _b_2.ValueError.$factory(`not enough values to unpack (expected ${has_starred ? " at least " : ""} ${left_length}, got ${right_length})`);
          throw exc;
        }
        if (!has_starred && right_length > left_length) {
          var exc = _b_2.ValueError.$factory(`too many values to unpack (expected ${left_length}, got ${right_length})`);
          throw exc;
        }
        t.index = -1;
        t.read_one = function() {
          t.index++;
          return t[t.index];
        };
        t.read_rest = function() {
          t.index++;
          var res = t.slice(t.index, t.length - nb_after_starred);
          t.index = t.length - nb_after_starred - 1;
          return $B2.$list(res);
        };
        return t;
      };
      $B2.set_lineno = function(frame, lineno, type) {
        frame.$lineno = lineno;
        if (frame.$f_trace !== _b_2.None) {
          $B2.trace_line();
        }
        if (type) {
          frame[type] = frame[type] || {};
          frame[type][lineno] = true;
        }
        return true;
      };
      $B2.get_method_class = function(method, ns, qualname, refs) {
        var klass = ns;
        if (method.$function_infos && method.$function_infos[$B2.func_attrs.method_class]) {
          return method.$function_infos[$B2.func_attrs.method_class];
        }
        for (var ref of refs) {
          if (klass[ref] === void 0) {
            return $B2.make_class(qualname);
          }
          klass = klass[ref];
        }
        return klass;
      };
      $B2.warn = function(klass, message, filename, token) {
        var warning = klass.$factory(message);
        warning.filename = filename;
        if (klass === _b_2.SyntaxWarning) {
          warning.lineno = token.lineno;
          warning.offset = token.col_offset;
          warning.end_lineno = token.end_lineno;
          warning.end_offset = token.end_coloffset;
          warning.text = token.line;
          warning.args[1] = $B2.fast_tuple([filename, warning.lineno, warning.offset, warning.text, warning.end_lineno, warning.end_offset]);
        }
        $B2.imported._warnings.warn(warning);
      };
      $B2.assert = function(test, msg, inum) {
        if (!$B2.$bool(test)) {
          var exc = _b_2.AssertionError.$factory(msg);
          $B2.set_inum(inum);
          throw exc;
        }
      };
      function index_error(obj) {
        var type = typeof obj == "string" ? "string" : "list";
        return _b_2.IndexError.$factory(type + " index out of range");
      }
      $B2.$getitem = function(obj, item2, inum) {
        try {
          return $B2.$getitem1(obj, item2);
        } catch (err) {
          $B2.set_inum(inum);
          throw err;
        }
      };
      $B2.$getitem1 = function(obj, item2) {
        var is_list = Array.isArray(obj) && obj.__class__ === _b_2.list, is_dict = obj.__class__ === _b_2.dict && !obj.$jsobj;
        if (typeof item2 == "number") {
          if (is_list || typeof obj == "string") {
            item2 = item2 >= 0 ? item2 : obj.length + item2;
            if (obj[item2] !== void 0) {
              return obj[item2];
            } else {
              throw index_error(obj);
            }
          }
        } else if (item2.valueOf && typeof item2.valueOf() == "string" && is_dict) {
          return _b_2.dict.$getitem(obj, item2);
        }
        if (obj.$is_class) {
          if (!Array.isArray(item2)) {
            item2 = $B2.fast_tuple([item2]);
          }
          if (obj === _b_2.type) {
            return $B2.$class_getitem(obj, item2);
          }
          var class_gi = $B2.$getattr(obj, "__class_getitem__", _b_2.None);
          if (class_gi !== _b_2.None) {
            return $B2.$call(class_gi)(item2);
          } else if (obj.__class__) {
            class_gi = $B2.$getattr(obj.__class__, "__getitem__", _b_2.None);
            if (class_gi !== _b_2.None) {
              return class_gi(obj, item2);
            } else {
              throw _b_2.TypeError.$factory("type '" + $B2.$getattr(obj, "__qualname__") + "' is not subscriptable");
            }
          }
        }
        if (is_list) {
          return _b_2.list.$getitem(obj, item2);
        }
        if (is_dict) {
          return _b_2.dict.$getitem(obj, item2);
        }
        var gi = $B2.$getattr(obj.__class__ || $B2.get_class(obj), "__getitem__", _b_2.None);
        if (gi !== _b_2.None) {
          return gi(obj, item2);
        }
        var exc = _b_2.TypeError.$factory("'" + $B2.class_name(obj) + "' object is not subscriptable");
        throw exc;
      };
      $B2.getitem_slice = function(obj, slice) {
        var res;
        if (Array.isArray(obj) && obj.__class__ === _b_2.list) {
          return _b_2.list.$getitem(obj, slice);
        } else if (typeof obj == "string") {
          return _b_2.str.__getitem__(obj, slice);
        }
        return $B2.$getattr($B2.get_class(obj), "__getitem__")(obj, slice);
      };
      $B2.$getattr_pep657 = function(obj, attr, inum) {
        try {
          return $B2.$getattr(obj, attr);
        } catch (err) {
          $B2.set_inum(inum);
          throw err;
        }
      };
      $B2.$setitem = function(obj, item2, value2, inum) {
        if (Array.isArray(obj) && obj.__class__ === void 0 && !obj.$is_js_array && typeof item2 == "number" && !$B2.$isinstance(obj, _b_2.tuple)) {
          if (item2 < 0) {
            item2 += obj.length;
          }
          if (obj[item2] === void 0) {
            $B2.set_inum(inum);
            throw _b_2.IndexError.$factory("list assignment index out of range");
          }
          obj[item2] = value2;
          return;
        } else if (obj.__class__ === _b_2.dict) {
          _b_2.dict.$setitem(obj, item2, value2);
          return;
        } else if (obj.__class__ === _b_2.list) {
          try {
            return _b_2.list.$setitem(obj, item2, value2);
          } catch (err) {
            if ($B2.is_exc(err, [_b_2.IndexError])) {
              $B2.set_inum(inum);
            }
            throw err;
          }
        }
        var si = $B2.$getattr(obj.__class__ || $B2.get_class(obj), "__setitem__", null);
        if (si === null || typeof si != "function") {
          $B2.set_inum(inum);
          throw _b_2.TypeError.$factory("'" + $B2.class_name(obj) + "' object does not support item assignment");
        }
        return si(obj, item2, value2);
      };
      $B2.set_inum = function(inum) {
        if (inum !== void 0 && $B2.frame_obj) {
          $B2.frame_obj.frame.inum = inum;
        }
      };
      $B2.$delitem = function(obj, item2, inum) {
        if (Array.isArray(obj) && obj.__class__ === _b_2.list && typeof item2 == "number" && !$B2.$isinstance(obj, _b_2.tuple)) {
          if (item2 < 0) {
            item2 += obj.length;
          }
          if (obj[item2] === void 0) {
            $B2.set_inum(inum);
            throw _b_2.IndexError.$factory("list deletion index out of range");
          }
          obj.splice(item2, 1);
          return;
        } else if (obj.__class__ === _b_2.dict) {
          if (obj.$is_namespace) {
            Object.defineProperty(
              obj.$jsobj,
              item2,
              { get() {
                throw $B2.name_error(item2);
              }, set(value2) {
                Object.defineProperty(obj.$jsobj, item2, { value: value2 });
                return _b_2.None;
              } }
            );
          } else {
            try {
              _b_2.dict.__delitem__(obj, item2);
            } catch (err) {
              if (err.__class__ === _b_2.KeyError) {
                $B2.set_inum(inum);
              }
              throw err;
            }
          }
          return;
        } else if (obj.__class__ === _b_2.list) {
          try {
            return _b_2.list.__delitem__(obj, item2);
          } catch (err) {
            if (err.__class__ === _b_2.IndexError) {
              $B2.set_inum(inum);
            }
            throw err;
          }
        }
        var di = $B2.$getattr($B2.get_class(obj), "__delitem__", null);
        if (di === null) {
          throw _b_2.TypeError.$factory("'" + $B2.class_name(obj) + "' object doesn't support item deletion");
        }
        return di(obj, item2);
      };
      function num_result_type(x, y) {
        var is_int, is_float, x_num, y_num;
        if (typeof x == "number") {
          x_num = x;
          if (typeof y == "number") {
            is_int = true;
            y_num = y;
          } else if (y.__class__ === _b_2.float) {
            is_float = true;
            y_num = y.value;
          }
        } else if (x.__class__ === _b_2.float) {
          x_num = x.value;
          if (typeof y == "number") {
            y_num = y;
            is_float = true;
          } else if (y.__class__ === _b_2.float) {
            is_float = true;
            y_num = y.value;
          }
        }
        return { is_int, is_float, x: x_num, y: y_num };
      }
      $B2.augm_assign = function(left, op, right) {
        var res_type = num_result_type(left, right);
        if (res_type.is_int || res_type.is_float) {
          var z;
          switch (op) {
            case "+=":
              z = res_type.x + res_type.y;
              break;
            case "-=":
              z = res_type.x - res_type.y;
              break;
            case "*=":
              z = res_type.x * res_type.y;
              break;
            case "/=":
              return $B2.fast_float(res_type.x / res_type.y);
          }
          if (z) {
            if (res_type.is_int && Number.isSafeInteger(z)) {
              return z;
            } else if (res_type.res_is_float) {
              return $B2.fast_float(z);
            }
          }
        } else if (op == "*=") {
          if (typeof left == "number" && typeof right == "string") {
            return left <= 0 ? "" : right.repeat(left);
          } else if (typeof left == "string" && typeof right == "number") {
            return right <= 0 ? "" : left.repeat(right);
          }
        } else if (op == "+=") {
          if (typeof left == "string" && typeof right == "string") {
            return left + right;
          }
        }
        var op1 = op.substr(0, op.length - 1), method = $B2.op2method.augmented_assigns[op], augm_func = $B2.$getattr(left, "__" + method + "__", null);
        if (augm_func !== null) {
          var res = $B2.$call(augm_func)(right);
          if (res === _b_2.NotImplemented) {
            throw _b_2.TypeError.$factory(`unsupported operand type(s) for ${op}: '${$B2.class_name(left)}' and '${$B2.class_name(right)}'`);
          }
          return res;
        } else {
          var method1 = $B2.op2method.operations[op1];
          if (method1 === void 0) {
            method1 = $B2.op2method.binary[op1];
          }
          return $B2.rich_op(`__${method1}__`, left, right);
        }
      };
      $B2.$is = function(a, b) {
        if ((a === void 0 || a === $B2.Undefined) && (b === void 0 || b === $B2.Undefined)) {
          return true;
        }
        if (a === null) {
          return b === null;
        }
        if (b === null) {
          return a === null;
        }
        if (a.__class__ === _b_2.float && b.__class__ === _b_2.float) {
          if (isNaN(a.value) && isNaN(b.value)) {
            return true;
          }
          return a.value == b.value;
        }
        if (a === _b_2.int && b == $B2.long_int || a === $B2.long_int && b === _b_2.int) {
          return true;
        }
        return a === b;
      };
      $B2.is_or_equals = function(x, y) {
        return $B2.$is(x, y) || $B2.rich_comp("__eq__", x, y);
      };
      $B2.member_func = function(obj) {
        var klass = $B2.get_class(obj), contains = $B2.$getattr(klass, "__contains__", null);
        if (contains !== null) {
          contains = $B2.$call(contains);
          return contains.bind(null, obj);
        }
        try {
          var iterator = $B2.make_js_iterator(obj);
          return function(key2) {
            try {
              for (var item2 of iterator) {
                if ($B2.is_or_equals(key2, item2)) {
                  return true;
                }
              }
              return false;
            } catch (err) {
              return false;
            }
          };
        } catch (err) {
          var getitem = $B2.$getattr(klass, "__getitem__", null);
          if (getitem !== null) {
            return function(key2) {
              var i = -1;
              while (true) {
                i++;
                try {
                  var item2 = getitem(obj, i);
                  if ($B2.is_or_equals(key2, item2)) {
                    return true;
                  }
                } catch (err2) {
                  if ($B2.$is_exc(err2, [_b_2.StopIteration])) {
                    return false;
                  }
                  throw err2;
                }
              }
            };
          } else {
            throw _b_2.TypeError.$factory(`argument of type '${$B2.class_name(obj)}' is not iterable`);
          }
        }
      };
      $B2.$is_member = function(item2, _set) {
        return $B2.member_func(_set)(item2);
      };
      $B2.$call = function(callable, inum) {
        try {
          callable = $B2.$call1(callable);
        } catch (err) {
          $B2.set_inum(inum);
          throw err;
        }
        return function() {
          try {
            return callable.apply(null, arguments);
          } catch (exc) {
            $B2.set_inum(inum);
            throw exc;
          }
        };
        return callable;
      };
      $B2.$call1 = function(callable) {
        if (callable.__class__ === $B2.method) {
          return callable;
        } else if (callable.__class__ === _b_2.staticmethod) {
          return callable.__func__;
        } else if (callable.$factory) {
          return callable.$factory;
        } else if (callable.$is_class) {
          return callable.$factory = $B2.$instance_creator(callable);
        } else if (callable.$is_js_class) {
          return callable.$factory = function() {
            return new callable(...arguments);
          };
        } else if (callable.$in_js_module) {
          return function() {
            var res = callable(...arguments);
            return res === void 0 ? _b_2.None : res;
          };
        } else if (callable.$is_func || typeof callable == "function") {
          if (callable.$function_infos) {
            var flags = callable.$function_infos[$B2.func_attrs.flags];
            if (flags & $B2.COMPILER_FLAGS.GENERATOR) {
              $B2.frame_obj.frame.$has_generators = true;
            }
            if (flags & $B2.COMPILER_FLAGS.COROUTINE) {
              if ($B2.frame_obj !== null) {
                var frame = $B2.frame_obj.frame;
                frame.$async = callable;
              }
            }
          }
          return callable;
        }
        try {
          return $B2.$getattr(callable, "__call__");
        } catch (err) {
          throw _b_2.TypeError.$factory("'" + $B2.class_name(callable) + "' object is not callable");
        }
      };
      var r_opnames = ["add", "sub", "mul", "truediv", "floordiv", "mod", "pow", "lshift", "rshift", "and", "xor", "or"];
      var ropsigns = ["+", "-", "*", "/", "//", "%", "**", "<<", ">>", "&", "^", "|"];
      $B2.make_rmethods = function(klass) {
        for (var r_opname of r_opnames) {
          if (klass["__r" + r_opname + "__"] === void 0 && klass["__" + r_opname + "__"]) {
            klass["__r" + r_opname + "__"] = /* @__PURE__ */ (function(name2) {
              return function(self2, other) {
                return klass["__" + name2 + "__"](other, self2);
              };
            })(r_opname);
          }
        }
      };
      $B2.UUID = function() {
        return $B2.$py_UUID++;
      };
      $B2.to_num = function(obj, methods) {
        var expected_class = { "__complex__": _b_2.complex, "__float__": _b_2.float, "__index__": _b_2.int, "__int__": _b_2.int };
        var klass = obj.__class__ || $B2.get_class(obj);
        for (var i = 0; i < methods.length; i++) {
          var missing = {}, method = $B2.$getattr(klass, methods[i], missing);
          if (method !== missing) {
            var res = method(obj);
            if (!$B2.$isinstance(res, expected_class[methods[i]])) {
              throw _b_2.TypeError.$factory(methods[i] + "returned non-" + expected_class[methods[i]].__name__ + "(type " + $B2.get_class(res) + ")");
            }
            return { result: res, method: methods[i] };
          }
        }
        return null;
      };
      $B2.PyNumber_Index = function(item2) {
        switch (typeof item2) {
          case "boolean":
            return item2 ? 1 : 0;
          case "number":
            return item2;
          case "object":
            if (item2.__class__ === $B2.long_int) {
              return item2;
            }
            if ($B2.$isinstance(item2, _b_2.int)) {
              return item2.$brython_value;
            }
            var method = $B2.$getattr(item2, "__index__", _b_2.None);
            if (method !== _b_2.None) {
              method = typeof method == "function" ? method : $B2.$getattr(method, "__call__");
              return $B2.int_or_bool(method());
            } else {
              throw _b_2.TypeError.$factory("'" + $B2.class_name(item2) + "' object cannot be interpreted as an integer");
            }
          default:
            throw _b_2.TypeError.$factory("'" + $B2.class_name(item2) + "' object cannot be interpreted as an integer");
        }
      };
      $B2.int_or_bool = function(v) {
        switch (typeof v) {
          case "boolean":
            return v ? 1 : 0;
          case "number":
            return v;
          case "object":
            if (v.__class__ === $B2.long_int) {
              return v;
            } else {
              throw _b_2.TypeError.$factory("'" + $B2.class_name(v) + "' object cannot be interpreted as an integer");
            }
          default:
            throw _b_2.TypeError.$factory("'" + $B2.class_name(v) + "' object cannot be interpreted as an integer");
        }
      };
      $B2.enter_frame = function(frame, __file__, lineno) {
        var count = $B2.frame_obj === null ? 0 : $B2.frame_obj.count;
        if (count > $B2.recursion_limit) {
          var exc = _b_2.RecursionError.$factory("maximum recursion depth exceeded");
          $B2.set_exc(exc, frame);
          throw exc;
        }
        frame.__class__ = $B2.frame;
        frame.__file__ = __file__;
        frame.$lineno = lineno;
        frame.$f_trace = _b_2.None;
        frame.$has_generators = !!frame[1].$has_generators;
        $B2.frame_obj = { prev: $B2.frame_obj, frame, count: count + 1 };
        if ($B2.tracefunc !== _b_2.None) {
          if (frame[4] === $B2.tracefunc || $B2.tracefunc.$infos && frame[4] && frame[4] === $B2.tracefunc.$infos.__func__) {
            $B2.tracefunc.$frame_id = frame[0];
            frame.$f_trace = _b_2.None;
            return;
          } else {
            var frame_obj = $B2.frame_obj;
            while (frame_obj !== null) {
              if (frame_obj.frame[0] == $B2.tracefunc.$frame_id) {
                frame.$f_trace = _b_2.None;
                return;
              }
              frame_obj = frame_obj.prev;
            }
            try {
              var res = $B2.tracefunc(frame, "call", _b_2.None);
              var frame_obj = $B2.frame_obj;
              while (frame_obj !== null) {
                if (frame_obj.frame[4] == res) {
                  return _b_2.None;
                }
                frame_obj = frame_obj.prev;
              }
              frame.$f_trace = res;
              return;
            } catch (err) {
              $B2.set_exc(err, frame);
              $B2.frame_obj = $B2.frame_obj.prev;
              err.$in_trace_func = true;
              throw err;
            }
          }
        }
      };
      $B2.trace_exception = function() {
        var frame = $B2.frame_obj.frame;
        if (frame[0] == $B2.tracefunc.$current_frame_id) {
          return _b_2.None;
        }
        var trace_func = frame.$f_trace, exc = frame[1].$current_exception;
        return trace_func(frame, "exception", $B2.fast_tuple([exc.__class__, exc, $B2.traceback.$factory(exc)]));
      };
      $B2.trace_line = function() {
        var frame = $B2.frame_obj.frame;
        if (frame[0] == $B2.tracefunc.$current_frame_id) {
          return _b_2.None;
        }
        var trace_func = frame.$f_trace;
        if (trace_func === void 0) {
          console.log("trace line, frame", frame);
        }
        return trace_func(frame, "line", _b_2.None);
      };
      $B2.trace_return = function(value2) {
        var frame = $B2.frame_obj.frame, trace_func = frame.$f_trace;
        if (frame[0] == $B2.tracefunc.$current_frame_id) {
          return _b_2.None;
        }
        trace_func(frame, "return", value2);
      };
      $B2.leave_frame = function(arg) {
        if ($B2.frame_obj === null) {
          return;
        }
        if (arg && arg.value !== void 0 && $B2.tracefunc !== _b_2.None) {
          if ($B2.frame_obj.frame.$f_trace === void 0) {
            $B2.frame_obj.frame.$f_trace = $B2.tracefunc;
          }
          if ($B2.frame_obj.frame.$f_trace !== _b_2.None) {
            $B2.trace_return(arg.value);
          }
        }
        var frame = $B2.frame_obj.frame;
        if (frame.$coroutine) {
          if (!frame.$coroutine.$sent) {
            var cname = frame.$coroutine.$func.$function_infos[$B2.func_attrs.name];
            var message = _b_2.RuntimeWarning.$factory(
              `coroutine '${cname}' was never awaited`
            );
            message.lineno = frame.$coroutine.$lineno;
            $B2.imported._warnings.warn(message);
          }
        }
        $B2.frame_obj = $B2.frame_obj.prev;
        if (frame.$has_generators) {
          for (var key2 in frame[1]) {
            if (frame[1][key2] && frame[1][key2].__class__ === $B2.generator) {
              var gen = frame[1][key2];
              if (gen.$frame === void 0) {
                continue;
              }
              var ctx_managers = gen.$frame[1].$context_managers;
              if (ctx_managers) {
                for (var cm of ctx_managers) {
                  $B2.$call($B2.$getattr(cm, "__exit__"))(
                    _b_2.None,
                    _b_2.None,
                    _b_2.None
                  );
                }
              }
            }
          }
        }
        if (frame[1].$current_exception) {
          delete frame[1].$current_exception;
        }
        return _b_2.None;
      };
      $B2.trace_return_and_leave = function(frame, return_value) {
        if (frame.$f_trace !== _b_2.None) {
          $B2.trace_return(return_value);
        }
        $B2.leave_frame();
        return return_value;
      };
      $B2.push_frame = function(frame) {
        var count = $B2.frame_obj === null ? 0 : $B2.frame_obj.count;
        return {
          prev: $B2.frame_obj,
          frame,
          count: count + 1
        };
      };
      var reversed_op = { "__lt__": "__gt__", "__le__": "__ge__", "__gt__": "__lt__", "__ge__": "__le__" };
      var method2comp = { "__lt__": "<", "__le__": "<=", "__gt__": ">", "__ge__": ">=" };
      $B2.rich_comp = function(op, x, y) {
        if (x === void 0) {
          throw _b_2.RuntimeError.$factory("error in rich comp");
        }
        var x1 = x !== null && x.valueOf ? x.valueOf() : x, y1 = y !== null && y.valueOf ? y.valueOf() : y;
        if (typeof x1 == "number" && typeof y1 == "number" && x.__class__ === void 0 && y.__class__ === void 0) {
          switch (op) {
            case "__eq__":
              return x1 == y1;
            case "__ne__":
              return x1 != y1;
            case "__le__":
              return x1 <= y1;
            case "__lt__":
              return x1 < y1;
            case "__ge__":
              return x1 >= y1;
            case "__gt__":
              return x1 > y1;
          }
        }
        var res;
        if (x !== null && (x.$is_class || x.$factory)) {
          if (op == "__eq__") {
            return x === y;
          } else if (op == "__ne__") {
            return !(x === y);
          } else {
            throw _b_2.TypeError.$factory("'" + method2comp[op] + "' not supported between instances of '" + $B2.class_name(x) + "' and '" + $B2.class_name(y) + "'");
          }
        }
        var x_class_op = $B2.$call($B2.$getattr($B2.get_class(x), op)), rev_op = reversed_op[op] || op, y_rev_func;
        if (x !== null && x.__class__ && y !== null && y.__class__) {
          if (y.__class__.__mro__.indexOf(x.__class__) > -1) {
            y_rev_func = $B2.$getattr(y, rev_op);
            res = $B2.$call(y_rev_func)(x);
            if (res !== _b_2.NotImplemented) {
              return res;
            }
          }
        }
        res = x_class_op(x, y);
        if (res !== _b_2.NotImplemented) {
          return res;
        }
        if (y_rev_func === void 0) {
          y_rev_func = $B2.$call($B2.$getattr($B2.get_class(y), rev_op));
          res = y_rev_func(y, x);
          if (res !== _b_2.NotImplemented) {
            return res;
          }
        }
        if (op == "__eq__") {
          return _b_2.False;
        } else if (op == "__ne__") {
          return _b_2.True;
        }
        throw _b_2.TypeError.$factory("'" + method2comp[op] + "' not supported between instances of '" + $B2.class_name(x) + "' and '" + $B2.class_name(y) + "'");
      };
      var opname2opsign = { __sub__: "-", __xor__: "^", __mul__: "*", __and__: "&", __or__: "|" };
      $B2.get_position_from_inum = function(inum) {
        if ($B2.frame_obj !== null) {
          var frame = $B2.frame_obj.frame;
          if (frame.positions) {
            return frame.positions[Math.floor(inum / 2)];
          }
        }
      };
      $B2.rich_op = function(op, x, y, inum) {
        try {
          return $B2.rich_op1(op, x, y);
        } catch (exc) {
          $B2.set_inum(inum);
          throw exc;
        }
      };
      $B2.rich_op1 = function(op, x, y) {
        var res_is_int, res_is_float, x_num, y_num;
        if (typeof x == "number") {
          x_num = x;
          if (typeof y == "number") {
            res_is_int = true;
            y_num = y;
          } else if (y.__class__ === _b_2.float) {
            res_is_float = true;
            y_num = y.value;
          }
        } else if (x.__class__ === _b_2.float) {
          x_num = x.value;
          if (typeof y == "number") {
            y_num = y;
            res_is_float = true;
          } else if (y.__class__ === _b_2.float) {
            res_is_float = true;
            y_num = y.value;
          }
        }
        if (res_is_int || res_is_float) {
          var z;
          switch (op) {
            case "__add__":
              z = x_num + y_num;
              break;
            case "__sub__":
              z = x_num - y_num;
              break;
            case "__mul__":
              z = x_num * y_num;
              break;
            case "__pow__":
              if (res_is_int && y_num >= 0) {
                return _b_2.int.$int_or_long(BigInt(x_num) ** BigInt(y_num));
              }
              break;
            case "__truediv__":
              if (y_num == 0) {
                throw _b_2.ZeroDivisionError.$factory("division by zero");
              }
              z = x_num / y_num;
              return { __class__: _b_2.float, value: z };
          }
          if (z) {
            if (res_is_int && Number.isSafeInteger(z)) {
              return z;
            } else if (res_is_float) {
              return { __class__: _b_2.float, value: z };
            }
          }
        } else if (typeof x == "string" && typeof y == "string" && op == "__add__") {
          return x + y;
        }
        var x_class = x.__class__ || $B2.get_class(x), y_class = y.__class__ || $B2.get_class(y), rop = "__r" + op.substr(2), method;
        if (x_class === y_class) {
          if (x_class === _b_2.int) {
            return _b_2.int[op](x, y);
          } else if (x_class === _b_2.bool) {
            return (_b_2.bool[op] || _b_2.int[op])(x, y);
          }
          try {
            method = $B2.$call($B2.$getattr(x_class, op));
          } catch (err) {
            if (err.__class__ === _b_2.AttributeError) {
              var kl_name = $B2.class_name(x);
              throw _b_2.TypeError.$factory("unsupported operand type(s) for " + opname2opsign[op] + ": '" + kl_name + "' and '" + kl_name + "'");
            }
            throw err;
          }
          return method(x, y);
        }
        if (_b_2.issubclass(y_class, x_class)) {
          var reflected_left = $B2.$getattr(x_class, rop, false), reflected_right = $B2.$getattr(y_class, rop, false);
          if (reflected_right && reflected_left && reflected_right !== reflected_left) {
            return reflected_right(y, x);
          }
        }
        if (op == "__mul__") {
          if (x_class.$is_sequence && $B2.$isinstance(y, [_b_2.float, _b_2.complex])) {
            throw _b_2.TypeError.$factory(`can't multiply sequence by non-int of type '${$B2.class_name(y)}'`);
          }
          if (y_class.$is_sequence && $B2.$isinstance(x, [_b_2.float, _b_2.complex])) {
            throw _b_2.TypeError.$factory(`can't multiply sequence by non-int of type '${$B2.class_name(x)}'`);
          }
        }
        var res;
        try {
          var attr = $B2.$getattr(x, op);
          method = $B2.$getattr(x_class, op);
        } catch (err) {
          if (err.__class__ !== _b_2.AttributeError) {
            throw err;
          }
          var rmethod = $B2.$getattr(y_class, rop, null);
          if (rmethod !== null) {
            res = $B2.$call(rmethod)(y, x);
            if (res !== _b_2.NotImplemented) {
              return res;
            }
          }
          throw _b_2.TypeError.$factory(
            `unsupported operand type(s) for ${$B2.method_to_op[op]}: '${$B2.class_name(x)}' and '${$B2.class_name(y)}'`
          );
        }
        res = method(x, y);
        if (res === _b_2.NotImplemented) {
          try {
            method = $B2.$getattr(y_class, rop);
          } catch (err) {
            if (err.__class__ !== _b_2.AttributeError) {
              throw err;
            }
            throw _b_2.TypeError.$factory(
              `unsupported operand type(s) for ${$B2.method_to_op[op]}: '${$B2.class_name(x)}' and '${$B2.class_name(y)}'`
            );
          }
          res = method(y, x);
          if (res === _b_2.NotImplemented) {
            throw _b_2.TypeError.$factory(
              `unsupported operand type(s) for ${$B2.method_to_op[op]}: '${$B2.class_name(x)}' and '${$B2.class_name(y)}'`
            );
          }
          return res;
        } else {
          return res;
        }
      };
      $B2.is_none = function(o) {
        return o === void 0 || o === null || o == _b_2.None;
      };
      var repr_stack = /* @__PURE__ */ new Set();
      $B2.repr = { enter: function(obj) {
        var obj_id = _b_2.id(obj);
        if (repr_stack.has(obj_id)) {
          return true;
        } else {
          repr_stack.add(obj_id);
          if (repr_stack.size > $B2.recursion_limit) {
            repr_stack.clear();
            throw _b_2.RecursionError.$factory("maximum recursion depth exceeded while getting the repr of an object");
          }
        }
      }, leave: function(obj) {
        repr_stack.delete(_b_2.id(obj));
      } };
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      var object = {
        __name__: "object",
        __qualname__: "object",
        $is_class: true,
        $native: true
      };
      object.__delattr__ = function(self2, attr) {
        if (self2.__dict__ && $B2.$isinstance(self2.__dict__, _b_2.dict) && _b_2.dict.$contains_string(self2.__dict__, attr)) {
          _b_2.dict.$delete_string(self2.__dict__, attr);
          delete self2[attr];
          return _b_2.None;
        } else if (self2.__dict__ === void 0 && self2[attr] !== void 0) {
          delete self2[attr];
          return _b_2.None;
        } else {
          var klass = $B2.get_class(self2);
          var kl_attr = $B2.search_in_mro(klass, attr);
          if (_b_2.hasattr(kl_attr, "__get__") && _b_2.hasattr(kl_attr, "__delete__")) {
            return $B2.$getattr(kl_attr, "__delete__")(self2);
          }
        }
        throw $B2.attr_error(attr, self2);
      };
      object.__dir__ = function(self2) {
        var objects;
        if (self2.$is_class) {
          objects = [self2].concat(self2.__mro__);
        } else {
          var klass = self2.__class__ || $B2.get_class(self2);
          objects = [self2, klass].concat(klass.__mro__);
        }
        var res = [];
        for (var i = 0, len = objects.length; i < len; i++) {
          for (let attr in objects[i]) {
            if (attr.charAt(0) == "$") {
              if (attr.charAt(1) == "$") {
                res.push(attr.substr(2));
              }
              continue;
            }
            if (!isNaN(parseInt(attr.charAt(0)))) {
              continue;
            }
            if (attr == "__mro__") {
              continue;
            }
            res.push(attr);
          }
        }
        if (self2.__dict__) {
          for (let attr of $B2.make_js_iterator(self2.__dict__)) {
            if (attr.charAt(0) != "$") {
              res.push(attr);
            }
          }
        }
        res = _b_2.list.$factory(_b_2.set.$factory(res));
        _b_2.list.sort(res);
        return res;
      };
      object.__eq__ = function(self2, other) {
        return self2 === other ? true : _b_2.NotImplemented;
      };
      object.__format__ = function() {
        var $ = $B2.args("__format__", 2, { self: null, spec: null }, ["self", "spec"], arguments, {}, null, null);
        if ($.spec !== "") {
          throw _b_2.TypeError.$factory(
            "non-empty format string passed to object.__format__"
          );
        }
        return _b_2.getattr($.self, "__str__")();
      };
      object.__ge__ = function() {
        return _b_2.NotImplemented;
      };
      $B2.nb_from_dict = 0;
      object.__getattribute__ = function(obj, attr) {
        var klass = obj.__class__ || $B2.get_class(obj), is_own_class_instance_method = false;
        var $test = false;
        if ($test) {
          console.log("object.__getattribute__, attr", attr, "de", obj, "klass", klass);
          console.log("obj.__dict__", obj.__dict__);
        }
        if (attr === "__class__") {
          return klass;
        }
        if (obj.$is_class && attr == "__bases__") {
          throw $B2.attr_error(attr, obj);
        }
        var res = obj[attr];
        if ($test) {
          console.log("obj[attr]", obj[attr]);
        }
        if (Array.isArray(obj) && Array.prototype[attr] !== void 0) {
          res = void 0;
        }
        if (res === void 0 && obj.__dict__) {
          var dict = obj.__dict__;
          if ($test) {
            console.log("obj.__dict__", obj.__dict__);
          }
          if (dict.__class__ === $B2.getset_descriptor) {
            return dict.cls[attr];
          }
          var in_dict = _b_2.dict.$get_string(dict, attr);
          if (in_dict !== _b_2.dict.$missing) {
            return in_dict;
          }
        }
        if (res === void 0) {
          let check2 = function(obj2, kl, attr2) {
            var v;
            if (kl.__dict__) {
              v = _b_2.dict.$get_string(kl.__dict__, attr2);
              if (v !== _b_2.dict.$missing) {
                return v;
              }
            }
            v = kl[attr2];
            if (v !== void 0) {
              if ($test) {
                console.log("check, kl", kl, "attr", attr2, "v", v);
              }
              return v;
            }
          };
          var check = check2;
          res = check2(obj, klass, attr);
          if (res === void 0) {
            var mro = klass.__mro__;
            for (let i = 0, len = mro.length; i < len; i++) {
              res = check2(obj, mro[i], attr);
              if ($test) {
                console.log("in class", mro[i], "res", res);
              }
              if (res !== void 0) {
                if ($test) {
                  console.log("found in", mro[i]);
                }
                break;
              }
            }
          } else {
            if ($test) {
              console.log(attr, "found in own class");
            }
            if (res.__class__ !== $B2.method && res.__get__ === void 0) {
              is_own_class_instance_method = true;
            }
          }
        } else {
          if (res.__set__ === void 0) {
            return res;
          }
        }
        if ($test) {
          console.log("after search classes", res);
        }
        if (res !== void 0) {
          if ($test) {
            console.log(res);
          }
          if (res.__class__ && _b_2.issubclass(res.__class__, _b_2.property)) {
            return $B2.$getattr(res, "__get__")(obj, klass);
          } else if (res.__class__ === _b_2.classmethod) {
            return _b_2.classmethod.__get__(res, obj, klass);
          }
          if (res.__class__ === $B2.method) {
            if (res.$infos.__self__) {
              return res;
            }
            return $B2.method.__get__(res);
          }
          var get = res.__get__;
          if (get === void 0 && res.__class__) {
            get = res.__class__.__get__;
            for (let i = 0; i < res.__class__.__mro__.length && get === void 0; i++) {
              get = res.__class__.__mro__[i].__get__;
            }
          }
          if ($test) {
            console.log("get", get);
          }
          var __get__ = get === void 0 ? null : $B2.$getattr(res, "__get__", null);
          if ($test) {
            console.log("__get__", __get__);
          }
          if (__get__ !== null) {
            if ($test) {
              console.log("apply __get__", [obj, klass]);
            }
            try {
              return __get__.apply(null, [obj, klass]);
            } catch (err) {
              if ($B2.get_option("debug") > 2) {
                console.log("error in get.apply", err);
                console.log("get attr", attr, "of", obj);
                console.log("res", res);
                console.log("__get__", __get__);
                console.log(__get__ + "");
              }
              throw err;
            }
          }
          if (__get__ === null && typeof res == "function") {
            __get__ = function(x) {
              return x;
            };
          }
          if (__get__ !== null) {
            res.__name__ = attr;
            if (attr == "__new__" || res.__class__ === $B2.builtin_function_or_method) {
              res.$type = "staticmethod";
            }
            var res1 = __get__.apply(null, [res, obj, klass]);
            if ($test) {
              console.log("res", res, "res1", res1);
            }
            if (typeof res1 == "function") {
              if (res1.__class__ === $B2.method) {
                return res;
              }
              if (res.$type == "staticmethod") {
                return res;
              } else {
                var self2 = res.__class__ === $B2.method ? klass : obj, method = function() {
                  var args = [self2];
                  for (var i = 0, len = arguments.length; i < len; i++) {
                    args.push(arguments[i]);
                  }
                  return res.apply(this, args);
                };
                method.__class__ = $B2.method;
                method.__get__ = function(obj2, cls) {
                  var clmethod = res.bind(null, cls);
                  clmethod.__class__ = $B2.method;
                  clmethod.$infos = { __self__: cls, __func__: res, __name__: res.$infos.__name__, __qualname__: cls.__name__ + "." + res.$infos.__name__ };
                  return clmethod;
                };
                method.__get__.__class__ = $B2.method_wrapper;
                method.__get__.$infos = res.$infos;
                method.$infos = { __self__: self2, __func__: res, __name__: attr, __qualname__: klass.__qualname__ + "." + attr };
                if ($test) {
                  console.log("return method", method);
                }
                if (is_own_class_instance_method) {
                  obj.$method_cache = obj.$method_cache || {};
                  obj.$method_cache[attr] = [method, res];
                }
                return method;
              }
            } else {
              return res1;
            }
          }
          return res;
        } else if (obj.hasOwnProperty && obj.hasOwnProperty(attr) && !Array.isArray(obj)) {
          return $B2.Undefined;
        } else {
          throw $B2.attr_error(attr, obj);
        }
      };
      object.__gt__ = function() {
        return _b_2.NotImplemented;
      };
      object.__hash__ = function(self2) {
        var hash = self2.__hashvalue__;
        if (hash !== void 0) {
          return hash;
        }
        return self2.__hashvalue__ = $B2.$py_next_hash--;
      };
      object.__init__ = function() {
        if (arguments.length == 0) {
          throw _b_2.TypeError.$factory("descriptor '__init__' of 'object' object needs an argument");
        }
        return _b_2.None;
      };
      object.__le__ = function() {
        return _b_2.NotImplemented;
      };
      object.__lt__ = function() {
        return _b_2.NotImplemented;
      };
      object.__mro__ = [];
      object.$new = function(cls) {
        return function() {
          var $ = $B2.args("__new__", 0, [], [], arguments, {}, "args", "kwargs");
          if ($.args.length > 0 || _b_2.dict.__len__($.kwargs) > 0) {
            throw _b_2.TypeError.$factory("object() takes no parameters");
          }
          var res = /* @__PURE__ */ Object.create(null);
          res.__class__ = cls;
          res.__dict__ = $B2.obj_dict({});
          return res;
        };
      };
      object.$no_new_init = function(cls) {
        var res = /* @__PURE__ */ Object.create(null);
        res.__class__ = cls;
        res.__dict__ = $B2.obj_dict({});
        return res;
      };
      object.__new__ = function(cls, ...args) {
        if (cls === void 0) {
          throw _b_2.TypeError.$factory("object.__new__(): not enough arguments");
        }
        var init_func = $B2.$getattr(cls, "__init__");
        if (init_func === object.__init__) {
          if (args.length > 0) {
            throw _b_2.TypeError.$factory("object() takes no parameters");
          }
        }
        var res = /* @__PURE__ */ Object.create(null);
        $B2.update_obj(res, { __class__: cls, __dict__: $B2.obj_dict({}) });
        return res;
      };
      object.__ne__ = function(self2, other) {
        if (self2 === other) {
          return false;
        }
        var eq = $B2.$getattr(self2.__class__ || $B2.get_class(self2), "__eq__", null);
        if (eq !== null) {
          var res = $B2.$call(eq)(self2, other);
          if (res === _b_2.NotImplemented) {
            return res;
          }
          return !$B2.$bool(res);
        }
        return _b_2.NotImplemented;
      };
      object.__reduce__ = function(self2) {
        if (!self2.__dict__) {
          throw _b_2.TypeError.$factory(`cannot pickle '${$B2.class_name(self2)}' object`);
        }
        if ($B2.imported.copyreg === void 0) {
          $B2.$import("copyreg");
        }
        var res = [$B2.imported.copyreg._reconstructor];
        var D2 = $B2.get_class(self2), B = object;
        for (var klass of D2.__mro__) {
          if (klass.__module__ == "builtins") {
            B = klass;
            break;
          }
        }
        var args = $B2.$list([D2, B]);
        if (B === object) {
          args.push(_b_2.None);
        } else {
          args.push($B2.$call(B)(self2));
        }
        res.push($B2.fast_tuple(args));
        var d = $B2.empty_dict();
        for (var attr of _b_2.dict.$keys_string(self2.__dict__)) {
          _b_2.dict.$setitem(d, attr, _b_2.dict.$getitem_string(self2.__dict__, attr));
        }
        res.push(d);
        return _b_2.tuple.$factory(res);
      };
      function getNewArguments(self2, klass) {
        var newargs_ex = $B2.$getattr(self2, "__getnewargs_ex__", null);
        if (newargs_ex !== null) {
          let newargs2 = newargs_ex();
          if (!newargs2 || newargs2.__class__ !== _b_2.tuple) {
            throw _b_2.TypeError.$factory(`__getnewargs_ex__ should return a tuple, not '${$B2.class_name(newargs2)}'`);
          }
          if (newargs2.length != 2) {
            throw _b_2.ValueError.$factory(`__getnewargs_ex__ should return a tuple of length 2, not ${newargs2.length}`);
          }
          let args2 = newargs2[0], kwargs = newargs2[1];
          if (!args2 || args2.__class__ !== _b_2.tuple) {
            throw _b_2.TypeError.$factory(`first item of the tuple returned by __getnewargs_ex__ must be a tuple, not '${$B2.class_name(args2)}'`);
          }
          if (!kwargs || kwargs.__class__ !== _b_2.dict) {
            throw _b_2.TypeError.$factory(`second item of the tuple returned by __getnewargs_ex__ must be a dict, not '${$B2.class_name(kwargs)}'`);
          }
          return { args: args2, kwargs };
        }
        let newargs = klass.$getnewargs, args;
        if (!newargs) {
          newargs = $B2.$getattr(klass, "__getnewargs__", null);
        }
        if (newargs) {
          args = newargs(self2);
          if (!args || args.__class__ !== _b_2.tuple) {
            throw _b_2.TypeError.$factory(`__getnewargs__ should return a tuple, not '${$B2.class_name(args)}'`);
          }
          return { args };
        }
      }
      object.__reduce_ex__ = function(self2, protocol) {
        var klass = $B2.get_class(self2);
        if ($B2.imported.copyreg === void 0) {
          $B2.$import("copyreg");
        }
        if (protocol < 2) {
          return $B2.$call($B2.imported.copyreg._reduce_ex)(self2, protocol);
        }
        var reduce = $B2.$getattr(klass, "__reduce__");
        if (reduce !== object.__reduce__) {
          return $B2.$call(reduce)(self2);
        }
        var res = [$B2.imported.copyreg.__newobj__];
        var arg2 = [klass];
        var newargs = getNewArguments(self2, klass);
        if (newargs) {
          arg2 = arg2.concat(newargs.args);
        }
        res.push($B2.fast_tuple(arg2));
        var d = $B2.empty_dict(), nb = 0;
        if (self2.__dict__) {
          for (var item2 of _b_2.dict.$iter_items(self2.__dict__)) {
            if (item2.key == "__class__" || item2.key.startsWith("$")) {
              continue;
            }
            _b_2.dict.$setitem(d, item2.key, item2.value);
            nb++;
          }
        }
        if (nb == 0) {
          d = _b_2.None;
        }
        res.push(d);
        var list_like_iterator = _b_2.None;
        if ($B2.$getattr(klass, "append", null) !== null && $B2.$getattr(klass, "extend", null) !== null) {
          list_like_iterator = _b_2.iter(self2);
        }
        res.push(list_like_iterator);
        var key_value_iterator = _b_2.None;
        if ($B2.$isinstance(self2, _b_2.dict)) {
          key_value_iterator = _b_2.dict.items(self2);
        }
        res.push(key_value_iterator);
        return _b_2.tuple.$factory(res);
      };
      object.__repr__ = function(self2) {
        if (self2 === object) {
          return "<class 'object'>";
        }
        if (self2.__class__ === _b_2.type) {
          return "<class '" + self2.__name__ + "'>";
        }
        var klass = $B2.get_class(self2), module2 = klass.__module__;
        if (module2 !== void 0 && !module2.startsWith("$") && module2 !== "builtins") {
          return `<${module2}.${$B2.class_name(self2)} object>`;
        } else {
          return "<" + $B2.class_name(self2) + " object>";
        }
      };
      object.__setattr__ = function(self2, attr, val) {
        if (val === void 0) {
          throw _b_2.TypeError.$factory(
            "can't set attributes of built-in/extension type 'object'"
          );
        } else if (self2.__class__ === object) {
          if (object[attr] === void 0) {
            throw $B2.attr_error(attr, self2);
          } else {
            throw _b_2.AttributeError.$factory(
              "'object' object attribute '" + attr + "' is read-only"
            );
          }
        }
        if (self2.__dict__) {
          _b_2.dict.$setitem(self2.__dict__, attr, val);
        } else {
          self2[attr] = val;
        }
        return _b_2.None;
      };
      object.__setattr__.__get__ = function(obj) {
        return function(attr, val) {
          object.__setattr__(obj, attr, val);
        };
      };
      object.__setattr__.__str__ = function() {
        return "method object.setattr";
      };
      object.__str__ = function(self2) {
        if (self2 === void 0 || self2.$kw) {
          throw _b_2.TypeError.$factory("descriptor '__str__' of 'object' object needs an argument");
        }
        var klass = self2.__class__ || $B2.get_class(self2);
        var repr_func = $B2.$getattr(klass, "__repr__");
        return $B2.$call(repr_func).apply(null, arguments);
      };
      object.__subclasshook__ = function() {
        return _b_2.NotImplemented;
      };
      object.$factory = function() {
        if (arguments.length > 0 || arguments.length == 1 && arguments[0].$kw && Object.keys(arguments[0].$kw).length > 0) {
          throw _b_2.TypeError.$factory("object() takes no arguments");
        }
        var res = { __class__: object }, args = [res];
        object.__init__.apply(null, args);
        return res;
      };
      $B2.set_func_names(object, "builtins");
      _b_2.object = object;
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      const TPFLAGS = { STATIC_BUILTIN: 1 << 1, MANAGED_WEAKREF: 1 << 3, MANAGED_DICT: 1 << 4, SEQUENCE: 1 << 5, MAPPING: 1 << 6, DISALLOW_INSTANTIATION: 1 << 7, IMMUTABLETYPE: 1 << 8, HEAPTYPE: 1 << 9, BASETYPE: 1 << 10, HAVE_VECTORCALL: 1 << 11, READY: 1 << 12, READYING: 1 << 13, HAVE_GC: 1 << 14, METHOD_DESCRIPTOR: 1 << 17, VALID_VERSION_TAG: 1 << 19, IS_ABSTRACT: 1 << 20, MATCH_SELF: 1 << 22, LONG_SUBCLASS: 1 << 24, LIST_SUBCLASS: 1 << 25, TUPLE_SUBCLASS: 1 << 26, BYTES_SUBCLASS: 1 << 27, UNICODE_SUBCLASS: 1 << 28, DICT_SUBCLASS: 1 << 29, BASE_EXC_SUBCLASS: 1 << 30, TYPE_SUBCLASS: 1 << 31, HAVE_FINALIZE: 1 << 0, HAVE_VERSION_TAG: 1 << 18 };
      $B2.$class_constructor = function(class_name, frame, metaclass, resolved_bases, bases, kwargs, static_attributes, annotate, firstlineno) {
        var dict;
        var class_obj_proxy = frame[1];
        if (class_obj_proxy instanceof $B2.str_dict) {
          dict = $B2.empty_dict();
          dict.$strings = class_obj_proxy;
        } else {
          dict = class_obj_proxy.$target;
        }
        var module2 = class_obj_proxy.__module__;
        for (var base of bases) {
          if (base.__flags__ !== void 0 && !(base.__flags__ & TPFLAGS.BASETYPE)) {
            throw _b_2.TypeError.$factory(
              "type 'bool' is not an acceptable base type"
            );
          }
        }
        var extra_kwargs = {};
        if (kwargs) {
          for (let i = 0; i < kwargs.length; i++) {
            var key2 = kwargs[i][0], val = kwargs[i][1];
            if (key2 != "metaclass") {
              extra_kwargs[key2] = val;
            }
          }
        }
        if (class_obj_proxy.__eq__ !== void 0 && class_obj_proxy.__hash__ === void 0) {
          $B2.$setitem(dict, "__hash__", _b_2.None);
        }
        var slots = class_obj_proxy.__slots__;
        if (slots !== void 0) {
          if (typeof slots == "string") {
            slots = [slots];
          } else {
            for (let item2 of $B2.make_js_iterator(slots)) {
              if (typeof item2 != "string") {
                throw _b_2.TypeError.$factory(`__slots__ items must be strings, not '${$B2.class_name(item2)}'`);
              }
            }
          }
          $B2.$setitem(dict, "__slots__", slots);
        }
        var meta_new = _b_2.type.__getattribute__(metaclass, "__new__");
        var kls = meta_new(metaclass, class_name, resolved_bases, dict, { $kw: [extra_kwargs] });
        kls.__module__ = module2;
        kls.$subclasses = [];
        kls.$is_class = true;
        kls.__static_attributes__ = $B2.fast_tuple(static_attributes);
        kls.__firstlineno__ = firstlineno;
        $B2.make_annotate_class(kls, annotate, frame);
        if (kls.__class__ === metaclass) {
          var meta_init = _b_2.type.__getattribute__(metaclass, "__init__");
          try {
            meta_init(kls, class_name, resolved_bases, dict, { $kw: [extra_kwargs] });
          } catch (err) {
            if (class_name == "SupportsInt") {
              console.log("err for", class_name);
              console.log(err);
              console.log(err.stack);
            }
            throw err;
          }
        }
        for (let i = 0; i < bases.length; i++) {
          bases[i].$subclasses = bases[i].$subclasses || [];
          bases[i].$subclasses.push(kls);
        }
        return kls;
      };
      $B2.get_metaclass = function(class_name, module2, bases, kw_meta) {
        var metaclass;
        if (kw_meta === void 0 && bases.length == 0) {
          return _b_2.type;
        } else if (kw_meta) {
          if (!$B2.$isinstance(kw_meta, _b_2.type)) {
            return kw_meta;
          }
          metaclass = kw_meta;
        }
        if (bases && bases.length > 0) {
          if (bases[0].__class__ === void 0) {
            if (typeof bases[0] == "function") {
              if (bases.length != 1) {
                throw _b_2.TypeError.$factory("A Brython class can inherit at most 1 Javascript constructor");
              }
              $B2.set_func_names(bases[0], module2);
              return $B2.JSMeta;
            } else {
              throw _b_2.TypeError.$factory("Argument of " + class_name + " is not a class (type '" + $B2.class_name(bases[0]) + "')");
            }
          }
          for (var base of bases) {
            var mc = base.__class__;
            if (metaclass === void 0) {
              metaclass = mc;
            } else if (mc === metaclass || _b_2.issubclass(metaclass, mc)) {
            } else if (_b_2.issubclass(mc, metaclass)) {
              metaclass = mc;
            } else if (metaclass.__bases__ && metaclass.__bases__.indexOf(mc) == -1) {
              throw _b_2.TypeError.$factory("metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases");
            }
          }
        } else {
          metaclass = metaclass || _b_2.type;
        }
        return metaclass;
      };
      function set_attr_if_absent(dict, attr, value2) {
        try {
          $B2.$getitem(dict, attr);
        } catch (err) {
          $B2.$setitem(dict, attr, value2);
        }
      }
      $B2.make_class_namespace = function(metaclass, class_name, module2, qualname, orig_bases, bases) {
        var class_dict = _b_2.dict.$literal([
          ["__module__", module2],
          ["__qualname__", qualname]
        ]);
        if (metaclass !== _b_2.type) {
          var prepare = $B2.$getattr(metaclass, "__prepare__", _b_2.None);
          if (prepare !== _b_2.None) {
            class_dict = $B2.$call(prepare)(class_name, bases);
            set_attr_if_absent(class_dict, "__module__", module2);
            set_attr_if_absent(class_dict, "__qualname__", qualname);
          }
        }
        if (orig_bases !== bases) {
          $B2.$setitem(class_dict, "__orig_bases__", orig_bases);
        }
        if (class_dict.__class__ === _b_2.dict) {
          if (class_dict.$all_str) {
            return class_dict.$strings;
          }
          return new Proxy(class_dict, { get: function(target, prop) {
            if (prop == "__class__") {
              return _b_2.dict;
            } else if (prop == "$target") {
              return target;
            }
            if (_b_2.dict.$contains_string(target, prop)) {
              return _b_2.dict.$getitem_string(target, prop);
            }
            return void 0;
          }, set: function(target, prop, value2) {
            _b_2.dict.$setitem(target, prop, value2);
          } });
        } else {
          var setitem = $B2.$getattr(class_dict, "__setitem__"), getitem = $B2.$getattr(class_dict, "__getitem__");
          return new Proxy(class_dict, { get: function(target, prop) {
            if (prop == "__class__") {
              return $B2.get_class(target);
            } else if (prop == "$target") {
              return target;
            }
            try {
              return getitem(prop);
            } catch (err) {
              return void 0;
            }
          }, set: function(target, prop, value2) {
            setitem(prop, value2);
            return _b_2.None;
          } });
        }
      };
      $B2.resolve_mro_entries = function(bases) {
        var new_bases = [], has_mro_entries = false;
        for (var base of bases) {
          if (!$B2.$isinstance(base, _b_2.type)) {
            var mro_entries = $B2.$getattr(base, "__mro_entries__", _b_2.None);
            if (mro_entries !== _b_2.None) {
              has_mro_entries = true;
              var entries = _b_2.list.$factory(mro_entries(bases));
              new_bases = new_bases.concat(entries);
            } else {
              new_bases.push(base);
            }
          } else {
            new_bases.push(base);
          }
        }
        return has_mro_entries ? new_bases : bases;
      };
      $B2.make_class = function(qualname, factory) {
        var A = { __class__: type, __bases__: [_b_2.object], __mro__: [_b_2.object], __name__: qualname, __qualname__: qualname, $is_class: true };
        A.$factory = factory;
        return A;
      };
      var type = $B2.make_class(
        "type",
        function() {
          var missing = {}, $ = $B2.args("type", 3, { kls: null, bases: null, cl_dict: null }, ["kls", "bases", "cl_dict"], arguments, { bases: missing, cl_dict: missing }, null, "kw"), kls = $.kls, bases = $.bases, cl_dict = $.cl_dict, kw = $.kw;
          var kwarg = {};
          for (var item2 of _b_2.dict.$iter_items(kw)) {
            kwarg[item2.key] = item2.value;
          }
          var kwargs = { $kw: [kwarg] };
          if (cl_dict === missing) {
            if (bases !== missing) {
              throw _b_2.TypeError.$factory("type() takes 1 or 3 arguments");
            }
            var res = $B2.get_class(kls);
            if (res === $B2.long_int) {
              return _b_2.int;
            }
            return res;
          } else {
            var module2 = $B2.frame_obj.frame[2], resolved_bases = $B2.resolve_mro_entries(bases), metaclass = $B2.get_metaclass(kls, module2, resolved_bases);
            return type.__call__(metaclass, kls, resolved_bases, cl_dict, kwargs);
          }
        }
      );
      type.__class__ = type;
      var classmethod = _b_2.classmethod = $B2.make_class(
        "classmethod",
        function(func) {
          $B2.check_nb_args_no_kw("classmethod", 1, arguments);
          return {
            __class__: classmethod,
            __func__: func
          };
        }
      );
      classmethod.__dict__ = {};
      classmethod.__get__ = function() {
        var $ = $B2.args("classmethod", 3, { self: null, obj: null, cls: null }, ["self", "obj", "cls"], arguments, { cls: _b_2.None }, null, null), self2 = $.self, obj = $.obj, cls = $.cls;
        if (cls === _b_2.None || cls === void 0) {
          cls = $B2.get_class(obj);
        }
        var func_class = $B2.get_class(self2.__func__), candidates = [func_class].concat(func_class.__mro__);
        for (var candidate of candidates) {
          if (candidate === $B2.function) {
            break;
          }
          if (candidate.__get__) {
            return candidate.__get__(self2.__func__, cls, cls);
          }
        }
        return $B2.method.$factory(self2.__func__, cls);
      };
      $B2.set_func_names(classmethod, "builtins");
      var staticmethod = _b_2.staticmethod = $B2.make_class(
        "staticmethod",
        function(func) {
          return {
            __class__: staticmethod,
            __func__: func
          };
        }
      );
      staticmethod.__call__ = function(self2) {
        return $B2.$call(self2.__func__);
      };
      staticmethod.__get__ = function(self2) {
        return self2.__func__;
      };
      $B2.set_func_names(staticmethod, "builtins");
      $B2.getset_descriptor = $B2.make_class(
        "getset_descriptor",
        function(klass, attr, getter, setter, deleter) {
          var res = { __class__: $B2.getset_descriptor, __doc__: _b_2.None, cls: klass, attr, getter, setter, deleter };
          return res;
        }
      );
      $B2.getset_descriptor.__delete__ = function(self2, obj) {
        return self2.deleter(obj);
      };
      $B2.getset_descriptor.__get__ = function(self2, obj) {
        if (obj === _b_2.None) {
          return self2;
        }
        return self2.getter(obj);
      };
      $B2.getset_descriptor.__set__ = function(self2, klass, value2) {
        return self2.setter(klass, value2);
      };
      $B2.getset_descriptor.__repr__ = function(self2) {
        return `<attribute '${self2.attr}' of '${self2.cls.__name__}' objects>`;
      };
      $B2.set_func_names($B2.getset_descriptor, "builtins");
      type.__dict__ = {};
      type.__dict__.__annotations__ = $B2.getset_descriptor.$factory(
        type,
        "__annotations__",
        function(klass) {
          if (klass.__annotations__ !== void 0) {
            return klass.__annotations__;
          }
          if (klass.__annotations_cache__ !== void 0) {
            return klass.__annotations_cache__;
          }
          var annotate = $B2.search_in_mro(klass, "__annotate__");
          var annotate_func = klass.__annotate_func__;
          if (annotate_func === void 0) {
            console.log("no __annotate_func__ for klass", klass);
          }
          if (annotate_func === _b_2.None) {
            return $B2.empty_dict();
          }
          return klass.__annotations_cache__ = $B2.$call(annotate_func)(1);
        },
        function(klass, value2) {
          klass.__annotations__ = value2;
        },
        function(klass) {
          if (klass.__annotations_cache__ === void 0) {
            throw _b_2.AttributeError.$factory("__annotations__");
          }
          klass.__annotations_cache__ = $B2.empty_dict();
          klass.__annotate__ = _b_2.None;
        }
      );
      type.__dict__.__annotate__ = $B2.getset_descriptor.$factory(
        type,
        "__annotate__",
        function(klass) {
          if (klass.__annotate__ !== void 0) {
            return klass.__annotate__;
          }
          return klass.__annotate_func__ ?? _b_2.None;
        },
        function(klass, value2) {
          try {
            $B2.$call(value2);
          } catch (err) {
            if (value2 !== _b_2.None) {
              throw _b_2.TypeError.$factory(
                "__annotate__ must be callable or None"
              );
            }
            klass.__annotate__ = value2;
          }
        }
      );
      type.__dict__.__mro__ = { __get__: function(cls) {
        return $B2.fast_tuple([cls].concat(cls.__mro__));
      } };
      type.$call = function(klass, new_func, init_func) {
        return function() {
          var instance = new_func.bind(null, klass).apply(null, arguments);
          if ($B2.$isinstance(instance, klass)) {
            init_func.bind(null, instance).apply(null, arguments);
          }
          return instance;
        };
      };
      type.$call_no_new_init = function(klass, init_func) {
        return function() {
          var instance = _b_2.object.$no_new_init(klass);
          init_func(instance, ...arguments);
          return instance;
        };
      };
      type.$call_no_init = function(klass, new_func) {
        return new_func.bind(null, klass);
      };
      type.__call__ = function() {
        var extra_args = [], klass = arguments[0];
        for (var i = 1, len = arguments.length; i < len; i++) {
          extra_args.push(arguments[i]);
        }
        var new_func = _b_2.type.__getattribute__(klass, "__new__");
        var instance = new_func.apply(null, arguments), instance_class = instance.__class__ || $B2.get_class(instance);
        if (instance_class === klass) {
          var init_func = _b_2.type.__getattribute__(klass, "__init__");
          if (init_func !== _b_2.object.__init__) {
            var args = [instance].concat(extra_args);
            init_func.apply(null, args);
          }
        }
        return instance;
      };
      $B2.$class_getitem = function(kls, origin, args) {
        return $B2.GenericAlias.$factory(kls, origin, args);
      };
      function merge_class_dict(dict, klass) {
        var classdict, bases;
        classdict = $B2.$getattr(klass, "__dict__", null);
        if (classdict !== null) {
          _b_2.dict.update(dict, classdict);
        } else {
          return;
        }
        bases = klass.__bases__;
        if (bases === void 0) {
          return;
        }
        for (var base of bases) {
          merge_class_dict(dict, base);
        }
      }
      type.__dir__ = function(klass) {
        var dict = $B2.empty_dict();
        merge_class_dict(dict, klass);
        return _b_2.sorted(dict);
      };
      type.__format__ = function(klass) {
        return _b_2.str.$factory(klass);
      };
      type.__getattribute__ = function(klass, attr) {
        switch (attr) {
          case "__bases__":
            if (klass.__bases__ !== void 0) {
              return $B2.fast_tuple($B2.resolve_mro_entries(klass.__bases__));
            }
            throw $B2.attr_error(attr, klass);
          case "__class__":
            return klass.__class__;
          case "__doc__":
            return klass.__doc__ || _b_2.None;
          case "__name__":
            return klass.__name__ || klass.__qualname__;
          case "__setattr__":
            var func = klass["__setattr__"] ?? function(kls, key2, value2) {
              kls[key2] = value2;
            };
            return method_wrapper.$factory(attr, klass, func);
          case "__delattr__":
            if (klass["__delattr__"] !== void 0) {
              return klass["__delattr__"];
            }
            return method_wrapper.$factory(attr, klass, function(key2) {
              if (klass.__flags__ && TPFLAGS.IMMUTABLETYPE) {
                throw _b_2.TypeError.$factory(
                  `cannot delete '${key2}' attribute of immutable type '${klass.__name__}'`
                );
              }
              if (klass.__dict__) {
                _b_2.dict.__delitem__(klass.__dict__, key2);
              }
              delete klass[key2];
            });
        }
        var res = klass.hasOwnProperty(attr) ? klass[attr] : void 0;
        var $test = false;
        if ($test) {
          console.log("attr", attr, "of", klass, "\n  ", res, res + "");
        }
        if (klass.__class__ && klass.__class__[attr] && klass.__class__[attr].__get__ && klass.__class__[attr].__set__) {
          if ($test) {
            console.log("data descriptor");
          }
          return klass.__class__[attr].__get__(klass);
        }
        if (res === void 0) {
          var v = klass.hasOwnProperty(attr) ? klass[attr] : void 0;
          if (v === void 0) {
            if ($test) {
              console.log(attr, "not in klass[attr], search in __dict__", klass.__dict__);
            }
            if (klass.__dict__ && klass.__dict__.__class__ === _b_2.dict && _b_2.dict.$contains_string(klass.__dict__, attr)) {
              res = klass[attr] = _b_2.dict.$getitem_string(klass.__dict__, attr);
              if ($test) {
                console.log("found in __dict__", res);
              }
            } else {
              var mro = klass.__mro__;
              if (mro === void 0) {
                console.log("no mro for", klass, "attr", attr);
              }
              for (let i = 0; i < mro.length; i++) {
                if (mro[i].hasOwnProperty(attr)) {
                  res = mro[i][attr];
                  break;
                }
              }
            }
          } else {
            res = v;
          }
        }
        if (res === void 0) {
          if (res === void 0) {
            var meta = klass.__class__ || $B2.get_class(klass);
            res = meta.hasOwnProperty(attr) ? meta[attr] : meta.__dict__ && _b_2.dict.$contains(meta.__dict__, attr) ? _b_2.dict.$getitem(meta.__dict__, attr) : void 0;
            if ($test) {
              console.log("search in meta", meta, res);
            }
            if (res === void 0) {
              var meta_mro = meta.__mro__;
              for (let i = 0; i < meta_mro.length; i++) {
                if (meta_mro[i].hasOwnProperty(attr)) {
                  res = meta_mro[i][attr];
                  break;
                }
              }
            }
            if (res !== void 0) {
              if ($test) {
                console.log("found in meta", res, typeof res);
              }
              if (res.__class__ === _b_2.property) {
                return res.fget(klass);
              } else if (res.__class__ === $B2.getset_descriptor) {
                return res.getter(klass);
              }
              if (typeof res == "function") {
                if (attr == "__new__") {
                  return res;
                }
                var meta_method = res.bind(null, klass);
                meta_method.__class__ = $B2.method;
                meta_method.$infos = { __self__: klass, __func__: res, __name__: attr, __qualname__: meta.__name__ + "." + attr, __module__: res.$infos ? res.$infos.__module__ : "" };
                if ($test) {
                  console.log("return method from meta", meta_method, meta_method + "");
                }
                return meta_method;
              }
            }
          }
          if (res === void 0) {
            var getattr = meta.__getattr__;
            if (getattr === void 0) {
              for (let i = 0; i < meta_mro.length; i++) {
                if (meta_mro[i].__getattr__ !== void 0) {
                  getattr = meta_mro[i].__getattr__;
                  break;
                }
              }
            }
            if (getattr !== void 0) {
              return getattr(klass, attr);
            }
          }
        }
        if (res !== void 0) {
          if ($test) {
            console.log("res", res);
          }
          if (res.__class__ === _b_2.property) {
            return res;
          } else if (res.__class__ === _b_2.classmethod) {
            return _b_2.classmethod.__get__(res, _b_2.None, klass);
          }
          if (res.__get__) {
            if (res.__class__ === method) {
              if ($test) {
                console.log("__get__ of method", res.$infos.__self__, klass);
              }
              if (res.$infos.__self__) {
                return res;
              }
              var result = res.__get__(res.__func__, klass);
              result.$infos = { __func__: res, __name__: res.$infos.__name__, __qualname__: klass.__name__ + "." + res.$infos.__name__, __self__: klass };
            } else {
              result = res.__get__(klass);
            }
            return result;
          } else if (res.__class__ && res.__class__.__get__) {
            if (!(attr.startsWith("__") && attr.endsWith("__"))) {
              return res.__class__.__get__(res, _b_2.None, klass);
            }
          }
          if (typeof res == "function") {
            if (res.$infos !== void 0 && res.$function_infos === void 0) {
              console.log("$infos not undef", res, res.$infos);
              throw Error();
            }
            if (res.$infos === void 0 && res.$function_infos === void 0 && $B2.get_option("debug") > 1) {
              console.log("warning: no attribute $infos for", res, "klass", klass, "attr", attr);
            }
            if ($test) {
              console.log("res is function", res);
            }
            if (attr == "__new__" || res.__class__ === $B2.builtin_function_or_method) {
              res.$type = "staticmethod";
            }
            if ((attr == "__class_getitem__" || attr == "__init_subclass__") && res.__class__ !== _b_2.classmethod) {
              res = _b_2.classmethod.$factory(res);
              return _b_2.classmethod.__get__(res, _b_2.None, klass);
            }
            if (res.__class__ === $B2.method) {
              return res.__get__(null, klass);
            } else {
              if ($test) {
                console.log("return res", res);
              }
              return res;
            }
          } else {
            return res;
          }
        }
      };
      type.__hash__ = function(cls) {
        return _b_2.hash(cls);
      };
      type.__init__ = function() {
        if (arguments.length == 0) {
          throw _b_2.TypeError.$factory("descriptor '__init__' of 'type' object needs an argument");
        }
      };
      type.__init_subclass__ = function() {
        var $ = $B2.args("__init_subclass__", 1, { cls: null }, ["cls"], arguments, {}, "args", "kwargs");
        if ($.args.length > 0) {
          throw _b_2.TypeError.$factory(
            `${$.cls.__qualname__}.__init_subclass__ takes no arguments (${$.args.length} given)`
          );
        }
        if (_b_2.dict.__len__($.kwargs) > 0) {
          throw _b_2.TypeError.$factory(
            `${$.cls.__qualname__}.__init_subclass__() takes no keyword arguments`
          );
        }
        return _b_2.None;
      };
      _b_2.object.__init_subclass__ = type.__init_subclass__;
      type.__instancecheck__ = function(cls, instance) {
        var kl = instance.__class__ || $B2.get_class(instance);
        if (kl === cls) {
          return true;
        } else {
          for (var i = 0; i < kl.__mro__.length; i++) {
            if (kl.__mro__[i] === cls) {
              return true;
            }
          }
        }
        return false;
      };
      type.__instancecheck__.$type = "staticmethod";
      type.__name__ = "type";
      type.__new__ = function(meta, name2, bases, cl_dict, extra_kwargs) {
        extra_kwargs = extra_kwargs === void 0 ? { $kw: [{}] } : extra_kwargs;
        var module2 = _b_2.dict.$get_string(cl_dict, "__module__", $B2.frame_obj.frame[2]);
        var qualname = _b_2.dict.$get_string(cl_dict, "__qualname__", name2);
        var class_dict = { __class__: meta, __bases__: bases.length == 0 ? [_b_2.object] : bases, __dict__: cl_dict, __qualname__: qualname, __module__: module2, __name__: name2, $is_class: true };
        let slots = _b_2.dict.$get_string(cl_dict, "__slots__", _b_2.None);
        if (slots !== _b_2.None) {
          for (let key3 of $B2.make_js_iterator(slots)) {
            class_dict[key3] = member_descriptor.$factory(key3, class_dict);
          }
        }
        class_dict.__mro__ = type.mro(class_dict).slice(1);
        for (var entry of _b_2.dict.$iter_items(cl_dict)) {
          var key2 = entry.key, v = entry.value;
          if (["__module__", "__class__", "__name__", "__qualname__"].includes(key2)) {
            continue;
          }
          if (key2.startsWith("$")) {
            continue;
          }
          if (v === void 0) {
            continue;
          }
          class_dict[key2] = v;
          if (v.__class__) {
            var set_name = $B2.$getattr(v.__class__, "__set_name__", _b_2.None);
            if (set_name !== _b_2.None) {
              set_name(v, class_dict, key2);
            }
          }
          if (typeof v == "function") {
            if (v.$function_infos === void 0) {
              if (v.$infos) {
                v.$infos.__qualname__ = name2 + "." + v.$infos.__name__;
              }
            } else {
              v.$function_infos[$B2.func_attrs.method_class] = class_dict;
              v.$function_infos[$B2.func_attrs.__qualname__] = name2 + "." + v.$function_infos[$B2.func_attrs.__name__];
            }
          }
        }
        class_dict.$tp_setattr = $B2.search_in_mro(class_dict, "__setattr__");
        var sup = _b_2.super.$factory(class_dict, class_dict);
        var init_subclass = _b_2.super.__getattribute__(sup, "__init_subclass__");
        init_subclass(extra_kwargs);
        return class_dict;
      };
      type.__or__ = function() {
        var $ = $B2.args("__or__", 2, { cls: null, other: null }, ["cls", "other"], arguments, {}, null, null), cls = $.cls, other = $.other;
        if (other !== _b_2.None && !$B2.$isinstance(other, [type, $B2.GenericAlias, $B2.UnionType])) {
          return _b_2.NotImplemented;
        }
        return $B2.UnionType.$factory([cls, other]);
      };
      type.__prepare__ = function() {
        return $B2.empty_dict();
      };
      type.__qualname__ = "type";
      type.__repr__ = function(kls) {
        $B2.builtins_repr_check(type, arguments);
        var qualname = kls.__qualname__;
        if (kls.__module__ && kls.__module__ != "builtins" && !kls.__module__.startsWith("$")) {
          qualname = kls.__module__ + "." + qualname;
        }
        return "<class '" + qualname + "'>";
      };
      type.__ror__ = function() {
        var len = arguments.length;
        if (len != 1) {
          throw _b_2.TypeError.$factory(`expected 1 argument, got ${len}`);
        }
        return _b_2.NotImplemented;
      };
      function update_subclasses(kls, name2, alias, value2) {
        for (var subclass of kls.$subclasses) {
          if (!subclass.hasOwnProperty(name2)) {
            subclass[alias] = value2;
            update_subclasses(subclass, name2, alias, value2);
          }
        }
      }
      type.__setattr__ = function(kls, attr, value2) {
        var $test = false;
        if ($test) {
          console.log("kls is class", type);
        }
        if ($B2.mappingproxy.$contains(type.__dict__, attr)) {
          var v = $B2.mappingproxy.$getitem(type.__dict__, attr);
          var vtype = $B2.get_class(v);
          if (vtype.__set__) {
            return vtype.__set__(v, kls, value2);
          }
        }
        if (kls.__flags__ && TPFLAGS.IMMUTABLETYPE) {
          throw _b_2.TypeError.$factory(
            `cannot set '${attr}' attribute of immutable type '` + kls.__qualname__ + "'"
          );
        }
        kls[attr] = value2;
        var mp = kls.__dict__ || $B2.$getattr(kls, "__dict__");
        _b_2.dict.$setitem(mp, attr, value2);
        switch (attr) {
          case "__init__":
          case "__new__":
            kls.$factory = $B2.$instance_creator(kls);
            break;
          case "__bases__":
            kls.__mro__ = _b_2.type.mro(kls);
            break;
          case "__setattr__":
            var initial_value = kls.$tp_setattr;
            kls.$tp_setattr = value2;
            update_subclasses(kls, "__setattr__", "$tp_setattr", value2);
            break;
        }
        if ($test) {
          console.log("after setattr", kls);
        }
        return _b_2.None;
      };
      type.$mro = function(cls) {
        if (cls === void 0) {
          throw _b_2.TypeError.$factory(
            "unbound method type.mro() needs an argument"
          );
        }
        var bases = cls.__bases__, seqs = [], pos1 = 0;
        for (var base of bases) {
          let bmro = [], pos2 = 0;
          if (base === void 0 || base.__mro__ === void 0) {
            if (base.__class__ === void 0) {
              return [_b_2.object];
            } else {
              console.log("error for base", base);
              console.log("cls", cls);
            }
          }
          bmro[pos2++] = base;
          var _tmp = base.__mro__;
          if (_tmp) {
            if (_tmp[0] === base) {
              _tmp.splice(0, 1);
            }
            for (var k = 0; k < _tmp.length; k++) {
              bmro[pos2++] = _tmp[k];
            }
          }
          seqs[pos1++] = bmro;
        }
        seqs[pos1++] = bases.slice();
        var mro = [cls], mpos = 1;
        while (1) {
          let non_empty = [], pos2 = 0;
          for (let i = 0; i < seqs.length; i++) {
            if (seqs[i].length > 0) {
              non_empty[pos2++] = seqs[i];
            }
          }
          if (non_empty.length == 0) {
            break;
          }
          let candidate;
          for (let i = 0; i < non_empty.length; i++) {
            let seq = non_empty[i];
            candidate = seq[0];
            let not_head = [], pos3 = 0;
            for (let j2 = 0; j2 < non_empty.length; j2++) {
              let s = non_empty[j2];
              if (s.slice(1).indexOf(candidate) > -1) {
                not_head[pos3++] = s;
              }
            }
            if (not_head.length > 0) {
              candidate = null;
            } else {
              break;
            }
          }
          if (candidate === null) {
            throw _b_2.TypeError.$factory(
              "inconsistent hierarchy, no C3 MRO is possible"
            );
          }
          mro[mpos++] = candidate;
          for (let i = 0; i < seqs.length; i++) {
            let seq = seqs[i];
            if (seq[0] === candidate) {
              seqs[i].shift();
            }
          }
        }
        if (mro[mro.length - 1] !== _b_2.object) {
          mro[mpos++] = _b_2.object;
        }
        return mro;
      };
      type.mro = function(cls) {
        return $B2.$list(type.$mro(cls));
      };
      type.__subclasscheck__ = function(self2, subclass) {
        var klass = self2;
        if (subclass.__bases__ === void 0) {
          return self2 === _b_2.object;
        }
        return subclass.__bases__.indexOf(klass) > -1;
      };
      $B2.set_func_names(type, "builtins");
      type.__init_subclass__ = _b_2.classmethod.$factory(type.__init_subclass__);
      _b_2.type = type;
      var property = _b_2.property = $B2.make_class(
        "property",
        function(fget, fset, fdel, doc) {
          var res = { __class__: property };
          property.__init__(res, fget, fset, fdel, doc);
          return res;
        }
      );
      property.__init__ = function() {
        var $ = $B2.args("__init__", 5, { self: null, fget: null, fset: null, fdel: null, doc: null }, ["self", "fget", "fset", "fdel", "doc"], arguments, { fget: _b_2.None, fset: _b_2.None, fdel: _b_2.None, doc: _b_2.None }, null, null), self2 = $.self, fget = $.fget, fset = $.fset, fdel = $.fdel, doc = $.doc;
        self2.__doc__ = doc;
        if ($B2.$getattr && doc === _b_2.None) {
          self2.__doc__ = $B2.$getattr(fget, "__doc__", doc);
        }
        self2.$type = fget.$type;
        self2.fget = fget;
        self2.fset = fset;
        self2.fdel = fdel;
        self2.$is_property = true;
        if (fget && fget.$attrs) {
          for (var key2 in fget.$attrs) {
            self2[key2] = fget.$attrs[key2];
          }
        }
        self2.__delete__ = fdel;
        self2.getter = function(fget2) {
          return property.$factory(fget2, self2.fset, self2.fdel, self2.__doc__);
        };
        self2.setter = function(fset2) {
          return property.$factory(self2.fget, fset2, self2.fdel, self2.__doc__);
        };
        self2.deleter = function(fdel2) {
          return property.$factory(self2.fget, self2.fset, fdel2, self2.__doc__);
        };
      };
      property.__get__ = function(self2, kls) {
        if (self2.fget === void 0) {
          throw _b_2.AttributeError.$factory("unreadable attribute");
        }
        return $B2.$call(self2.fget)(kls);
      };
      property.__new__ = function(cls) {
        return {
          __class__: cls
        };
      };
      property.__set__ = function(self2, obj, value2) {
        if (self2.fset === void 0) {
          var name2 = self2.fget.$function_infos[$B2.func_attrs.__name__];
          var msg = `property '${name2}' of '${$B2.class_name(obj)}' object has no setter`;
          throw _b_2.AttributeError.$factory(msg);
        }
        $B2.$getattr(self2.fset, "__call__")(obj, value2);
      };
      $B2.set_func_names(property, "builtins");
      var wrapper_descriptor = $B2.wrapper_descriptor = $B2.make_class("wrapper_descriptor");
      wrapper_descriptor.__text_signature__ = { __get__: function() {
        return "(self, /, *args, **kwargs)";
      } };
      $B2.set_func_names(wrapper_descriptor, "builtins");
      type.__call__.__class__ = wrapper_descriptor;
      $B2.$instance_creator = function(klass) {
        var test = false;
        if (test) {
          console.log("instance creator of", klass);
        }
        if (klass.prototype && klass.prototype.constructor == klass) {
          return function() {
            return new klass(...arguments);
          };
        }
        if (klass.__abstractmethods__ && $B2.$bool(klass.__abstractmethods__)) {
          return function() {
            var ams = Array.from($B2.make_js_iterator(klass.__abstractmethods__));
            ams.sort();
            var msg = (ams.length > 1 ? "s " : " ") + ams.join(", ");
            throw _b_2.TypeError.$factory(
              "Can't instantiate abstract class interface with abstract method" + msg
            );
          };
        }
        var metaclass = klass.__class__ || $B2.get_class(klass), call_func, factory;
        if (metaclass === _b_2.type) {
          var new_func = type.__getattribute__(klass, "__new__"), init_func = type.__getattribute__(klass, "__init__");
          if (init_func === _b_2.object.__init__) {
            if (new_func === _b_2.object.__new__) {
              factory = _b_2.object.$new(klass);
            } else {
              factory = new_func.bind(null, klass);
            }
          } else if (new_func === _b_2.object.__new__) {
            factory = type.$call_no_new_init(klass, init_func);
          } else {
            factory = type.$call(klass, new_func, init_func);
          }
        } else {
          call_func = _b_2.type.__getattribute__(metaclass, "__call__");
          if (call_func.$is_class) {
            factory = $B2.$call(call_func);
          } else {
            factory = call_func.bind(null, klass);
          }
        }
        factory.__class__ = $B2.function;
        factory.$infos = { __name__: klass.__name__, __module__: klass.__module__ };
        return factory;
      };
      var method_wrapper = $B2.method_wrapper = $B2.make_class(
        "method_wrapper",
        function(attr, klass, method2) {
          var f = function() {
            return method2.apply(null, arguments);
          };
          f.$infos = { __name__: attr, __module__: klass.__module__ };
          return f;
        }
      );
      method_wrapper.__str__ = method_wrapper.__repr__ = function(self2) {
        return "<method '" + self2.$infos.__name__ + "' of function object>";
      };
      var member_descriptor = $B2.member_descriptor = $B2.make_class(
        "member_descriptor",
        function(attr, cls) {
          return { __class__: member_descriptor, cls, attr };
        }
      );
      member_descriptor.__delete__ = function(self2, kls) {
        if (kls.$slot_values === void 0 || !kls.$slot_values.hasOwnProperty(self2.attr)) {
          throw _b_2.AttributeError.$factory(self2.attr);
        }
        kls.$slot_values.delete(self2.attr);
      };
      member_descriptor.__get__ = function(self2, kls) {
        if (kls === _b_2.None) {
          return self2;
        }
        if (kls.$slot_values === void 0 || !kls.$slot_values.has(self2.attr)) {
          throw $B2.attr_error(self2.attr, kls);
        }
        return kls.$slot_values.get(self2.attr);
      };
      member_descriptor.__set__ = function(self2, kls, value2) {
        if (kls.$slot_values === void 0) {
          kls.$slot_values = /* @__PURE__ */ new Map();
        }
        kls.$slot_values.set(self2.attr, value2);
      };
      member_descriptor.__str__ = member_descriptor.__repr__ = function(self2) {
        return "<member '" + self2.attr + "' of '" + self2.cls.__name__ + "' objects>";
      };
      $B2.set_func_names(member_descriptor, "builtins");
      var method = $B2.method = $B2.make_class(
        "method",
        function(func, cls) {
          var f = function() {
            return $B2.$call(func).bind(null, cls).apply(null, arguments);
          };
          f.__class__ = method;
          if (typeof func !== "function") {
            console.log("method from func w-o $infos", func, "all", $B2.$call(func));
          }
          if (!func.$infos && func.$function_infos) {
            $B2.make_function_infos(func, ...func.$function_infos);
            f.$function_infos = func.$function_infos;
          }
          f.$infos = func.$infos || {};
          f.$infos.__func__ = func;
          f.$infos.__self__ = cls;
          f.$infos.__dict__ = $B2.empty_dict();
          return f;
        }
      );
      method.__eq__ = function(self2, other) {
        return self2.$infos !== void 0 && other.$infos !== void 0 && self2.$infos.__func__ === other.$infos.__func__ && self2.$infos.__self__ === other.$infos.__self__;
      };
      method.__ne__ = function(self2, other) {
        return !$B2.method.__eq__(self2, other);
      };
      method.__get__ = function(self2) {
        var f = function() {
          return self2(...arguments);
        };
        f.__class__ = $B2.method_wrapper;
        f.$infos = method.$infos;
        return f;
      };
      method.__getattribute__ = function(self2, attr) {
        var infos = self2.$infos;
        if (infos && infos[attr]) {
          if (attr == "__code__") {
            var res = { __class__: $B2.Code };
            for (var key2 in infos.__code__) {
              res[key2] = infos.__code__[key2];
            }
            return res;
          } else {
            return infos[attr];
          }
        } else if (method.hasOwnProperty(attr)) {
          return _b_2.object.__getattribute__(self2, attr);
        } else {
          return _b_2.object.__getattribute__(self2.$infos.__func__, attr);
        }
      };
      method.__repr__ = method.__str__ = function(self2) {
        return "<bound method " + self2.$infos.__qualname__ + " of " + _b_2.str.$factory(self2.$infos.__self__) + ">";
      };
      method.__setattr__ = function(self2, key2) {
        if (key2 == "__class__") {
          throw _b_2.TypeError.$factory("__class__ assignment only supported for heap types or ModuleType subclasses");
        }
        throw $B2.attr_error(key2, self2);
      };
      $B2.set_func_names(method, "builtins");
      $B2.method_descriptor = $B2.make_class("method_descriptor");
      $B2.classmethod_descriptor = $B2.make_class("classmethod_descriptor");
      _b_2.object.__class__ = type;
      $B2.make_iterator_class = function(name2, reverse) {
        var klass = { __class__: _b_2.type, __mro__: [_b_2.object], __name__: name2, __qualname__: name2, $factory: function(items) {
          return {
            __class__: klass,
            __dict__: $B2.empty_dict(),
            counter: reverse ? items.length : -1,
            items,
            len: items.length,
            $builtin_iterator: true
          };
        }, $is_class: true, $iterator_class: true, __iter__: function(self2) {
          self2.counter = self2.counter === void 0 ? reverse ? self2.items.length : -1 : self2.counter;
          self2.len = self2.items.length;
          return self2;
        }, __len__: function(self2) {
          return self2.items.length;
        }, __next__: function(self2) {
          if (typeof self2.test_change == "function") {
            var message = self2.test_change();
            if (message) {
              throw _b_2.RuntimeError.$factory(message);
            }
          }
          if (reverse) {
            self2.counter--;
            if (self2.counter >= 0) {
              var item2 = self2.items[self2.counter];
              if (self2.items.$is_js_array) {
                item2 = $B2.jsobj2pyobj(item2);
              }
              return item2;
            }
          } else {
            self2.counter++;
            if (self2.counter < self2.items.length) {
              var item2 = self2.items[self2.counter];
              if (self2.items.$is_js_array) {
                item2 = $B2.jsobj2pyobj(item2);
              }
              return item2;
            }
          }
          throw _b_2.StopIteration.$factory("StopIteration");
        }, __reduce_ex__: function(self2) {
          return $B2.fast_tuple([_b_2.iter, _b_2.tuple.$factory([self2.items])]);
        } };
        $B2.set_func_names(klass, "builtins");
        return klass;
      };
      $B2.GenericAlias = $B2.make_class(
        "GenericAlias",
        function(origin_class, items) {
          var res = { __class__: $B2.GenericAlias, __mro__: [origin_class], origin_class, items };
          return res;
        }
      );
      $B2.GenericAlias.__args__ = _b_2.property.$factory(
        (self2) => $B2.fast_tuple(self2.items)
      );
      $B2.GenericAlias.__call__ = function(self2, ...args) {
        return self2.origin_class.$factory.apply(null, args);
      };
      $B2.GenericAlias.__eq__ = function(self2, other) {
        if (!$B2.$isinstance(other, $B2.GenericAlias)) {
          return false;
        }
        return $B2.rich_comp("__eq__", self2.origin_class, other.origin_class) && $B2.rich_comp("__eq__", self2.items, other.items);
      };
      $B2.GenericAlias.__getitem__ = function(self2, item2) {
        throw _b_2.TypeError.$factory("descriptor '__getitem__' for '" + self2.origin_class.__name__ + "' objects doesn't apply to a '" + $B2.class_name(item2) + "' object");
      };
      $B2.GenericAlias.__mro_entries__ = function(self2) {
        return $B2.fast_tuple([self2.origin_class]);
      };
      $B2.GenericAlias.__new__ = function(origin_class, items) {
        var res = { __class__: $B2.GenericAlias, __mro__: [origin_class], origin_class, items, $is_class: true };
        return res;
      };
      $B2.GenericAlias.__or__ = function() {
        var $ = $B2.args("__or__", 2, { self: null, other: null }, ["self", "other"], arguments, {}, null, null);
        return $B2.UnionType.$factory([$.self, $.other]);
      };
      $B2.GenericAlias.__origin__ = _b_2.property.$factory(
        (self2) => self2.origin_class
      );
      $B2.GenericAlias.__parameters__ = _b_2.property.$factory(
        function() {
          return $B2.fast_tuple([]);
        }
      );
      $B2.GenericAlias.__repr__ = function(self2) {
        var items = Array.isArray(self2.items) ? self2.items : [self2.items];
        var reprs = [];
        for (var item2 of items) {
          if (item2 === _b_2.Ellipsis) {
            reprs.push("...");
          } else {
            if (item2.$is_class) {
              reprs.push(item2.__name__);
            } else {
              reprs.push(_b_2.repr(item2));
            }
          }
        }
        var iv = $B2.$getattr(self2.origin_class, "__infer_variance__", true);
        var prefix = iv ? "" : "~";
        return prefix + $B2.$getattr(self2.origin_class, "__qualname__") + "[" + reprs.join(", ") + "]";
      };
      $B2.GenericAlias.__type_params__ = _b_2.property.$factory(
        function(self2) {
          return $B2.$getattr(self2.origin_class, "__type_params__");
        }
      );
      $B2.set_func_names($B2.GenericAlias, "types");
      $B2.UnionType = $B2.make_class(
        "UnionType",
        function(items) {
          return {
            __class__: $B2.UnionType,
            items
          };
        }
      );
      $B2.UnionType.__args__ = _b_2.property.$factory(
        (self2) => $B2.fast_tuple(self2.items)
      );
      $B2.UnionType.__class_getitem__ = function(cls, items) {
        if ($B2.$isinstance(items, _b_2.tuple)) {
          return $B2.UnionType.$factory(items);
        } else {
          return items;
        }
      };
      $B2.UnionType.__eq__ = function(self2, other) {
        if (!$B2.$isinstance(other, $B2.UnionType)) {
          return _b_2.NotImplemented;
        }
        return _b_2.list.__eq__(self2.items, other.items);
      };
      $B2.UnionType.__or__ = function(self2, other) {
        var items = self2.items.slice();
        if (!items.includes(other)) {
          items.push(other);
        }
        return $B2.UnionType.$factory(items);
      };
      $B2.UnionType.__parameters__ = _b_2.property.$factory(
        () => $B2.fast_tuple([])
      );
      $B2.UnionType.__repr__ = function(self2) {
        var t = [];
        for (var item2 of self2.items) {
          if (item2.$is_class) {
            var s = item2.__name__;
            if (item2.__module__ !== "builtins") {
              s = item2.__module__ + "." + s;
            }
            t.push(s);
          } else {
            t.push(_b_2.repr(item2));
          }
        }
        return t.join(" | ");
      };
      $B2.set_func_names($B2.UnionType, "types");
      $B2.make_annotate_class = function(kls, annotations, class_frame) {
        if (annotations === void 0) {
          kls.__annotate_func__ = _b_2.None;
          return;
        }
        kls.$annotations = annotations;
        kls.__annotate_func__ = function(format) {
          if (!$B2.$isinstance(format, _b_2.int)) {
            throw _b_2.TypeError.$factory(`__annotate__ argument should be int, not ${$B2.class_name(format)}`);
          }
          var file = class_frame.__file__;
          var locals = { format };
          var frame = ["__annotate__", locals, class_frame[2], class_frame[3]];
          $B2.enter_frame(frame, file);
          frame.positions = class_frame.positions;
          try {
            switch (format) {
              case 1:
              case 2:
                var ann_dict = $B2.empty_dict();
                if (kls.$annotations === void 0) {
                  return $B2.trace_return_and_leave(frame, ann_dict);
                }
                for (var key2 in kls.$annotations) {
                  if (key2 == "$lineno") {
                    continue;
                  }
                  try {
                    var [lineno, func] = kls.$annotations[key2];
                  } catch (err) {
                    throw err;
                  }
                  try {
                    $B2.$setitem(ann_dict, key2, func());
                  } catch (err) {
                    frame.$lineno = lineno;
                    console.log("error", frame.inum, frame.positions);
                    throw err;
                  }
                }
                return $B2.trace_return_and_leave(frame, ann_dict);
              default:
                frame.$lineno = kls.$annotations.$lineno;
                throw _b_2.NotImplementedError.$factory("");
            }
          } catch (err) {
            $B2.set_exc_and_leave(frame, err);
          }
        };
        $B2.add_function_infos(kls, "__annotate_func__");
        $B2.set_function_attr(kls.__annotate_func__, "__name__", "__annotate__");
        $B2.set_function_attr(kls.__annotate_func__, "__qualname__", kls.__qualname__ + ".__annotate__");
      };
      $B2.postpone_annotations = function(obj, file) {
        var module_frame = $B2.frame_obj.frame;
        obj.$annotations = {};
        Object.defineProperty(
          obj,
          "__annotations__",
          { configurable: true, get() {
            if (obj.$set_annotations) {
              return obj.$set_annotations;
            }
            var res = $B2.empty_dict();
            for (var key2 in obj.$annotations) {
              _b_2.dict.$setitem(res, key2, obj.$annotations[key2][1]());
            }
            return res;
          }, set(value2) {
            obj.$set_annotations = value2;
          } }
        );
      };
      $B2.make_module_annotate = function(locals) {
        Object.defineProperty(
          locals,
          "__annotations__",
          { get() {
            if (locals.$set_annotations) {
              return locals.$set_annotations;
            }
            if (locals.__annotate__) {
              return locals.__annotate__(1);
            }
            return locals.__annotate_func__(1);
          }, set(value2) {
            locals.$set_annotations = value2;
          } }
        );
        Object.defineProperty(
          locals,
          "__annotate__",
          { get() {
            if (locals.$annotate) {
              return locals.$annotate;
            }
            return locals.__annotate_func__;
          }, set(value2) {
            locals.$annotate = value2;
          } }
        );
        locals.__annotate_func__ = function(format) {
          switch (format) {
            case 1:
              var ann_dict = $B2.empty_dict();
              for (var key2 in locals.$annotations) {
                var item2 = locals.$annotations[key2];
                $B2.$setitem(ann_dict, key2, item2[1]());
              }
              return ann_dict;
            default:
              throw _b_2.NotImplementedError.$factory();
          }
        };
        $B2.add_function_infos(locals, "__annotate_func__");
        $B2.set_function_attr(locals.__annotate_func__, "__name__", "__annotate__");
        $B2.set_function_attr(locals.__annotate_func__, "__qualname__", "__annotate__");
      };
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      var FunctionCode = $B2.make_class("function code");
      var FunctionGlobals = $B2.make_class("function globals");
      $B2.function = { __class__: _b_2.type, __mro__: [_b_2.object], __name__: "function", __qualname__: "function", $is_class: true };
      $B2.function.__dict__ = {};
      $B2.function.__dict__.__annotations__ = $B2.getset_descriptor.$factory(
        $B2.function,
        "__annotations__",
        function(f) {
          $B2.check_infos(f);
          if (f.__annotations__ !== void 0) {
            return f.__annotations__;
          } else {
            return f.__annotations__ = f.__annotate__(1);
          }
        },
        function(f, value2) {
          $B2.check_infos(f);
          if (!$B2.$isinstance(value2, _b_2.dict)) {
            throw _b_2.TypeError.$factory(
              "__annotations__ must be set to a dict object"
            );
          }
          f.__annotations__ = value2;
        }
      );
      $B2.function.__dict__.__builtins__ = $B2.getset_descriptor.$factory(
        $B2.function,
        "__builtins__",
        function(f) {
          $B2.check_infos(f);
          if (f.$infos && f.$infos.__globals__) {
            return _b_2.dict.$getitem(self.$infos.__globals__, "__builtins__");
          }
          return $B2.obj_dict(_b_2);
        },
        function() {
          throw _b_2.AttributeError.$factory("readonly attribute");
        }
      );
      $B2.function.__dict__.__closure__ = $B2.getset_descriptor.$factory(
        $B2.function,
        "__closure__",
        function(f) {
          var free_vars = f.$function_infos[$B2.func_attrs.free_vars];
          if (free_vars === void 0 || free_vars.length == 0) {
            return _b_2.None;
          }
          var cells = [];
          for (var i = 0; i < free_vars.length; i++) {
            try {
              cells.push($B2.cell.$factory($B2.$check_def_free(free_vars[i])));
            } catch (err) {
              cells.push($B2.cell.$factory(_b_2.None));
            }
          }
          return $B2.fast_tuple(cells);
        },
        function() {
          throw _b_2.AttributeError.$factory("readonly attribute");
        }
      );
      $B2.function.__dict__.__code__ = $B2.getset_descriptor.$factory(
        $B2.function,
        "__code__",
        function(f) {
          $B2.check_infos(f);
          var res = { __class__: _b_2.code };
          for (var _attr in f.$infos.__code__) {
            res[_attr] = f.$infos.__code__[_attr];
          }
          res.name = f.$infos.__name__;
          res.filename = f.$infos.__code__.co_filename;
          res.co_code = f + "";
          return res;
        },
        function(f, value2) {
          $B2.check_infos(f);
          if (!$B2.$isinstance(value2, _b_2.code)) {
            throw _b_2.TypeError.$factory(
              "__code__ must be set to a code object"
            );
          }
          f.$infos.__code__ = value2;
        }
      );
      $B2.function.__dict__.__defaults__ = $B2.getset_descriptor.$factory(
        $B2.function,
        "__defaults__",
        function(f) {
          $B2.check_infos(f);
          return f.$infos.__defaults__;
        },
        function(f, value2) {
          $B2.check_infos(f);
          if (value2 === _b_2.None) {
            value2 = [];
          } else if (!$B2.$isinstance(value2, _b_2.tuple)) {
            throw _b_2.TypeError.$factory(
              "__defaults__ must be set to a tuple object"
            );
          }
          f.$infos.__defaults__ = value2;
          f.$function_infos[$B2.func_attrs.__defaults__] = value2;
          $B2.make_args_parser(f);
        }
      );
      $B2.function.__delattr__ = function(self2, attr) {
        if (attr == "__dict__") {
          throw _b_2.TypeError.$factory("can't delete function __dict__");
        }
      };
      $B2.function.__dict__.__doc__ = $B2.getset_descriptor.$factory(
        $B2.function,
        "__doc__",
        function(f) {
          $B2.check_infos(f);
          return f.$infos.__doc__;
        },
        function(f, value2) {
          $B2.check_infos(f);
          f.$infos.__doc__ = value2;
        }
      );
      $B2.function.__dict__.__module__ = $B2.getset_descriptor.$factory(
        $B2.function,
        "__module__",
        function(f) {
          $B2.check_infos(f);
          return f.$infos.__module__;
        },
        function(f, value2) {
          $B2.check_infos(f);
          f.$infos.__module__ = value2;
        }
      );
      $B2.function.__dict__.__name__ = $B2.getset_descriptor.$factory(
        $B2.function,
        "__name__",
        function(f) {
          $B2.check_infos(f);
          return f.$infos.__name__;
        },
        function(f, value2) {
          $B2.check_infos(f);
          if (!$B2.$isinstance(value2, _b_2.str)) {
            throw _b_2.TypeError.$factory(
              "__name__ must be set to a string object"
            );
          }
          f.$infos.__name__ = value2;
        }
      );
      $B2.function.__dict__.__qualname__ = $B2.getset_descriptor.$factory(
        $B2.function,
        "__qualname__",
        function(f) {
          $B2.check_infos(f);
          return f.$infos.__qualname__;
        },
        function(f, value2) {
          $B2.check_infos(f);
          if (!$B2.$isinstance(value2, _b_2.str)) {
            throw _b_2.TypeError.$factory(
              "__qualname__ must be set to a string object"
            );
          }
          f.$infos.__qualname__ = value2;
        }
      );
      $B2.function.__dict__.__type_params__ = $B2.getset_descriptor.$factory(
        $B2.function,
        "__type_params__",
        function(f) {
          $B2.check_infos(f);
          return f.$infos.__type_params__;
        },
        function(f, value2) {
          $B2.check_infos(f);
          if (!$B2.$isinstance(value2, _b_2.tuple)) {
            throw _b_2.TypeError.$factory(
              "TypeError: __type_params__ must be set to a tuple"
            );
          }
          f.$infos.__type_params__ = value2;
        }
      );
      $B2.function.__dir__ = function(self2) {
        if (self2.$function_infos && !self2.$infos) {
          $B2.make_function_infos(self2, ...self2.$function_infos);
        }
        var infos = self2.$infos.__dict__ || {}, attrs = self2.$attrs || {};
        return $B2.$list(Object.keys(infos).concat(Object.keys(attrs)).concat(Object.keys($B2.function)).filter((x) => !x.startsWith("$"))).sort();
      };
      $B2.function.__get__ = function(self2, obj) {
        if (obj === _b_2.None) {
          return self2;
        }
        return $B2.method.$factory(self2, obj);
      };
      $B2.function.__dict__.__globals__ = $B2.getset_descriptor.$factory(
        $B2.function,
        "__globals__",
        function(f) {
          $B2.check_infos(f);
          return $B2.obj_dict($B2.imported[f.$infos.__module__]);
        },
        function() {
          throw _b_2.AttributeError.$factory("readonly attribute");
        }
      );
      $B2.function.__dict__.__kwdefaults__ = $B2.getset_descriptor.$factory(
        $B2.function,
        "__kwdefaults__",
        function(f) {
          $B2.check_infos(f);
          return f.$infos.__kwdefaults__;
        },
        function(f, value2) {
          $B2.check_infos(f);
          if (value2 == _b_2.None) {
            value2 = $B2.empty_dict();
          } else if (!$B2.$isinstance(value2, _b_2.dict)) {
            throw _b_2.TypeError.$factory(
              "__kwdefaults__ must be set to a dict object"
            );
          }
          f.$infos.__kwdefaults__ = value2;
          var kwd = {};
          for (var item2 of _b_2.dict.$iter_items(value2)) {
            kwd[item2.key] = item2.value;
          }
          f.$function_infos[$B2.func_attrs.__kwdefaults__] = kwd;
          $B2.make_args_parser(f);
        }
      );
      $B2.function.__repr__ = function(self2) {
        if (self2.$function_infos) {
          return `<function ${self2.$function_infos[$B2.func_attrs.__qualname__]}>`;
        } else if (self2.$infos === void 0) {
          return "<function " + self2.name + ">";
        } else {
          return "<function " + self2.$infos.__qualname__ + ">";
        }
      };
      $B2.function.__mro__ = [_b_2.object];
      $B2.function.__setattr__ = function(self2, attr, value2) {
        if (self2.$infos === void 0) {
          $B2.make_function_infos(self2, ...self2.$function_infos);
        }
        var klass_attr = $B2.function[attr];
        if (klass_attr !== void 0 && klass_attr.__class__ && klass_attr.__class__.__get__ && klass_attr.__set__) {
          return klass_attr.__class__.__set__(klass_attr, self2, value2);
        }
        try {
          klass_attr = _b_2.dict.$getitem($B2.function.__dict__, attr);
        } catch (err) {
          klass_attr = null;
        }
        if (klass_attr && klass_attr.__class__.__get__ && klass_attr.__class__.__set__) {
          return klass_attr.__class__.__set__(klass_attr, self2, value2);
        }
        if (!self2.__dict__) {
          self2.__dict__ = $B2.empty_dict();
        }
        _b_2.dict.$setitem(self2.__dict__, attr, value2);
      };
      $B2.check_infos = function(f) {
        if (!f.$infos) {
          if (f.$function_infos) {
            $B2.make_function_infos(f, ...f.$function_infos);
          } else {
            console.log("no $infos, no $function_infos");
          }
        }
      };
      $B2.make_function_infos = function(f, __module__, co_name, co_qualname, co_filename, __defaults__, __kwdefaults__, __doc__, arg_names, vararg, kwarg, co_argcount, co_firstlineno, co_flags, co_freevars, co_kwonlyargcount, co_posonlyargcount, co_varnames, annotations, type_params) {
        f.$is_func = true;
        f.$args_parser = $B2.make_args_parser_and_parse;
        if (co_flags & $B2.COMPILER_FLAGS.COROUTINE) {
          f.$is_async = true;
        }
        __defaults__ = __defaults__ === _b_2.None ? [] : __defaults__;
        __defaults__.__class__ = _b_2.tuple;
        __kwdefaults__ = __kwdefaults__ === _b_2.None ? _b_2.None : _b_2.dict.$from_js(__kwdefaults__);
        f.$infos = { __module__, __defaults__, __kwdefaults__, __doc__, arg_names, vararg, kwarg };
        f.$infos.__name__ = co_name;
        f.$infos.__qualname__ = co_qualname;
        type_params = type_params ?? [];
        type_params.__class__ = _b_2.tuple;
        f.$infos.__type_params__ = type_params;
        co_freevars = co_freevars ?? [];
        co_freevars.__class__ = _b_2.tuple;
        co_varnames = co_varnames ?? [];
        co_varnames.__class__ = _b_2.tuple;
        if (annotations) {
          f.__annotations__ = _b_2.dict.$literal(annotations);
        }
        f.$infos.__code__ = { co_argcount, co_filename, co_firstlineno, co_flags, co_freevars, co_kwonlyargcount, co_name, co_nlocals: co_varnames.length, co_posonlyargcount, co_qualname, co_varnames, co_positions: {} };
        f.$infos.__dict__ = $B2.empty_dict();
      };
      $B2.make_args_parser_and_parse = function make_args_parser_and_parse(fct, args) {
        return $B2.make_args_parser(fct)(fct, args);
      };
      $B2.make_args_parser = function(f) {
        if (!f.$infos && f.$function_infos) {
          $B2.make_function_infos(f, ...f.$function_infos);
        }
        if (f.$infos === void 0 || f.$infos.__code__ === void 0) {
          console.log("f", f);
          throw _b_2.AttributeError.$factory(`cannot set defauts to ${_b_2.str.$factory(f)}`);
        }
        const varnames = f.$infos.__code__.co_varnames, value2 = f.$infos.__defaults__, offset = f.$infos.__code__.co_argcount - value2.length, $kwdefaults = /* @__PURE__ */ new Map();
        var nb_kw_defaults = f.$infos.__kwdefaults__ === _b_2.None ? 0 : _b_2.dict.__len__(f.$infos.__kwdefaults__);
        if (f.$infos.__kwdefaults__ !== _b_2.None) {
          const kwdef = f.$infos.__kwdefaults__;
          for (let kw of $B2.make_js_iterator(kwdef)) {
            $kwdefaults.set(kw, $B2.$getitem(kwdef, kw));
          }
        }
        f.$kwdefaults = $kwdefaults;
        f.$kwdefaults_values = [...$kwdefaults.values()];
        f.$hasParams = /* @__PURE__ */ new Set();
        var nb_args = f.$infos.__code__.co_argcount + f.$infos.__code__.co_kwonlyargcount + (f.$infos.kwargs ? 1 : 0);
        for (let i = 0; i < nb_args; ++i) {
          f.$hasParams.add(varnames[i]);
        }
        const $INFOS = f.$infos, $CODE = $INFOS.__code__, DEFAULTS2 = $B2.getArgs0.DEFAULTS;
        const PARAMS_NAMED_COUNT = $CODE.co_kwonlyargcount, PARAMS_NAMED_DEFAULTS_COUNT = nb_kw_defaults;
        let named_defaults = DEFAULTS2.NONE;
        if (PARAMS_NAMED_DEFAULTS_COUNT > 0) {
          named_defaults = PARAMS_NAMED_DEFAULTS_COUNT >= PARAMS_NAMED_COUNT ? DEFAULTS2.ALL : DEFAULTS2.SOME;
        }
        const PARAMS_POSONLY_COUNT = $CODE.co_posonlyargcount;
        const PARAMS_POS_COUNT = $CODE.co_argcount - PARAMS_POSONLY_COUNT;
        let pos_defaults = DEFAULTS2.NONE;
        if (PARAMS_POS_COUNT !== 0 && value2.length > 0) {
          pos_defaults = value2.length >= PARAMS_POS_COUNT ? DEFAULTS2.ALL : DEFAULTS2.SOME;
        }
        let posonly_defaults = DEFAULTS2.NONE;
        if (value2.length > PARAMS_POS_COUNT) {
          posonly_defaults = value2.length >= $CODE.co_argcount ? DEFAULTS2.ALL : DEFAULTS2.SOME;
        }
        f.$args_parser = f.$infos.args_parser = $B2.getArgs0(
          PARAMS_POSONLY_COUNT !== 0,
          posonly_defaults,
          PARAMS_POS_COUNT !== 0,
          pos_defaults,
          $INFOS.vararg !== null,
          PARAMS_NAMED_COUNT !== 0,
          named_defaults,
          $INFOS.kwarg !== null
        );
        return f.$args_parser;
      };
      $B2.function.$factory = function() {
      };
      $B2.set_func_names($B2.function, "builtins");
      const args0_fcts = $B2.args_parsers = [];
      function getArgs0(hasPosOnly, posOnlyDefaults, hasPos, posDefaults, hasVargars, hasNamedOnly, namedOnlyDefaults, hasKWargs) {
        const IDX = hasPosOnly | posOnlyDefaults << 1 | hasPos << 3 | posDefaults << 4 | hasVargars << 6 | hasNamedOnly << 7 | namedOnlyDefaults << 8 | hasKWargs << 10;
        const args0 = args0_fcts[IDX];
        if (args0 !== void 0)
          return args0;
        const fct = args0_fcts[IDX] = generate_args0(hasPosOnly, posOnlyDefaults, hasPos, posDefaults, hasVargars, hasNamedOnly, namedOnlyDefaults, hasKWargs);
        fct.id = IDX;
        return fct;
      }
      $B2.getArgs0 = getArgs0;
      const DEFAULTS = getArgs0.DEFAULTS = { NONE: 0, SOME: 1, ALL: 3 };
      function generate_args0(...args) {
        return new Function("fct", "args", generate_args0_str(...args));
      }
      function generate_args0_str(hasPosOnly, posOnlyDefaults, hasPos, posDefaults, hasVargars, hasNamedOnly, namedOnlyDefaults, hasKWargs) {
        let fct = `
    const LAST_ARGS = args[args.length-1];
    const HAS_KW = LAST_ARGS !== undefined && LAST_ARGS !== null && LAST_ARGS.$kw !== undefined;
    let ARGS_POS_COUNT        = args.length;
    let ARGS_NAMED            = null;
    if( HAS_KW ) {
        --ARGS_POS_COUNT;
        ARGS_NAMED = LAST_ARGS.$kw;
    }
    const result = {};
    // using const should enable the browser to perform some optimisation.
    const $INFOS = fct.$infos;
    const $CODE  = $INFOS.__code__;
`;
        if (hasPos || hasPosOnly || hasNamedOnly)
          fct += `
    const PARAMS_NAMES        = $INFOS.arg_names;
`;
        let PARAMS_POS_COUNT = "0";
        if (hasPos || hasPosOnly) {
          PARAMS_POS_COUNT = "PARAMS_POS_COUNT";
          fct += `
    const PARAMS_POS_COUNT    = $CODE.co_argcount;
`;
        }
        let PARAMS_POS_DEFAULTS_OFFSET = PARAMS_POS_COUNT;
        let PARAMS_POS_DEFAULTS_COUNT = "0";
        if (posOnlyDefaults !== DEFAULTS.NONE || posDefaults !== DEFAULTS.NONE) {
          PARAMS_POS_DEFAULTS_OFFSET = "PARAMS_POS_DEFAULTS_OFFSET";
          PARAMS_POS_DEFAULTS_COUNT = "PARAMS_POS_DEFAULTS_COUNT";
          fct += `
    const PARAMS_POS_DEFAULTS = $INFOS.__defaults__;
    const PARAMS_POS_DEFAULTS_COUNT = PARAMS_POS_DEFAULTS.length;
    const PARAMS_POS_DEFAULTS_OFFSET= ${PARAMS_POS_COUNT} - PARAMS_POS_DEFAULTS_COUNT;
`;
        }
        fct += `
    let offset = 0;
`;
        if (hasVargars) {
          fct += `
    result[$INFOS.vararg] = $B.fast_tuple( Array.prototype.slice.call(args, ${PARAMS_POS_COUNT}, ARGS_POS_COUNT ) ); //TODO: opti, better way to construct tuple from subarray ?
`;
          if (hasPosOnly || hasPos) {
            fct += `
    const min = Math.min( ARGS_POS_COUNT, ${PARAMS_POS_COUNT} );
    for( ; offset < min ; ++offset)
        result[ PARAMS_NAMES[offset] ] = args[offset];
`;
          }
        } else {
          fct += `
    if( ARGS_POS_COUNT > ${PARAMS_POS_COUNT} ) {
        $B.args0_old(fct, args);
        throw new Error('Too much positional arguments given (args0 should have raised an error) !');
    }
`;
          if (hasPosOnly || hasPos) {
            fct += `
    for( ; offset < ARGS_POS_COUNT ; ++offset)
        result[ PARAMS_NAMES[offset] ] = args[offset];
`;
          }
        }
        if (!hasPos && !hasNamedOnly && !hasKWargs) {
          fct += `
    if( HAS_KW === true ) {
        for(let argname in ARGS_NAMED[0] ) {
            $B.args0_old(fct, args);
            throw new Error('No named arguments expected !!!');
        }
        for(let id = 1; id < ARGS_NAMED.length; ++id ) {
            const kargs = ARGS_NAMED[id];
            for(let argname of $B.unpack_mapping( fct, kargs) ) { //TODO: not optimal
                $B.args0_old(fct, args);
                throw new Error('No named arguments expected !!!');
            }
        }
    }
`;
        } else {
          fct += `
    if( HAS_KW === false ) {
    `;
        }
        if (hasPos || hasPosOnly) {
          if (posOnlyDefaults !== DEFAULTS.ALL && posDefaults !== DEFAULTS.ALL) {
            fct += `
        if( offset < ${PARAMS_POS_DEFAULTS_OFFSET} ) {
            $B.args0_old(fct, args);
            throw new Error('Not enough positional arguments given (args0 should have raised an error) !');
        }
`;
          }
          if (posOnlyDefaults !== DEFAULTS.NONE || posDefaults !== DEFAULTS.NONE) {
            fct += `
        for(let i = offset - PARAMS_POS_DEFAULTS_OFFSET;
            i < PARAMS_POS_DEFAULTS_COUNT;
            ++i)
            result[ PARAMS_NAMES[offset++] ] = PARAMS_POS_DEFAULTS[i];`;
          }
        }
        if (hasKWargs) {
          fct += `
        result[$INFOS.kwarg] = __BRYTHON__.empty_dict();`;
        }
        if (hasNamedOnly && namedOnlyDefaults !== DEFAULTS.ALL) {
          fct += `
        $B.args0_old(fct, args);
        throw new Error('Named argument expected (args0 should have raised an error) !');
`;
        } else if (namedOnlyDefaults !== DEFAULTS.NONE) {
          fct += `
        const kwargs_defaults_values = fct.$kwdefaults_values;
        for(let i = 0; i < kwargs_defaults_values.length; ++i )
                result[ PARAMS_NAMES[offset++] ] = kwargs_defaults_values[i];
`;
        }
        fct += `
        return result;
`;
        if (!hasPos && !hasNamedOnly && !hasKWargs) {
          return fct;
        } else {
          fct += `
    }
`;
        }
        if (namedOnlyDefaults !== DEFAULTS.NONE) {
          fct += `
    const kwargs_defaults = fct.$kwdefaults;
`;
        }
        if (hasPosOnly) {
          fct += `
    const PARAMS_POSONLY_COUNT         = $CODE.co_posonlyargcount;
    if( offset < PARAMS_POSONLY_COUNT ) {
        `;
          if (posOnlyDefaults !== DEFAULTS.SOME) {
            fct += `
        if( offset < ${PARAMS_POS_DEFAULTS_OFFSET} ) {
            $B.args0_old(fct, args);
            throw new Error('Not enough positional parameters given (args0 should have raised an error) !');
        }
`;
          }
          if (posOnlyDefaults === DEFAULTS.NONE) {
            fct += `
        $B.args0_old(fct, args);
        throw new Error('Not enough positional parameters given (args0 should have raised an error) !');
`;
          }
          fct += `
        const max = ${PARAMS_POS_DEFAULTS_COUNT} - (${PARAMS_POS_COUNT} - PARAMS_POSONLY_COUNT);
        // default parameters
        for(let i = offset - ${PARAMS_POS_DEFAULTS_OFFSET};
                i < max;
                ++i)
            result[ PARAMS_NAMES[offset++] ] = PARAMS_POS_DEFAULTS[i];
    }
`;
        }
        if (hasKWargs) {
          fct += `
    const extra = {};
    let nb_extra_args = 0;
`;
          if (hasPos || hasNamedOnly) {
            fct += `
    const HAS_PARAMS = fct.$hasParams;
`;
          }
        }
        fct += `
    let nb_named_args = 0;
    const kargs = ARGS_NAMED[0];
    for(let argname in kargs) {
        `;
        if (!hasKWargs) {
          fct += `
        result[ argname ] = kargs[argname];
        ++nb_named_args;
`;
        }
        if (hasKWargs) {
          if (!hasNamedOnly && !hasPos) {
            fct += `
        extra[ argname ] = kargs[argname];
        ++nb_extra_args;
`;
          } else {
            fct += `
        if( HAS_PARAMS.has(argname) ) {
            result[ argname ] = kargs[argname];
            ++nb_named_args;
        } else {
            extra[ argname ] = kargs[argname];
            ++nb_extra_args;
        }
`;
          }
        }
        fct += `
    }
    for(let id = 1; id < ARGS_NAMED.length; ++id ) {
        const kargs = ARGS_NAMED[id];
        for(let item of $B.unpack_mapping(fct, kargs) ) {
            let argname = item.key
            if( typeof argname !== "string") {
                $B.args0_old(fct, args);
                throw new Error('Non string key passed in **kargs');
            }
            `;
        if (!hasKWargs) {
          fct += `
            result[ argname ] = item.value;
            ++nb_named_args;
`;
        }
        if (hasKWargs) {
          if (!hasNamedOnly && !hasPos) {
            fct += `
            extra[ argname ] = $B.$getitem(kargs, argname);
            ++nb_extra_args;
`;
          } else {
            fct += `
            if( HAS_PARAMS.has(argname) ) {
                result[ argname ] = $B.$getitem(kargs, argname);
                ++nb_named_args;
            } else {
                extra[ argname ] = $B.$getitem(kargs, argname);
                ++nb_extra_args;
            }
`;
          }
        }
        fct += `
        }
    }
`;
        fct += `
    let found = 0;
    let ioffset = offset;
`;
        if ((hasPosOnly || hasPos) && (!hasPosOnly || posOnlyDefaults !== DEFAULTS.ALL) && (!hasPos || posDefaults !== DEFAULTS.ALL)) {
          fct += `
    for( ; ioffset < ${PARAMS_POS_DEFAULTS_OFFSET}; ++ioffset) {
        const key = PARAMS_NAMES[ioffset];
        if( key in result ) // maybe could be speed up using "!(key in result)"
            continue;
        $B.args0_old(fct, args);
        throw new Error('Missing a named arguments (args0 should have raised an error) !');
    }
`;
        }
        if (hasPosOnly && posOnlyDefaults !== DEFAULTS.NONE || hasPos && posDefaults !== DEFAULTS.NONE) {
          fct += `
    for( ; ioffset < PARAMS_POS_COUNT; ++ioffset) {
        const key = PARAMS_NAMES[ioffset];
        if( key in result )
            continue;
        result[key] = PARAMS_POS_DEFAULTS[ioffset - ${PARAMS_POS_DEFAULTS_OFFSET}];
    ++found;
    }
`;
        }
        if (hasNamedOnly) {
          fct += `
        for( ; ioffset < PARAMS_NAMES.length; ++ioffset) {
            const key = PARAMS_NAMES[ioffset];
            if( key in result )
                continue;
`;
          if (namedOnlyDefaults === DEFAULTS.SOME) {
            fct += `
            if( ! kwargs_defaults.has(key) ) {
                $B.args0_old(fct, args);
                throw new Error('Missing a named arguments (args0 should have raised an error) !');
            }
`;
          }
          if (namedOnlyDefaults === DEFAULTS.NONE) {
            fct += `
            $B.args0_old(fct, args);
            throw new Error('Missing a named arguments (args0 should have raised an error) !');
`;
          }
          if (namedOnlyDefaults !== DEFAULTS.NONE) {
            fct += `
            result[key] = kwargs_defaults.get(key);
            ++found;
`;
          }
          fct += `
        }
`;
        }
        if (hasNamedOnly || hasPos)
          fct += `
        if( found + nb_named_args !== PARAMS_NAMES.length - offset) {
            $B.args0_old(fct, args);
            throw new Error('Inexistant or duplicate named arguments (args0 should have raised an error) !');
        }
`;
        if (hasKWargs) {
          fct += `
    if( Object.keys(extra).length !== nb_extra_args ) {
        $B.args0_old(fct, args);
        throw new Error('Duplicate name given to **kargs parameter (args0 should have raised an error) !');
    }
    result[$INFOS.kwarg] = __BRYTHON__.builtins.dict.$from_js(extra);
`;
        }
        fct += `
    return result
    `;
        return fct;
      }
      function missing_names(missing) {
        var len = missing.length;
        var plural = len == 1 ? "" : "s";
        var report;
        switch (len) {
          case 1:
            report = `${missing[0]}`;
            break;
          case 2:
            report = `${missing[0]} and ${missing[1]}`;
            break;
          default:
            report = `${missing.slice(0, len - 1).join(", ")}, and ${missing[len - 1]}`;
            break;
        }
        return report;
      }
      function add_to_kwargs(kw_dict, key2, value2) {
        kw_dict.$strings[key2] = value2;
      }
      $B2.args_parser = function(f, args) {
        if (!f.$arguments_parser) {
          f.$arguments_parser = make_arguments_parser(f);
        }
        return f.$arguments_parser(f, args);
      };
      $B2.has_kw = function(args) {
        var last_arg = args[args.length - 1];
        return last_arg && last_arg.$kw;
      };
      var empty = {};
      function make_arguments_parser(f) {
        var infos = f.$function_infos;
        var name2 = infos[$B2.func_attrs.__name__];
        var arg_names = infos[$B2.func_attrs.arg_names];
        var positional_length = infos[$B2.func_attrs.positional_length];
        var kwonly_length = infos[$B2.func_attrs.kwonlyargs_length];
        var vararg = infos[$B2.func_attrs.args_vararg];
        var kwarg = infos[$B2.func_attrs.args_kwarg];
        var defaults = infos[$B2.func_attrs.__defaults__];
        var posonly_length = infos[$B2.func_attrs.posonlyargs_length];
        var kwonly_defs = [$B2.func_attrs.__kwdefaults__];
        var nb_formal = positional_length + kwonly_length;
        var def_obj = {};
        if (defaults !== _b_2.None) {
          var start_defs = positional_length - defaults.length;
          for (var i = start_defs; i < positional_length; i++) {
            def_obj[arg_names[i]] = defaults[i - start_defs];
          }
        }
        if (kwonly_defs !== _b_2.None) {
          for (var key2 in kwonly_defs) {
            def_obj[key2] = kwonly_defs[key2];
          }
        }
        var parser = function(f2, args) {
          function add_key(key3, value2) {
            var index = arg_names.indexOf(key3);
            if (index == -1) {
              if (kwarg) {
                add_to_kwargs(locals[kwarg], key3, value2);
                return;
              } else {
                throw _b_2.TypeError.$factory(name2 + `() got an unexpected keyword argument '${key3}'`);
              }
            }
            if (locals.hasOwnProperty(key3)) {
              if (kwarg && index < posonly_length) {
                _b_2.dict.$setitem_string(locals[kwarg], key3, value2);
                return;
              }
              throw _b_2.TypeError.$factory(name2 + `() got multiple values for argument '${key3}'`);
            }
            if (index < posonly_length) {
              if (defaults === _b_2.None || index <= positional_length - defaults.length) {
                if (kwarg) {
                  _b_2.dict.$setitem_string(locals[kwarg], key3, value2);
                } else {
                  posonly_as_keywords.push(key3);
                }
              }
            } else {
              locals[key3] = value2;
              filled_pos++;
            }
          }
          var too_many_pos = 0;
          var posonly_as_keywords = [];
          const locals = {};
          var filled_pos = 0;
          var vargs;
          if (kwarg !== null) {
            locals[kwarg] = $B2.empty_dict();
          }
          const args_length = args.length;
          const last_arg = args[args_length - 1];
          const has_kw = last_arg && last_arg.$kw;
          const nb_pos = has_kw ? args_length - 1 : args_length;
          if (vararg !== null) {
            locals[vararg] = vargs = [];
          }
          if (nb_pos <= positional_length) {
            for (let iarg = 0; iarg < nb_pos; iarg++) {
              locals[arg_names[iarg]] = args[iarg];
            }
            filled_pos = nb_pos;
          } else {
            for (let iarg = 0; iarg < positional_length; iarg++) {
              locals[arg_names[iarg]] = args[iarg];
            }
            filled_pos = positional_length;
            if (vararg !== null) {
              for (let j2 = positional_length; j2 < nb_pos; j2++) {
                vargs[vargs.length] = args[j2];
              }
            } else {
              too_many_pos = nb_pos - positional_length;
            }
          }
          if (has_kw) {
            var elt = last_arg;
            for (let key3 in elt.$kw[0]) {
              add_key(key3, elt.$kw[0][key3]);
            }
            for (let i2 = 1; i2 < elt.$kw.length; i2++) {
              if (elt.$kw[i2].__class__ === _b_2.dict) {
                for (let item2 of _b_2.dict.$iter_items(elt.$kw[i2])) {
                  add_key(item2.key, item2.value);
                }
              } else {
                let klass = $B2.get_class(elt.$kw[i2]);
                let keys_method = $B2.$getattr(klass, "keys", null);
                let getitem = $B2.$getattr(klass, "__getitem__", null);
                if (keys_method === null || getitem === null) {
                  throw _b_2.TypeError.$factory(
                    `${name2} argument after ** must be a mapping, not ${$B2.class_name(elt.$kw[i2])}`
                  );
                }
                for (let key3 of $B2.make_js_iterator(keys_method(elt.$kw[i2]))) {
                  add_key(key3, getitem(elt.$kw[i2], key3));
                }
              }
            }
          }
          if (vararg !== null) {
            locals[vararg] = $B2.fast_tuple(locals[vararg]);
          }
          if (nb_formal == 0) {
            return locals;
          }
          if (too_many_pos > 0) {
            var plural = positional_length == 1 ? "" : "s";
            var nb = positional_length + too_many_pos;
            var report = positional_length;
            if (defaults.length) {
              var nb_min = positional_length - defaults.length;
              report = `from ${nb_min} to ${positional_length}`;
              plural = "s";
            }
            throw _b_2.TypeError.$factory(
              `${name2}() takes ${report} positional argument${plural} but ${nb} were given`
            );
          }
          if (posonly_as_keywords.length > 0) {
            throw _b_2.TypeError.$factory(
              `${name2}() got some positional-only arguments passed as keyword arguments: '${posonly_as_keywords.join(", ")}'`
            );
          }
          if (filled_pos < nb_formal) {
            for (let key3 in def_obj) {
              if (!locals.hasOwnProperty(key3)) {
                locals[key3] = def_obj[key3];
                filled_pos++;
              }
            }
            if (filled_pos < nb_formal) {
              var missing_positional = [];
              var missing_kwonly = [];
              for (let i2 = 0; i2 < nb_formal; i2++) {
                let arg_name = arg_names[i2];
                if (!locals.hasOwnProperty(arg_name)) {
                  if (i2 < positional_length) {
                    missing_positional.push(`'${arg_name}'`);
                  } else {
                    missing_kwonly.push(`'${arg_name}'`);
                  }
                }
              }
              var missing;
              var missing_type;
              var report;
              if (missing_positional.length) {
                missing = missing_positional;
                missing_type = "positional";
              } else {
                missing = missing_kwonly;
                missing_type = "keyword-only";
              }
              var report = missing_names(missing);
              var nb_missing = missing.length;
              var plural = nb_missing == 1 ? "" : "s";
              throw _b_2.TypeError.$factory(name2 + `() missing ${nb_missing} required ${missing_type} argument${plural}: ${report}`);
            }
          }
          return locals;
        };
        return parser;
      }
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      _b_2.__debug__ = false;
      $B2.$comps = { ">": "gt", ">=": "ge", "<": "lt", "<=": "le" };
      $B2.$inv_comps = { ">": "lt", ">=": "le", "<": "gt", "<=": "ge" };
      var check_nb_args = $B2.check_nb_args, check_no_kw = $B2.check_no_kw, check_nb_args_no_kw = $B2.check_nb_args_no_kw;
      var NoneType = $B2.NoneType = { $factory: function() {
        return None;
      }, __bool__: function() {
        return False;
      }, __class__: _b_2.type, __hash__: function() {
        return 0;
      }, __module__: "builtins", __mro__: [_b_2.object], __name__: "NoneType", __qualname__: "NoneType", __repr__: function() {
        return "None";
      }, __str__: function() {
        return "None";
      }, $is_class: true };
      NoneType.__setattr__ = function(self2, attr) {
        return no_set_attr(NoneType, attr);
      };
      var None = _b_2.None = { __class__: NoneType };
      None.__doc__ = None;
      NoneType.__doc__ = None;
      for (var $op in $B2.$comps) {
        var key2 = $B2.$comps[$op];
        switch (key2) {
          case "ge":
          case "gt":
          case "le":
          case "lt":
            NoneType["__" + key2 + "__"] = /* @__PURE__ */ (function() {
              return function() {
                return _b_2.NotImplemented;
              };
            })($op);
        }
      }
      for (var $func in None) {
        if (typeof None[$func] == "function") {
          None[$func].__str__ = /* @__PURE__ */ (function(f) {
            return function() {
              return "<method-wrapper " + f + " of NoneType object>";
            };
          })($func);
        }
      }
      $B2.set_func_names(NoneType, "builtins");
      _b_2.__build_class__ = function() {
        throw _b_2.NotImplementedError.$factory("__build_class__");
      };
      _b_2.abs = function(obj) {
        check_nb_args_no_kw("abs", 1, arguments);
        var klass = obj.__class__ || $B2.get_class(obj);
        try {
          var method = $B2.$getattr(klass, "__abs__");
        } catch (err) {
          if (err.__class__ === _b_2.AttributeError) {
            throw _b_2.TypeError.$factory("Bad operand type for abs(): '" + $B2.class_name(obj) + "'");
          }
          throw err;
        }
        return $B2.$call(method)(obj);
      };
      _b_2.aiter = function(async_iterable) {
        return $B2.$call($B2.$getattr(async_iterable, "__aiter__"))();
      };
      _b_2.all = function(obj) {
        check_nb_args_no_kw("all", 1, arguments);
        var iterable = iter(obj);
        while (1) {
          try {
            var elt = next(iterable);
            if (!$B2.$bool(elt)) {
              return false;
            }
          } catch (err) {
            return true;
          }
        }
      };
      _b_2.anext = function() {
        var missing = {}, $ = $B2.args("anext", 2, { async_iterator: null, _default: null }, ["async_iterator", "_default"], arguments, { _default: missing }, null, null);
        var awaitable = $B2.$call($B2.$getattr($.async_iterator, "__anext__"))();
        return awaitable.catch(
          function(err) {
            if ($B2.is_exc(err, [_b_2.StopAsyncIteration])) {
              if ($._default !== missing) {
                return $._default;
              }
            }
            throw err;
          }
        );
      };
      _b_2.any = function(obj) {
        check_nb_args_no_kw("any", 1, arguments);
        for (var elt of $B2.make_js_iterator(obj)) {
          if ($B2.$bool(elt)) {
            return true;
          }
        }
        return false;
      };
      _b_2.ascii = function(obj) {
        check_nb_args_no_kw("ascii", 1, arguments);
        var res = repr(obj), res1 = "", cp;
        for (var i = 0; i < res.length; i++) {
          cp = res.charCodeAt(i);
          if (cp < 128) {
            res1 += res.charAt(i);
          } else if (cp < 256) {
            res1 += "\\x" + cp.toString(16);
          } else {
            var s = cp.toString(16);
            if (s.length % 2 == 1) {
              s = "0" + s;
            }
            res1 += "\\u" + s;
          }
        }
        return res1;
      };
      function $builtin_base_convert_helper(obj, base) {
        var prefix = "";
        switch (base) {
          case 2:
            prefix = "0b";
            break;
          case 8:
            prefix = "0o";
            break;
          case 16:
            prefix = "0x";
            break;
          default:
            console.log("invalid base:" + base);
        }
        if (obj.__class__ === $B2.long_int) {
          var res = prefix + obj.value.toString(base);
          return res;
        }
        var value2 = $B2.PyNumber_Index(obj);
        if (value2 === void 0) {
          throw _b_2.TypeError.$factory("Error, argument must be an integer or contains an __index__ function");
        }
        if (value2 >= 0) {
          return prefix + value2.toString(base);
        }
        return "-" + prefix + (-value2).toString(base);
      }
      function bin_hex_oct(base, obj) {
        if ($B2.$isinstance(obj, _b_2.int)) {
          return $builtin_base_convert_helper(obj, base);
        } else {
          try {
            var klass = obj.__class__ || $B2.get_class(obj), method = $B2.$getattr(klass, "__index__");
          } catch (err) {
            if (err.__class__ === _b_2.AttributeError) {
              throw _b_2.TypeError.$factory("'" + $B2.class_name(obj) + "' object cannot be interpreted as an integer");
            }
            throw err;
          }
          var res = $B2.$call(method)(obj);
          return $builtin_base_convert_helper(res, base);
        }
      }
      _b_2.bin = function(obj) {
        check_nb_args_no_kw("bin", 1, arguments);
        return bin_hex_oct(2, obj);
      };
      _b_2.breakpoint = function() {
        $B2.$import("sys", []);
        var missing = {}, hook = $B2.$getattr($B2.imported.sys, "breakpointhook", missing);
        if (hook === missing) {
          throw _b_2.RuntimeError.$factory("lost sys.breakpointhook");
        }
        return $B2.$call(hook).apply(null, arguments);
      };
      _b_2.callable = function(obj) {
        check_nb_args_no_kw("callable", 1, arguments);
        return _b_2.hasattr(obj, "__call__");
      };
      _b_2.chr = function(i) {
        check_nb_args_no_kw("chr", 1, arguments);
        i = $B2.PyNumber_Index(i);
        if (i < 0 || i > 1114111) {
          throw _b_2.ValueError.$factory("Outside valid range");
        } else if (i >= 65536 && i <= 1114111) {
          var code2 = i - 65536, s = String.fromCodePoint(55296 | code2 >> 10) + String.fromCodePoint(56320 | code2 & 1023);
          return $B2.make_String(s, [0]);
        } else {
          return String.fromCodePoint(i);
        }
      };
      var code = _b_2.code = $B2.make_class("code");
      code.__repr__ = code.__str__ = function(_self) {
        return `<code object ${_self.co_name}, file '${_self.co_filename}', line ${_self.co_firstlineno || 1}>`;
      };
      code.__getattribute__ = function(self2, attr) {
        if (attr == "co_positions") {
          var positions = [[0, 0, 0, 0]];
          if (self2.co_positions) {
            positions = self2.co_positions;
          }
          var f = () => $B2.$list(positions);
          f.__class__ = $B2.function;
          return f;
        }
        return self2[attr];
      };
      $B2.set_func_names(code, "builtins");
      _b_2.compile = function() {
        var $ = $B2.args("compile", 7, { source: null, filename: null, mode: null, flags: null, dont_inherit: null, optimize: null, _feature_version: null }, ["source", "filename", "mode", "flags", "dont_inherit", "optimize", "_feature_version"], arguments, { flags: 0, dont_inherit: false, optimize: -1, _feature_version: 0 }, null, null);
        var module_name = "$exec_" + $B2.UUID();
        $.__class__ = code;
        $.co_flags = $.flags;
        $.co_name = "<module>";
        var filename = $.co_filename = $.filename;
        var interactive = $.mode == "single" && $.flags & 512;
        $B2.file_cache[filename] = $.source;
        $B2.url2name[filename] = module_name;
        if ($.flags & $B2.PyCF_TYPE_COMMENTS) {
        }
        if ($B2.$isinstance($.source, _b_2.bytes)) {
          var encoding = "utf-8", lfpos = $.source.source.indexOf(10), first_line, second_line;
          if (lfpos == -1) {
            first_line = $.source;
          } else {
            first_line = _b_2.bytes.$factory($.source.source.slice(0, lfpos));
          }
          first_line = _b_2.bytes.decode(first_line, "latin-1");
          var encoding_re = /^[\t\f]*#.*?coding[:=][\t]*([-_.a-zA-Z0-9]+)/;
          var mo = first_line.match(encoding_re);
          if (mo) {
            encoding = mo[1];
          } else if (lfpos > -1) {
            var rest = $.source.source.slice(lfpos + 1);
            lfpos = rest.indexOf(10);
            if (lfpos > -1) {
              second_line = _b_2.bytes.$factory(rest.slice(0, lfpos));
            } else {
              second_line = _b_2.bytes.$factory(rest);
            }
            second_line = _b_2.bytes.decode(second_line, "latin-1");
            mo = second_line.match(encoding_re);
            if (mo) {
              encoding = mo[1];
            }
          }
          $.source = _b_2.bytes.decode($.source, encoding);
        }
        if (!$B2.$isinstance(filename, [_b_2.bytes, _b_2.str])) {
          $B2.warn(_b_2.DeprecationWarning, `path should be string, bytes, or os.PathLike, not ${$B2.class_name(filename)}`);
        }
        if (interactive && !$.source.endsWith("\n")) {
          var lines = $.source.split("\n"), last_line = $B2.last(lines);
          if (last_line.startsWith(" ")) {
            var msg = "unexpected EOF while parsing", exc = _b_2.SyntaxError.$factory();
            exc.filename = filename;
            exc.lineno = exc.end_lineno = lines.length - 1;
            exc.offset = 0;
            exc.end_offset = last_line.length - 1;
            exc.text = last_line;
            exc.args = [msg, $B2.fast_tuple([filename, exc.lineno, exc.offset, exc.text, exc.end_lineno, exc.end_offset])];
            throw exc;
          }
        }
        if ($.source.__class__ && $.source.__class__.__module__ == "ast") {
          $B2.imported._ast._validate($.source);
          $._ast = $.source;
          delete $.source;
          return $;
        }
        var _ast, parser;
        try {
          var parser_mode = $.mode == "eval" ? "eval" : "file";
          parser = new $B2.Parser($.source, filename, parser_mode);
          parser.flags = $.flags;
          _ast = $B2._PyPegen.run_parser(parser);
        } catch (err) {
          if ($.mode == "single") {
            var tester = parser.tokens[parser.tokens.length - 2];
            if (tester && (tester.type == "NEWLINE" && $.flags & $B2.PyCF_ALLOW_INCOMPLETE_INPUT || tester.type == "DEDENT" && $.flags & 512)) {
              err.__class__ = _b_2._IncompleteInputError;
              err.args[0] = "incomplete input";
            }
          }
          throw err;
        }
        if ($.mode == "single" && _ast.body.length == 1 && _ast.body[0] instanceof $B2.ast.Expr) {
          parser = new $B2.Parser($.source, filename, "eval");
          _ast = $B2._PyPegen.run_parser(parser);
          $.single_expression = true;
        }
        if ($.flags == $B2.PyCF_ONLY_AST) {
          delete $B2.url2name[filename];
          let res = $B2.ast_js_to_py(_ast);
          res.$js_ast = _ast;
          return res;
        }
        delete $B2.url2name[filename];
        $._ast = $B2.ast_js_to_py(_ast);
        $._ast.$js_ast = _ast;
        var future = $B2.future_features(_ast, filename);
        var symtable = $B2._PySymtable_Build(_ast, filename, future);
        $B2.js_from_root({ ast: _ast, symtable, filename, src: $.source });
        return $;
      };
      _b_2.debug = $B2.debug > 0;
      _b_2.delattr = function(obj, attr) {
        check_nb_args_no_kw("delattr", 2, arguments);
        if (typeof attr != "string") {
          throw _b_2.TypeError.$factory("attribute name must be string, not '" + $B2.class_name(attr) + "'");
        }
        var deleter = $B2.search_in_mro($B2.get_class(obj), "__delattr__");
        if (deleter) {
          return deleter(obj, attr);
        }
        return _b_2.object.__delattr__(obj, attr);
      };
      $B2.$delattr = function(obj, attr, inum) {
        try {
          _b_2.delattr(obj, attr);
        } catch (err) {
          $B2.set_inum(inum);
          throw err;
        }
      };
      $B2.$delete = function(name3, locals_id, inum) {
        function del(obj) {
          if (obj.__class__ === $B2.generator) {
            obj.js_gen.return();
          }
        }
        var found = false;
        if (locals_id == "local") {
          var frame = $B2.frame_obj.frame;
          if (frame[1].hasOwnProperty(name3)) {
            found = true;
            del(frame[1][name3]);
            delete frame[1][name3];
          }
        } else if (locals_id == "global") {
          var frame = $B2.frame_obj.frame;
          if (frame[3].hasOwnProperty(name3)) {
            found = true;
            del(frame[3][name3]);
            delete frame[3][name3];
          }
        } else if (locals_id !== null && locals_id[name3] !== void 0) {
          found = true;
          del(locals_id[name3]);
          delete locals_id[name3];
        }
        if (!found) {
          $B2.set_inum(inum);
          if (locals_id == "local") {
            throw _b_2.UnboundLocalError.$factory(
              `cannot access local variable '${name3}' where it is not associated with a value`
            );
          } else {
            throw $B2.name_error(name3);
          }
        }
      };
      _b_2.dir = function(obj) {
        if (obj === void 0) {
          var locals = _b_2.locals();
          return _b_2.sorted(locals);
        }
        check_nb_args_no_kw("dir", 1, arguments);
        var klass = obj.__class__ || $B2.get_class(obj);
        if (obj.$is_class) {
          var dir_func = $B2.$getattr(obj.__class__, "__dir__");
          return $B2.$call(dir_func)(obj);
        }
        try {
          let res = $B2.$call($B2.$getattr(klass, "__dir__"))(obj);
          res = _b_2.list.$factory(res);
          return res;
        } catch (err) {
          if ($B2.get_option("debug") > 2) {
            console.log("error in dir, obj", obj, "klass", klass, $B2.$getattr(klass, "__dir__"), err.message);
          }
          throw err;
        }
      };
      _b_2.divmod = function(x, y) {
        check_nb_args_no_kw("divmod", 2, arguments);
        try {
          return $B2.rich_op("__divmod__", x, y);
        } catch (err) {
          if ($B2.is_exc(err, [_b_2.TypeError])) {
            return _b_2.tuple.$factory([$B2.rich_op("__floordiv__", x, y), $B2.rich_op("__mod__", x, y)]);
          }
          throw err;
        }
      };
      var enumerate = _b_2.enumerate = $B2.make_class(
        "enumerate",
        function() {
          var $ns = $B2.args("enumerate", 2, { iterable: null, start: null }, ["iterable", "start"], arguments, { start: 0 }, null, null), _iter = iter($ns["iterable"]), start = $ns["start"];
          return {
            __class__: enumerate,
            __name__: "enumerate iterator",
            counter: start - 1,
            iter: _iter,
            start
          };
        }
      );
      enumerate.__class_getitem__ = $B2.$class_getitem;
      enumerate.__iter__ = function(self2) {
        self2.counter = self2.start - 1;
        return self2;
      };
      enumerate.__next__ = function(self2) {
        self2.counter++;
        return $B2.fast_tuple([self2.counter, next(self2.iter)]);
      };
      $B2.set_func_names(enumerate, "builtins");
      $B2.LOCALS_PROXY = Symbol("locals_proxy");
      enumerate.__class_getitem__ = _b_2.classmethod.$factory(enumerate.__class_getitem__);
      var $$eval = _b_2.eval = function() {
        var $ = $B2.args("eval", 4, { src: null, globals: null, locals: null, mode: null }, ["src", "globals", "locals", "mode"], arguments, { globals: _b_2.None, locals: _b_2.None, mode: "eval" }, null, null, 4), src = $.src, _globals = $.globals, _locals = $.locals, mode = $.mode;
        if ($.src.mode && $.src.mode == "single" && ["<console>", "<stdin>"].indexOf($.src.filename) > -1) {
          _b_2.print(">", $.src.source.trim());
        }
        var filename = "<string>";
        if (src.__class__ === code) {
          filename = src.filename;
        } else if (!src.valueOf || typeof src.valueOf() !== "string") {
          throw _b_2.TypeError.$factory(`${mode}() arg 1 must be a string, bytes or code object`);
        } else {
          src = src.valueOf();
          src = src.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        }
        var __name__ = "exec";
        if (_globals === _b_2.None) {
          if ($B2.frame_obj !== null) {
            __name__ = $B2.frame_obj.frame[2];
          }
        }
        if (_globals !== _b_2.None && _globals.__class__ == _b_2.dict && _b_2.dict.$contains_string(_globals, "__name__")) {
          __name__ = _b_2.dict.$getitem_string(_globals, "__name__");
        }
        $B2.url2name[filename] = __name__;
        var frame = $B2.frame_obj.frame;
        $B2.exec_scope = $B2.exec_scope || {};
        if (typeof src == "string" && src.endsWith("\\\n")) {
          var exc = _b_2.SyntaxError.$factory("unexpected EOF while parsing");
          var lines = src.split("\n"), line = lines[lines.length - 2];
          exc.args = ["unexpected EOF while parsing", [filename, lines.length - 1, 1, line]];
          exc.filename = filename;
          exc.text = line;
          throw exc;
        }
        var local_name = ("locals_" + __name__).replace(/\./g, "_"), global_name = ("globals_" + __name__).replace(/\./g, "_"), exec_locals = {}, exec_globals = {};
        if (_globals === _b_2.None) {
          if (frame[1] === frame[3]) {
            global_name += "_globals";
            exec_locals = exec_globals = frame[3];
          } else {
            if (mode == "exec") {
              exec_locals = $B2.clone(frame[1]);
              for (var attr in frame[3]) {
                exec_locals[attr] = frame[3][attr];
              }
              exec_globals = exec_locals;
            } else {
              exec_locals = frame[1];
              exec_globals = frame[3];
            }
          }
        } else {
          if (_globals.__class__ !== _b_2.dict) {
            throw _b_2.TypeError.$factory(`${mode}() globals must be a dict, not ` + $B2.class_name(_globals));
          }
          exec_globals = {};
          if (_globals.$jsobj) {
            exec_globals = _globals.$jsobj;
          } else {
            exec_globals = _globals.$jsobj = {};
            for (var key3 of _b_2.dict.$keys_string(_globals)) {
              _globals.$jsobj[key3] = _b_2.dict.$getitem_string(_globals, key3);
              if (key3 == "__name__") {
                __name__ = _globals.$jsobj[key3];
              }
            }
            _globals.$all_str = false;
          }
          if (exec_globals.__builtins__ === void 0) {
            exec_globals.__builtins__ = _b_2.__builtins__;
          }
          if (_locals === _b_2.None) {
            exec_locals = exec_globals;
          } else {
            if (_locals === _globals) {
              global_name += "_globals";
              exec_locals = exec_globals;
            } else if (_locals.$jsobj) {
              for (let key4 in _locals.$jsobj) {
                exec_globals[key4] = _locals.$jsobj[key4];
              }
            } else {
              if (_locals.$jsobj) {
                exec_locals = _locals.$jsobj;
              } else {
                var klass = $B2.get_class(_locals), getitem = $B2.$call($B2.$getattr(klass, "__getitem__")), setitem = $B2.$call($B2.$getattr(klass, "__setitem__"));
                exec_locals = new Proxy(_locals, { get(target, prop) {
                  if (prop == "$target") {
                    return target;
                  } else if (prop == $B2.LOCALS_PROXY) {
                    return true;
                  }
                  try {
                    return getitem(target, prop);
                  } catch (err) {
                    return void 0;
                  }
                }, set(target, prop, value2) {
                  return setitem(target, prop, value2);
                } });
              }
            }
          }
        }
        var save_frame_obj = $B2.frame_obj;
        var _ast;
        frame = [__name__, exec_locals, __name__, exec_globals];
        frame.is_exec_top = true;
        $B2.enter_frame(frame, filename, 1);
        var _frame_obj = $B2.frame_obj;
        if (src.__class__ === code) {
          if (src.mode == "exec" && mode == "eval") {
            return _b_2.None;
          }
          _ast = src._ast;
          if (_ast.$js_ast) {
            _ast = _ast.$js_ast;
          } else {
            _ast = $B2.ast_py_to_js(_ast);
          }
          if (_ast instanceof $B2.ast.Expression) {
            var expr_name = "_" + $B2.UUID();
            var name3 = new $B2.ast.Name(expr_name, new $B2.ast.Store());
            $B2.copy_position(name3, _ast.body);
            var assign = new $B2.ast.Assign([name3], _ast.body);
            $B2.copy_position(assign, _ast.body);
            _ast = new $B2.ast.Module([assign]);
          }
        }
        try {
          if (!_ast) {
            var _mode = mode == "eval" ? "eval" : "file";
            var parser = new $B2.Parser(src, filename, _mode);
            _ast = $B2._PyPegen.run_parser(parser);
          }
          var future = $B2.future_features(_ast, filename), symtable = $B2._PySymtable_Build(_ast, filename, future), js_obj = $B2.js_from_root({ ast: _ast, symtable, filename, src, namespaces: { local_name, exec_locals, global_name, exec_globals } }), js = js_obj.js;
        } catch (err) {
          if (err.args) {
            if (err.args[1]) {
              exec_locals.$lineno = err.args[1][1];
            }
          } else {
            console.log("JS Error", err.message);
          }
          $B2.frame_obj = save_frame_obj;
          throw err;
        }
        if (mode == "eval") {
          if (src.__class__ === _b_2.code) {
            js += `
return locals.${expr_name}`;
          } else {
            js = `var __file__ = '${filename}'
var locals = ${local_name};
return ` + js;
          }
        } else if (src.single_expression) {
          if (src.__class__ === _b_2.code) {
            js += `var result = locals.${expr_name}
if(result !== _b_.None){
_b_.print(result)
}`;
          } else {
            js = `var __file__ = '${filename}'
var result = ${js}
if(result !== _b_.None){
_b_.print(result)
}`;
          }
        }
        try {
          var exec_func = new Function("$B", "_b_", "locals", local_name, global_name, "frame", "_frame_obj", js);
        } catch (err) {
          if ($B2.get_option("debug") > 1) {
            console.log("eval() error\n", $B2.format_indent(js, 0));
            console.log("-- python source\n", src);
          }
          $B2.frame_obj = save_frame_obj;
          throw err;
        }
        try {
          var res = exec_func($B2, _b_2, exec_locals, exec_locals, exec_globals, frame, _frame_obj);
        } catch (err) {
          if ($B2.get_option("debug") > 2) {
            console.log(
              "Python code\n",
              src,
              "\nexec func",
              $B2.format_indent(exec_func + "", 0),
              "\n    filename",
              filename,
              "\n    name from filename",
              $B2.url2name[filename],
              "\n    local_name",
              local_name,
              "\n    exec_locals",
              exec_locals,
              "\n    global_name",
              global_name,
              "\n    exec_globals",
              exec_globals,
              "\n    frame",
              frame,
              "\n    _ast",
              _ast,
              "\n    js",
              js,
              "\n    err",
              err.__class__,
              err.args,
              err.$frame_obj
            );
          }
          $B2.set_exc(err, frame);
          $B2.frame_obj = save_frame_obj;
          throw err;
        }
        if (_globals !== _b_2.None && !_globals.$jsobj) {
          for (var _key in exec_globals) {
            if (!_key.startsWith("$")) {
              _b_2.dict.$setitem(_globals, _key, exec_globals[_key]);
            }
          }
        }
        $B2.frame_obj = save_frame_obj;
        return res;
      };
      $$eval.$is_func = true;
      var exec = _b_2.exec = function() {
        var $ = $B2.args("exec", 3, { src: null, globals: null, locals: null }, ["src", "globals", "locals"], arguments, { globals: _b_2.None, locals: _b_2.None }, null, null, 1), src = $.src, globals = $.globals, locals = $.locals;
        $$eval(src, globals, locals, "exec");
        return _b_2.None;
      };
      exec.$is_func = true;
      var exit = _b_2.exit = function() {
        throw _b_2.SystemExit;
      };
      exit.__repr__ = exit.__str__ = function() {
        return "Use exit() or Ctrl-Z plus Return to exit";
      };
      var filter = _b_2.filter = $B2.make_class(
        "filter",
        function(func, iterable) {
          check_nb_args_no_kw("filter", 2, arguments);
          iterable = iter(iterable);
          if (func === _b_2.None) {
            func = $B2.$bool;
          }
          return {
            __class__: filter,
            func,
            iterable
          };
        }
      );
      filter.__iter__ = function(self2) {
        return self2;
      };
      filter.__next__ = function(self2) {
        while (true) {
          var _item = next(self2.iterable);
          if (self2.func(_item)) {
            return _item;
          }
        }
      };
      $B2.set_func_names(filter, "builtins");
      _b_2.format = function() {
        var $ = $B2.args("format", 2, { value: null, format_spec: null }, ["value", "format_spec"], arguments, { format_spec: "" }, null, null), value2 = $.value;
        var klass = value2.__class__ || $B2.get_class(value2);
        try {
          var method = $B2.$getattr(klass, "__format__");
        } catch (err) {
          if (err.__class__ === _b_2.AttributeError) {
            throw _b_2.NotImplementedError("__format__ is not implemented for object '" + _b_2.str.$factory(value2) + "'");
          }
          throw err;
        }
        return $B2.$call(method)(value2, $.format_spec);
      };
      function attr_error(attr, obj) {
        var cname = $B2.get_class(obj);
        var msg = "bad operand type for unary #: '" + cname + "'";
        switch (attr) {
          case "__neg__":
            throw _b_2.TypeError.$factory(msg.replace("#", "-"));
          case "__pos__":
            throw _b_2.TypeError.$factory(msg.replace("#", "+"));
          case "__invert__":
            throw _b_2.TypeError.$factory(msg.replace("#", "~"));
          case "__call__":
            throw _b_2.TypeError.$factory("'" + cname + "' object is not callable");
          default:
            throw $B2.attr_error(attr, obj);
        }
      }
      _b_2.getattr = function() {
        var missing = {};
        var $ = $B2.args("getattr", 3, { obj: null, attr: null, _default: null }, ["obj", "attr", "_default"], arguments, { _default: missing }, null, null);
        if (!$B2.$isinstance($.attr, _b_2.str)) {
          throw _b_2.TypeError.$factory(`attribute name must be string, not '${$B2.class_name($.attr)}'`);
        }
        return $B2.$getattr($.obj, _b_2.str.$to_string($.attr), $._default === missing ? void 0 : $._default);
      };
      $B2.search_in_mro = function(klass, attr) {
        var test = false;
        if (klass.hasOwnProperty(attr)) {
          return klass[attr];
        } else if (klass.__dict__) {
          var v = _b_2.dict.$get_string(klass.__dict__, attr, false);
          if (v !== false) {
            if (test) {
              console.log("found in klass dict", klass.__dict__, v);
            }
            return v;
          }
        }
        var mro = klass.__mro__;
        for (var i = 0, len2 = mro.length; i < len2; i++) {
          if (mro[i].hasOwnProperty(attr)) {
            return mro[i][attr];
          } else if (mro[i].__dict__) {
            var v = _b_2.dict.$get_string(mro[i].__dict__, attr, false);
            if (v !== false) {
              if (test) {
                console.log("found in dict of mro", i, v);
              }
              return v;
            }
          }
        }
      };
      $B2.$getattr = function(obj, attr, _default) {
        var res;
        if (obj === void 0 || obj === null) {
          throw _b_2.AttributeError.$factory("Javascript object '" + obj + "' has no attribute");
        }
        if (obj.$method_cache && obj.$method_cache[attr] && obj.__class__ && obj.__class__[attr] == obj.$method_cache[attr][1]) {
          return obj.$method_cache[attr][0];
        }
        var rawname = attr;
        if (obj === void 0) {
          console.log("get attr", attr, "of undefined");
        }
        var is_class = obj.$is_class || obj.$factory;
        var klass = obj.__class__;
        var $test = false;
        if ($test) {
          console.log("attr", attr, "of", obj, "class", klass ?? $B2.get_class(obj), "isclass", is_class);
        }
        if (klass === void 0) {
          klass = $B2.get_class(obj);
          if (klass === void 0) {
            if ($test) {
              console.log("no class", attr, obj.hasOwnProperty(attr), obj[attr]);
            }
            res = obj[attr];
            if (res !== void 0) {
              if (typeof res == "function") {
                var f = function() {
                  return res.apply(obj, arguments);
                };
                f.$infos = { __name__: attr, __qualname__: attr };
                $B2.set_function_infos(
                  f,
                  { name: attr, qualname: attr }
                );
                return f;
              } else {
                return $B2.jsobj2pyobj(res);
              }
            }
            if (_default !== void 0) {
              return _default;
            }
            throw $B2.attr_error(rawname, obj);
          }
        }
        switch (attr) {
          case "__call__":
            if (typeof obj == "function") {
              res = function() {
                return obj.apply(null, arguments);
              };
              res.__class__ = method_wrapper;
              res.$infos = { __name__: "__call__" };
              return res;
            }
            break;
          case "__class__":
            if (klass.__dict__) {
              var klass_from_dict = _b_2.None;
              if ($B2.$isinstance(klass.__dict__, _b_2.dict)) {
                klass_from_dict = $B2.$call($B2.$getattr(klass.__dict__, "get"))("__class__");
              }
              if (klass_from_dict !== _b_2.None) {
                if (klass_from_dict.$is_property) {
                  return klass_from_dict.fget(obj);
                }
                return klass_from_dict;
              }
            }
            return klass;
          case "__dict__":
            if (is_class) {
              var dict = {}, key3;
              if (obj.__dict__) {
                for (key3 of _b_2.dict.$keys_string(obj.__dict__)) {
                  dict[key3] = _b_2.dict.$getitem_string(obj.__dict__, key3);
                  if (key3 == "__new__" && dict[key3].__class__ !== _b_2.staticmethod) {
                    dict[key3] = _b_2.staticmethod.$factory(dict[key3]);
                  }
                }
              } else {
                for (key3 in obj) {
                  if (!key3.startsWith("$")) {
                    dict[key3] = obj[key3];
                    if (key3 == "__new__" && dict[key3].__class__ !== _b_2.staticmethod) {
                      dict[key3] = _b_2.staticmethod.$factory(dict[key3]);
                    }
                  }
                }
              }
              dict.__dict__ = $B2.getset_descriptor.$factory(
                obj,
                "__dict__",
                function() {
                }
              );
              return {
                __class__: $B2.mappingproxy,
                $jsobj: dict,
                $version: 0
              };
            } else if (!klass.$native) {
              if (obj[attr] !== void 0) {
                return obj[attr];
              } else if (obj.__dict__) {
                return obj.__dict__;
              } else if (obj.$function_infos || obj.$infos) {
                if (!obj.$infos) {
                  $B2.make_function_infos(obj, ...obj.$function_infos);
                }
                if (obj.hasOwnProperty("__dict__")) {
                  return obj.__dict__;
                } else if (obj.$infos.hasOwnProperty("__func__") && obj.$infos.__func__) {
                  obj.$infos.__func__.__dict__ = obj.$infos.__func__.__dict__ ?? $B2.empty_dict();
                }
              } else if (obj.__class__ && obj.__class__.__dict__) {
              } else if (!obj.__class__) {
              }
              return $B2.obj_dict(
                obj,
                function(attr2) {
                  return attr2.startsWith("$") || ["__class__"].indexOf(attr2) > -1;
                }
              );
            }
            break;
          case "__mro__":
            if (obj.__mro__) {
              return _b_2.tuple.$factory([obj].concat(obj.__mro__));
            } else if (obj.__dict__ && _b_2.dict.$contains_string(obj.__dict__, "__mro__")) {
              return _b_2.dict.$getitem_string(obj.__dict__, "__mro__");
            }
            throw $B2.attr_error(attr, obj);
          case "__subclasses__":
            if (klass.$factory || klass.$is_class) {
              var subclasses = obj.$subclasses || [];
              return function() {
                return $B2.$list(subclasses);
              };
            }
            break;
        }
        if (typeof obj == "function") {
          var value2 = obj[attr];
          if (value2 !== void 0) {
            if (attr == "__module__") {
              return value2;
            }
          }
        }
        if (!is_class && klass.$native) {
          if (obj.$method_cache && obj.$method_cache[attr]) {
            return obj.$method_cache[attr];
          }
          if ($test) {
            console.log("native class", klass, klass[attr]);
          }
          if (klass[attr] === void 0) {
            var parent_attr;
            for (var parent_class of klass.__mro__) {
              if (parent_class[attr] !== void 0) {
                parent_attr = parent_class[attr];
                break;
              }
            }
            if ($test) {
              console.log("parent class attr", parent_attr);
            }
            if (parent_attr !== void 0) {
              klass[attr] = parent_attr;
            } else {
              if ($test) {
                console.log("obj[attr]", obj[attr]);
              }
              var attrs = obj.__dict__;
              if (attrs && _b_2.dict.$contains_string(attrs, attr)) {
                return _b_2.dict.$getitem_string(attrs, attr);
              }
              if (_default === void 0) {
                throw $B2.attr_error(attr, obj);
              }
              return _default;
            }
          } else if (["__name__", "__qualname__"].includes(attr)) {
            attr_error(attr, obj);
          }
          if (klass.$descriptors && klass.$descriptors[attr] !== void 0) {
            return klass[attr](obj);
          }
          if (typeof klass[attr] == "function") {
            var func = klass[attr];
            if (attr == "__new__") {
              func.$type = "staticmethod";
            }
            if (func.$type == "staticmethod") {
              return func;
            }
            var self2 = klass[attr].__class__ == $B2.method ? klass : obj, method = klass[attr].bind(null, self2);
            method.__class__ = $B2.method;
            method.$infos = { __func__: func, __name__: attr, __self__: self2, __qualname__: klass.__qualname__ + "." + attr };
            if (typeof obj == "object") {
              obj.__class__ = klass;
              obj.$method_cache = obj.$method_cache || {};
              if (obj.$method_cache) {
                obj.$method_cache[attr] = method;
              }
            }
            return method;
          } else if (klass[attr].__class__ === _b_2.classmethod) {
            return _b_2.classmethod.__get__(klass[attr], obj, klass);
          } else if (klass[attr] !== void 0) {
            return klass[attr];
          }
          attr_error(rawname, klass);
        }
        var attr_func;
        if (is_class) {
          if ($test) {
            console.log("obj is class", obj);
            console.log("is a type ?", _b_2.isinstance(klass, _b_2.type));
            console.log("is type", klass === _b_2.type);
          }
          if (klass === _b_2.type) {
            attr_func = _b_2.type.__getattribute__;
          } else {
            attr_func = $B2.$call($B2.$getattr(klass, "__getattribute__"));
          }
          if ($test) {
            console.log("attr func", attr_func);
          }
        } else {
          attr_func = klass.__getattribute__;
          if (attr_func === void 0) {
            for (var cls of klass.__mro__) {
              attr_func = cls["__getattribute__"];
              if (attr_func !== void 0) {
                break;
              }
            }
          }
          if ($test) {
            console.log("attr func", attr_func);
          }
        }
        if (typeof attr_func !== "function") {
          console.log(attr + " is not a function " + attr_func, klass);
        }
        var odga = _b_2.object.__getattribute__;
        if ($test) {
          console.log("attr_func is odga ?", attr_func, attr_func === odga, "\n", "\nobj[attr]", obj[attr]);
        }
        if (attr_func === odga) {
          res = obj[attr];
          if (Array.isArray(obj) && Array.prototype[attr] !== void 0) {
            res = void 0;
          } else if (res === null) {
            return null;
          } else if (res !== void 0) {
            if ($test) {
              console.log(obj, attr, obj[attr], res.__set__ || res.$is_class);
            }
            if (res.$is_property) {
              return _b_2.property.__get__(res);
            }
            if (res.__set__ === void 0 || res.$is_class) {
              if ($test) {
                console.log("return", res, res + "", res.__set__, res.$is_class);
              }
              return res;
            }
          }
        }
        var getattr;
        try {
          res = attr_func(obj, attr);
          if ($test) {
            console.log("result of attr_func", res);
          }
        } catch (err) {
          if ($test) {
            console.log("attr_func raised error", err.__class__, err.args, err.name);
            console.log(err);
          }
          if (klass === $B2.module) {
            getattr = obj.__getattr__;
            if ($test) {
              console.log("use module getattr", getattr);
              console.log(getattr + "");
            }
            if (getattr) {
              try {
                return getattr(attr);
              } catch (err2) {
                if ($test) {
                  console.log("encore erreur", err2);
                }
                if (_default !== void 0) {
                  return _default;
                }
                throw err2;
              }
            }
          }
          getattr = $B2.search_in_mro(klass, "__getattr__");
          if ($test) {
            console.log("try getattr", getattr);
          }
          if (getattr) {
            if ($test) {
              console.log("try with getattr", getattr);
            }
            try {
              return getattr(obj, attr);
            } catch (err2) {
              if ($B2.is_exc(err2, [_b_2.AttributeError])) {
                if (_default !== void 0) {
                  return _default;
                }
              }
              throw err2;
            }
          }
          if (_default !== void 0) {
            return _default;
          }
          throw err;
        }
        if (res !== void 0) {
          return res;
        }
        if (_default !== void 0) {
          return _default;
        }
        attr_error(rawname, is_class ? obj : klass);
      };
      _b_2.globals = function() {
        check_nb_args_no_kw("globals", 0, arguments);
        var res = $B2.obj_dict($B2.frame_obj.frame[3]);
        res.$jsobj.__BRYTHON__ = $B2.jsobj2pyobj($B2);
        res.$is_namespace = true;
        return res;
      };
      _b_2.hasattr = function(obj, attr) {
        check_nb_args_no_kw("hasattr", 2, arguments);
        try {
          $B2.$getattr(obj, attr);
          return true;
        } catch (err) {
          return false;
        }
      };
      _b_2.hash = function(obj) {
        check_nb_args_no_kw("hash", 1, arguments);
        return $B2.$hash(obj);
      };
      $B2.$hash = function(obj) {
        if (obj.__hashvalue__ !== void 0) {
          return obj.__hashvalue__;
        }
        if (typeof obj === "boolean") {
          return obj ? 1 : 0;
        }
        if (obj.$is_class || obj.__class__ === _b_2.type || obj.__class__ === $B2.function) {
          return obj.__hashvalue__ = $B2.$py_next_hash--;
        }
        if (typeof obj == "string") {
          return _b_2.str.__hash__(obj);
        } else if (typeof obj == "number") {
          return obj;
        } else if (typeof obj == "boolean") {
          return obj ? 1 : 0;
        } else if (obj.__class__ === _b_2.float) {
          return _b_2.float.$hash_func(obj);
        }
        var klass = obj.__class__ || $B2.get_class(obj);
        if (klass === void 0) {
          throw _b_2.TypeError.$factory("unhashable type: '" + _b_2.str.$factory($B2.jsobj2pyobj(obj)) + "'");
        }
        var hash_method = _b_2.type.__getattribute__(klass, "__hash__", _b_2.None);
        if (hash_method === _b_2.None) {
          throw _b_2.TypeError.$factory("unhashable type: '" + $B2.class_name(obj) + "'");
        }
        function check_int(v) {
          if (!Number.isInteger(v) && !$B2.$isinstance(v, _b_2.int)) {
            throw _b_2.TypeError.$factory(
              "__hash__ method should return an integer"
            );
          }
          return v;
        }
        var res;
        if (hash_method === _b_2.object.__hash__) {
          if (_b_2.type.__getattribute__(klass, "__eq__") !== _b_2.object.__eq__) {
            throw _b_2.TypeError.$factory("unhashable type: '" + $B2.class_name(obj) + "'", "hash");
          } else {
            return obj.__hashvalue__ = check_int(_b_2.object.__hash__(obj));
          }
        } else {
          return check_int($B2.$call(hash_method)(obj));
        }
      };
      var help = _b_2.help = function(obj) {
        if (obj === void 0) {
          obj = "help";
        }
        if (typeof obj == "string") {
          var lib_url = "https://docs.python.org/3/library";
          var parts = obj.split("."), head = [], url;
          while (parts.length > 0) {
            head.push(parts.shift());
            if ($B2.stdlib[head.join(".")]) {
              url = head.join(".");
            } else {
              break;
            }
          }
          if (url) {
            var doc_url;
            if (["browser", "javascript", "interpreter"].indexOf(obj.split(".")[0]) > -1) {
              doc_url = "/static_doc/" + ($B2.language == "fr" ? "fr" : "en");
            } else {
              doc_url = lib_url;
            }
            window.open(`${doc_url}/${url}.html#` + obj);
            return;
          }
          if (_b_2[obj]) {
            if (obj == obj.toLowerCase()) {
              url = lib_url + `/functions.html#${obj}`;
            } else if (["False", "True", "None", "NotImplemented", "Ellipsis", "__debug__"].indexOf(obj) > -1) {
              url = lib_url + `/constants.html#${obj}`;
            } else if (_b_2[obj].$is_class && _b_2[obj].__bases__.indexOf(_b_2.Exception) > -1) {
              url = lib_url + `/exceptions.html#${obj}`;
            }
            if (url) {
              window.open(url);
              return;
            }
          }
          $B2.$import("pydoc");
          return $B2.$call($B2.$getattr($B2.imported.pydoc, "help"))(obj);
        }
        if (obj.__class__ === $B2.module) {
          return help(obj.__name__);
        }
        try {
          _b_2.print($B2.$getattr(obj, "__doc__"));
        } catch (err) {
          return "";
        }
      };
      help.__repr__ = help.__str__ = function() {
        return "Type help() for interactive help, or help(object) for help about object.";
      };
      _b_2.hex = function(obj) {
        check_nb_args_no_kw("hex", 1, arguments);
        return bin_hex_oct(16, obj);
      };
      _b_2.id = function(obj) {
        check_nb_args_no_kw("id", 1, arguments);
        if (obj.$id !== void 0) {
          return obj.$id;
        } else if ($B2.$isinstance(obj, [_b_2.str, _b_2.int, _b_2.float]) && !$B2.$isinstance(obj, $B2.long_int)) {
          return $B2.$getattr(_b_2.str.$factory(obj), "__hash__")();
        } else {
          return obj.$id = $B2.UUID();
        }
      };
      _b_2.__import__ = function() {
        var $ = $B2.args("__import__", 5, { name: null, globals: null, locals: null, fromlist: null, level: null }, ["name", "globals", "locals", "fromlist", "level"], arguments, { globals: None, locals: None, fromlist: _b_2.tuple.$factory(), level: 0 }, null, null);
        return $B2.$__import__($.name, $.globals, $.locals, $.fromlist);
      };
      _b_2.input = function(msg) {
        var res = prompt(msg || "") || "";
        if ($B2.imported["sys"] && $B2.imported["sys"].ps1) {
          var ps1 = $B2.imported["sys"].ps1, ps2 = $B2.imported["sys"].ps2;
          if (msg == ps1 || msg == ps2) {
            console.log(msg, res);
          }
        }
        return res;
      };
      _b_2.isinstance = function(obj, cls) {
        check_nb_args_no_kw("isinstance", 2, arguments);
        return $B2.$isinstance(obj, cls);
      };
      $B2.$isinstance = function(obj, cls) {
        if (obj === null) {
          return cls === $B2.imported.javascript.NullType;
        }
        if (obj === void 0) {
          return false;
        }
        var kls;
        if (Array.isArray(cls)) {
          for (kls of cls) {
            if ($B2.$isinstance(obj, kls)) {
              return true;
            }
          }
          return false;
        }
        if (cls.__class__ === $B2.UnionType) {
          for (kls of cls.items) {
            if ($B2.$isinstance(obj, kls)) {
              return true;
            }
          }
          return false;
        }
        if (cls.__class__ === $B2.GenericAlias) {
          throw _b_2.TypeError.$factory(
            "isinstance() arg 2 cannot be a parameterized generic"
          );
        }
        if (!cls.__class__ && !cls.$is_class) {
          if (!$B2.$getattr(cls, "__instancecheck__", false)) {
            throw _b_2.TypeError.$factory("isinstance() arg 2 must be a type or tuple of types");
          }
        }
        if (cls === _b_2.int && (obj === True || obj === False)) {
          return true;
        }
        if (cls === _b_2.bool) {
          switch (typeof obj) {
            case "string":
              return false;
            case "number":
              return false;
            case "boolean":
              return true;
          }
        }
        var klass = obj.__class__;
        if (klass == void 0) {
          if (typeof obj == "string") {
            if (cls == _b_2.str) {
              return true;
            } else if ($B2.builtin_classes.includes(cls)) {
              return false;
            }
          } else if (typeof obj == "number" && Number.isFinite(obj)) {
            if (Number.isFinite(obj) && cls == _b_2.int) {
              return true;
            }
          }
          klass = $B2.get_class(obj);
        }
        if (klass === void 0) {
          return false;
        }
        if (klass === cls) {
          return true;
        }
        var mro = klass.__mro__;
        for (var i = 0; i < mro.length; i++) {
          if (mro[i] === cls) {
            return true;
          }
        }
        var instancecheck = $B2.$getattr(cls.__class__ || $B2.get_class(cls), "__instancecheck__", _b_2.None);
        if (cls.__name__ == "DemoComponent2169") {
          console.log("use instance check", obj, cls, instancecheck);
          console.log("class of obj", $B2.get_class(obj));
          console.log("same as cls ?", $B2.get_class(obj) === cls);
          console.log("result", instancecheck(cls, obj));
        }
        if (instancecheck !== _b_2.None) {
          return instancecheck(cls, obj);
        }
        return false;
      };
      var issubclass = _b_2.issubclass = function(klass, classinfo) {
        check_nb_args_no_kw("issubclass", 2, arguments);
        var mro;
        if (!klass.__class__ || !(klass.$factory !== void 0 || klass.$is_class !== void 0)) {
          var meta = $B2.$getattr(klass, "__class__", null);
          if (meta === null) {
            console.log("no class for", klass);
            throw _b_2.TypeError.$factory("issubclass() arg 1 must be a class");
          } else {
            mro = [_b_2.object];
          }
        } else {
          mro = klass.__mro__;
        }
        if ($B2.$isinstance(classinfo, _b_2.tuple)) {
          for (var i = 0; i < classinfo.length; i++) {
            if (issubclass(klass, classinfo[i])) {
              return true;
            }
          }
          return false;
        }
        if (classinfo.__class__ === $B2.GenericAlias) {
          throw _b_2.TypeError.$factory(
            "issubclass() arg 2 cannot be a parameterized generic"
          );
        }
        if (klass === classinfo || mro.indexOf(classinfo) > -1) {
          return true;
        }
        var sch = $B2.$getattr(classinfo.__class__ || $B2.get_class(classinfo), "__subclasscheck__", _b_2.None);
        if (sch == _b_2.None) {
          return false;
        }
        return sch(classinfo, klass);
      };
      var iterator_class = $B2.make_class(
        "iterator",
        function(getitem) {
          return {
            __class__: iterator_class,
            getitem,
            counter: -1
          };
        }
      );
      iterator_class.__next__ = function(self2) {
        self2.counter++;
        try {
          return self2.getitem(self2.counter);
        } catch (err) {
          throw _b_2.StopIteration.$factory("");
        }
      };
      $B2.set_func_names(iterator_class, "builtins");
      const callable_iterator = $B2.make_class(
        "callable_iterator",
        function(func, sentinel) {
          return {
            __class__: callable_iterator,
            func,
            sentinel
          };
        }
      );
      callable_iterator.__iter__ = function(self2) {
        return self2;
      };
      callable_iterator.__next__ = function(self2) {
        var res = self2.func();
        if ($B2.rich_comp("__eq__", res, self2.sentinel)) {
          throw _b_2.StopIteration.$factory();
        }
        return res;
      };
      $B2.set_func_names(callable_iterator, "builtins");
      $B2.$iter = function(obj, sentinel) {
        if (sentinel === void 0) {
          var klass = obj.__class__ || $B2.get_class(obj);
          try {
            var _iter = $B2.$call($B2.$getattr(klass, "__iter__"));
          } catch (err) {
            if (err.__class__ === _b_2.AttributeError) {
              try {
                var gi_method = $B2.$call($B2.$getattr(klass, "__getitem__")), gi = function(i) {
                  return gi_method(obj, i);
                }, len2;
                return iterator_class.$factory(gi);
              } catch (err2) {
                throw _b_2.TypeError.$factory("'" + $B2.class_name(obj) + "' object is not iterable");
              }
            }
            throw err;
          }
          var res = $B2.$call(_iter)(obj);
          try {
            $B2.$getattr(res, "__next__");
          } catch (err) {
            if ($B2.$isinstance(err, _b_2.AttributeError)) {
              throw _b_2.TypeError.$factory(
                "iter() returned non-iterator of type '" + $B2.class_name(res) + "'"
              );
            }
          }
          return res;
        } else {
          return callable_iterator.$factory(obj, sentinel);
        }
      };
      var iter = _b_2.iter = function() {
        var $ = $B2.args("iter", 1, { obj: null }, ["obj"], arguments, {}, "args", "kw"), sentinel;
        if ($.args.length > 0) {
          sentinel = $.args[0];
        }
        return $B2.$iter($.obj, sentinel);
      };
      var len = _b_2.len = function(obj) {
        check_nb_args_no_kw("len", 1, arguments);
        var klass = obj.__class__ || $B2.get_class(obj);
        try {
          var method = $B2.$getattr(klass, "__len__");
        } catch (err) {
          throw _b_2.TypeError.$factory("object of type '" + $B2.class_name(obj) + "' has no len()");
        }
        let res = $B2.$call(method)(obj);
        if (!$B2.$isinstance(res, _b_2.int)) {
          throw _b_2.TypeError.$factory(`'${$B2.class_name(res)}' object cannot be interpreted as an integer`);
        }
        if (!$B2.rich_comp("__ge__", res, 0)) {
          throw _b_2.ValueError.$factory("ValueError: __len__() should return >= 0");
        }
        return res;
      };
      _b_2.locals = function() {
        check_nb_args("locals", 0, arguments);
        var locals_obj = $B2.frame_obj.frame[1];
        var class_locals = locals_obj.$target;
        if (class_locals) {
          return class_locals;
        }
        var res = $B2.obj_dict(
          $B2.clone(locals_obj),
          function(key3) {
            return key3.startsWith("$");
          }
        );
        res.$is_namespace = true;
        return res;
      };
      var map = _b_2.map = $B2.make_class(
        "map",
        function() {
          var $ = $B2.args("map", 2, { func: null, it1: null }, ["func", "it1"], arguments, {}, "args", null), func = $B2.$call($.func);
          var iter_args = [$B2.make_js_iterator($.it1)];
          for (var arg of $.args) {
            iter_args.push($B2.make_js_iterator(arg));
          }
          return {
            __class__: map,
            args: iter_args,
            func
          };
        }
      );
      map.__iter__ = function(self2) {
        return self2;
      };
      map.__next__ = function(self2) {
        var args = [];
        for (var iter2 of self2.args) {
          var arg = iter2.next();
          if (arg.done) {
            throw _b_2.StopIteration.$factory("");
          }
          args.push(arg.value);
        }
        return self2.func.apply(null, args);
      };
      $B2.set_func_names(map, "builtins");
      function $extreme(args, op) {
        var $op_name = "min";
        if (op === "__gt__") {
          $op_name = "max";
        }
        var $ = $B2.args($op_name, 0, {}, [], args, {}, "args", "kw");
        var has_default = false, func = false;
        for (var item2 of _b_2.dict.$iter_items($.kw)) {
          switch (item2.key) {
            case "key":
              func = item2.value;
              func = func === _b_2.None ? func : $B2.$call(func);
              break;
            case "default":
              var default_value = item2.value;
              has_default = true;
              break;
            default:
              throw _b_2.TypeError.$factory("'" + item2.key + "' is an invalid keyword argument for this function");
          }
        }
        if (!func || func === _b_2.None) {
          func = (x2) => x2;
        }
        if ($.args.length == 0) {
          throw _b_2.TypeError.$factory($op_name + " expected 1 arguments, got 0");
        } else if ($.args.length == 1) {
          var $iter = $B2.make_js_iterator($.args[0]), res = null, x_value, extr_value;
          for (var x of $iter) {
            if (res === null) {
              extr_value = func(x);
              res = x;
            } else {
              x_value = func(x);
              if ($B2.rich_comp(op, x_value, extr_value)) {
                res = x;
                extr_value = x_value;
              }
            }
          }
          if (res === null) {
            if (has_default) {
              return default_value;
            } else {
              throw _b_2.ValueError.$factory($op_name + "() arg is an empty sequence");
            }
          } else {
            return res;
          }
        } else {
          if (has_default) {
            throw _b_2.TypeError.$factory("Cannot specify a default for " + $op_name + "() with multiple positional arguments");
          }
          var _args;
          if ($B2.last(args).$kw) {
            _args = [$.args].concat($B2.last(args));
          } else {
            _args = [$.args];
          }
          return $extreme.call(null, _args, op);
        }
      }
      _b_2.max = function() {
        return $extreme(arguments, "__gt__");
      };
      var memoryview = _b_2.memoryview = $B2.make_class(
        "memoryview",
        function(obj) {
          check_nb_args_no_kw("memoryview", 1, arguments);
          if (obj.__class__ === memoryview) {
            return obj;
          }
          if ($B2.get_class(obj).$buffer_protocol) {
            return {
              __class__: memoryview,
              obj,
              format: "B",
              itemsize: 1,
              ndim: 1,
              shape: _b_2.tuple.$factory([_b_2.len(obj)]),
              strides: _b_2.tuple.$factory([1]),
              suboffsets: _b_2.tuple.$factory([]),
              c_contiguous: true,
              f_contiguous: true,
              contiguous: true
            };
          } else {
            throw _b_2.TypeError.$factory("memoryview: a bytes-like object is required, not '" + $B2.class_name(obj) + "'");
          }
        }
      );
      memoryview.$match_sequence_pattern = true, memoryview.$buffer_protocol = true;
      memoryview.$not_basetype = true;
      memoryview.$is_sequence = true;
      memoryview.__eq__ = function(self2, other) {
        if (other.__class__ !== memoryview) {
          return false;
        }
        return $B2.$getattr(self2.obj, "__eq__")(other.obj);
      };
      memoryview.__getitem__ = function(self2, key3) {
        var res;
        if ($B2.$isinstance(key3, _b_2.int)) {
          var start = key3 * self2.itemsize;
          if (self2.format == "I") {
            res = self2.obj.source[start];
            var coef = 256;
            for (var i = 1; i < 4; i++) {
              res += self2.obj.source[start + i] * coef;
              coef *= 256;
            }
            return res;
          } else if ("B".indexOf(self2.format) > -1) {
            if (key3 > self2.obj.source.length - 1) {
              throw _b_2.KeyError.$factory(key3);
            }
            return self2.obj.source[key3];
          } else {
            return self2.obj.source[key3];
          }
        }
        res = self2.obj.__class__.__getitem__(self2.obj, key3);
        if (key3.__class__ === _b_2.slice) {
          return memoryview.$factory(res);
        }
      };
      memoryview.__len__ = function(self2) {
        return len(self2.obj) / self2.itemsize;
      };
      memoryview.__setitem__ = function(self2, key3, value2) {
        try {
          $B2.$setitem(self2.obj, key3, value2);
        } catch (err) {
          throw _b_2.TypeError.$factory("cannot modify read-only memory");
        }
      };
      var struct_format = { "x": { "size": 1 }, "b": { "size": 1 }, "B": { "size": 1 }, "c": { "size": 1 }, "s": { "size": 1 }, "p": { "size": 1 }, "h": { "size": 2 }, "H": { "size": 2 }, "i": { "size": 4 }, "I": { "size": 4 }, "l": { "size": 4 }, "L": { "size": 4 }, "q": { "size": 8 }, "Q": { "size": 8 }, "f": { "size": 4 }, "d": { "size": 8 }, "P": { "size": 8 } };
      memoryview.cast = function(self2, format, shape) {
        if (!struct_format.hasOwnProperty(format)) {
          throw _b_2.ValueError.$factory(`unknown format: '${format}'`);
        }
        var new_itemsize = struct_format[format].size;
        if (shape === void 0) {
          shape = _b_2.len(self2);
        } else {
          if (!$B2.$isinstance(shape, [_b_2.list, _b_2.tuple])) {
            throw _b_2.TypeError.$factory("shape must be a list or a tuple");
          }
          var nb = 1;
          for (var item2 of shape) {
            if (!$B2.$isinstance(item2, _b_2.int)) {
              throw _b_2.TypeError.$factory(
                "memoryview.cast(): elements of shape must be integers"
              );
            }
            nb *= item2;
          }
          if (nb * new_itemsize != _b_2.len(self2)) {
            throw _b_2.TypeError.$factory(
              "memoryview: product(shape) * itemsize != buffer size"
            );
          }
        }
        switch (format) {
          case "B":
            return memoryview.$factory(self2.obj);
          case "I":
            var res = memoryview.$factory(self2.obj), objlen = len(self2.obj);
            res.itemsize = 4;
            res.format = "I";
            if (objlen % 4 != 0) {
              throw _b_2.TypeError.$factory("memoryview: length is not a multiple of itemsize");
            }
            return res;
        }
      };
      memoryview.hex = function(self2) {
        var res = "", bytes = _b_2.bytes.$factory(self2);
        bytes.source.forEach(function(item2) {
          res += item2.toString(16);
        });
        return res;
      };
      memoryview.tobytes = function(self2) {
        return {
          __class__: _b_2.bytes,
          source: self2.obj.source
        };
      };
      memoryview.tolist = function(self2) {
        if (self2.itemsize == 1) {
          return _b_2.list.$factory(_b_2.bytes.$factory(self2.obj));
        } else if (self2.itemsize == 4) {
          if (self2.format == "I") {
            var res = [];
            for (var i = 0; i < self2.obj.source.length; i += 4) {
              var item2 = self2.obj.source[i], coef = 256;
              for (var j2 = 1; j2 < 4; j2++) {
                item2 += coef * self2.obj.source[i + j2];
                coef *= 256;
              }
              res.push(item2);
            }
            return res;
          }
        }
      };
      $B2.set_func_names(memoryview, "builtins");
      _b_2.min = function() {
        return $extreme(arguments, "__lt__");
      };
      var next = _b_2.next = function(obj) {
        check_no_kw("next", obj);
        var missing = {}, $ = $B2.args("next", 2, { obj: null, def: null }, ["obj", "def"], arguments, { def: missing }, null, null);
        var klass = obj.__class__ || $B2.get_class(obj), ga = $B2.$call($B2.$getattr(klass, "__next__"));
        if (ga !== void 0) {
          try {
            return $B2.$call(ga)(obj);
          } catch (err) {
            if (err.__class__ === _b_2.StopIteration && $.def !== missing) {
              return $.def;
            }
            throw err;
          }
        }
        throw _b_2.TypeError.$factory("'" + $B2.class_name(obj) + "' object is not an iterator");
      };
      var NotImplementedType = $B2.NotImplementedType = $B2.make_class(
        "NotImplementedType",
        function() {
          return NotImplemented;
        }
      );
      NotImplementedType.__repr__ = NotImplementedType.__str__ = function() {
        return "NotImplemented";
      };
      $B2.set_func_names(NotImplementedType, "builtins");
      var NotImplemented = _b_2.NotImplemented = { __class__: NotImplementedType };
      _b_2.oct = function(obj) {
        check_nb_args_no_kw("oct", 1, arguments);
        return bin_hex_oct(8, obj);
      };
      _b_2.ord = function(c) {
        check_nb_args_no_kw("ord", 1, arguments);
        if (typeof c.valueOf() == "string") {
          if (c.length == 1) {
            return c.charCodeAt(0);
          } else if (c.length == 2) {
            var code2 = c.codePointAt(0);
            if (code2 >= 65536 && code2 <= 1114111) {
              return code2;
            }
          }
          throw _b_2.TypeError.$factory("ord() expected a character, but string of length " + c.length + " found");
        }
        switch ($B2.get_class(c)) {
          case _b_2.str:
            if (c.length == 1) {
              return c.charCodeAt(0);
            }
            throw _b_2.TypeError.$factory("ord() expected a character, but string of length " + c.length + " found");
          case _b_2.bytes:
          case _b_2.bytearray:
            if (c.source.length == 1) {
              return c.source[0];
            }
            throw _b_2.TypeError.$factory("ord() expected a character, but string of length " + c.source.length + " found");
          default:
            throw _b_2.TypeError.$factory("ord() expected a character, but " + $B2.class_name(c) + " was found");
        }
      };
      var complex_modulo = () => _b_2.ValueError.$factory("complex modulo");
      var all_ints = () => _b_2.TypeError.$factory("pow() 3rd argument not allowed unless all arguments are integers");
      _b_2.pow = function() {
        var $ = $B2.args("pow", 3, { x: null, y: null, mod: null }, ["x", "y", "mod"], arguments, { mod: None }, null, null), x = $.x, y = $.y, z = $.mod;
        if (z === _b_2.None) {
          return $B2.rich_op("__pow__", x, y);
        } else {
          if ($B2.$isinstance(x, _b_2.int)) {
            if ($B2.$isinstance(y, _b_2.float)) {
              throw all_ints();
            } else if ($B2.$isinstance(y, _b_2.complex)) {
              throw complex_modulo();
            } else if ($B2.$isinstance(y, _b_2.int)) {
              if ($B2.$isinstance(z, _b_2.complex)) {
                throw complex_modulo();
              } else if (!$B2.$isinstance(z, _b_2.int)) {
                throw all_ints();
              }
            }
            return _b_2.int.__pow__(x, y, z);
          } else if ($B2.$isinstance(x, _b_2.float)) {
            throw all_ints();
          } else if ($B2.$isinstance(x, _b_2.complex)) {
            throw complex_modulo();
          }
        }
      };
      var $print = _b_2.print = function() {
        var $ns = $B2.args("print", 0, {}, [], arguments, {}, "args", "kw");
        var kw = $ns["kw"], end = _b_2.dict.get(kw, "end", "\n"), sep = _b_2.dict.get(kw, "sep", " "), file = _b_2.dict.get(kw, "file", $B2.get_stdout());
        var args = $ns["args"], writer = $B2.$getattr(file, "write");
        for (var i = 0, len2 = args.length; i < len2; i++) {
          var arg = _b_2.str.$factory(args[i]);
          writer(arg);
          if (i < len2 - 1) {
            writer(sep);
          }
        }
        writer(end);
        var flush = $B2.$getattr(file, "flush", None);
        if (flush !== None) {
          $B2.$call(flush)();
        }
        return None;
      };
      $print.__name__ = "print";
      $print.is_func = true;
      var quit = _b_2.quit = function() {
        throw _b_2.SystemExit;
      };
      quit.__repr__ = quit.__str__ = function() {
        return "Use quit() or Ctrl-Z plus Return to exit";
      };
      var repr = _b_2.repr = function(obj) {
        check_nb_args_no_kw("repr", 1, arguments);
        var klass = $B2.get_class(obj);
        return $B2.$call($B2.$getattr(klass, "__repr__"))(obj);
      };
      var reversed = _b_2.reversed = $B2.make_class(
        "reversed",
        function(seq) {
          check_nb_args_no_kw("reversed", 1, arguments);
          var klass = seq.__class__ || $B2.get_class(seq), rev_method = $B2.$getattr(klass, "__reversed__", null);
          if (rev_method !== null) {
            return $B2.$call(rev_method)(seq);
          }
          try {
            var method = $B2.$getattr(klass, "__getitem__");
          } catch (err) {
            throw _b_2.TypeError.$factory("argument to reversed() must be a sequence");
          }
          var res = { __class__: reversed, $counter: _b_2.len(seq), getter: function(i) {
            return $B2.$call(method)(seq, i);
          } };
          return res;
        }
      );
      reversed.__iter__ = function(self2) {
        return self2;
      };
      reversed.__next__ = function(self2) {
        self2.$counter--;
        if (self2.$counter < 0) {
          throw _b_2.StopIteration.$factory("");
        }
        return self2.getter(self2.$counter);
      };
      $B2.set_func_names(reversed, "builtins");
      _b_2.round = function() {
        var $ = $B2.args("round", 2, { number: null, ndigits: null }, ["number", "ndigits"], arguments, { ndigits: None }, null, null), arg = $.number, n = $.ndigits === None ? 0 : $.ndigits;
        var klass;
        if (!$B2.$isinstance(arg, [_b_2.int, _b_2.float])) {
          klass = arg.__class__ || $B2.get_class(arg);
          try {
            return $B2.$call($B2.$getattr(klass, "__round__")).apply(null, arguments);
          } catch (err) {
            if (err.__class__ === _b_2.AttributeError) {
              throw _b_2.TypeError.$factory("type " + $B2.class_name(arg) + " doesn't define __round__ method");
            } else {
              throw err;
            }
          }
        }
        if (!$B2.$isinstance(n, _b_2.int)) {
          throw _b_2.TypeError.$factory("'" + $B2.class_name(n) + "' object cannot be interpreted as an integer");
        }
        klass = $B2.get_class(arg);
        if ($B2.$isinstance(arg, _b_2.float)) {
          return _b_2.float.__round__(arg, $.ndigits);
        }
        var mult = Math.pow(10, n), x = arg * mult, floor = Math.floor(x), diff = Math.abs(x - floor), res;
        if (diff == 0.5) {
          if (floor % 2) {
            floor += 1;
          }
          res = _b_2.int.__truediv__(floor, mult);
        } else {
          res = _b_2.int.__truediv__(Math.round(x), mult);
        }
        if (res.value === Infinity || res.value === -Infinity) {
          throw _b_2.OverflowError.$factory(
            "rounded value too large to represent"
          );
        }
        if ($.ndigits === None) {
          return Math.floor(res.value);
        } else {
          return $B2.$call(klass)(res);
        }
      };
      _b_2.setattr = function() {
        var $ = $B2.args("setattr", 3, { obj: null, attr: null, value: null }, ["obj", "attr", "value"], arguments, {}, null, null), obj = $.obj, attr = $.attr, value2 = $.value;
        if (!(typeof attr == "string")) {
          throw _b_2.TypeError.$factory("setattr(): attribute name must be string");
        }
        return $B2.$setattr(obj, attr, value2);
      };
      $B2.$setattr1 = function(obj, attr, value2, inum) {
        try {
          $B2.$setattr(obj, attr, value2);
        } catch (err) {
          $B2.set_inum(inum);
          throw err;
        }
      };
      $B2.$setattr = function(obj, attr, value2) {
        if (obj === void 0) {
          console.log("obj undef", attr, value2);
        }
        var $test = false;
        switch (attr) {
          case "__dict__":
            if (!$B2.$isinstance(value2, _b_2.dict)) {
              throw _b_2.TypeError.$factory("__dict__ must be set to a dictionary, not a '" + $B2.class_name(value2) + "'");
            }
            if (obj.$function_infos && !obj.$infos) {
              $B2.make_function_infos(obj, ...obj.$function_infos);
            }
            if (obj.$infos) {
              obj.$infos.__dict__ = value2;
              return None;
            }
            obj.__dict__ = value2;
            return None;
          case "__class__":
            let error2 = function(msg) {
              throw _b_2.TypeError.$factory(msg);
            };
            var error = error2;
            if (value2.__class__) {
              if (value2.__module__ == "builtins") {
                error2("__class__ assignement only supported for heap types or ModuleType subclasses");
              } else if (Array.isArray(value2.__bases__)) {
                for (var i = 0; i < value2.__bases__.length; i++) {
                  if (value2.__bases__[i] !== _b_2.object && value2.__bases__[i].__module__ == "builtins") {
                    error2("__class__ assignment: '" + $B2.class_name(obj) + "' object layout differs from '" + $B2.class_name(value2) + "'");
                  }
                }
              }
            }
            obj.__class__ = value2;
            return None;
          case "__doc__":
            if (obj.__class__ === _b_2.property) {
              obj[attr] = value2;
            }
            break;
        }
        if ($test) {
          console.log("set attr", attr, "of", obj, "to", value2);
        }
        if (obj.$factory || obj.$is_class) {
          var metaclass = obj.__class__;
          if (metaclass === _b_2.type) {
            return _b_2.type.__setattr__(obj, attr, value2);
          }
          return $B2.$call($B2.$getattr(metaclass, "__setattr__"))(obj, attr, value2);
        }
        var res = obj[attr], klass = obj.__class__ || $B2.get_class(obj);
        if ($test) {
          console.log("set attr", attr, "of obj", obj, "class", klass, "obj[attr]", obj[attr]);
        }
        if (res === void 0 && klass) {
          res = $B2.search_in_mro(klass, attr);
        }
        if ($test) {
          console.log("set attr", attr, "klass", klass, "found in class", res);
        }
        if (res !== void 0 && res !== null) {
          if (res.__set__ !== void 0) {
            res.__set__(res, obj, value2);
            return None;
          }
          var rcls = res.__class__, __set1__;
          if (rcls !== void 0) {
            __set1__ = $B2.search_in_mro(rcls, "__set__");
          }
          if (__set1__ !== void 0) {
            var __set__ = $B2.$getattr(res, "__set__", null);
            if (__set__ && typeof __set__ == "function") {
              __set__.apply(res, [obj, value2]);
              return None;
            }
          } else if (klass && klass.$descriptors !== void 0 && klass[attr] !== void 0) {
            var setter = klass[attr].setter;
            if (typeof setter == "function") {
              setter(obj, value2);
              return None;
            } else {
              throw _b_2.AttributeError.$factory("readonly attribute");
            }
          }
        }
        klass.$tp_setattr = klass.$tp_setattr ?? $B2.search_in_mro(klass, "__setattr__");
        var _setattr = klass.$tp_setattr;
        if (_setattr === _b_2.object.__setattr__) {
          _setattr = false;
        }
        var special_attrs = ["__module__"];
        if (klass && klass.__slots__ && special_attrs.indexOf(attr) == -1 && !_setattr) {
          var _slots = true;
          for (var kl of klass.__mro__) {
            if (kl === _b_2.object || kl === _b_2.type) {
              break;
            }
            if (!kl.__slots__) {
              _slots = false;
              break;
            }
          }
          if (_slots) {
            let mangled_slots2 = function(klass2) {
              if (klass2.__slots__) {
                if (Array.isArray(klass2.__slots__)) {
                  return klass2.__slots__.map(function(item2) {
                    if (item2.startsWith("__") && !item2.endsWith("_")) {
                      return "_" + klass2.__name__ + item2;
                    } else {
                      return item2;
                    }
                  });
                } else {
                  return klass2.__slots__;
                }
              }
              return [];
            };
            var mangled_slots = mangled_slots2;
            var has_slot = false;
            if ($B2.$is_member(attr, mangled_slots2(klass))) {
              has_slot = true;
            } else {
              for (var cls of klass.__mro__) {
                if (mangled_slots2(cls).indexOf(attr) > -1) {
                  has_slot = true;
                  break;
                }
              }
            }
            if (!has_slot) {
              throw $B2.attr_error(attr, klass);
            }
          }
        }
        if ($test) {
          console.log("attr", attr, "use _setattr", _setattr);
        }
        if (!_setattr) {
          if (obj[attr] !== void 0) {
            obj[attr] = value2;
          } else if (obj.__dict__ === void 0) {
            throw _b_2.AttributeError.$factory(`'${$B2.class_name(obj)}' object has no attribute '${attr}' and no __dict__ for setting new attributes`);
          } else {
            _b_2.dict.$setitem(obj.__dict__, attr, value2);
            if (obj.$method_cache && obj.$method_cache[attr]) {
              delete obj.$method_cache[attr];
            }
          }
          if ($test) {
            console.log("no setattr, obj", obj);
          }
        } else {
          if ($test) {
            console.log("apply _setattr", obj, attr);
          }
          if (typeof _setattr !== "function") {
            console.log("not a function", _setattr);
            console.log("attr", attr, "of", obj);
          }
          _setattr(obj, attr, value2);
        }
        return None;
      };
      _b_2.sorted = function() {
        var $ = $B2.args("sorted", 1, { iterable: null }, ["iterable"], arguments, {}, null, "kw");
        var _list = _b_2.list.$factory($.iterable), args = [_list].concat(Array.from(arguments).slice(1));
        _b_2.list.sort.apply(null, args);
        return _list;
      };
      _b_2.sum = function() {
        var $ = $B2.args("sum", 2, { iterable: null, start: null }, ["iterable", "start"], arguments, { start: 0 }, null, null), iterable = $.iterable, start = $.start;
        if ($B2.$isinstance(start, [_b_2.str, _b_2.bytes])) {
          throw _b_2.TypeError.$factory("sum() can't sum bytes [use b''.join(seq) instead]");
        }
        var res = start;
        iterable = iter(iterable);
        while (true) {
          try {
            var _item = next(iterable);
            res = $B2.rich_op("__add__", res, _item);
          } catch (err) {
            if (err.__class__ === _b_2.StopIteration) {
              break;
            } else {
              throw err;
            }
          }
        }
        return res;
      };
      var $$super = _b_2.super = $B2.make_class(
        "super",
        function(_type, object_or_type) {
          var no_object_or_type = object_or_type === void 0;
          if (_type === void 0 && object_or_type === void 0) {
            var frame = $B2.frame_obj.frame, pyframe = $B2.imported["_sys"]._getframe(), code2 = $B2.frame.f_code.__get__(pyframe), co_varnames = code2.co_varnames;
            if (co_varnames.length > 0) {
              _type = frame[1].__class__;
              if (_type === void 0) {
                throw _b_2.RuntimeError.$factory("super(): no arguments");
              }
              object_or_type = frame[1][code2.co_varnames[0]];
            } else {
              throw _b_2.RuntimeError.$factory("super(): no arguments");
            }
          }
          if (!no_object_or_type && Array.isArray(object_or_type)) {
            object_or_type = object_or_type[0];
          }
          var $arg2;
          if (object_or_type !== void 0) {
            if (object_or_type === _type || object_or_type.$is_class && _b_2.issubclass(object_or_type, _type)) {
              $arg2 = "type";
            } else if ($B2.$isinstance(object_or_type, _type)) {
              $arg2 = "object";
            } else {
              throw _b_2.TypeError.$factory(
                "super(type, obj): obj must be an instance or subtype of type"
              );
            }
          }
          return {
            __class__: $$super,
            __thisclass__: _type,
            __self_class__: object_or_type,
            $arg2
          };
        }
      );
      $$super.__get__ = function(self2, instance) {
        return $$super.$factory(self2.__thisclass__, instance);
      };
      $$super.__getattribute__ = function(self2, attr) {
        if (self2.__thisclass__.$is_js_class) {
          if (attr == "__init__") {
            return function() {
              mro[0].$js_func.call(self2.__self_class__, ...arguments);
            };
          }
        }
        var object_or_type = self2.__self_class__, mro = self2.$arg2 == "type" ? object_or_type.__mro__ : $B2.get_class(object_or_type).__mro__;
        var search_start = mro.indexOf(self2.__thisclass__) + 1, search_classes = mro.slice(search_start);
        var $test = false;
        if ($test) {
          console.log("super.__ga__, self", self2, "search classes", search_classes);
        }
        var f;
        for (var klass of search_classes) {
          if (klass === void 0) {
            console.log("klass undef in super", self2);
            console.log("mro", mro);
          }
          if (klass[attr] !== void 0) {
            f = klass[attr];
            break;
          }
        }
        if (f === void 0) {
          if ($$super[attr] !== void 0) {
            return /* @__PURE__ */ (function(x) {
              return function() {
                var args = [x];
                for (var i = 0, len2 = arguments.length; i < len2; i++) {
                  args.push(arguments[i]);
                }
                return $$super[attr].apply(null, args);
              };
            })(self2);
          }
          if ($test) {
            console.log("no attr", attr, self2, "mro", mro);
          }
          throw $B2.attr_error(attr, self2);
        }
        if ($test) {
          console.log("super", attr, self2, "mro", mro, "found in mro[0]", mro[0], f, f + "");
        }
        if (f.$type == "staticmethod" || attr == "__new__") {
          return f;
        } else if (f.__class__ === _b_2.classmethod) {
          return f.__func__.bind(null, object_or_type);
        } else if (f.$is_property) {
          return f.fget(object_or_type);
        } else if (typeof f != "function") {
          return f;
        } else {
          if (f.__class__ === $B2.method) {
            f = f.$infos.__func__;
          }
          var callable = $B2.$call(f);
          var method = function() {
            var res = callable(self2.__self_class__, ...arguments);
            if ($test) {
              console.log("calling super", self2.__self_class__, attr, f, "res", res);
            }
            return res;
          };
          method.__class__ = $B2.method;
          var module2;
          if (f.$infos !== void 0) {
            module2 = f.$infos.__module__;
          } else if (f.__class__ === _b_2.property) {
            module2 = f.fget.$infos.__module;
          } else if (f.$is_class) {
            module2 = f.__module__;
          }
          method.$infos = { __self__: self2.__self_class__, __func__: f, __name__: attr, __module__: module2, __qualname__: klass.__name__ + "." + attr };
          return method;
        }
      };
      $$super.__init__ = function(cls) {
        if (cls === void 0) {
          throw _b_2.TypeError.$factory("descriptor '__init__' of 'super' object needs an argument");
        }
        if (cls.__class__ !== $$super) {
          throw _b_2.TypeError.$factory("descriptor '__init__' requires a 'super' object but received a '" + $B2.class_name(cls) + "'");
        }
      };
      $$super.__repr__ = function(self2) {
        $B2.builtins_repr_check($$super, arguments);
        var res = "<super: <class '" + self2.__thisclass__.__name__ + "'>";
        if (self2.__self_class__ !== void 0) {
          res += ", <" + self2.__self_class__.__class__.__name__ + " object>";
        } else {
          res += ", NULL";
        }
        return res + ">";
      };
      $B2.set_func_names($$super, "builtins");
      _b_2.vars = function() {
        var def = {}, $ = $B2.args("vars", 1, { obj: null }, ["obj"], arguments, { obj: def }, null, null);
        if ($.obj === def) {
          return _b_2.locals();
        } else {
          try {
            return $B2.$getattr($.obj, "__dict__");
          } catch (err) {
            if (err.__class__ === _b_2.AttributeError) {
              throw _b_2.TypeError.$factory("vars() argument must have __dict__ attribute");
            }
            throw err;
          }
        }
      };
      var $Reader = $B2.make_class("Reader");
      $Reader.__bool__ = function() {
        return true;
      };
      $Reader.__enter__ = function(self2) {
        return self2;
      };
      $Reader.__exit__ = function(self2) {
        $Reader.close(self2);
      };
      $Reader.__init__ = function(_self, initial_value = "") {
        _self.$content = initial_value;
        _self.$counter = 0;
      };
      $Reader.__iter__ = function(self2) {
        self2.$lc = -1;
        delete self2.$lines;
        make_lines(self2);
        return self2;
      };
      $Reader.__len__ = function(self2) {
        return self2.lines.length;
      };
      $Reader.__next__ = function(self2) {
        self2.$lc++;
        if (self2.$lc >= self2.$lines.length) {
          throw _b_2.StopIteration.$factory();
        }
        return self2.$lines[self2.$lc];
      };
      $Reader.__new__ = function(cls) {
        return {
          __class__: cls
        };
      };
      $Reader.close = function(self2) {
        self2.closed = true;
      };
      $Reader.flush = function() {
        return None;
      };
      $Reader.read = function() {
        var $ = $B2.args("read", 2, { self: null, size: null }, ["self", "size"], arguments, { size: -1 }, null, null), self2 = $.self, size = $B2.PyNumber_Index($.size);
        if (self2.closed === true) {
          throw _b_2.ValueError.$factory("I/O operation on closed file");
        }
        var len2 = _b_2.len(self2.$content);
        if (size < 0) {
          size = len2 - self2.$counter;
        }
        var res;
        if (self2.$binary) {
          res = _b_2.bytes.$factory(self2.$content.source.slice(self2.$counter, self2.$counter + size));
        } else {
          res = self2.$content.substr(self2.$counter, size);
        }
        self2.$counter += size;
        return res;
      };
      $Reader.readable = function() {
        return true;
      };
      function make_lines(self2) {
        if (self2.$lines === void 0) {
          if (!self2.$binary) {
            self2.$lines = self2.$content.split("\n");
            if ($B2.last(self2.$lines) == "") {
              self2.$lines.pop();
            }
            self2.$lines = self2.$lines.map((x) => x + "\n");
          } else {
            var lines = [], pos2 = 0, source = self2.$content.source, len2 = source.length;
            while (pos2 < len2) {
              var ix = source.indexOf(10, pos2);
              if (ix == -1) {
                lines.push({ __class__: _b_2.bytes, source: source.slice(pos2) });
                break;
              } else {
                lines.push({ __class__: _b_2.bytes, source: source.slice(pos2, ix + 1) });
                pos2 = ix + 1;
              }
            }
            self2.$lines = lines;
          }
        }
      }
      $Reader.readline = function() {
        var $ = $B2.args("readline", 2, { self: null, size: null }, ["self", "size"], arguments, { size: -1 }, null, null), self2 = $.self, size = $.size, result, rest, ix;
        if (size === _b_2.None) {
          size = -1;
        } else if (!_b_2.isinstance(size, _b_2.int)) {
          throw _b_2.TypeError.$factory(`argument should be integer or None, not '${$B2.class_name(size)}'`);
        } else {
          size = _b_2.int.$int_value(size);
        }
        self2.$lc = self2.$lc === void 0 ? -1 : self2.$lc;
        if (self2.closed === true) {
          throw _b_2.ValueError.$factory("I/O operation on closed file");
        }
        if (self2.$binary) {
          ix = self2.$content.source.indexOf(10, self2.$counter);
          if (ix == -1) {
            rest = self2.$content.source.slice(self2.$counter);
            if (size > -1) {
              rest = rest.slice(0, size);
            }
            self2.$counter = self2.$content.source.length;
            return _b_2.bytes.$factory(rest);
          } else {
            var line_source = self2.$content.source.slice(self2.$counter, ix + 1);
            if (size > -1) {
              line_source = line_source.slice(0, size);
            }
            result = { __class__: _b_2.bytes, source: line_source };
            self2.$counter = ix + 1;
            return result;
          }
        } else {
          if (self2.$counter == self2.$content.length) {
            return "";
          }
          ix = self2.$content.indexOf("\n", self2.$counter);
          if (ix == -1) {
            rest = self2.$content.substr(self2.$counter);
            if (size > -1) {
              rest = rest.substr(0, size);
            }
            self2.$counter = self2.$content.length;
            return rest;
          } else {
            result = self2.$content.substring(self2.$counter, ix + 1);
            if (size > -1) {
              result = result.substr(0, size);
            }
            self2.$counter = ix + 1;
            self2.$lc += 1;
            return result;
          }
        }
      };
      $Reader.readlines = function() {
        var $ = $B2.args("readlines", 2, { self: null, hint: null }, ["self", "hint"], arguments, { hint: -1 }, null, null), self2 = $.self, hint = $B2.PyNumber_Index($.hint);
        var nb_read = 0;
        if (self2.closed === true) {
          throw _b_2.ValueError.$factory("I/O operation on closed file");
        }
        self2.$lc = self2.$lc === void 0 ? -1 : self2.$lc;
        make_lines(self2);
        var lines;
        if (hint < 0) {
          lines = self2.$lines.slice(self2.$lc + 1);
        } else {
          lines = [];
          while (self2.$lc < self2.$lines.length && nb_read < hint) {
            self2.$lc++;
            lines.push(self2.$lines[self2.$lc]);
          }
        }
        return $B2.$list(lines);
      };
      $Reader.seek = function(self2, offset, whence) {
        if (self2.closed === True) {
          throw _b_2.ValueError.$factory("I/O operation on closed file");
        }
        if (whence === void 0) {
          whence = 0;
        }
        if (whence === 0) {
          self2.$counter = offset;
        } else if (whence === 1) {
          self2.$counter += offset;
        } else if (whence === 2) {
          self2.$counter = _b_2.len(self2.$content) + offset;
        }
        return None;
      };
      $Reader.seekable = function() {
        return true;
      };
      $Reader.tell = function(self2) {
        return self2.$counter;
      };
      $Reader.write = function(_self, data2) {
        if (_self.mode.indexOf("w") == -1) {
          if ($B2.$io.UnsupportedOperation === void 0) {
            $B2.$io.UnsupportedOperation = $B2.$class_constructor(
              "UnsupportedOperation",
              {},
              [_b_2.Exception],
              ["Exception"]
            );
          }
          throw $B2.$call($B2.$io.UnsupportedOperation)("not writable");
        }
        if (_self.mode.indexOf("b") == -1) {
          if (typeof data2 != "string") {
            throw _b_2.TypeError.$factory(`write() argument must be str, not ${$B2.class_name(data2)}`);
          }
          _self.$content += data2;
        } else {
          if (!$B2.$isinstance(data2, [_b_2.bytes, _b_2.bytearray])) {
            throw _b_2.TypeError.$factory(`write() argument must be bytes, not ${$B2.class_name(data2)}`);
          }
          _self.$content.source = _self.$content.source.concat(data2.source);
        }
        $B2.file_cache[_self.name] = _self.$content;
      };
      $Reader.writable = function() {
        return false;
      };
      $B2.set_func_names($Reader, "builtins");
      var $BufferedReader = $B2.make_class(
        "_io.BufferedReader",
        function(content2) {
          return {
            __class__: $BufferedReader,
            $binary: true,
            $content: content2,
            $read_func: $B2.$getattr(content2, "read")
          };
        }
      );
      $BufferedReader.__mro__ = [$Reader, _b_2.object];
      $BufferedReader.read = function(self2, size) {
        if (self2.$read_func === void 0) {
          return $Reader.read(self2, size === void 0 ? -1 : size);
        }
        return self2.$read_func(size || -1);
      };
      var $TextIOWrapper = $B2.make_class(
        "_io.TextIOWrapper",
        function() {
          var $ = $B2.args("TextIOWrapper", 6, { buffer: null, encoding: null, errors: null, newline: null, line_buffering: null, write_through: null }, ["buffer", "encoding", "errors", "newline", "line_buffering", "write_through"], arguments, { encoding: "utf-8", errors: _b_2.None, newline: _b_2.None, line_buffering: _b_2.False, write_through: _b_2.False }, null, null);
          return {
            __class__: $TextIOWrapper,
            __dict__: $B2.empty_dict(),
            $content: _b_2.bytes.decode($.buffer.$content, $.encoding),
            encoding: $.encoding,
            errors: $.errors,
            newline: $.newline
          };
        }
      );
      $TextIOWrapper.__bases__ = [$Reader];
      $TextIOWrapper.__mro__ = [$Reader, _b_2.object];
      $B2.set_func_names($TextIOWrapper, "builtins");
      $B2.Reader = $Reader;
      $B2.TextIOWrapper = $TextIOWrapper;
      $B2.BufferedReader = $BufferedReader;
      _b_2.open = function() {
        var $ = $B2.args("open", 3, { file: null, mode: null, encoding: null }, ["file", "mode", "encoding"], arguments, { mode: "r", encoding: "utf-8" }, "args", "kw"), file = $.file, mode = $.mode, encoding = $.encoding, result = {};
        if (encoding == "locale") {
          encoding = "utf-8";
        }
        var is_binary = mode.search("b") > -1;
        if (mode.search("w") > -1) {
          result = { $binary: is_binary, $content: is_binary ? _b_2.bytes.$factory() : "", $encoding: encoding, closed: False, mode, name: file };
          result.__class__ = is_binary ? $BufferedReader : $TextIOWrapper;
          $B2.file_cache[file] = result.$content;
          return result;
        } else if (["r", "rb"].indexOf(mode) == -1) {
          throw _b_2.ValueError.$factory("Invalid mode '" + mode + "'");
        }
        if ($B2.$isinstance(file, _b_2.str)) {
          if ($B2.file_cache.hasOwnProperty($.file)) {
            var f = $B2.file_cache[$.file];
            result.content = f;
            if (is_binary && typeof f == "string") {
              result.content = _b_2.str.encode(f, "utf-8");
            } else if (f.__class__ === _b_2.bytes && !is_binary) {
              result.content = _b_2.bytes.decode(f, encoding);
            }
          } else if ($B2.files && $B2.files.hasOwnProperty($.file)) {
            var $res = atob($B2.files[$.file].content);
            var source = [];
            for (const char of $res) {
              source.push(char.charCodeAt(0));
            }
            result.content = _b_2.bytes.$factory(source);
            if (!is_binary) {
              try {
                result.content = _b_2.bytes.decode(result.content, encoding);
              } catch (error) {
                result.error = error;
              }
            }
          } else if ($B2.protocol != "file") {
            var req = new XMLHttpRequest();
            req.overrideMimeType("text/plain;charset=x-user-defined");
            req.onreadystatechange = function() {
              if (this.readyState != 4) {
                return;
              }
              var status = this.status;
              if (status == 404) {
                result.error = _b_2.FileNotFoundError.$factory(file);
              } else if (status != 200) {
                result.error = _b_2.IOError.$factory("Could not open file " + file + " : status " + status);
              } else {
                var bytes = [];
                for (var codePoint of this.response) {
                  var cp = codePoint.codePointAt(0);
                  if (cp > 63232) {
                    cp -= 63232;
                  }
                  bytes[bytes.length] = cp;
                }
                result.content = _b_2.bytes.$factory(bytes);
                if (!is_binary) {
                  try {
                    result.content = _b_2.bytes.decode(result.content, encoding);
                  } catch (error) {
                    result.error = error;
                  }
                }
              }
            };
            var cache = $B2.get_option("cache"), fake_qs = cache ? "" : "?foo=" + (/* @__PURE__ */ new Date()).getTime();
            req.open("GET", encodeURI(file + fake_qs), false);
            req.send();
          } else {
            throw _b_2.FileNotFoundError.$factory(
              "cannot use 'open()' with protocol 'file'"
            );
          }
          if (result.error !== void 0) {
            throw result.error;
          }
          var res = { $binary: is_binary, $content: result.content, $counter: 0, $encoding: encoding, $length: is_binary ? result.content.source.length : result.content.length, closed: False, mode, name: file };
          res.__class__ = is_binary ? $BufferedReader : $TextIOWrapper;
          return res;
        } else {
          throw _b_2.TypeError.$factory("invalid argument for open(): " + _b_2.str.$factory(file));
        }
      };
      var zip = _b_2.zip = $B2.make_class(
        "zip",
        function() {
          var res = { __class__: zip, items: [] };
          if (arguments.length == 0) {
            return res;
          }
          var $ns = $B2.args("zip", 0, {}, [], arguments, {}, "args", "kw");
          var _args = $ns["args"], strict = $B2.$bool(_b_2.dict.get($ns.kw, "strict", false));
          var iters = [];
          for (var arg of _args) {
            iters.push($B2.make_js_iterator(arg));
          }
          return {
            __class__: zip,
            iters,
            strict
          };
        }
      );
      zip.__iter__ = function(self2) {
        return self2;
      };
      zip.__next__ = function(self2) {
        var res = [], len2 = self2.iters.length;
        for (var i = 0; i < len2; i++) {
          var v = self2.iters[i].next();
          if (v.done) {
            if (self2.strict) {
              if (i > 0) {
                throw _b_2.ValueError.$factory(
                  `zip() argument ${i + 1} is longer than argument ${i}`
                );
              } else {
                for (var j2 = 1; j2 < len2; j2++) {
                  var v1 = self2.iters[j2].next();
                  if (!v1.done) {
                    throw _b_2.ValueError.$factory(
                      `zip() argument ${j2 + 1} is longer than argument ${i + 1}`
                    );
                  }
                }
              }
            }
            throw _b_2.StopIteration.$factory("");
          }
          res.push(v.value);
        }
        return $B2.fast_tuple(res);
      };
      $B2.set_func_names(zip, "builtins");
      function no_set_attr(klass, attr) {
        if (klass[attr] !== void 0) {
          throw _b_2.AttributeError.$factory("'" + klass.__name__ + "' object attribute '" + attr + "' is read-only");
        } else {
          throw $B2.attr_error(attr, klass);
        }
      }
      var True = _b_2.True = true;
      var False = _b_2.False = false;
      var ellipsis = $B2.ellipsis = $B2.make_class(
        "ellipsis",
        function() {
          return Ellipsis;
        }
      );
      ellipsis.__repr__ = function() {
        return "Ellipsis";
      };
      var Ellipsis = _b_2.Ellipsis = { __class__: ellipsis };
      for (var comp in $B2.$comps) {
        switch ($B2.$comps[comp]) {
          case "ge":
          case "gt":
          case "le":
          case "lt":
            ellipsis["__" + $B2.$comps[comp] + "__"] = function() {
              return _b_2.NotImplemented;
            };
        }
      }
      $B2.set_func_names(ellipsis);
      _b_2.__BRYTHON__ = __BRYTHON__;
      $B2.builtin_funcs = [
        "__build_class__",
        "abs",
        "aiter",
        "all",
        "anext",
        "any",
        "ascii",
        "bin",
        "breakpoint",
        "callable",
        "chr",
        "compile",
        "delattr",
        "dir",
        "divmod",
        "eval",
        "exec",
        "exit",
        "format",
        "getattr",
        "globals",
        "hasattr",
        "hash",
        "help",
        "hex",
        "id",
        "input",
        "isinstance",
        "issubclass",
        "iter",
        "len",
        "locals",
        "max",
        "min",
        "next",
        "oct",
        "open",
        "ord",
        "pow",
        "print",
        "quit",
        "repr",
        "round",
        "setattr",
        "sorted",
        "sum",
        "vars"
      ];
      var builtin_function = $B2.builtin_function_or_method = $B2.make_class(
        "builtin_function_or_method",
        function(f) {
          f.__class__ = builtin_function;
          return f;
        }
      );
      builtin_function.__getattribute__ = $B2.function.__getattribute__;
      builtin_function.__reduce_ex__ = builtin_function.__reduce__ = function(self2) {
        return self2.$function_infos[$B2.func_attrs.__name__];
      };
      builtin_function.__repr__ = builtin_function.__str__ = function(self2) {
        return "<built-in function " + self2.$function_infos[$B2.func_attrs.__name__] + ">";
      };
      $B2.set_func_names(builtin_function, "builtins");
      var method_wrapper = $B2.make_class("method_wrapper");
      method_wrapper.__repr__ = method_wrapper.__str__ = function(self2) {
        return "<method wrapper '" + self2.$function_infos[$B2.func_attrs.__name__] + "' of function object>";
      };
      $B2.set_func_names(method_wrapper, "builtins");
      $B2.builtin_classes = [
        "bool",
        "bytearray",
        "bytes",
        "classmethod",
        "complex",
        "dict",
        "enumerate",
        "filter",
        "float",
        "frozenset",
        "int",
        "list",
        "map",
        "memoryview",
        "object",
        "property",
        "range",
        "reversed",
        "set",
        "slice",
        "staticmethod",
        "str",
        "super",
        "tuple",
        "type",
        "zip"
      ];
      var other_builtins = [
        "Ellipsis",
        "False",
        "None",
        "True",
        "__debug__",
        "__import__",
        "copyright",
        "credits",
        "license",
        "NotImplemented"
      ];
      var builtin_names = $B2.builtin_funcs.concat($B2.builtin_classes).concat(other_builtins);
      for (var name2 of builtin_names) {
        try {
          if ($B2.builtin_funcs.indexOf(name2) > -1) {
            _b_2[name2].__class__ = builtin_function;
            _b_2[name2].$infos = { __module__: "builtins", __name__: name2, __qualname__: name2 };
            $B2.set_function_infos(
              _b_2[name2],
              { __module__: "builtins", __name__: name2, __qualname__: name2 }
            );
          }
        } catch (err) {
        }
      }
      _b_2.object.__init__.__class__ = $B2.wrapper_descriptor;
      _b_2.object.__new__.__class__ = builtin_function;
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      var DEFAULT_MIN_MERGE = 32;
      var DEFAULT_MIN_GALLOPING = 7;
      var DEFAULT_TMP_STORAGE_LENGTH = 256;
      var POWERS_OF_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
      function log10(x) {
        if (x < 1e5) {
          if (x < 100) {
            return x < 10 ? 0 : 1;
          }
          if (x < 1e4) {
            return x < 1e3 ? 2 : 3;
          }
          return 4;
        }
        if (x < 1e7) {
          return x < 1e6 ? 5 : 6;
        }
        if (x < 1e9) {
          return x < 1e8 ? 7 : 8;
        }
        return 9;
      }
      function alphabeticalCompare(a, b) {
        if (a === b) {
          return 0;
        }
        if (~~a === a && ~~b === b) {
          if (a === 0 || b === 0) {
            return a < b ? -1 : 1;
          }
          if (a < 0 || b < 0) {
            if (b >= 0) {
              return -1;
            }
            if (a >= 0) {
              return 1;
            }
            a = -a;
            b = -b;
          }
          var al = log10(a), bl = log10(b);
          var t = 0;
          if (al < bl) {
            a *= POWERS_OF_TEN[bl - al - 1];
            b /= 10;
            t = -1;
          } else if (al > bl) {
            b *= POWERS_OF_TEN[al - bl - 1];
            a /= 10;
            t = 1;
          }
          if (a === b) {
            return t;
          }
          return a < b ? -1 : 1;
        }
        var aStr = String(a);
        var bStr = String(b);
        if (aStr === bStr) {
          return 0;
        }
        return aStr < bStr ? -1 : 1;
      }
      function minRunLength(n) {
        var r = 0;
        while (n >= DEFAULT_MIN_MERGE) {
          r |= n & 1;
          n >>= 1;
        }
        return n + r;
      }
      function makeAscendingRun(array, lo, hi, compare) {
        var runHi = lo + 1;
        if (runHi === hi) {
          return 1;
        }
        if (compare(array[runHi++], array[lo]) < 0) {
          while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
            runHi++;
          }
          reverseRun(array, lo, runHi);
        } else {
          while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
            runHi++;
          }
        }
        return runHi - lo;
      }
      function reverseRun(array, lo, hi) {
        hi--;
        while (lo < hi) {
          var t = array[lo];
          array[lo++] = array[hi];
          array[hi--] = t;
        }
      }
      function binaryInsertionSort(array, lo, hi, start, compare) {
        if (start === lo) {
          start++;
        }
        for (; start < hi; start++) {
          var pivot = array[start];
          var left = lo;
          var right = start;
          while (left < right) {
            var mid = left + right >>> 1;
            if (compare(pivot, array[mid]) < 0) {
              right = mid;
            } else {
              left = mid + 1;
            }
          }
          var n = start - left;
          switch (n) {
            case 3:
              array[left + 3] = array[left + 2];
            case 2:
              array[left + 2] = array[left + 1];
            case 1:
              array[left + 1] = array[left];
              break;
            default:
              while (n > 0) {
                array[left + n] = array[left + n - 1];
                n--;
              }
          }
          array[left] = pivot;
        }
      }
      function gallopLeft(value2, array, start, length, hint, compare) {
        var lastOffset = 0, maxOffset = 0, offset = 1;
        if (compare(value2, array[start + hint]) > 0) {
          maxOffset = length - hint;
          while (offset < maxOffset && compare(value2, array[start + hint + offset]) > 0) {
            lastOffset = offset;
            offset = (offset << 1) + 1;
            if (offset <= 0) {
              offset = maxOffset;
            }
          }
          if (offset > maxOffset) {
            offset = maxOffset;
          }
          lastOffset += hint;
          offset += hint;
        } else {
          maxOffset = hint + 1;
          while (offset < maxOffset && compare(value2, array[start + hint - offset]) <= 0) {
            lastOffset = offset;
            offset = (offset << 1) + 1;
            if (offset <= 0) {
              offset = maxOffset;
            }
          }
          if (offset > maxOffset) {
            offset = maxOffset;
          }
          var tmp = lastOffset;
          lastOffset = hint - offset;
          offset = hint - tmp;
        }
        lastOffset++;
        while (lastOffset < offset) {
          var m = lastOffset + (offset - lastOffset >>> 1);
          if (compare(value2, array[start + m]) > 0) {
            lastOffset = m + 1;
          } else {
            offset = m;
          }
        }
        return offset;
      }
      function gallopRight(value2, array, start, length, hint, compare) {
        var lastOffset = 0, maxOffset = 0, offset = 1;
        if (compare(value2, array[start + hint]) < 0) {
          maxOffset = hint + 1;
          while (offset < maxOffset && compare(value2, array[start + hint - offset]) < 0) {
            lastOffset = offset;
            offset = (offset << 1) + 1;
            if (offset <= 0) {
              offset = maxOffset;
            }
          }
          if (offset > maxOffset) {
            offset = maxOffset;
          }
          var tmp = lastOffset;
          lastOffset = hint - offset;
          offset = hint - tmp;
        } else {
          maxOffset = length - hint;
          while (offset < maxOffset && compare(value2, array[start + hint + offset]) >= 0) {
            lastOffset = offset;
            offset = (offset << 1) + 1;
            if (offset <= 0) {
              offset = maxOffset;
            }
          }
          if (offset > maxOffset) {
            offset = maxOffset;
          }
          lastOffset += hint;
          offset += hint;
        }
        lastOffset++;
        while (lastOffset < offset) {
          var m = lastOffset + (offset - lastOffset >>> 1);
          if (compare(value2, array[start + m]) < 0) {
            offset = m;
          } else {
            lastOffset = m + 1;
          }
        }
        return offset;
      }
      var TIM_SORT_ASSERTION = "TimSortAssertion";
      var TimSortAssertion = function(message) {
        this.name = TIM_SORT_ASSERTION;
        this.message = message;
      };
      var TimSort = function(array, compare) {
        var self2 = {
          array,
          compare,
          minGallop: DEFAULT_MIN_GALLOPING,
          length: array.length,
          tmpStorageLength: DEFAULT_TMP_STORAGE_LENGTH,
          stackLength: 0,
          runStart: null,
          runLength: null,
          stackSize: 0,
          pushRun: function(runStart, runLength) {
            this.runStart[this.stackSize] = runStart;
            this.runLength[this.stackSize] = runLength;
            this.stackSize += 1;
          },
          mergeRuns: function() {
            while (this.stackSize > 1) {
              var n = this.stackSize - 2;
              if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {
                if (this.runLength[n - 1] < this.runLength[n + 1]) {
                  n--;
                }
              } else if (this.runLength[n] > this.runLength[n + 1]) {
                break;
              }
              this.mergeAt(n);
            }
          },
          forceMergeRuns: function() {
            while (this.stackSize > 1) {
              var n = this.stackSize - 2;
              if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
                n--;
              }
              this.mergeAt(n);
            }
          },
          mergeAt: function(i) {
            var compare2 = this.compare, array2 = this.array, start1 = this.runStart[i], length1 = this.runLength[i], start2 = this.runStart[i + 1], length2 = this.runLength[i + 1];
            this.runLength[i] = length1 + length2;
            if (i === this.stackSize - 3) {
              this.runStart[i + 1] = this.runStart[i + 2];
              this.runLength[i + 1] = this.runLength[i + 2];
            }
            this.stackSize--;
            var k = gallopRight(array2[start2], array2, start1, length1, 0, compare2);
            start1 += k;
            length1 -= k;
            if (length1 === 0) {
              return;
            }
            length2 = gallopLeft(array2[start1 + length1 - 1], array2, start2, length2, length2 - 1, compare2);
            if (length2 === 0) {
              return;
            }
            if (length1 <= length2) {
              this.mergeLow(start1, length1, start2, length2);
            } else {
              this.mergeHigh(start1, length1, start2, length2);
            }
          },
          mergeLow: function(start1, length1, start2, length2) {
            var compare2 = this.compare, array2 = this.array, tmp = this.tmp, i = 0;
            for (let i2 = 0; i2 < length1; i2++) {
              tmp[i2] = array2[start1 + i2];
            }
            var cursor1 = 0, cursor2 = start2, dest = start1;
            array2[dest++] = array2[cursor2++];
            if (--length2 === 0) {
              for (let i2 = 0; i2 < length1; i2++) {
                array2[dest + i2] = tmp[cursor1 + i2];
              }
              return;
            }
            if (length1 === 1) {
              for (let i2 = 0; i2 < length2; i2++) {
                array2[dest + i2] = array2[cursor2 + i2];
              }
              array2[dest + length2] = tmp[cursor1];
              return;
            }
            var minGallop = this.minGallop;
            while (true) {
              var count1 = 0, count2 = 0, exit = false;
              do {
                if (compare2(array2[cursor2], tmp[cursor1]) < 0) {
                  array2[dest++] = array2[cursor2++];
                  count2++;
                  count1 = 0;
                  if (--length2 === 0) {
                    exit = true;
                    break;
                  }
                } else {
                  array2[dest++] = tmp[cursor1++];
                  count1++;
                  count2 = 0;
                  if (--length1 === 1) {
                    exit = true;
                    break;
                  }
                }
              } while ((count1 | count2) < minGallop);
              if (exit) {
                break;
              }
              do {
                count1 = gallopRight(array2[cursor2], tmp, cursor1, length1, 0, compare2);
                if (count1 !== 0) {
                  for (let i2 = 0; i2 < count1; i2++) {
                    array2[dest + i2] = tmp[cursor1 + i2];
                  }
                  dest += count1;
                  cursor1 += count1;
                  length1 -= count1;
                  if (length1 <= 1) {
                    exit = true;
                    break;
                  }
                }
                array2[dest++] = array2[cursor2++];
                if (--length2 === 0) {
                  exit = true;
                  break;
                }
                count2 = gallopLeft(tmp[cursor1], array2, cursor2, length2, 0, compare2);
                if (count2 !== 0) {
                  for (let i2 = 0; i2 < count2; i2++) {
                    array2[dest + i2] = array2[cursor2 + i2];
                  }
                  dest += count2;
                  cursor2 += count2;
                  length2 -= count2;
                  if (length2 === 0) {
                    exit = true;
                    break;
                  }
                }
                array2[dest++] = tmp[cursor1++];
                if (--length1 === 1) {
                  exit = true;
                  break;
                }
                minGallop--;
              } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
              if (exit) {
                break;
              }
              if (minGallop < 0) {
                minGallop = 0;
              }
              minGallop += 2;
            }
            this.minGallop = minGallop;
            if (minGallop < 1) {
              this.minGallop = 1;
            }
            if (length1 === 1) {
              for (let i2 = 0; i2 < length2; i2++) {
                array2[dest + i2] = array2[cursor2 + i2];
              }
              array2[dest + length2] = tmp[cursor1];
            } else if (length1 === 0) {
              throw new TimSortAssertion("mergeLow preconditions were not respected");
            } else {
              for (let i2 = 0; i2 < length1; i2++) {
                array2[dest + i2] = tmp[cursor1 + i2];
              }
            }
          },
          mergeHigh: function(start1, length1, start2, length2) {
            let compare2 = this.compare, array2 = this.array, tmp = this.tmp;
            for (let i = 0; i < length2; i++) {
              tmp[i] = array2[start2 + i];
            }
            let cursor1 = start1 + length1 - 1, cursor2 = length2 - 1, dest = start2 + length2 - 1, customCursor = 0, customDest = 0;
            array2[dest--] = array2[cursor1--];
            if (--length1 === 0) {
              customCursor = dest - (length2 - 1);
              for (let i = 0; i < length2; i++) {
                array2[customCursor + i] = tmp[i];
              }
              return;
            }
            if (length2 === 1) {
              dest -= length1;
              cursor1 -= length1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;
              for (let i = length1 - 1; i >= 0; i--) {
                array2[customDest + i] = array2[customCursor + i];
              }
              array2[dest] = tmp[cursor2];
              return;
            }
            var minGallop = this.minGallop;
            while (true) {
              let count1 = 0, count2 = 0, exit = false;
              do {
                if (compare2(tmp[cursor2], array2[cursor1]) < 0) {
                  array2[dest--] = array2[cursor1--];
                  count1++;
                  count2 = 0;
                  if (--length1 === 0) {
                    exit = true;
                    break;
                  }
                } else {
                  array2[dest--] = tmp[cursor2--];
                  count2++;
                  count1 = 0;
                  if (--length2 === 1) {
                    exit = true;
                    break;
                  }
                }
              } while ((count1 | count2) < minGallop);
              if (exit) {
                break;
              }
              do {
                count1 = length1 - gallopRight(tmp[cursor2], array2, start1, length1, length1 - 1, compare2);
                if (count1 !== 0) {
                  dest -= count1;
                  cursor1 -= count1;
                  length1 -= count1;
                  customDest = dest + 1;
                  customCursor = cursor1 + 1;
                  for (let i = count1 - 1; i >= 0; i--) {
                    array2[customDest + i] = array2[customCursor + i];
                  }
                  if (length1 === 0) {
                    exit = true;
                    break;
                  }
                }
                array2[dest--] = tmp[cursor2--];
                if (--length2 === 1) {
                  exit = true;
                  break;
                }
                count2 = length2 - gallopLeft(array2[cursor1], tmp, 0, length2, length2 - 1, compare2);
                if (count2 !== 0) {
                  dest -= count2;
                  cursor2 -= count2;
                  length2 -= count2;
                  customDest = dest + 1;
                  customCursor = cursor2 + 1;
                  for (let i = 0; i < count2; i++) {
                    array2[customDest + i] = tmp[customCursor + i];
                  }
                  if (length2 <= 1) {
                    exit = true;
                    break;
                  }
                }
                array2[dest--] = array2[cursor1--];
                if (--length1 === 0) {
                  exit = true;
                  break;
                }
                minGallop--;
              } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
              if (exit) {
                break;
              }
              if (minGallop < 0) {
                minGallop = 0;
              }
              minGallop += 2;
            }
            this.minGallop = minGallop;
            if (minGallop < 1) {
              this.minGallop = 1;
            }
            if (length2 === 1) {
              dest -= length1;
              cursor1 -= length1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;
              for (let i = length1 - 1; i >= 0; i--) {
                array2[customDest + i] = array2[customCursor + i];
              }
              array2[dest] = tmp[cursor2];
            } else if (length2 == 0) {
              throw new TimSortAssertion("mergeHigh preconditions were not respected");
            } else {
              customCursor = dest - (length2 - 1);
              for (let i = 0; i < length2; i++) {
                array2[customCursor + i] = tmp[i];
              }
            }
          }
        };
        if (self2.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
          self2.tmpStorageLength = self2.length >>> 1;
        }
        self2.tmp = new Array(self2.tmpStorageLength);
        self2.stackLength = self2.length < 120 ? 5 : self2.length < 1542 ? 10 : self2.length < 119151 ? 19 : 40;
        self2.runStart = new Array(self2.stackLength);
        self2.runLength = new Array(self2.stackLength);
        return self2;
      };
      function tim_sort(array, compare, lo, hi) {
        if (!Array.isArray(array)) {
          throw _b_2.TypeError.$factory("Can only sort arrays");
        }
        if (!compare) {
          compare = alphabeticalCompare;
        } else if (typeof compare !== "function") {
          hi = lo;
          lo = compare;
          compare = alphabeticalCompare;
        }
        if (!lo) {
          lo = 0;
        }
        if (!hi) {
          hi = array.length;
        }
        var remaining = hi - lo;
        if (remaining < 2) {
          return;
        }
        var runLength = 0;
        if (remaining < DEFAULT_MIN_MERGE) {
          runLength = makeAscendingRun(array, lo, hi, compare);
          binaryInsertionSort(array, lo, hi, lo + runLength, compare);
          return;
        }
        var ts = new TimSort(array, compare);
        var minRun = minRunLength(remaining);
        do {
          runLength = makeAscendingRun(array, lo, hi, compare);
          if (runLength < minRun) {
            var force = remaining;
            if (force > minRun) {
              force = minRun;
            }
            binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
            runLength = force;
          }
          ts.pushRun(lo, runLength);
          ts.mergeRuns();
          remaining -= runLength;
          lo += runLength;
        } while (remaining !== 0);
        ts.forceMergeRuns();
      }
      function tim_sort_safe(array, compare) {
        try {
          tim_sort(array, compare, 0, array.length);
        } catch (e) {
          if (e.name == TIM_SORT_ASSERTION) {
            array.sort(compare);
          } else {
            throw e;
          }
        }
      }
      $B2.$TimSort = tim_sort_safe;
      $B2.$AlphabeticalCompare = alphabeticalCompare;
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      $B2.del_exc = function(frame2) {
        delete frame2[1].$current_exception;
      };
      $B2.set_exc = function(exc, frame2) {
        exc.__traceback__ = exc.__traceback__ === _b_2.None ? make_tb() : exc.__traceback__;
        if (!exc.__class__) {
          console.log("no class", exc);
        }
        exc.__class__ = exc.__class__ ?? _b_2.JavascriptError;
        exc.args = exc.args ?? [exc.message];
        if (frame2 === void 0) {
          var msg = "Internal error: no frame for exception " + _b_2.repr(exc);
          console.error(["Traceback (most recent call last):", $B2.print_stack(exc.$frame_obj), msg].join("\n"));
          if ($B2.get_option("debug", exc) > 1) {
            console.log(exc.args);
            console.log(exc.stack);
          }
          throw Error(msg);
        } else {
          frame2[1].$current_exception = $B2.exception(exc);
        }
      };
      $B2.set_exc_and_trace = function(frame2, exc) {
        $B2.set_exc(exc, frame2);
        if (!exc.$in_trace_func && frame2.$f_trace !== _b_2.None) {
          frame2.$f_trace = $B2.trace_exception();
        }
      };
      $B2.set_exc_and_leave = function(frame2, exc) {
        $B2.set_exc_and_trace(frame2, exc);
        $B2.leave_frame();
        throw exc;
      };
      $B2.get_exc = function() {
        var frame2 = $B2.frame_obj.frame;
        return frame2[1].$current_exception;
      };
      $B2.set_exception_offsets = function(exc, position) {
        exc.$positions = exc.$positions || {};
        exc.$positions[$B2.frame_obj.count - 1] = position;
        return exc;
      };
      $B2.$raise = function(arg, cause) {
        var active_exc = $B2.get_exc();
        if (arg === void 0) {
          if (active_exc !== void 0) {
            throw active_exc;
          }
          throw _b_2.RuntimeError.$factory("No active exception to reraise");
        } else {
          if ($B2.$isinstance(arg, _b_2.BaseException)) {
            if (arg.__class__ === _b_2.StopIteration && $B2.frame_obj.frame.$is_generator) {
              arg = _b_2.RuntimeError.$factory("generator raised StopIteration");
            }
            arg.__context__ = active_exc === void 0 ? _b_2.None : active_exc;
            arg.__cause__ = cause || _b_2.None;
            arg.__suppress_context__ = cause !== void 0;
            throw arg;
          } else if (arg.$is_class && _b_2.issubclass(arg, _b_2.BaseException)) {
            if (arg === _b_2.StopIteration) {
              if ($B2.frame_obj.frame[1].$is_generator) {
                throw _b_2.RuntimeError.$factory("generator raised StopIteration");
              }
            }
            var exc = $B2.$call(arg)();
            exc.__context__ = active_exc === void 0 ? _b_2.None : active_exc;
            exc.__cause__ = cause || _b_2.None;
            exc.__suppress_context__ = cause !== void 0;
            throw exc;
          } else {
            throw _b_2.TypeError.$factory("exceptions must derive from BaseException");
          }
        }
      };
      $B2.print_stack = function(frame_obj) {
        var stack = make_frames_stack(frame_obj || $B2.frame_obj);
        var trace = [];
        for (var frame2 of stack) {
          var lineno = frame2.$lineno, filename = frame2.__file__;
          if (lineno !== void 0) {
            var local = frame2[0] == frame2[2] ? "<module>" : frame2[0];
            trace.push(`  File "${filename}" line ${lineno}, in ${local}`);
            var src = $B2.file_cache[filename];
            if (src) {
              var lines = src.split("\n"), line = lines[lineno - 1];
              trace.push("    " + line.trim());
            }
          }
        }
        return trace.join("\n");
      };
      $B2.count_frames = function(frame_obj) {
        frame_obj = frame_obj || $B2.frame_obj;
        return frame_obj == null ? 0 : frame_obj.count;
      };
      $B2.get_frame_at = function(pos2, frame_obj) {
        frame_obj = frame_obj || $B2.frame_obj;
        var nb = frame_obj.count - pos2 - 1;
        for (var i = 0; i < nb; i++) {
          if (frame_obj.prev === null) {
            break;
          }
          frame_obj = frame_obj.prev;
        }
        return frame_obj.frame;
      };
      function make_frames_list() {
        var t = [];
        var frame_obj = $B2.frame_obj;
        while (frame_obj) {
          t.push(frame_obj.frame);
          frame_obj = frame_obj.prev;
        }
        return t;
      }
      var make_tb = $B2.make_tb = function(frames_list) {
        frames_list = frames_list ?? make_frames_list();
        if (frames_list.length == 0) {
          return _b_2.None;
        }
        var _frame = frames_list.pop();
        var res = { __class__: traceback, tb_frame: frame.$factory(_frame), tb_lineno: _frame.$lineno, tb_lasti: _frame.inum ?? -1, tb_next: make_tb(frames_list) };
        return res;
      };
      var traceback = $B2.traceback = $B2.make_class(
        "traceback",
        function(exc) {
          return make_tb();
        }
      );
      $B2.set_func_names(traceback, "builtins");
      var frame = $B2.frame = $B2.make_class(
        "frame",
        function(frame_list) {
          frame_list.__class__ = frame;
          return frame_list;
        }
      );
      frame.__bool__ = function() {
        return true;
      };
      frame.__delattr__ = function(_self, attr) {
        if (attr == "f_trace") {
          _self.$f_trace = _b_2.None;
        }
      };
      frame.__dir__ = function() {
        return _b_2.object.__dir__(frame).concat(["clear", "f_back", "f_builtins", "f_code", "f_globals", "f_lasti", "f_lineno", "f_locals", "f_trace", "f_trace_lines", "f_trace_opcodes"]);
      };
      frame.__getattr__ = function(_self, attr) {
        if (attr == "f_back") {
          var frame_obj = $B2.frame_obj;
          while (frame_obj !== null) {
            if (frame_obj.frame === _self) {
              break;
            }
            frame_obj = frame_obj.prev;
          }
          if (frame_obj.prev !== null) {
            return frame.$factory(frame_obj.prev.frame);
          }
          return _b_2.None;
        } else if (attr == "clear") {
          return function() {
          };
        } else if (attr == "f_trace") {
          return _self.$f_trace ?? _b_2.None;
        } else if (attr == "f_lasti") {
          return 0;
        }
        throw $B2.attr_error(attr, _self);
      };
      frame.__setattr__ = function(_self, attr, value2) {
        if (attr == "f_trace") {
          _self.$f_trace = value2;
        }
      };
      frame.__str__ = frame.__repr__ = function(_self) {
        return "<frame object, file " + _self.__file__ + ", line " + _self.$lineno + ", code " + frame.f_code.__get__(_self).co_name + ">";
      };
      frame.f_builtins = { __get__: function(_self) {
        return $B2.$getattr(_self[3].__builtins__, "__dict__");
      } };
      frame.f_code = { __get__: function(_self) {
        var res;
        var positions;
        if (_self[4]) {
          res = $B2.$getattr(_self[4], "__code__");
          positions = _self.positions ?? [];
        } else if (_self.f_code) {
          res = _self.f_code;
        } else {
          res = { co_name: _self[0] == _self[2] ? "<module>" : _self[0], co_filename: _self.__file__, co_varnames: $B2.fast_tuple([]), co_firstlineno: 1 };
          res.co_qualname = res.co_name;
          positions = _self.positions;
        }
        res.__class__ = _b_2.code;
        if (positions) {
          res.co_positions = positions.map($B2.decode_position);
        }
        return res;
      } };
      frame.f_globals = { __get__: function(_self) {
        if (_self.f_globals) {
          return _self.f_globals;
        } else if (_self.f_locals && _self[1] == _self[3]) {
          return _self.f_globals = _self.f_locals;
        } else {
          return _self.f_globals = $B2.obj_dict(_self[3]);
        }
      } };
      frame.f_lineno = { __get__: function(_self) {
        return _self.$lineno;
      } };
      frame.f_locals = { __get__: function(_self) {
        if (_self.f_locals) {
          return _self.f_locals;
        } else if (_self.f_globals && _self[1] == _self[3]) {
          return _self.f_locals = _self.f_globals;
        } else {
          return _self.f_locals = $B2.obj_dict(_self[1]);
        }
      } };
      frame.f_trace = { __get__: function(_self) {
        return _self.$f_trace;
      } };
      $B2.set_func_names(frame, "builtins");
      $B2._frame = frame;
      $B2.make_f_code = function(frame2, varnames) {
        frame2.f_code = { co_argcount: 1, co_firstlineno: frame2.$lineno, co_name: "<genexpr>", co_filename: frame2.__file__, co_flags: 115, co_freevars: $B2.fast_tuple([]), co_kwonlyargcount: 0, co_posonlyargount: 0, co_qualname: "genexpr", co_varnames: $B2.fast_tuple([".0"].concat(varnames)) };
      };
      $B2.restore_frame_obj = function(frame_obj, locals) {
        $B2.frame_obj = frame_obj;
        $B2.frame_obj.frame[1] = locals;
      };
      var make_frames_stack = $B2.make_frames_stack = function(frame_obj) {
        var stack = [];
        while (frame_obj !== null) {
          stack[stack.length] = frame_obj.frame;
          frame_obj = frame_obj.prev;
        }
        stack.reverse();
        return stack;
      };
      $B2.exception = function(js_exc) {
        var exc;
        if (!js_exc.__class__) {
          if (js_exc.$py_exc) {
            return js_exc.$py_exc;
          }
          if ($B2.get_option("debug", exc) > 1) {
            console.log("Javascript error", js_exc);
          }
          var msg = js_exc.name + ": " + js_exc.message;
          exc = _b_2.JavascriptError.$factory(msg);
          exc.$js_exc = js_exc;
          if ($B2.is_recursion_error(js_exc)) {
            msg = "maximum recursion depth exceeded";
            exc = _b_2.RecursionError.$factory(msg);
          }
          exc.__cause__ = _b_2.None;
          exc.__context__ = _b_2.None;
          exc.__suppress_context__ = false;
          exc.__traceback__ = traceback.$factory(js_exc);
          exc.args = _b_2.tuple.$factory([msg]);
          exc.$py_error = true;
          js_exc.$py_exc = exc;
        } else {
          exc = js_exc;
        }
        exc.__traceback__ = exc.__traceback__ ?? traceback.$factory(exc);
        return exc;
      };
      $B2.is_exc = function(exc, exc_list) {
        if (exc.__class__ === void 0) {
          exc = $B2.exception(exc);
        }
        var this_exc_class = exc.$is_class ? exc : exc.__class__;
        for (var i = 0; i < exc_list.length; i++) {
          var exc_class = exc_list[i];
          if (this_exc_class === void 0) {
            console.log("exc class undefined", exc);
          }
          if (_b_2.issubclass(this_exc_class, exc_class)) {
            return true;
          }
        }
        return false;
      };
      $B2.is_recursion_error = function(js_exc) {
        var msg = js_exc + "", parts = msg.split(":");
        if (parts.length == 1) {
          return false;
        }
        var err_type = parts[0].trim(), err_msg = parts[1].trim();
        return err_type == "InternalError" && err_msg == "too much recursion" || err_type == "Error" && err_msg == "Out of stack space" || err_type == "RangeError" && err_msg == "Maximum call stack size exceeded";
      };
      function make_builtin_exception(exc_name, base, set_value) {
        if (Array.isArray(exc_name)) {
          for (var name2 of exc_name) {
            make_builtin_exception(name2, base, set_value);
          }
          return;
        }
        var exc_class = $B2.make_class(
          exc_name,
          function() {
            var err = Error();
            err.args = $B2.fast_tuple(Array.from(arguments));
            err.__class__ = exc_class;
            err.__traceback__ = _b_2.None;
            err.$py_error = true;
            if (set_value) {
              if (typeof set_value == "string") {
                err[set_value] = arguments[0] || _b_2.None;
              } else if (typeof set_value == "function") {
                set_value(err, arguments);
              }
            }
            err.__cause__ = _b_2.None;
            err.__context__ = _b_2.None;
            err.__suppress_context__ = false;
            return err;
          }
        );
        exc_class.__bases__ = [base];
        exc_class.__mro__ = _b_2.type.$mro(exc_class).slice(1);
        $B2.set_func_names(exc_class, "builtins");
        _b_2[exc_name] = exc_class;
      }
      make_builtin_exception("BaseException", _b_2.object);
      _b_2.BaseException.__init__ = function(self2) {
        var args = arguments[1] === void 0 ? [] : [arguments[1]];
        self2.args = _b_2.tuple.$factory(args);
      };
      _b_2.BaseException.__repr__ = function(self2) {
        var res = self2.__class__.__name__ + "(";
        if (self2.args[0] !== void 0) {
          res += _b_2.repr(self2.args[0]);
        }
        if (self2.args.length > 1) {
          res += ", " + _b_2.repr($B2.fast_tuple(self2.args.slice(1)));
        }
        return res + ")";
      };
      _b_2.BaseException.__str__ = function(self2) {
        if (self2.args.length > 0 && self2.args[0] !== _b_2.None) {
          return _b_2.str.$factory(self2.args[0]);
        }
        return "";
      };
      _b_2.BaseException.__new__ = function(cls) {
        var err = _b_2.BaseException.$factory();
        err.__class__ = cls;
        err.__dict__ = $B2.empty_dict();
        return err;
      };
      _b_2.BaseException.__getattr__ = function(self2, attr) {
        switch (attr) {
          case "__context__":
            var frame2 = $B2.frame_obj.frame, ctx = frame2[1].$current_exception;
            return ctx || _b_2.None;
          case "__cause__":
          case "__suppress_context__":
            return self2[attr] ?? _b_2.None;
          default:
            throw $B2.attr_error(attr, self2);
        }
      };
      _b_2.BaseException.add_note = function(self2, note) {
        if (!$B2.$isinstance(note, _b_2.str)) {
          throw _b_2.TypeError.$factory(`note must be a str, not '${$B2.class_name(note)}'`);
        }
        if (self2.__notes__ !== void 0) {
          self2.__notes__.push(note);
        } else {
          self2.__notes__ = $B2.$list([note]);
        }
      };
      _b_2.BaseException.with_traceback = function(_self, tb) {
        _self.__traceback__ = tb;
        return _self;
      };
      $B2.set_func_names(_b_2.BaseException, "builtins");
      make_builtin_exception(["SystemExit", "KeyboardInterrupt", "GeneratorExit", "Exception"], _b_2.BaseException);
      make_builtin_exception("JavascriptError", _b_2.Exception);
      make_builtin_exception(["ArithmeticError", "AssertionError", "BufferError", "EOFError", "LookupError", "MemoryError", "OSError", "ReferenceError", "RuntimeError", "SystemError", "TypeError", "ValueError", "Warning"], _b_2.Exception);
      make_builtin_exception("StopIteration", _b_2.Exception, "value");
      make_builtin_exception("StopAsyncIteration", _b_2.Exception, "value");
      make_builtin_exception("ImportError", _b_2.Exception, "name");
      make_builtin_exception(
        "SyntaxError",
        _b_2.Exception,
        function(err, args) {
          err.msg = args[0];
          err.args = $B2.fast_tuple(Array.from(args));
          var details = args[1];
          if (details) {
            details = _b_2.tuple.$factory(details);
            if (details.length < 4) {
              throw _b_2.TypeError.$factory(
                `function takes at least 4 arguments (${args.length} given)`
              );
            }
            if (details.length > 6) {
              throw _b_2.TypeError.$factory(
                `function takes at most 6 arguments (${args.length} given)`
              );
            }
          } else {
            details = [];
          }
          let attrs = ["filename", "lineno", "offset", "text", "end_lineno", "end_offset"], expected_types = [_b_2.str, _b_2.int, _b_2.int, _b_2.str, _b_2.int, _b_2.int];
          for (var i = 0; i < attrs.length; i++) {
            if (details[i] !== void 0) {
              if (!$B2.$isinstance(details[i], expected_types[i])) {
                throw _b_2.TypeError.$factory(`item #${i + 1} (${attrs[i]}) of the second argument of SyntaxError should be '${expected_types[i].__name__}', not '${$B2.class_name(details[i])}'`);
              }
              err[attrs[i]] = details[i];
            } else {
              err[attrs[i]] = _b_2.None;
            }
          }
        }
      );
      make_builtin_exception(["FloatingPointError", "OverflowError", "ZeroDivisionError"], _b_2.ArithmeticError);
      make_builtin_exception("ModuleNotFoundError", _b_2.ImportError, "name");
      make_builtin_exception(["IndexError", "KeyError"], _b_2.LookupError);
      make_builtin_exception(["BlockingIOError", "ChildProcessError", "ConnectionError", "FileExistsError", "FileNotFoundError", "InterruptedError", "IsADirectoryError", "NotADirectoryError", "PermissionError", "ProcessLookupError", "TimeoutError"], _b_2.OSError);
      make_builtin_exception(["BrokenPipeError", "ConnectionAbortedError", "ConnectionRefusedError", "ConnectionResetError"], _b_2.ConnectionError);
      make_builtin_exception(["NotImplementedError", "RecursionError", "PythonFinalizationError"], _b_2.RuntimeError);
      make_builtin_exception(["IndentationError", "_IncompleteInputError"], _b_2.SyntaxError, "msg");
      make_builtin_exception("TabError", _b_2.IndentationError);
      make_builtin_exception("UnicodeError", _b_2.ValueError);
      make_builtin_exception(["UnicodeDecodeError", "UnicodeEncodeError", "UnicodeTranslateError"], _b_2.UnicodeError);
      make_builtin_exception(["DeprecationWarning", "PendingDeprecationWarning", "RuntimeWarning", "SyntaxWarning", "UserWarning", "FutureWarning", "ImportWarning", "UnicodeWarning", "BytesWarning", "ResourceWarning", "EncodingWarning"], _b_2.Warning);
      _b_2.EnvironmentError = _b_2.OSError;
      _b_2.WindowsError = _b_2.OSError;
      _b_2.IOError = _b_2.OSError;
      _b_2.KeyError.__str__ = function(self2) {
        if (self2.args.length == 1) {
          return _b_2.repr(self2.args[0]);
        }
        return _b_2.BaseException.__str__(self2);
      };
      $B2.set_func_names(_b_2.KeyError, "builtins");
      _b_2.AttributeError = $B2.make_class(
        "AttributeError",
        function() {
          var $ = $B2.args("AttributeError", 3, { "msg": null, "name": null, "obj": null }, ["msg", "name", "obj"], arguments, { msg: _b_2.None, name: _b_2.None, obj: _b_2.None }, "*", null);
          var err = Error();
          err.__class__ = _b_2.AttributeError;
          err.__traceback__ = _b_2.None;
          err.$py_error = true;
          err.args = $B2.fast_tuple($.msg === _b_2.None ? [] : [$.msg]);
          err.name = $.name;
          err.obj = $.obj;
          if (err.obj === void 0) {
            console.log("pas de obj", $);
          }
          err.__cause__ = _b_2.None;
          err.__context__ = _b_2.None;
          err.__suppress_context__ = false;
          return err;
        }
      );
      _b_2.AttributeError.__bases__ = [_b_2.Exception];
      _b_2.AttributeError.__mro__ = _b_2.type.$mro(_b_2.AttributeError);
      _b_2.AttributeError.__str__ = function(self2) {
        return self2.args[0];
      };
      $B2.set_func_names(_b_2.AttributeError, "builtins");
      $B2.attr_error = function(name2, obj) {
        var msg;
        if (obj.$is_class) {
          msg = `type object '${obj.__name__}'`;
        } else {
          msg = `'${$B2.class_name(obj)}' object`;
        }
        msg += ` has no attribute '${name2}'`;
        return _b_2.AttributeError.$factory({ $kw: [{ name: name2, obj, msg }] });
      };
      _b_2.NameError = $B2.make_class(
        "NameError",
        function() {
          var $ = $B2.args("NameError", 2, { "message": null, "name": null }, ["message", "name"], arguments, { message: _b_2.None, name: _b_2.None }, "*", null, 1);
          var err = Error();
          err.__class__ = _b_2.NameError;
          err.__traceback__ = _b_2.None;
          err.$py_error = true;
          err.args = $B2.fast_tuple($.message === _b_2.None ? [] : [$.message]);
          err.name = $.name;
          err.__cause__ = _b_2.None;
          err.__context__ = _b_2.None;
          err.__suppress_context__ = false;
          return err;
        }
      );
      _b_2.NameError.__bases__ = [_b_2.Exception];
      _b_2.NameError.__mro__ = _b_2.type.$mro(_b_2.NameError).slice(1);
      _b_2.NameError.__str__ = function(self2) {
        return self2.args[0];
      };
      $B2.set_func_names(_b_2.NameError, "builtins");
      make_builtin_exception("UnboundLocalError", _b_2.NameError);
      _b_2.UnboundLocalError.__str__ = function(self2) {
        return self2.args[0];
      };
      $B2.set_func_names(_b_2.UnboundLocalError, "builtins");
      $B2.name_error = function(name2) {
        var exc = _b_2.NameError.$factory(`name '${name2}' is not defined`);
        exc.name = name2;
        return exc;
      };
      $B2.recursion_error = function(frame2) {
        var exc = _b_2.RecursionError.$factory("maximum recursion depth exceeded");
        $B2.set_exc(exc, frame2);
        return exc;
      };
      function calculate_suggestions(list, name2) {
        return $B2.imported._suggestions._generate_suggestions(list, name2);
      }
      $B2.offer_suggestions_for_attribute_error = function(exc) {
        var name2 = exc.name, obj = exc.obj;
        if (name2 === _b_2.None) {
          return _b_2.None;
        }
        var dir = _b_2.dir(obj), suggestions = calculate_suggestions(dir, name2);
        return suggestions || _b_2.None;
      };
      $B2.offer_suggestions_for_name_error = function(exc, frame2) {
        var name2 = exc.name;
        if (typeof name2 != "string") {
          return _b_2.None;
        }
        var tb = exc.__traceback__;
        if (tb === void 0 || tb === _b_2.None) {
          return _b_2.None;
        }
        while (tb.tb_next !== _b_2.None) {
          tb = tb.tb_next;
        }
        var frame2 = tb.tb_frame;
        var locals = Object.keys(frame2[1]).filter((x) => !x.startsWith("$"));
        var suggestion = calculate_suggestions(locals, name2);
        if (suggestion) {
          return suggestion;
        }
        if (frame2[2] != frame2[0]) {
          var globals = Object.keys(frame2[3]).filter((x) => !x.startsWith("$"));
          suggestion = calculate_suggestions(globals, name2);
          if (suggestion) {
            return suggestion;
          }
        }
        if (frame2[4] && frame2[4].$is_method) {
          var instance_name = frame2[4].$infos.__code__.co_varnames[0], instance = frame2[1][instance_name];
          if (_b_2.hasattr(instance, name2)) {
            return `self.${name2}`;
          }
        }
        return _b_2.None;
      };
      $B2.offer_suggestions_for_unexpected_keyword_error = function(arg_names, key2) {
        if (key2 === _b_2.None) {
          return _b_2.None;
        }
        var suggestions = calculate_suggestions(arg_names, key2);
        return suggestions || _b_2.None;
      };
      _b_2.BaseExceptionGroup = $B2.make_class(
        "BaseExceptionGroup",
        function() {
          var missing = {}, $ = $B2.args("BaseExceptionGroup", 2, { message: null, exceptions: null }, ["message", "exceptions"], arguments, { exceptions: missing }, null, null);
          var err = Error();
          err.args = $B2.fast_tuple(Array.from(arguments));
          err.__class__ = _b_2.BaseExceptionGroup;
          err.__traceback__ = _b_2.None;
          err.$py_error = true;
          err.message = $.message;
          err.exceptions = $.exceptions === missing ? [] : $.exceptions;
          if (err.exceptions !== _b_2.None) {
            var exc_list = _b_2.list.$factory(err.exceptions);
            var all_exceptions = true;
            for (var exc of exc_list) {
              if (!$B2.$isinstance(exc, _b_2.Exception)) {
                all_exceptions = false;
                break;
              }
            }
            if (all_exceptions) {
              err.__class__ = _b_2.ExceptionGroup;
            }
          }
          err.__cause__ = _b_2.None;
          err.__context__ = _b_2.None;
          err.__suppress_context__ = false;
          return err;
        }
      );
      _b_2.BaseExceptionGroup.__bases__ = [_b_2.BaseException];
      _b_2.BaseExceptionGroup.__class_getitem__ = $B2.$class_getitem;
      _b_2.BaseExceptionGroup.__mro__ = _b_2.type.$mro(_b_2.BaseExceptionGroup);
      _b_2.BaseExceptionGroup.__str__ = function(self2) {
        return `${self2.message} (${self2.exceptions.length} sub-exception${self2.exceptions.length > 1 ? "s" : ""})`;
      };
      _b_2.BaseExceptionGroup.split = function(self2, condition) {
        var matching_excs = [], non_matching_excs = [];
        for (var exc of self2.exceptions) {
          if ($B2.$isinstance(exc, _b_2.BaseExceptionGroup)) {
            var subsplit = _b_2.BaseExceptionGroup.split(exc, condition), matching = subsplit[0], non_matching = subsplit[1];
            if (matching === _b_2.None) {
              non_matching_excs.push(exc);
            } else if (matching.exceptions.length == exc.exceptions.length) {
              matching_excs.push(exc);
            } else {
              if (matching.exceptions.length > 0) {
                matching_excs = matching_excs.concat(matching);
              }
              if (non_matching.exceptions.length > 0) {
                non_matching_excs = non_matching_excs.concat(non_matching);
              }
            }
          } else if (condition(exc)) {
            matching_excs.push(exc);
          } else {
            non_matching_excs.push(exc);
          }
        }
        if (matching_excs.length == 0) {
          matching_excs = _b_2.None;
        }
        if (non_matching_excs.length == 0) {
          non_matching_excs = _b_2.None;
        }
        var res = [];
        for (var item2 of [matching_excs, non_matching_excs]) {
          var eg = _b_2.BaseExceptionGroup.$factory(self2.message, item2);
          eg.__cause__ = self2.__cause__;
          eg.__context__ = self2.__context__;
          eg.__traceback__ = self2.__traceback__;
          res.push(eg);
        }
        return $B2.fast_tuple(res);
      };
      _b_2.BaseExceptionGroup.subgroup = function(self2, condition) {
        return _b_2.BaseExceptionGroup.split(self2, condition)[0];
      };
      $B2.set_func_names(_b_2.BaseExceptionGroup, "builtins");
      _b_2.BaseExceptionGroup.__class_getitem__ = _b_2.classmethod.$factory(_b_2.BaseExceptionGroup.__class_getitem__);
      _b_2.ExceptionGroup = $B2.make_class(
        "ExceptionGroup",
        function() {
          var missing = {}, $ = $B2.args("ExceptionGroup", 2, { message: null, exceptions: null }, ["message", "exceptions"], arguments, { exceptions: missing }, null, null);
          var err = Error();
          err.args = $B2.fast_tuple(Array.from(arguments));
          err.__class__ = _b_2.ExceptionGroup;
          err.__traceback__ = _b_2.None;
          err.$py_error = true;
          err.message = $.message;
          err.exceptions = $.exceptions === missing ? [] : $.exceptions;
          if (err.exceptions !== _b_2.None) {
            var exc_list = _b_2.list.$factory(err.exceptions);
            for (var exc of exc_list) {
              if (!$B2.$isinstance(exc, _b_2.Exception)) {
                throw _b_2.TypeError.$factory(
                  "Cannot nest BaseExceptions in an ExceptionGroup"
                );
              }
            }
          }
          err.__cause__ = _b_2.None;
          err.__context__ = _b_2.None;
          err.__suppress_context__ = false;
          return err;
        }
      );
      _b_2.ExceptionGroup.__bases__ = [_b_2.BaseExceptionGroup, _b_2.Exception];
      _b_2.ExceptionGroup.__mro__ = _b_2.type.$mro(_b_2.ExceptionGroup);
      $B2.set_func_names(_b_2.ExceptionGroup, "builtins");
      function make_report(lines, positions) {
        var [lineno, end_lineno, col_offset, end_col_offset] = positions;
        lines = lines.slice(lineno - 1, end_lineno);
        var min_indent = get_min_indent(lines);
        lines = lines.map((line) => "    " + line.substr(min_indent).trimRight());
        if (lines.length > 3) {
          lines = [lines[0], `    ...<${lines.length - 2} lines>...`, lines[lines.length - 1]];
        }
        return lines.join("\n");
      }
      function make_trace_lines(lines, lineno, expr) {
        var line_start = expr.lineno + lineno - 2;
        var line_end = expr.end_lineno + lineno - 2;
        return make_report(lines, [line_start, line_end, expr.col_offset, expr.end_col_offset]);
      }
      function get_indent(line) {
        return line.length - line.trimLeft().length;
      }
      function get_min_indent(lines) {
        var min_indent = 2 ** 16;
        for (var line of lines) {
          if (!line.trim()) {
            continue;
          }
          var indent = get_indent(line);
          if (indent < min_indent) {
            min_indent = indent;
          }
        }
        return min_indent;
      }
      function fill_marks(lines, first_lineno, first_col_offset) {
        var args = Array.from(arguments).slice(3);
        var start_lineno = first_lineno;
        var start_col_offset = first_col_offset;
        var marks = " ".repeat(first_col_offset);
        var line;
        var indent;
        for (var i = 0; i < args.length; i += 3) {
          var [mark, lineno, col_offset] = args.slice(i, i + 3);
          if (lineno == start_lineno) {
            marks += mark.repeat(col_offset - start_col_offset);
          } else {
            line = lines[start_lineno - 1];
            marks += mark.repeat(line.length - start_col_offset) + "\n";
            for (var lnum = start_lineno + 1; lnum < lineno; lnum++) {
              line = lines[lnum - 1].trimRight();
              indent = get_indent(line);
              marks += " ".repeat(indent) + mark.repeat(line.length - indent) + "\n";
            }
            line = lines[lineno - 1].trimRight();
            indent = get_indent(line);
            marks += " ".repeat(indent) + mark.repeat(col_offset - indent);
          }
          start_lineno = lineno;
          start_col_offset = col_offset;
        }
        var marks_lines = marks.split("\n");
        var min_indent = get_min_indent(lines.slice(first_lineno - 1, lineno));
        var err_lines = [];
        for (var lnum = 0; lnum < marks_lines.length; lnum++) {
          err_lines.push("    " + lines[first_lineno + lnum - 1].trimRight().substr(min_indent));
          err_lines.push("    " + marks_lines[lnum].substr(min_indent));
        }
        return err_lines.join("\n");
      }
      function make_line_setter(lineno) {
        return function(coords) {
          return {
            lineno: coords.lineno + lineno - 2,
            end_lineno: coords.end_lineno + lineno - 2,
            col_offset: coords.col_offset,
            end_col_offset: coords.end_col_offset
          };
        };
      }
      function handle_BinOp_error(lines, lineno, ast_obj, tokens) {
        var reset_lineno = make_line_setter(lineno);
        var operator;
        for (var token of tokens) {
          if (token.type == $B2.py_tokens.OP) {
            if (is_before(ast_obj.right, token.lineno, token.col_offset) && token.string != "(") {
              operator = reset_lineno(token);
            }
          }
        }
        var end_binop = reset_lineno(tokens[tokens.length - 1]);
        var left = reset_lineno(ast_obj.left);
        return fill_marks(lines, lineno, left.col_offset, "~", operator.lineno, operator.col_offset, "^", operator.end_lineno, operator.end_col_offset, "~", end_binop.end_lineno, end_binop.end_col_offset);
      }
      function handle_Call_error(lines, lineno, ast_obj, tokens) {
        var reset_lineno = make_line_setter(lineno);
        var opening_parenth;
        var closing_parenth;
        for (var token of tokens) {
          if (token.type == $B2.py_tokens.OP) {
            if (token.string == "(" && !opening_parenth && token.lineno == ast_obj.func.end_lineno && token.col_offset >= ast_obj.func.end_col_offset) {
              opening_parenth = reset_lineno(token);
            } else if (token.string == ")") {
              closing_parenth = reset_lineno(token);
            }
          }
        }
        var func = reset_lineno(ast_obj.func);
        return fill_marks(lines, lineno, func.col_offset, "~", opening_parenth.lineno, opening_parenth.col_offset, "^", closing_parenth.end_lineno, closing_parenth.end_col_offset);
      }
      function handle_Expr_error(lines, lineno, ast_obj) {
        var reset_lineno = make_line_setter(lineno);
        var expr = reset_lineno(ast_obj);
        return fill_marks(lines, lineno, expr.col_offset, "^", expr.end_lineno, expr.end_col_offset);
      }
      function is_before(obj, lineno, col) {
        return lineno < obj.lineno || lineno == obj.lineno && col < obj.col_offset;
      }
      function handle_Subscript_error(lines, lineno, ast_obj, tokens) {
        var reset_lineno = make_line_setter(lineno);
        for (var token of tokens) {
          if (token.type == $B2.py_tokens.OP) {
            if (token.string == "[" && is_before(ast_obj.slice, token.lineno, token.col_offset)) {
              var opening_bracket = reset_lineno(token);
            } else if (token.string == "]") {
              var closing_bracket = reset_lineno(token);
            }
          }
        }
        var value2 = reset_lineno(ast_obj.value);
        return fill_marks(lines, lineno, value2.col_offset, "~", opening_bracket.lineno, opening_bracket.col_offset, "^", closing_bracket.end_lineno, closing_bracket.end_col_offset);
      }
      function trace_from_stack(err) {
        function handle_repeats(src2, count_repeats2) {
          if (count_repeats2 > 0) {
            var len = trace.length;
            for (var i = 0; i < 2; i++) {
              if (src2) {
                trace.push(trace[len - 2]);
                trace.push(trace[len - 1]);
              } else {
                trace.push(trace[len - 1]);
              }
              count_repeats2--;
              if (count_repeats2 == 0) {
                break;
              }
            }
            if (count_repeats2 > 0) {
              trace.push(`[Previous line repeated ${count_repeats2} more time${count_repeats2 > 1 ? "s" : ""}]`);
            }
          }
        }
        var trace = [], save_filename, save_lineno, save_scope, count_repeats = 0, tb = err.__traceback__;
        var is_syntax_error = $B2.is_exc(err, [_b_2.SyntaxError]);
        while (tb !== _b_2.None) {
          let frame2 = tb.tb_frame, lineno = tb.tb_lineno, filename = frame2.__file__, scope = frame2[0] == frame2[2] ? "<module>" : frame2[0];
          if (filename == save_filename && scope == save_scope && lineno == save_lineno) {
            count_repeats++;
            tb = tb.tb_next;
            continue;
          }
          handle_repeats(src, count_repeats);
          save_filename = filename;
          save_lineno = lineno;
          save_scope = scope;
          count_repeats = 0;
          trace.push(`  File "${filename}", line ${lineno}, in ` + (frame2[0] == frame2[2] ? "<module>" : frame2[0]));
          var src;
          if (!filename.startsWith("<")) {
            src = $B2.file_cache[filename];
          }
          if (src) {
            var lines = src.split("\n");
            var positions = false;
            if (!is_syntax_error && frame2.inum && frame2.positions) {
              positions = $B2.decode_position(
                frame2.positions[Math.floor(frame2.inum / 2)]
              );
            }
            if (positions) {
              let [lineno2, end_lineno, col_offset, end_col_offset] = positions;
              if (lines[lineno2 - 1] === void 0) {
                console.log("no line, lines\n", lines, "lineno", lineno2);
                console.log("filename", filename, "src", src);
                continue;
              }
              var head = lines[lineno2 - 1].substr(0, col_offset);
              var segment = " ".repeat(col_offset);
              if (lineno2 == end_lineno) {
                segment += lines[lineno2 - 1].substring(col_offset, end_col_offset);
              } else {
                segment += lines[lineno2 - 1].substr(col_offset) + "\n";
                for (var lnum = lineno2 + 1; lnum < end_lineno; lnum++) {
                  segment += lines[lnum - 1] + "\n";
                }
                segment += lines[end_lineno - 1].substr(0, end_col_offset);
              }
              try {
                let parser = new $B2.Parser(`(
${segment}
)`, "test", "file");
                var ast = $B2._PyPegen.run_parser(parser);
                var tokens = parser.tokens;
                tokens = tokens.slice(1, tokens.length - 3);
              } catch (err2) {
                trace.push(make_report(lines, positions));
                tb = tb.tb_next;
                continue;
              }
              if (!(ast instanceof $B2.ast.Module)) {
                console.log("not a module", ast);
                continue;
              }
              var expr = ast.body[0];
              var marks = "";
              switch (expr.constructor) {
                case $B2.ast.Expr:
                  try {
                    switch (expr.value.constructor) {
                      case $B2.ast.BinOp:
                        trace.push(handle_BinOp_error(
                          lines,
                          lineno2,
                          expr.value,
                          tokens
                        ));
                        break;
                      case $B2.ast.Call:
                        trace.push(handle_Call_error(
                          lines,
                          lineno2,
                          expr.value,
                          tokens
                        ));
                        break;
                      case $B2.ast.Subscript:
                        trace.push(handle_Subscript_error(
                          lines,
                          lineno2,
                          expr.value,
                          tokens
                        ));
                        break;
                      default:
                        trace.push(handle_Expr_error(
                          lines,
                          lineno2,
                          expr.value
                        ));
                        break;
                    }
                  } catch (err2) {
                    if ($B2.get_option("debug") > 1) {
                      console.log("error in error handlers", err2);
                    }
                    trace.push(make_trace_lines(lines, lineno2, expr));
                  }
                  break;
                default:
                  trace.push(make_trace_lines(lines, lineno2, expr));
              }
            } else {
              trace.push("    " + lines[lineno - 1].trim());
            }
          } else {
            if ($B2.get_option("debug") > 1) {
              console.log("no src for filename", filename);
            }
          }
          tb = tb.tb_next;
        }
        if (count_repeats > 1) {
          let len = trace.length;
          for (let i = 0; i < 2; i++) {
            if (src) {
              trace.push(trace[len - 2]);
              trace.push(trace[len - 1]);
            } else {
              trace.push(trace[len - 1]);
            }
          }
          trace.push(`[Previous line repeated ${count_repeats - 2} more times]`);
        }
        return trace.join("\n") + "\n";
      }
      var python_keywords;
      function _find_keyword_typos(err) {
        if (err.msg != "invalid syntax" && !err.msg.includes("Perhaps you forgot a comma")) {
          return;
        }
        let [line, offset, source] = err._metadata;
        let end_line = self.lineno === _b_2.None ? 0 : self.lineno;
        let lines = source.split("\n");
        var error_code;
        if (line > 0) {
          error_code = [lines[line - 1]];
        } else {
          error_code = lines.slice(0, end_line);
        }
        var indent = Math.min(...error_code.map((x) => x.length - x.trimLeft().length));
        var error_code_lines = error_code.map((x) => x.substr(indent));
        error_code = error_code_lines.join("\n");
        if (error_code.length > 1024) {
          return;
        }
        if (python_keywords === void 0) {
          python_keywords = Object.keys($B2.python_keywords);
        }
        for (let token of $B2.tokenizer(error_code, "<debug>", "exec")) {
          if (token.type == $B2.py_tokens["NAME"]) {
            if (python_keywords.includes(token.string)) {
              continue;
            }
            var suggestions = calculate_suggestions(python_keywords, token.string);
            if (suggestions) {
              console.log(token.lineno);
              var new_line = token.line.substr(0, token.col_offset) + suggestions + token.line.substr(token.end_col_offset);
              var new_lines = error_code_lines.slice();
              new_lines.splice(token.lineno - 1, 1, new_line);
              var candidate = new_lines.join("\n");
              var found = false;
              try {
                var parser = new $B2.Parser(candidate, "<debug>", "file");
                parser.flags = $B2.PyCF_ALLOW_INCOMPLETE_INPUT;
                var _ast = $B2._PyPegen.run_parser(parser);
                found = true;
              } catch (err2) {
                if ($B2.is_exc(err2, [_b_2._IncompleteInputError])) {
                  found = true;
                }
              }
              if (found) {
                err.args[1][2] = err.offset = token.col_offset;
                err.args[1][5] = err.end_offset = token.end_col_offset;
                err.args[0] = err.msg = `invalid syntax. Did you mean '${suggestions}'?`;
                return;
              }
            }
          }
        }
      }
      $B2.error_trace = function(err) {
        var trace = "", has_stack = err.__traceback__ !== _b_2.None;
        var debug = $B2.get_option("debug", err);
        if (debug > 1) {
          console.log("handle error", err.__class__, err.args, err.__traceback__);
        }
        if (has_stack) {
          trace = "Traceback (most recent call last):\n";
        }
        if (err.__class__ === _b_2.SyntaxError || err.__class__ === _b_2.IndentationError) {
          trace += trace_from_stack(err);
          if (err.args.length > 0) {
            var filename = err.filename, line = err.text;
            if (line !== _b_2.None) {
              var indent = line.length - line.trimLeft().length;
              trace += `  File "${filename}", line ${err.args[1][1]}
    ${line.trim()}
`;
            }
          }
          if (err.__class__ !== _b_2.IndentationError && err.text && err.text !== _b_2.None) {
            if (err._metadata) {
              _find_keyword_typos(err);
            }
            if ($B2.get_option("debug") > 2) {
              console.log("debug from error", $B2.get_option("debug", err));
              console.log("error args", err.args[1]);
              console.log("err line", line);
              console.log("indent", indent);
            }
            var end_lineno = err.end_lineno === _b_2.None ? err.lineno : err.end_lineno;
            var end_offset = err.end_offset === _b_2.None ? err.offset : err.end_offset;
            var start = err.offset - indent - 1, end_offset = end_offset - 1 + (end_offset == err.offset ? 1 : 0), marks = "    " + " ".repeat(Math.max(0, start)), nb_marks = 1;
            if (end_lineno > err.lineno) {
              nb_marks = line.length - start - indent;
            } else {
              nb_marks = end_offset - start - indent;
            }
            if (nb_marks == 0 && end_offset == line.substr(indent).length) {
              nb_marks = 1;
            }
            marks += "^".repeat(nb_marks) + "\n";
            trace += marks;
          }
          trace += `${err.__class__.__name__}: ${err.args[0] ?? "<no detail available>"}`;
        } else if (err.__class__ !== void 0) {
          var name2 = $B2.class_name(err);
          trace += trace_from_stack(err);
          var args_str = _b_2.str.$factory(err);
          trace += name2 + (args_str ? ": " + args_str : "");
          var save_frame_obj = $B2.frame_obj;
          $B2.frame_obj = err.$frame_obj;
          if (err.__class__ === _b_2.NameError) {
            let suggestion = $B2.offer_suggestions_for_name_error(err);
            if (suggestion !== _b_2.None && suggestion !== err.name) {
              trace += `. Did you mean: '${suggestion}'?`;
            }
            if ($B2.stdlib_module_names.indexOf(err.name) > -1) {
              trace += `. Did you forget to import '${err.name}'?`;
            }
          } else if (err.__class__ === _b_2.AttributeError) {
            var tb = err.__traceback__;
            let suggestion = $B2.offer_suggestions_for_attribute_error(err);
            if (suggestion !== _b_2.None) {
              trace += `. Did you mean: '${suggestion}'?`;
            }
          } else if (err.__class__ === _b_2.ImportError) {
            if (err.$suggestion !== _b_2.None) {
              trace += `. Did you mean: '${err.$suggestion}'?`;
            }
          }
          $B2.frame_obj = save_frame_obj;
        } else {
          trace = err + "";
        }
        if (err.$js_exc) {
          trace += "\n";
          if ($B2.get_option("debug", err) > 1) {
            trace += err.$js_exc.stack;
          }
        }
        return trace;
      };
      $B2.get_stderr = function() {
        return $B2.imported.sys ? $B2.imported.sys.stderr : $B2.imported._sys.stderr;
      };
      $B2.get_stdout = function() {
        return $B2.imported.sys ? $B2.imported.sys.stdout : $B2.imported._sys.stdout;
      };
      $B2.show_error = function(err) {
        if ($B2.get_option("debug", err) > 2) {
          console.debug(err.stack);
        }
        var trace = $B2.error_trace($B2.exception(err));
        try {
          var stderr2 = $B2.get_stderr();
          $B2.$getattr(stderr2, "write")(trace);
          var flush = $B2.$getattr(stderr2, "flush", _b_2.None);
          if (flush !== _b_2.None) {
            flush();
          }
        } catch (print_exc_err) {
          console.debug(trace);
        }
      };
      $B2.handle_error = function(err) {
        if (err.$handled) {
          return;
        }
        err.$handled = true;
        $B2.show_error(err);
        throw err;
      };
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins, None = _b_2.None, range = {
        __class__: _b_2.type,
        __mro__: [_b_2.object],
        __qualname__: "range",
        $is_class: true,
        $native: true,
        $match_sequence_pattern: true,
        $is_sequence: true,
        $not_basetype: true,
        $descriptors: { start: true, step: true, stop: true }
      };
      range.__contains__ = function(self2, other) {
        if (range.__len__(self2) == 0) {
          return false;
        }
        try {
          other = $B2.int_or_bool(other);
        } catch (err) {
          try {
            range.index(self2, other);
            return true;
          } catch (err2) {
            return false;
          }
        }
        var start = _b_2.int.$to_bigint(self2.start), stop = _b_2.int.$to_bigint(self2.stop), step = _b_2.int.$to_bigint(self2.step);
        other = _b_2.int.$to_bigint(other);
        var sub = other - start, fl = sub / step, res = step * fl;
        if (res == sub) {
          if (stop > start) {
            return other >= start && stop > other;
          } else {
            return start >= other && other > stop;
          }
        } else {
          return false;
        }
      };
      range.__delattr__ = function() {
        throw _b_2.AttributeError.$factory("readonly attribute");
      };
      range.__eq__ = function(self2, other) {
        if ($B2.$isinstance(other, range)) {
          var len = range.__len__(self2);
          if (!$B2.rich_comp("__eq__", len, range.__len__(other))) {
            return false;
          }
          if (len == 0) {
            return true;
          }
          if (!$B2.rich_comp("__eq__", self2.start, other.start)) {
            return false;
          }
          if (len == 1) {
            return true;
          }
          return $B2.rich_comp("__eq__", self2.step, other.step);
        }
        return false;
      };
      function compute_item(r, i) {
        var len = range.__len__(r);
        if (len == 0) {
          return r.start;
        } else if (i > len) {
          return r.stop;
        }
        return $B2.rich_op("__add__", r.start, $B2.rich_op("__mul__", r.step, i));
      }
      range.__getitem__ = function(self2, rank) {
        if ($B2.$isinstance(rank, _b_2.slice)) {
          var norm = _b_2.slice.$conv_for_seq(rank, range.__len__(self2)), substep = $B2.rich_op("__mul__", self2.step, norm.step), substart = compute_item(self2, norm.start), substop = compute_item(self2, norm.stop);
          return range.$factory(substart, substop, substep);
        }
        try {
          rank = $B2.PyNumber_Index(rank);
        } catch (err) {
          throw _b_2.TypeError.$factory(`range indices must be integers or slices, not ${$B2.class_name(rank)}`);
        }
        if ($B2.rich_comp("__gt__", 0, rank)) {
          rank = $B2.rich_op("__add__", rank, range.__len__(self2));
        }
        var res = $B2.rich_op("__add__", self2.start, $B2.rich_op("__mul__", rank, self2.step));
        if ($B2.rich_comp("__gt__", self2.step, 0) && ($B2.rich_comp("__ge__", res, self2.stop) || $B2.rich_comp("__gt__", self2.start, res)) || $B2.rich_comp("__gt__", 0, self2.step) && ($B2.rich_comp("__ge__", self2.stop, res) || $B2.rich_comp("__gt__", res, self2.start))) {
          throw _b_2.IndexError.$factory("range object index out of range");
        }
        return res;
      };
      range.__hash__ = function(self2) {
        var len = range.__len__(self2);
        if (len == 0) {
          return _b_2.hash(_b_2.tuple.$factory([0, None, None]));
        }
        if (len == 1) {
          return _b_2.hash(_b_2.tuple.$factory([1, self2.start, None]));
        }
        return _b_2.hash(_b_2.tuple.$factory([len, self2.start, self2.step]));
      };
      var RangeIterator = $B2.make_class(
        "range_iterator",
        function(obj) {
          return { __class__: RangeIterator, obj };
        }
      );
      RangeIterator.__iter__ = function(self2) {
        return self2;
      };
      RangeIterator.__next__ = function(self2) {
        return _b_2.next(self2.obj);
      };
      $B2.set_func_names(RangeIterator, "builtins");
      range.__iter__ = function(self2) {
        var res = { __class__: range, start: self2.start, stop: self2.stop, step: self2.step };
        if (self2.$safe) {
          res.$counter = self2.start - self2.step;
        } else {
          res.$counter = $B2.rich_op("__sub__", self2.start, self2.step);
        }
        return RangeIterator.$factory(res);
      };
      range.__len__ = function(self2) {
        var len, start = _b_2.int.$to_bigint(self2.start), stop = _b_2.int.$to_bigint(self2.stop), step = _b_2.int.$to_bigint(self2.step);
        if (self2.step > 0) {
          if (self2.start >= self2.stop) {
            return 0;
          }
          len = 1n + (stop - start - 1n) / step;
        } else {
          if (self2.stop >= self2.start) {
            return 0;
          }
          len = 1n + (start - stop - 1n) / -step;
        }
        return _b_2.int.$int_or_long(len);
      };
      range.__next__ = function(self2) {
        if (self2.$safe) {
          self2.$counter += self2.step;
          if (self2.step > 0 && self2.$counter >= self2.stop || self2.step < 0 && self2.$counter <= self2.stop) {
            throw _b_2.StopIteration.$factory("");
          }
        } else {
          self2.$counter = $B2.rich_op("__add__", self2.$counter, self2.step);
          if ($B2.rich_comp("__gt__", self2.step, 0) && $B2.rich_comp("__ge__", self2.$counter, self2.stop) || $B2.rich_comp("__gt__", 0, self2.step) && $B2.rich_comp("__ge__", self2.stop, self2.$counter)) {
            throw _b_2.StopIteration.$factory("");
          }
        }
        return self2.$counter;
      };
      range.__reversed__ = function(self2) {
        var n = $B2.rich_op("__sub__", range.__len__(self2), 1);
        return range.$factory($B2.rich_op("__add__", self2.start, $B2.rich_op("__mul__", n, self2.step)), $B2.rich_op("__sub__", self2.start, self2.step), $B2.rich_op("__mul__", -1, self2.step));
      };
      range.__repr__ = function(self2) {
        $B2.builtins_repr_check(range, arguments);
        var res = "range(" + _b_2.str.$factory(self2.start) + ", " + _b_2.str.$factory(self2.stop);
        if (self2.step != 1) {
          res += ", " + _b_2.str.$factory(self2.step);
        }
        return res + ")";
      };
      range.__setattr__ = function() {
        throw _b_2.AttributeError.$factory("readonly attribute");
      };
      range.start = function(self2) {
        return self2.start;
      };
      range.step = function(self2) {
        return self2.step;
      }, range.stop = function(self2) {
        return self2.stop;
      };
      range.count = function(self2, ob) {
        if ($B2.$isinstance(ob, [_b_2.int, _b_2.float, _b_2.bool])) {
          return _b_2.int.$factory(range.__contains__(self2, ob));
        } else {
          var comp = function(other) {
            return $B2.rich_comp("__eq__", ob, other);
          }, it = range.__iter__(self2), _next = RangeIterator.__next__, nb = 0;
          while (true) {
            try {
              if (comp(_next(it))) {
                nb++;
              }
            } catch (err) {
              if ($B2.$isinstance(err, _b_2.StopIteration)) {
                return nb;
              }
              throw err;
            }
          }
        }
      };
      range.index = function() {
        var $ = $B2.args("index", 2, { self: null, other: null }, ["self", "other"], arguments, {}, null, null), self2 = $.self, other = $.other;
        try {
          other = $B2.int_or_bool(other);
        } catch (err) {
          var comp = function(x) {
            return $B2.rich_comp("__eq__", other, x);
          }, it = range.__iter__(self2), _next = RangeIterator.__next__, nb = 0;
          while (true) {
            try {
              if (comp(_next(it))) {
                return nb;
              }
              nb++;
            } catch (err2) {
              if ($B2.$isinstance(err2, _b_2.StopIteration)) {
                throw _b_2.ValueError.$factory(_b_2.str.$factory(other) + " not in range");
              }
              throw err2;
            }
          }
        }
        var sub = $B2.rich_op("__sub__", other, self2.start), fl = $B2.rich_op("__floordiv__", sub, self2.step), res = $B2.rich_op("__mul__", self2.step, fl);
        if ($B2.rich_comp("__eq__", res, sub)) {
          if ($B2.rich_comp("__gt__", self2.stop, self2.start) && $B2.rich_comp("__ge__", other, self2.start) && $B2.rich_comp("__gt__", self2.stop, other) || $B2.rich_comp("__ge__", self2.start, self2.stop) && $B2.rich_comp("__ge__", self2.start, other) && $B2.rich_comp("__gt__", other, self2.stop)) {
            return fl;
          } else {
            throw _b_2.ValueError.$factory(_b_2.str.$factory(other) + " not in range");
          }
        } else {
          throw _b_2.ValueError.$factory(_b_2.str.$factory(other) + " not in range");
        }
      };
      range.$factory = function() {
        var $ = $B2.args("range", 3, { start: null, stop: null, step: null }, ["start", "stop", "step"], arguments, { start: null, stop: null, step: null }, null, null), start = $.start, stop = $.stop, step = $.step, safe;
        if (stop === null && step === null) {
          if (start == null) {
            throw _b_2.TypeError.$factory("range expected 1 arguments, got 0");
          }
          stop = $B2.PyNumber_Index(start);
          safe = typeof stop === "number";
          return { __class__: range, start: 0, stop, step: 1, $is_range: true, $safe: safe };
        }
        if (step === null) {
          step = 1;
        }
        start = $B2.PyNumber_Index(start);
        stop = $B2.PyNumber_Index(stop);
        step = $B2.PyNumber_Index(step);
        if (step == 0) {
          throw _b_2.ValueError.$factory("range arg 3 must not be zero");
        }
        safe = typeof start == "number" && typeof stop == "number" && typeof step == "number";
        return { __class__: range, start, stop, step, $is_range: true, $safe: safe };
      };
      $B2.set_func_names(range, "builtins");
      var slice = {
        __class__: _b_2.type,
        __mro__: [_b_2.object],
        __qualname__: "slice",
        $is_class: true,
        $native: true,
        $not_basetype: true,
        $descriptors: { start: true, step: true, stop: true }
      };
      slice.__eq__ = function(self2, other) {
        var conv1 = conv_slice(self2), conv2 = conv_slice(other);
        return conv1[0] == conv2[0] && conv1[1] == conv2[1] && conv1[2] == conv2[2];
      };
      slice.__repr__ = function(self2) {
        $B2.builtins_repr_check(slice, arguments);
        return "slice(" + _b_2.str.$factory(self2.start) + ", " + _b_2.str.$factory(self2.stop) + ", " + _b_2.str.$factory(self2.step) + ")";
      };
      slice.__setattr__ = function() {
        throw _b_2.AttributeError.$factory("readonly attribute");
      };
      function conv_slice(self2) {
        var attrs = ["start", "stop", "step"], res = [];
        for (var i = 0; i < attrs.length; i++) {
          var val = self2[attrs[i]];
          if (val === _b_2.None) {
            res.push(val);
          } else {
            try {
              res.push($B2.PyNumber_Index(val));
            } catch (err) {
              throw _b_2.TypeError.$factory("slice indices must be integers or None or have an __index__ method");
            }
          }
        }
        return res;
      }
      slice.$conv_for_seq = function(self2, len) {
        var step = self2.step === None ? 1 : $B2.PyNumber_Index(self2.step), step_is_neg = $B2.rich_comp("__gt__", 0, step), len_1 = $B2.rich_op("__sub__", len, 1);
        if (step == 0) {
          throw _b_2.ValueError.$factory("slice step cannot be zero");
        }
        var start, stop;
        if (self2.start === None) {
          start = step_is_neg ? len_1 : 0;
        } else {
          start = $B2.PyNumber_Index(self2.start);
          if ($B2.rich_comp("__gt__", 0, start)) {
            start = $B2.rich_op("__add__", start, len);
            if ($B2.rich_comp("__gt__", 0, start)) {
              start = 0;
            }
          }
          if ($B2.rich_comp("__ge__", start, len)) {
            start = step < 0 ? len_1 : len;
          }
        }
        if (self2.stop === None) {
          stop = step_is_neg ? -1 : len;
        } else {
          stop = $B2.PyNumber_Index(self2.stop);
          if ($B2.rich_comp("__gt__", 0, stop)) {
            stop = $B2.rich_op("__add__", stop, len);
          }
          if ($B2.rich_comp("__ge__", stop, len)) {
            stop = step_is_neg ? len_1 : len;
          }
        }
        return { start, stop, step };
      };
      slice.start = function(self2) {
        return self2.start;
      };
      slice.step = function(self2) {
        return self2.step;
      };
      slice.stop = function(self2) {
        return self2.stop;
      };
      slice.indices = function(self2) {
        var $ = $B2.args("indices", 2, { self: null, length: null }, ["self", "length"], arguments, {}, null, null);
        var len = $B2.PyNumber_Index($.length);
        if (len < 0) {
          throw _b_2.ValueError.$factory("length should not be negative");
        }
        var _step = self2.step == _b_2.None ? 1 : self2.step, _start, _stop;
        if (_step < 0) {
          _start = self2.start;
          _stop = self2.stop;
          _start = _start == _b_2.None ? len - 1 : _start < 0 ? _b_2.max(-1, _start + len) : _b_2.min(len - 1, self2.start);
          _stop = self2.stop == _b_2.None ? -1 : _stop < 0 ? _b_2.max(-1, _stop + len) : _b_2.min(len - 1, self2.stop);
        } else {
          _start = self2.start == _b_2.None ? 0 : _b_2.min(len, self2.start);
          _stop = self2.stop == _b_2.None ? len : _b_2.min(len, self2.stop);
          if (_start < 0) {
            _start = _b_2.max(0, _start + len);
          }
          if (_stop < 0) {
            _stop = _b_2.max(0, _stop + len);
          }
        }
        return _b_2.tuple.$factory([_start, _stop, _step]);
      };
      slice.$fast_slice = function(start, stop, step) {
        return { __class__: _b_2.slice, start, stop, step };
      };
      slice.$factory = function() {
        var $ = $B2.args("slice", 3, { start: null, stop: null, step: null }, ["start", "stop", "step"], arguments, { stop: null, step: null }, null, null);
        return slice.$fast_slice($.start, $.stop, $.step);
      };
      slice.$fast_slice = function(start, stop, step) {
        if (stop === null && step === null) {
          stop = start;
          start = _b_2.None;
          step = _b_2.None;
        } else {
          step = step === null ? _b_2.None : step;
        }
        var res = { __class__: slice, start, stop, step };
        conv_slice(res);
        return res;
      };
      $B2.set_func_names(slice, "builtins");
      _b_2.range = range;
      _b_2.slice = slice;
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      var from_unicode = {}, to_unicode = {};
      function bytes_value(obj) {
        return obj.__class__ === bytes ? obj : fast_bytes(obj.source);
      }
      $B2.to_bytes = function(obj) {
        var res;
        if ($B2.$isinstance(obj, [bytes, bytearray])) {
          res = obj.source;
        } else {
          var ga = $B2.$getattr(obj, "tobytes", null);
          if (ga !== null) {
            res = $B2.$call(ga)().source;
          } else {
            throw _b_2.TypeError.$factory("object doesn't support the buffer protocol");
          }
        }
        return res;
      };
      function _strip(self2, cars, lr) {
        if (cars === void 0) {
          cars = [];
          var ws = "\r\n 	";
          for (let i2 = 0, len = ws.length; i2 < len; i2++) {
            cars.push(ws.charCodeAt(i2));
          }
        } else if ($B2.$isinstance(cars, bytes)) {
          cars = cars.source;
        } else {
          throw _b_2.TypeError.$factory("Type str doesn't support the buffer API");
        }
        if (lr == "l") {
          let i2, len;
          for (i2 = 0, len = self2.source.length; i2 < len; i2++) {
            if (cars.indexOf(self2.source[i2]) == -1) {
              break;
            }
          }
          return bytes.$factory(self2.source.slice(i2));
        }
        let i;
        for (i = self2.source.length - 1; i >= 0; i--) {
          if (cars.indexOf(self2.source[i]) == -1) {
            break;
          }
        }
        return bytes.$factory(self2.source.slice(0, i + 1));
      }
      function invalid(other) {
        return !$B2.$isinstance(other, [bytes, bytearray]);
      }
      var bytearray = { __class__: _b_2.type, __mro__: [_b_2.object], __qualname__: "bytearray", $buffer_protocol: true, $is_sequence: true, $is_class: true };
      var mutable_methods = ["__delitem__", "clear", "copy", "count", "index", "pop", "remove", "reverse"];
      for (var method of mutable_methods) {
        bytearray[method] = /* @__PURE__ */ (function(m) {
          return function(self2) {
            var args = [self2.source], pos2 = 1;
            for (var i = 1, len = arguments.length; i < len; i++) {
              args[pos2++] = arguments[i];
            }
            return _b_2.list[m].apply(null, args);
          };
        })(method);
      }
      bytearray.__hash__ = _b_2.None;
      var bytearray_iterator = $B2.make_iterator_class("bytearray_iterator");
      bytearray.__iter__ = function(self2) {
        return bytearray_iterator.$factory(self2.source);
      };
      bytearray.__mro__ = [_b_2.object];
      bytearray.__repr__ = bytearray.__str__ = function(self2) {
        return "bytearray(" + bytes.__repr__(self2) + ")";
      };
      bytearray.__setitem__ = function(self2, arg, value2) {
        if ($B2.$isinstance(arg, _b_2.int)) {
          if (!$B2.$isinstance(value2, _b_2.int)) {
            throw _b_2.TypeError.$factory("an integer is required");
          } else if (value2 > 255) {
            throw _b_2.ValueError.$factory("byte must be in range(0, 256)");
          }
          var pos2 = arg;
          if (arg < 0) {
            pos2 = self2.source.length + pos2;
          }
          if (pos2 >= 0 && pos2 < self2.source.length) {
            self2.source[pos2] = value2;
          } else {
            throw _b_2.IndexError.$factory("list index out of range");
          }
        } else if ($B2.$isinstance(arg, _b_2.slice)) {
          var start = arg.start === _b_2.None ? 0 : arg.start;
          var stop = arg.stop === _b_2.None ? self2.source.length : arg.stop;
          if (start < 0) {
            start = self2.source.length + start;
          }
          if (stop < 0) {
            stop = self2.source.length + stop;
          }
          self2.source.splice(start, stop - start);
          try {
            var $temp = _b_2.list.$factory(value2);
            for (var i = $temp.length - 1; i >= 0; i--) {
              if (!$B2.$isinstance($temp[i], _b_2.int)) {
                throw _b_2.TypeError.$factory("an integer is required");
              } else if ($temp[i] > 255) {
                throw _b_2.ValueError.$factory("byte must be in range(0, 256)");
              }
              self2.source.splice(start, 0, $temp[i]);
            }
          } catch (err) {
            throw _b_2.TypeError.$factory("can only assign an iterable");
          }
        } else {
          throw _b_2.TypeError.$factory("list indices must be integer, not " + $B2.class_name(arg));
        }
      };
      bytearray.append = function(self2, b) {
        if (arguments.length != 2) {
          throw _b_2.TypeError.$factory(
            "append takes exactly one argument (" + (arguments.length - 1) + " given)"
          );
        }
        if (!$B2.$isinstance(b, _b_2.int)) {
          throw _b_2.TypeError.$factory("an integer is required");
        }
        if (b > 255) {
          throw _b_2.ValueError.$factory("byte must be in range(0, 256)");
        }
        self2.source[self2.source.length] = b;
      };
      bytearray.extend = function(self2, b) {
        if (self2.in_iteration) {
          throw _b_2.BufferError.$factory("Existing exports of data: object cannot be re-sized");
        }
        if (b.__class__ === bytearray || b.__class__ === bytes) {
          self2.source = self2.source.concat(b.source);
          return _b_2.None;
        }
        for (var item2 of $B2.make_js_iterator(b)) {
          bytearray.append(self2, $B2.PyNumber_Index(item2));
        }
        return _b_2.None;
      };
      bytearray.insert = function(self2, pos2, b) {
        if (arguments.length != 3) {
          throw _b_2.TypeError.$factory(
            "insert takes exactly 2 arguments (" + (arguments.length - 1) + " given)"
          );
        }
        if (!$B2.$isinstance(b, _b_2.int)) {
          throw _b_2.TypeError.$factory("an integer is required");
        }
        if (b > 255) {
          throw _b_2.ValueError.$factory("byte must be in range(0, 256)");
        }
        _b_2.list.insert(self2.source, pos2, b);
      };
      bytearray.$factory = function() {
        var args = [bytearray];
        for (var i = 0, len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        return bytearray.__new__.apply(null, args);
      };
      var bytes = { __class__: _b_2.type, __mro__: [_b_2.object], __qualname__: "bytes", $buffer_protocol: true, $is_sequence: true, $is_class: true };
      bytes.__add__ = function(self2, other) {
        var other_bytes;
        if ($B2.$isinstance(other, [bytes, bytearray])) {
          other_bytes = other.source;
        } else if ($B2.$isinstance(other, _b_2.memoryview)) {
          other_bytes = _b_2.memoryview.tobytes(other).source;
        }
        if (other_bytes !== void 0) {
          return {
            __class__: self2.__class__,
            source: self2.source.concat(other_bytes)
          };
        }
        throw _b_2.TypeError.$factory("can't concat bytes to " + _b_2.str.$factory(other));
      };
      bytes.__bytes__ = function(self2) {
        return self2;
      };
      bytes.__contains__ = function(self2, other) {
        if (typeof other == "number") {
          return self2.source.indexOf(other) > -1;
        }
        if (self2.source.length < other.source.length) {
          return false;
        }
        var len = other.source.length;
        for (var i = 0; i < self2.source.length - other.source.length + 1; i++) {
          var flag = true;
          for (var j2 = 0; j2 < len; j2++) {
            if (other.source[i + j2] != self2.source[j2]) {
              flag = false;
              break;
            }
          }
          if (flag) {
            return true;
          }
        }
        return false;
      };
      var bytes_iterator = $B2.make_iterator_class("bytes_iterator");
      bytes.__iter__ = function(self2) {
        return bytes_iterator.$factory(self2.source);
      };
      bytes.__eq__ = function(self2, other) {
        if (invalid(other)) {
          return false;
        }
        if (self2.source.length !== other.source.length) {
          return false;
        }
        for (var i = 0, len = self2.source.length; i < len; i++) {
          if (self2.source[i] !== other.source[i]) {
            return false;
          }
        }
        return true;
      };
      bytes.__ge__ = function(self2, other) {
        if (invalid(other)) {
          return _b_2.NotImplemented;
        }
        return _b_2.list.__ge__(self2.source, other.source);
      };
      bytes.__getitem__ = function(self2, arg) {
        if ($B2.$isinstance(arg, _b_2.int)) {
          let pos2 = arg;
          if (arg < 0) {
            pos2 = self2.source.length + pos2;
          }
          if (pos2 >= 0 && pos2 < self2.source.length) {
            return self2.source[pos2];
          }
          throw _b_2.IndexError.$factory("index out of range");
        } else if ($B2.$isinstance(arg, _b_2.slice)) {
          let s = _b_2.slice.$conv_for_seq(arg, self2.source.length), start = s.start, stop = s.stop, step = s.step;
          let res = [], pos2 = 0;
          if (step > 0) {
            stop = Math.min(stop, self2.source.length);
            if (stop <= start) {
              return bytes.$factory([]);
            }
            for (let i = start; i < stop; i += step) {
              res[pos2++] = self2.source[i];
            }
          } else {
            if (stop >= start) {
              return bytes.$factory([]);
            }
            stop = Math.max(0, stop);
            for (let i = start; i >= stop; i += step) {
              res[pos2++] = self2.source[i];
            }
          }
          return bytes.$factory(res);
        } else if ($B2.$isinstance(arg, _b_2.bool)) {
          return self2.source.__getitem__(_b_2.int.$factory(arg));
        }
      };
      bytes.$getnewargs = function(self2) {
        return $B2.fast_tuple([bytes_value(self2)]);
      };
      bytes.__getnewargs__ = function() {
        return bytes.$getnewargs($B2.single_arg("__getnewargs__", "self", arguments));
      };
      bytes.__gt__ = function(self2, other) {
        if (invalid(other)) {
          return _b_2.NotImplemented;
        }
        return _b_2.list.__gt__(self2.source, other.source);
      };
      bytes.__hash__ = function(self2) {
        if (self2 === void 0) {
          return bytes.__hashvalue__ || $B2.$py_next_hash--;
        }
        var hash = 1;
        for (var i = 0, len = self2.source.length; i < len; i++) {
          hash = 101 * hash + self2.source[i] & 4294967295;
        }
        return hash;
      };
      bytes.__init__ = function() {
        return _b_2.None;
      };
      bytes.__le__ = function(self2, other) {
        if (invalid(other)) {
          return _b_2.NotImplemented;
        }
        return _b_2.list.__le__(self2.source, other.source);
      };
      bytes.__len__ = function(self2) {
        return self2.source.length;
      };
      bytes.__lt__ = function(self2, other) {
        if (invalid(other)) {
          return _b_2.NotImplemented;
        }
        return _b_2.list.__lt__(self2.source, other.source);
      };
      bytes.__mod__ = function(self2, args) {
        var s = decode(self2, "latin-1", "strict"), res = $B2.printf_format(s, "bytes", args);
        return _b_2.str.encode(res, "ascii");
      };
      bytes.__mul__ = function() {
        var $ = $B2.args("__mul__", 2, { self: null, other: null }, ["self", "other"], arguments, {}, null, null), other = $B2.PyNumber_Index($.other);
        var t = [], source = $.self.source, slen = source.length;
        for (var i = 0; i < other; i++) {
          for (var j2 = 0; j2 < slen; j2++) {
            t.push(source[j2]);
          }
        }
        var res = bytes.$factory();
        res.source = t;
        return res;
      };
      bytes.__ne__ = function(self2, other) {
        return !bytes.__eq__(self2, other);
      };
      bytes.__new__ = function() {
        var missing = {}, $ = $B2.args("__new__", 4, { cls: null, source: null, encoding: null, errors: null }, ["cls", "source", "encoding", "errors"], arguments, { source: missing, encoding: missing, errors: missing }, null, null), source = $.source;
        if ($.source === missing) {
          return {
            __class__: $.cls,
            source: []
          };
        } else if (typeof $.source == "string" || $B2.$isinstance($.source, _b_2.str)) {
          if ($.encoding === missing) {
            throw _b_2.TypeError.$factory("string argument without an encoding");
          }
          $.errors = $.errors === missing ? "strict" : $.errors;
          let res = encode($.source, $.encoding, $.errors);
          if (!$B2.$isinstance(res, bytes)) {
            throw _b_2.TypeError.$factory(`'${$.encoding}' codec returns ${$B2.class_name(res)}, not bytes`);
          }
          res.__class__ = $.cls;
          return res;
        }
        if ($.encoding !== missing) {
          throw _b_2.TypeError.$factory("encoding without a string argument");
        }
        if (typeof $.source == "number" || $B2.$isinstance($.source, _b_2.int)) {
          var size = $B2.PyNumber_Index($.source);
          source = [];
          for (var i = 0; i < size; i++) {
            source[i] = 0;
          }
        } else if ($B2.$isinstance($.source, [_b_2.bytes, _b_2.bytearray])) {
          source = $.source.source;
        } else if ($B2.$isinstance($.source, _b_2.memoryview)) {
          source = $.source.obj.source;
        } else {
          var int_list;
          if (Array.isArray($.source)) {
            int_list = $.source;
          } else {
            try {
              int_list = _b_2.list.$factory($.source);
            } catch (err) {
              var bytes_method = $B2.$getattr(source, "__bytes__", _b_2.None);
              if (bytes_method === _b_2.None) {
                throw _b_2.TypeError.$factory(`cannot convert '${$B2.class_name(source)}' object to bytes`);
              }
              let res = $B2.$call(bytes_method)();
              if (!$B2.$isinstance(res, _b_2.bytes)) {
                throw _b_2.TypeError.$factory(`__bytes__ returned non-bytes (type ${$B2.class_name(res)})`);
              }
              return res;
            }
          }
          source = [];
          for (var item2 of int_list) {
            item2 = $B2.PyNumber_Index(item2);
            if (item2 >= 0 && item2 < 256) {
              source.push(item2);
            } else {
              throw _b_2.ValueError.$factory(
                "bytes must be in range (0, 256)"
              );
            }
          }
        }
        return {
          __class__: $.cls,
          source
        };
      };
      bytes.$new = function(cls, source, encoding, errors) {
        var self2 = { __class__: cls }, int_list = [], pos2 = 0;
        if (source === void 0) {
        } else if (typeof source == "number" || $B2.$isinstance(source, _b_2.int)) {
          let i = source;
          while (i--) {
            int_list[pos2++] = 0;
          }
        } else {
          if (typeof source == "string" || $B2.$isinstance(source, _b_2.str)) {
            if (encoding === void 0) {
              throw _b_2.TypeError.$factory("string argument without an encoding");
            }
            int_list = encode(source, encoding || "utf-8", errors || "strict");
          } else {
            if (encoding !== void 0) {
              console.log("encoding", encoding);
              throw _b_2.TypeError.$factory("encoding without a string argument");
            }
            if (Array.isArray(source)) {
              int_list = source;
            } else {
              try {
                int_list = _b_2.list.$factory(source);
              } catch (err) {
                var bytes_method = $B2.$getattr(source, "__bytes__", _b_2.None);
                if (bytes_method === _b_2.None) {
                  throw _b_2.TypeError.$factory(`cannot convert '${$B2.class_name(source)}' object to bytes`);
                }
                var res = $B2.$call(bytes_method)();
                if (!$B2.$isinstance(res, _b_2.bytes)) {
                  throw _b_2.TypeError.$factory(`__bytes__ returned non-bytes (type ${$B2.class_name(res)})`);
                }
                return res;
              }
              for (let i = 0; i < int_list.length; i++) {
                try {
                  var item2 = _b_2.int.$factory(int_list[i]);
                } catch (err) {
                  throw _b_2.TypeError.$factory("'" + $B2.class_name(int_list[i]) + "' object cannot be interpreted as an integer");
                }
                if (item2 < 0 || item2 > 255) {
                  throw _b_2.ValueError.$factory("bytes must be in range(0, 256)");
                }
              }
            }
          }
        }
        self2.source = int_list;
        self2.encoding = encoding;
        self2.errors = errors;
        return self2;
      };
      bytes.__repr__ = bytes.__str__ = function(self2) {
        var t = $B2.special_string_repr, res = "";
        for (var i = 0, len = self2.source.length; i < len; i++) {
          var s = self2.source[i];
          if (t[s] !== void 0) {
            res += t[s];
          } else if (s < 32 || s >= 128) {
            var hx = s.toString(16);
            hx = (hx.length == 1 ? "0" : "") + hx;
            res += "\\x" + hx;
          } else if (s == "\\".charCodeAt(0)) {
            res += "\\\\";
          } else {
            res += String.fromCharCode(s);
          }
        }
        if (res.indexOf("'") > -1 && res.indexOf('"') == -1) {
          return 'b"' + res + '"';
        } else {
          return "b'" + res.replace(new RegExp("'", "g"), "\\'") + "'";
        }
      };
      bytes.capitalize = function(self2) {
        var src = self2.source, len = src.length, buffer = src.slice();
        if (buffer[0] > 96 && buffer[0] < 123) {
          buffer[0] -= 32;
        }
        for (var i = 1; i < len; ++i) {
          if (buffer[i] > 64 && buffer[i] < 91) {
            buffer[i] += 32;
          }
        }
        return bytes.$factory(buffer);
      };
      bytes.center = function() {
        var $ = $B2.args("center", 3, { self: null, width: null, fillbyte: null }, ["self", "width", "fillbyte"], arguments, { fillbyte: bytes.$factory([32]) }, null, null);
        var diff = $.width - $.self.source.length;
        if (diff <= 0) {
          return bytes.$factory($.self.source);
        }
        var ljust = bytes.ljust($.self, $.self.source.length + Math.floor(diff / 2), $.fillbyte);
        return bytes.rjust(ljust, $.width, $.fillbyte);
      };
      bytes.count = function() {
        var $ = $B2.args("count", 4, { self: null, sub: null, start: null, end: null }, ["self", "sub", "start", "end"], arguments, { start: 0, end: -1 }, null, null);
        var n = 0, index = -1, len = 0;
        if (typeof $.sub == "number") {
          if ($.sub < 0 || $.sub > 255)
            throw _b_2.ValueError.$factory("byte must be in range(0, 256)");
          len = 1;
        } else if (!$.sub.__class__) {
          throw _b_2.TypeError.$factory("first argument must be a bytes-like object, not '" + $B2.class_name($.sub) + "'");
        } else if (!$.sub.__class__.$buffer_protocol) {
          throw _b_2.TypeError.$factory("first argument must be a bytes-like object, not '" + $B2.class_name($.sub) + "'");
        } else {
          len = $.sub.source.length;
        }
        do {
          index = bytes.find($.self, $.sub, Math.max(index + len, $.start), $.end);
          if (index != -1) {
            n++;
          }
        } while (index != -1);
        return n;
      };
      bytes.decode = function() {
        var $ = $B2.args("decode", 3, { self: null, encoding: null, errors: null }, ["self", "encoding", "errors"], arguments, { encoding: "utf-8", errors: "strict" }, null, null);
        switch ($.errors) {
          case "strict":
          case "ignore":
          case "replace":
          case "surrogateescape":
          case "surrogatepass":
          case "xmlcharrefreplace":
          case "backslashreplace":
            return decode($.self, $.encoding, $.errors);
          default:
        }
      };
      bytes.endswith = function() {
        var $ = $B2.args("endswith", 4, { self: null, suffix: null, start: null, end: null }, ["self", "suffix", "start", "end"], arguments, { start: -1, end: -1 }, null, null);
        if ($B2.$isinstance($.suffix, bytes)) {
          var end = $.end == -1 ? $.self.source.length : $.end;
          var res = true;
          for (let i = $.suffix.source.length - 1, len = $.suffix.source.length; i >= 0 && res; --i) {
            res = $.self.source[end - len + i] == $.suffix.source[i];
          }
          return res;
        } else if ($B2.$isinstance($.suffix, _b_2.tuple)) {
          for (let i = 0; i < $.suffix.length; ++i) {
            if ($B2.$isinstance($.suffix[i], bytes)) {
              if (bytes.endswith($.self, $.suffix[i], $.start, $.end)) {
                return true;
              }
            } else {
              throw _b_2.TypeError.$factory("endswith first arg must be bytes or a tuple of bytes, not " + $B2.class_name($.suffix));
            }
          }
          return false;
        } else {
          throw _b_2.TypeError.$factory("endswith first arg must be bytes or a tuple of bytes, not " + $B2.class_name($.suffix));
        }
      };
      bytes.expandtabs = function() {
        var $ = $B2.args("expandtabs", 2, { self: null, tabsize: null }, ["self", "tabsize"], arguments, { tabsize: 8 }, null, null);
        var tab_spaces = [];
        for (let i = 0; i < $.tabsize; ++i) {
          tab_spaces.push(32);
        }
        var buffer = $.self.source.slice();
        for (let i = 0; i < buffer.length; ++i) {
          if (buffer[i] === 9) {
            var nb_spaces = $.tabsize - i % $.tabsize;
            var tabs = new Array(nb_spaces);
            tabs.fill(32);
            buffer.splice.apply(buffer, [i, 1].concat(tabs));
          }
        }
        return _b_2.bytes.$factory(buffer);
      };
      bytes.find = function(self2, sub) {
        var start, end;
        if (arguments.length != 2) {
          var $ = $B2.args("find", 4, { self: null, sub: null, start: null, end: null }, ["self", "sub", "start", "end"], arguments, { start: 0, end: -1 }, null, null);
          sub = $.sub;
          start = $.start;
          end = $.end;
        } else {
          start = 0;
          end = -1;
        }
        if (typeof sub == "number") {
          if (sub < 0 || sub > 255) {
            throw _b_2.ValueError.$factory("byte must be in range(0, 256)");
          }
          return self2.source.slice(0, end == -1 ? void 0 : end).indexOf(sub, start);
        } else if (!sub.__class__) {
          throw _b_2.TypeError.$factory("first argument must be a bytes-like object, not '" + $B2.class_name(sub) + "'");
        } else if (!sub.__class__.$buffer_protocol) {
          throw _b_2.TypeError.$factory("first argument must be a bytes-like object, not '" + $B2.class_name(sub) + "'");
        }
        end = end == -1 ? self2.source.length : Math.min(self2.source.length, end);
        var len = sub.source.length;
        for (var i = start; i <= end - len; i++) {
          var chunk = self2.source.slice(i, i + len), found = true;
          for (var j2 = 0; j2 < len; j2++) {
            if (chunk[j2] != sub.source[j2]) {
              found = false;
              break;
            }
          }
          if (found) {
            return i;
          }
        }
        return -1;
      };
      bytes.fromhex = function() {
        var $ = $B2.args("fromhex", 2, { cls: null, string: null }, ["cls", "string"], arguments, {}, null, null), string = $.string.replace(/\s/g, ""), source = [];
        for (var i = 0; i < string.length; i += 2) {
          if (i + 2 > string.length) {
            throw _b_2.ValueError.$factory("non-hexadecimal number found in fromhex() arg");
          }
          source.push(_b_2.int.$factory(string.substr(i, 2), 16));
        }
        return $.cls.$factory(source);
      };
      bytes.hex = function() {
        var $ = $B2.args("hex", 3, { self: null, sep: null, bytes_per_sep: null }, ["self", "sep", "bytes_per_sep"], arguments, { sep: "", bytes_per_sep: 1 }, null, null), self2 = $.self, sep = $.sep, bytes_per_sep = $.bytes_per_sep, res = "", digits = "0123456789abcdef", bps = bytes_per_sep, jstart = bps, len = self2.source.length;
        if (bytes_per_sep < 0) {
          bps = -bytes_per_sep;
          jstart = bps;
        } else if (bytes_per_sep == 0) {
          sep = "";
        } else {
          jstart = len % bps;
          if (jstart == 0) {
            jstart = bps;
          }
        }
        for (var i = 0, j2 = jstart; i < len; i++) {
          var c = self2.source[i];
          if (j2 == 0) {
            res += sep;
            j2 = bps;
          }
          j2--;
          res += digits[c >> 4];
          res += digits[c & 15];
        }
        return res;
      };
      bytes.index = function() {
        var $ = $B2.args("index", 4, { self: null, sub: null, start: null, end: null }, ["self", "sub", "start", "end"], arguments, { start: 0, end: -1 }, null, null);
        var index = bytes.find($.self, $.sub, $.start, $.end);
        console.log("index", index);
        if (index == -1) {
          throw _b_2.ValueError.$factory("subsection not found");
        }
        return index;
      };
      bytes.isalnum = function() {
        var $ = $B2.args("isalnum", 1, { self: null }, ["self"], arguments, {}, null, null), self2 = $.self;
        var src = self2.source, len = src.length, res = len > 0;
        for (var i = 0; i < len && res; ++i) {
          res = src[i] > 96 && src[i] < 123 || src[i] > 64 && src[i] < 91 || src[i] > 47 && src[i] < 58;
        }
        return res;
      };
      bytes.isalpha = function() {
        var $ = $B2.args("isalpha", 1, { self: null }, ["self"], arguments, {}, null, null), self2 = $.self;
        var src = self2.source, len = src.length, res = len > 0;
        for (var i = 0; i < len && res; ++i) {
          res = src[i] > 96 && src[i] < 123 || src[i] > 64 && src[i] < 91;
        }
        return res;
      };
      bytes.isdigit = function() {
        var $ = $B2.args("isdigit", 1, { self: null }, ["self"], arguments, {}, null, null), self2 = $.self;
        var src = self2.source, len = src.length, res = len > 0;
        for (let i = 0; i < len && res; ++i) {
          res = src[i] > 47 && src[i] < 58;
        }
        return res;
      };
      bytes.islower = function() {
        var $ = $B2.args("islower", 1, { self: null }, ["self"], arguments, {}, null, null), self2 = $.self;
        var src = self2.source, len = src.length, res = false;
        for (let i = 0; i < len; ++i) {
          res = res || src[i] > 96 && src[i] < 123;
          if (src[i] > 64 && src[i] < 91) {
            return false;
          }
        }
        return res;
      };
      bytes.isspace = function() {
        var $ = $B2.args("isspace", 1, { self: null }, ["self"], arguments, {}, null, null), self2 = $.self;
        var src = self2.source, len = src.length;
        for (let i = 0; i < len; ++i) {
          switch (src[i]) {
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 32:
              break;
            default:
              return false;
          }
        }
        return true;
      };
      bytes.isupper = function() {
        var $ = $B2.args("isupper", 1, { self: null }, ["self"], arguments, {}, null, null), self2 = $.self;
        var src = self2.source, len = src.length, res = false;
        for (let i = 0; i < len; ++i) {
          res = res || src[i] > 64 && src[i] < 91;
          if (src[i] > 96 && src[i] < 123) {
            return false;
          }
        }
        return res;
      };
      bytes.istitle = function() {
        var $ = $B2.args("istitle", 1, { self: null }, ["self"], arguments, {}, null, null), self2 = $.self;
        var src = self2.source, len = src.length, current_char_is_letter = false, prev_char_was_letter = false, is_uppercase = false, is_lowercase = false;
        for (var i = 0; i < len; ++i) {
          is_lowercase = src[i] > 96 && src[i] < 123;
          is_uppercase = src[i] > 64 && src[i] < 91;
          current_char_is_letter = is_lowercase || is_uppercase;
          if (current_char_is_letter && (prev_char_was_letter && is_uppercase) || !prev_char_was_letter && is_lowercase) {
            return false;
          }
          prev_char_was_letter = current_char_is_letter;
        }
        return true;
      };
      bytes.join = function() {
        var $ns = $B2.args("join", 2, { self: null, iterable: null }, ["self", "iterable"], arguments, {}), self2 = $ns["self"], iterable = $ns["iterable"];
        var next_func = $B2.$getattr(_b_2.iter(iterable), "__next__"), res = self2.__class__.$factory(), empty = true;
        while (true) {
          try {
            var item2 = next_func();
            if (empty) {
              empty = false;
            } else {
              res = bytes.__add__(res, self2);
            }
            res = bytes.__add__(res, item2);
          } catch (err) {
            if ($B2.$isinstance(err, _b_2.StopIteration)) {
              break;
            }
            throw err;
          }
        }
        return res;
      };
      var _lower = function(char_code) {
        if (char_code >= 65 && char_code <= 90) {
          return char_code + 32;
        } else {
          return char_code;
        }
      };
      bytes.lower = function(self2) {
        var _res = [], pos2 = 0;
        for (var i = 0, len = self2.source.length; i < len; i++) {
          if (self2.source[i]) {
            _res[pos2++] = _lower(self2.source[i]);
          }
        }
        return bytes.$factory(_res);
      };
      bytes.ljust = function() {
        var $ = $B2.args("ljust", 3, { self: null, width: null, fillbyte: null }, ["self", "width", "fillbyte"], arguments, { fillbyte: bytes.$factory([32]) }, null, null);
        if (!$.fillbyte.__class__) {
          throw _b_2.TypeError.$factory("argument 2 must be a byte string of length 1, not '" + $B2.class_name($.fillbyte) + "'");
        } else if (!$.fillbyte.__class__.$buffer_protocol) {
          throw _b_2.TypeError.$factory("argument 2 must be a byte string of length 1, not '" + $B2.class_name($.fillbyte) + "'");
        }
        var padding = [], count = $.width - $.self.source.length;
        for (var i = 0; i < count; ++i) {
          padding.push($.fillbyte.source[0]);
        }
        return bytes.$factory($.self.source.concat(padding));
      };
      bytes.lstrip = function(self2, cars) {
        return _strip(self2, cars, "l");
      };
      bytes.maketrans = function(from, to) {
        var _t = [];
        to = $B2.to_bytes(to);
        for (let i = 0; i < 256; i++) {
          _t[i] = i;
        }
        for (let i = 0, len = from.source.length; i < len; i++) {
          var _ndx = from.source[i];
          _t[_ndx] = to[i];
        }
        return bytes.$factory(_t);
      };
      bytes.partition = function() {
        var $ = $B2.args("partition", 2, { self: null, sep: null }, ["self", "sep"], arguments, {}, null, null);
        if (!$.sep.__class__) {
          throw _b_2.TypeError.$factory("a bytes-like object is required, not '" + $B2.class_name($.sep) + "'");
        } else if (!$.sep.__class__.$buffer_protocol) {
          throw _b_2.TypeError.$factory("a bytes-like object is required, not '" + $B2.class_name($.sep) + "'");
        }
        var len = $.sep.source.length, src = $.self.source, i = bytes.find($.self, $.sep);
        return _b_2.tuple.$factory([
          bytes.$factory(src.slice(0, i)),
          bytes.$factory(src.slice(i, i + len)),
          bytes.$factory(src.slice(i + len))
        ]);
      };
      bytes.removeprefix = function() {
        var $ = $B2.args("removeprefix", 2, { self: null, prefix: null }, ["self", "prefix"], arguments, {}, null, null);
        if (!$B2.$isinstance($.prefix, [bytes, bytearray])) {
          throw _b_2.ValueError.$factory(`prefix should be bytes, not '${$B2.class_name($.prefix)}'`);
        }
        if (bytes.startswith($.self, $.prefix)) {
          return bytes.__getitem__($.self, _b_2.slice.$factory($.prefix.source.length, _b_2.None));
        }
        return bytes.__getitem__($.self, _b_2.slice.$factory(0, _b_2.None));
      };
      bytes.removesuffix = function() {
        var $ = $B2.args("removesuffix", 2, { self: null, suffix: null }, ["self", "suffix"], arguments, {}, null, null);
        if (!$B2.$isinstance($.suffix, [bytes, bytearray])) {
          throw _b_2.ValueError.$factory(`suffix should be bytes, not '${$B2.class_name($.suffix)}'`);
        }
        if (bytes.endswith($.self, $.suffix)) {
          return bytes.__getitem__($.self, _b_2.slice.$factory(0, $.suffix.source.length + 1));
        }
        return bytes.__getitem__($.self, _b_2.slice.$factory(0, _b_2.None));
      };
      bytes.replace = function() {
        var $ = $B2.args("replace", 4, { self: null, old: null, new: null, count: null }, ["self", "old", "new", "count"], arguments, { count: -1 }, null, null), res = [];
        var self2 = $.self, src = self2.source, len = src.length, old = $.old, $new = $.new;
        var count = $.count >= 0 ? $.count : src.length;
        if (!$.old.__class__) {
          throw _b_2.TypeError.$factory("first argument must be a bytes-like object, not '" + $B2.class_name($.old) + "'");
        } else if (!$.old.__class__.$buffer_protocol) {
          throw _b_2.TypeError.$factory("first argument must be a bytes-like object, not '" + $B2.class_name($.sep) + "'");
        }
        if (!$.new.__class__) {
          throw _b_2.TypeError.$factory("second argument must be a bytes-like object, not '" + $B2.class_name($.old) + "'");
        } else if (!$.new.__class__.$buffer_protocol) {
          throw _b_2.TypeError.$factory("second argument must be a bytes-like object, not '" + $B2.class_name($.sep) + "'");
        }
        for (var i = 0; i < len; i++) {
          if (bytes.startswith(self2, old, i) && count) {
            for (var j2 = 0; j2 < $new.source.length; j2++) {
              res.push($new.source[j2]);
            }
            i += old.source.length - 1;
            count--;
          } else {
            res.push(src[i]);
          }
        }
        return bytes.$factory(res);
      };
      bytes.rfind = function(self2, subbytes) {
        var sub, start, end;
        if (arguments.length == 2 && subbytes.__class__ === bytes) {
          sub = subbytes;
          start = 0;
          end = -1;
        } else {
          var $ = $B2.args("rfind", 4, { self: null, sub: null, start: null, end: null }, ["self", "sub", "start", "end"], arguments, { start: 0, end: -1 }, null, null);
          sub = $.sub;
          start = $.start;
          end = $.end;
        }
        if (typeof sub == "number") {
          if (sub < 0 || sub > 255) {
            throw _b_2.ValueError.$factory("byte must be in range(0, 256)");
          }
          return $.self.source.slice(start, $.end == -1 ? void 0 : $.end).lastIndexOf(sub) + start;
        } else if (!sub.__class__) {
          throw _b_2.TypeError.$factory("first argument must be a bytes-like object, not '" + $B2.class_name($.sub) + "'");
        } else if (!sub.__class__.$buffer_protocol) {
          throw _b_2.TypeError.$factory("first argument must be a bytes-like object, not '" + $B2.class_name(sub) + "'");
        }
        end = end == -1 ? self2.source.length : Math.min(self2.source.length, end);
        var len = sub.source.length;
        for (var i = end - len; i >= start; --i) {
          var chunk = self2.source.slice(i, i + len), found = true;
          for (var j2 = 0; j2 < len; j2++) {
            if (chunk[j2] != sub.source[j2]) {
              found = false;
              break;
            }
          }
          if (found) {
            return i;
          }
        }
        return -1;
      };
      bytes.rindex = function() {
        var $ = $B2.args("rfind", 4, { self: null, sub: null, start: null, end: null }, ["self", "sub", "start", "end"], arguments, { start: 0, end: -1 }, null, null);
        var index = bytes.rfind($.self, $.sub, $.start, $.end);
        if (index == -1) {
          throw _b_2.ValueError.$factory("subsection not found");
        }
        return index;
      };
      bytes.rjust = function() {
        var $ = $B2.args("rjust", 3, { self: null, width: null, fillbyte: null }, ["self", "width", "fillbyte"], arguments, { fillbyte: bytes.$factory([32]) }, null, null);
        if (!$.fillbyte.__class__) {
          throw _b_2.TypeError.$factory("argument 2 must be a byte string of length 1, not '" + $B2.class_name($.fillbyte) + "'");
        } else if (!$.fillbyte.__class__.$buffer_protocol) {
          throw _b_2.TypeError.$factory("argument 2 must be a byte string of length 1, not '" + $B2.class_name($.fillbyte) + "'");
        }
        var padding = [], count = $.width - $.self.source.length;
        for (var i = 0; i < count; ++i) {
          padding.push($.fillbyte.source[0]);
        }
        return bytes.$factory(padding.concat($.self.source));
      };
      bytes.rpartition = function() {
        var $ = $B2.args("rpartition", 2, { self: null, sep: null }, ["self", "sep"], arguments, {}, null, null);
        if (!$.sep.__class__) {
          throw _b_2.TypeError.$factory("a bytes-like object is required, not '" + $B2.class_name($.sep) + "'");
        } else if (!$.sep.__class__.$buffer_protocol) {
          throw _b_2.TypeError.$factory("a bytes-like object is required, not '" + $B2.class_name($.sep) + "'");
        }
        var len = $.sep.source.length, src = $.self.source, i = bytes.rfind($.self, $.sep);
        return _b_2.tuple.$factory([
          bytes.$factory(src.slice(0, i)),
          bytes.$factory(src.slice(i, i + len)),
          bytes.$factory(src.slice(i + len))
        ]);
      };
      bytes.rstrip = function(self2, cars) {
        return _strip(self2, cars, "r");
      };
      bytes.split = function() {
        var $ = $B2.args("split", 2, { self: null, sep: null }, ["self", "sep"], arguments, { sep: bytes.$factory([32]) }, null, null), res = [], start = 0, stop = 0;
        if (!$.sep.__class__) {
          throw _b_2.TypeError.$factory("a bytes-like object is required, not '" + $B2.class_name($.sep) + "'");
        } else if (!$.sep.__class__.$buffer_protocol) {
          throw _b_2.TypeError.$factory("a bytes-like object is required, not '" + $B2.class_name($.sep) + "'");
        }
        var seps = $.sep.source, len = seps.length, src = $.self.source, blen = src.length;
        while (stop < blen) {
          var match = true;
          for (var i = 0; i < len && match; i++) {
            if (src[stop + i] != seps[i]) {
              match = false;
            }
          }
          if (match) {
            res.push(bytes.$factory(src.slice(start, stop)));
            start = stop + len;
            stop = start;
          } else {
            stop++;
          }
        }
        if (match || stop > start) {
          res.push(bytes.$factory(src.slice(start, stop)));
        }
        return $B2.$list(res);
      };
      bytes.splitlines = function() {
        var $ = $B2.args("splitlines", 2, { self: null, keepends: null }, ["self", "keepends"], arguments, { keepends: false }, null, null);
        if (!$B2.$isinstance($.keepends, [_b_2.bool, _b_2.int])) {
          throw _b_2.TypeError("integer argument expected, got " + $B2.get_class($.keepends).__name);
        }
        var keepends = _b_2.int.$factory($.keepends), res = $B2.$list([]), source = $.self.source, start = 0, pos2 = 0;
        if (!source.length) {
          return res;
        }
        while (pos2 < source.length) {
          if (pos2 < source.length - 1 && source[pos2] == 13 && source[pos2 + 1] == 10) {
            res.push(bytes.$factory(source.slice(start, keepends ? pos2 + 2 : pos2)));
            start = pos2 = pos2 + 2;
          } else if (source[pos2] == 13 || source[pos2] == 10) {
            res.push(bytes.$factory(source.slice(start, keepends ? pos2 + 1 : pos2)));
            start = pos2 = pos2 + 1;
          } else {
            pos2++;
          }
        }
        if (start < source.length) {
          res.push(bytes.$factory(source.slice(start)));
        }
        return $B2.$list(res);
      };
      bytes.startswith = function() {
        var $ = $B2.args("startswith", 3, { self: null, prefix: null, start: null }, ["self", "prefix", "start"], arguments, { start: 0 }, null, null), start = $.start;
        if ($B2.$isinstance($.prefix, bytes)) {
          let res = true;
          for (let i = 0; i < $.prefix.source.length && res; i++) {
            res = $.self.source[start + i] == $.prefix.source[i];
          }
          return res;
        } else if ($B2.$isinstance($.prefix, _b_2.tuple)) {
          let items = [];
          for (let i = 0; i < $.prefix.length; i++) {
            if ($B2.$isinstance($.prefix[i], bytes)) {
              items = items.concat($.prefix[i].source);
            } else {
              throw _b_2.TypeError.$factory("startswith first arg must be bytes or a tuple of bytes, not " + $B2.class_name($.prefix));
            }
          }
          let prefix = bytes.$factory(items);
          return bytes.startswith($.self, prefix, start);
        } else {
          throw _b_2.TypeError.$factory("startswith first arg must be bytes or a tuple of bytes, not " + $B2.class_name($.prefix));
        }
      };
      bytes.strip = function(self2, cars) {
        var res = bytes.lstrip(self2, cars);
        return bytes.rstrip(res, cars);
      };
      bytes.swapcase = function(self2) {
        var src = self2.source, len = src.length, buffer = src.slice();
        for (var i = 0; i < len; ++i) {
          if (buffer[i] > 96 && buffer[i] < 123) {
            buffer[i] -= 32;
          } else if (buffer[i] > 64 && buffer[i] < 91) {
            buffer[i] += 32;
          }
        }
        return bytes.$factory(buffer);
      };
      bytes.title = function(self2) {
        var src = self2.source, len = src.length, buffer = src.slice(), current_char_is_letter = false, prev_char_was_letter = false, is_uppercase = false, is_lowercase = false;
        for (var i = 0; i < len; ++i) {
          is_lowercase = buffer[i] > 96 && buffer[i] < 123;
          is_uppercase = buffer[i] > 64 && buffer[i] < 91;
          current_char_is_letter = is_lowercase || is_uppercase;
          if (current_char_is_letter) {
            if (prev_char_was_letter && is_uppercase) {
              buffer[i] += 32;
            } else if (!prev_char_was_letter && is_lowercase) {
              buffer[i] -= 32;
            }
          }
          prev_char_was_letter = current_char_is_letter;
        }
        return bytes.$factory(buffer);
      };
      bytes.translate = function(self2, table, _delete) {
        if (_delete === void 0) {
          _delete = [];
        } else if ($B2.$isinstance(_delete, bytes)) {
          _delete = _delete.source;
        } else {
          throw _b_2.TypeError.$factory("Type " + $B2.get_class(_delete).__name + " doesn't support the buffer API");
        }
        var res = [], pos2 = 0;
        if ($B2.$isinstance(table, bytes) && table.source.length == 256) {
          for (var i = 0, len = self2.source.length; i < len; i++) {
            if (_delete.indexOf(self2.source[i]) > -1) {
              continue;
            }
            res[pos2++] = table.source[self2.source[i]];
          }
        }
        return bytes.$factory(res);
      };
      var _upper = function(char_code) {
        if (char_code >= 97 && char_code <= 122) {
          return char_code - 32;
        } else {
          return char_code;
        }
      };
      bytes.upper = function(self2) {
        var _res = [], pos2 = 0;
        for (var i = 0, len = self2.source.length; i < len; i++) {
          if (self2.source[i]) {
            _res[pos2++] = _upper(self2.source[i]);
          }
        }
        return bytes.$factory(_res);
      };
      bytes.zfill = function(self2, width) {
        var buffer = self2.source.slice(), prefix_offset = buffer[0] == 43 || buffer[0] == 45 ? 1 : 0;
        var count = width - self2.source.length;
        var padding = [];
        for (var i = 0; i < count; ++i) {
          padding.push(48);
        }
        buffer.splice.apply(buffer, [prefix_offset, 0].concat(padding));
        return bytes.$factory(buffer);
      };
      function $UnicodeEncodeError(encoding, code_point, position) {
        throw _b_2.UnicodeEncodeError.$factory("'" + encoding + "' codec can't encode character " + _b_2.hex(code_point) + " in position " + position);
      }
      function _hex(_int) {
        var h = _int.toString(16);
        return "0x" + "0".repeat(2 - h.length) + h;
      }
      var aliases = { ascii: ["646", "us-ascii"], big5: ["big5-tw", "csbig5"], big5hkscs: ["big5-hkscs", "hkscs"], cp037: ["IBM037", "IBM039"], cp273: ["273", "IBM273", "csIBM273"], cp424: ["EBCDIC-CP-HE", "IBM424"], cp437: ["437", "IBM437"], cp500: ["EBCDIC-CP-BE", "EBCDIC-CP-CH", "IBM500"], cp775: ["IBM775"], cp850: ["850", "IBM850"], cp852: ["852", "IBM852"], cp855: ["855", "IBM855"], cp857: ["857", "IBM857"], cp858: ["858", "IBM858"], cp860: ["860", "IBM860"], cp861: ["861", "CP-IS", "IBM861"], cp862: ["862", "IBM862"], cp863: ["863", "IBM863"], cp864: ["IBM864"], cp865: ["865", "IBM865"], cp866: ["866", "IBM866"], cp869: ["869", "CP-GR", "IBM869"], cp932: ["932", "ms932", "mskanji", "ms-kanji"], cp949: ["949", "ms949", "uhc"], cp950: ["950", "ms950"], cp1026: ["ibm1026"], cp1125: ["1125", "ibm1125", "cp866u", "ruscii"], cp1140: ["ibm1140"], cp1250: ["windows-1250"], cp1251: ["windows-1251"], cp1252: ["windows-1252"], cp1253: ["windows-1253"], cp1254: ["windows-1254"], cp1255: ["windows-1255"], cp1256: ["windows-1256"], cp1257: ["windows-1257"], cp1258: ["windows-1258"], euc_jp: ["eucjp", "ujis", "u-jis"], euc_jis_2004: ["jisx0213", "eucjis2004"], euc_jisx0213: ["eucjisx0213"], euc_kr: ["euckr", "korean", "ksc5601", "ks_c-5601", "ks_c-5601-1987", "ksx1001", "ks_x-1001"], gb2312: ["chinese", "csiso58gb231280", "euc-cn", "euccn", "eucgb2312-cn", "gb2312-1980", "gb2312-80", "iso-ir-58"], gbk: ["936", "cp936", "ms936"], gb18030: ["gb18030-2000"], hz: ["hzgb", "hz-gb", "hz-gb-2312"], iso2022_jp: ["csiso2022jp", "iso2022jp", "iso-2022-jp"], iso2022_jp_1: ["iso2022jp-1", "iso-2022-jp-1"], iso2022_jp_2: ["iso2022jp-2", "iso-2022-jp-2"], iso2022_jp_2004: ["iso2022jp-2004", "iso-2022-jp-2004"], iso2022_jp_3: ["iso2022jp-3", "iso-2022-jp-3"], iso2022_jp_ext: ["iso2022jp-ext", "iso-2022-jp-ext"], iso2022_kr: ["csiso2022kr", "iso2022kr", "iso-2022-kr"], latin_1: ["iso-8859-1", "iso8859-1", "8859", "cp819", "latin", "latin1", "L1"], iso8859_2: ["iso-8859-2", "latin2", "L2"], iso8859_3: ["iso-8859-3", "latin3", "L3"], iso8859_4: ["iso-8859-4", "latin4", "L4"], iso8859_5: ["iso-8859-5", "cyrillic"], iso8859_6: ["iso-8859-6", "arabic"], iso8859_7: ["iso-8859-7", "greek", "greek8"], iso8859_8: ["iso-8859-8", "hebrew"], iso8859_9: ["iso-8859-9", "latin5", "L5"], iso8859_10: ["iso-8859-10", "latin6", "L6"], iso8859_11: ["iso-8859-11", "thai"], iso8859_13: ["iso-8859-13", "latin7", "L7"], iso8859_14: ["iso-8859-14", "latin8", "L8"], iso8859_15: ["iso-8859-15", "latin9", "L9"], iso8859_16: ["iso-8859-16", "latin10", "L10"], johab: ["cp1361", "ms1361"], kz1048: ["kz_1048", "strk1048_2002", "rk1048"], mac_cyrillic: ["maccyrillic"], mac_greek: ["macgreek"], mac_iceland: ["maciceland"], mac_latin2: ["maclatin2", "maccentraleurope", "mac_centeuro"], mac_roman: ["macroman", "macintosh"], mac_turkish: ["macturkish"], ptcp154: ["csptcp154", "pt154", "cp154", "cyrillic-asian"], shift_jis: ["csshiftjis", "shiftjis", "sjis", "s_jis"], shift_jis_2004: ["shiftjis2004", "sjis_2004", "sjis2004"], shift_jisx0213: ["shiftjisx0213", "sjisx0213", "s_jisx0213"], utf_32: ["U32", "utf32"], utf_32_be: ["UTF-32BE"], utf_32_le: ["UTF-32LE"], utf_16: ["U16", "utf16"], utf_16_be: ["UTF-16BE"], utf_16_le: ["UTF-16LE"], utf_7: ["U7", "unicode-1-1-utf-7"], utf_8: ["U8", "UTF", "utf8", "cp65001"], mbcs: ["ansi", "dbcs"], bz2_codec: ["bz2"], hex_codec: ["hex"], quopri_codec: ["quopri", "quotedprintable", "quoted_printable"], uu_codec: ["uu"], zlib_codec: ["zip", "zlib"], rot_13: ["rot13"] };
      var codecs_aliases = {};
      for (var name2 in aliases) {
        for (var alias of aliases[name2]) {
          codecs_aliases[alias.toLowerCase().replace(/-/g, "_")] = name2;
        }
      }
      function normalise(encoding) {
        var enc = encoding.toLowerCase().replace(/ /g, "_").replace(/-/g, "_");
        if (codecs_aliases[enc] !== void 0) {
          enc = codecs_aliases[enc];
        }
        return enc;
      }
      function load_decoder(enc) {
        if (to_unicode[enc] === void 0) {
          var mod = _b_2.__import__("encodings." + enc);
          if (mod[enc].getregentry) {
            to_unicode[enc] = $B2.$getattr(mod[enc].getregentry(), "decode");
          }
        }
      }
      function load_encoder(enc) {
        if (from_unicode[enc] === void 0) {
          var mod = _b_2.__import__("encodings." + enc);
          if (mod[enc].getregentry) {
            from_unicode[enc] = $B2.$getattr(mod[enc].getregentry(), "encode");
          }
        }
      }
      var decode = $B2.decode = function(obj, encoding, errors) {
        var s = "", b = obj.source, enc = normalise(encoding);
        switch (enc) {
          case "utf_8":
          case "utf-8":
          case "utf8":
          case "U8":
          case "UTF":
            if (globalThis.TextDecoder) {
              var decoder = new TextDecoder("utf-8", { fatal: true }), array = new Uint8Array(b);
              try {
                return decoder.decode(array);
              } catch (err) {
              }
            }
            var pos2 = 0, err_info;
            while (pos2 < b.length) {
              let byte = b[pos2];
              err_info = null;
              if (!(byte & 128)) {
                s += String.fromCodePoint(byte);
                pos2++;
              } else if (byte >> 5 == 6) {
                if (b[pos2 + 1] === void 0) {
                  err_info = [byte, pos2, "end"];
                } else if ((b[pos2 + 1] & 192) != 128) {
                  err_info = [byte, pos2, "continuation"];
                }
                if (err_info !== null) {
                  if (errors == "ignore") {
                    pos2++;
                  } else {
                    throw _b_2.UnicodeDecodeError.$factory(
                      "'utf-8' codec can't decode byte 0x" + err_info[0].toString(16) + "  in position " + err_info[1] + (err_info[2] == "end" ? ": unexpected end of data" : ": invalid continuation byte")
                    );
                  }
                } else {
                  let cp = byte & 31;
                  cp <<= 6;
                  cp += b[pos2 + 1] & 63;
                  s += String.fromCodePoint(cp);
                  pos2 += 2;
                }
              } else if (byte >> 4 == 14) {
                if (b[pos2 + 1] === void 0) {
                  err_info = [byte, pos2, "end", pos2 + 1];
                } else if ((b[pos2 + 1] & 192) != 128) {
                  err_info = [byte, pos2, "continuation", pos2 + 2];
                } else if (b[pos2 + 2] === void 0) {
                  err_info = [byte, pos2 + "-" + (pos2 + 1), "end", pos2 + 2];
                } else if ((b[pos2 + 2] & 192) != 128) {
                  err_info = [byte, pos2, "continuation", pos2 + 3];
                }
                if (err_info !== null) {
                  if (errors == "ignore") {
                    pos2 = err_info[3];
                  } else if (errors == "surrogateescape") {
                    for (let i = pos2; i < err_info[3]; i++) {
                      s += String.fromCodePoint(56448 + b[i] - 128);
                    }
                    pos2 = err_info[3];
                  } else {
                    throw _b_2.UnicodeDecodeError.$factory(
                      "'utf-8' codec can't decode byte 0x" + err_info[0].toString(16) + "  in position " + err_info[1] + (err_info[2] == "end" ? ": unexpected end of data" : ": invalid continuation byte")
                    );
                  }
                } else {
                  let cp = byte & 15;
                  cp = cp << 12;
                  cp += (b[pos2 + 1] & 63) << 6;
                  cp += b[pos2 + 2] & 63;
                  s += String.fromCodePoint(cp);
                  pos2 += 3;
                }
              } else if (byte >> 3 == 30) {
                if (b[pos2 + 1] === void 0) {
                  err_info = [byte, pos2, "end", pos2 + 1];
                } else if ((b[pos2 + 1] & 192) != 128) {
                  err_info = [byte, pos2, "continuation", pos2 + 2];
                } else if (b[pos2 + 2] === void 0) {
                  err_info = [byte, pos2 + "-" + (pos2 + 1), "end", pos2 + 2];
                } else if ((b[pos2 + 2] & 192) != 128) {
                  err_info = [byte, pos2, "continuation", pos2 + 3];
                } else if (b[pos2 + 3] === void 0) {
                  err_info = [byte, pos2 + "-" + (pos2 + 1) + "-" + (pos2 + 2), "end", pos2 + 3];
                }
                if (err_info !== null) {
                  if (errors == "ignore") {
                    pos2 = err_info[3];
                  } else if (errors == "surrogateescape") {
                    for (let i = pos2; i < err_info[3]; i++) {
                      s += String.fromCodePoint(56448 + b[i] - 128);
                    }
                    pos2 = err_info[3];
                  } else {
                    throw _b_2.UnicodeDecodeError.$factory(
                      "'utf-8' codec can't decode byte 0x" + err_info[0].toString(16) + "  in position " + err_info[1] + (err_info[2] == "end" ? ": unexpected end of data" : ": invalid continuation byte")
                    );
                  }
                } else {
                  let cp = byte & 15;
                  cp = cp << 18;
                  cp += (b[pos2 + 1] & 63) << 12;
                  cp += (b[pos2 + 2] & 63) << 6;
                  cp += b[pos2 + 3] & 63;
                  s += String.fromCodePoint(cp);
                  pos2 += 4;
                }
              } else {
                if (errors == "ignore") {
                  pos2++;
                } else if (errors == "surrogateescape") {
                  s += String.fromCodePoint(56448 + b[pos2] - 128);
                  pos2++;
                } else {
                  throw _b_2.UnicodeDecodeError.$factory(
                    "'utf-8' codec can't decode byte 0x" + byte.toString(16) + " in position " + pos2 + ": invalid start byte"
                  );
                }
              }
            }
            return s;
          case "latin_1":
          case "windows1252":
          case "iso-8859-1":
          case "iso8859-1":
          case "8859":
          case "cp819":
          case "latin":
          case "latin1":
          case "L1":
            b.forEach(function(item2) {
              s += String.fromCharCode(item2);
            });
            break;
          case "unicode_escape":
            if (obj.__class__ === bytes || obj.__class__ === bytearray) {
              obj = decode(obj, "latin-1", "strict");
            }
            return obj.replace(/\\n/g, "\n").replace(/\\a/g, "\x07").replace(/\\b/g, "\b").replace(/\\f/g, "\f").replace(/\\t/g, "	").replace(/\\'/g, "'").replace(/\\"/g, '"');
          case "raw_unicode_escape":
            if (obj.__class__ === bytes || obj.__class__ === bytearray) {
              obj = decode(obj, "latin-1", "strict");
            }
            return obj.replace(/\\u([a-fA-F0-9]{4})/g, function(mo) {
              let cp = parseInt(mo.substr(2), 16);
              return String.fromCharCode(cp);
            });
          case "ascii":
            for (let i = 0, len = b.length; i < len; i++) {
              let cp = b[i];
              if (cp <= 127) {
                s += String.fromCharCode(cp);
              } else {
                if (errors == "ignore") {
                } else if (errors == "backslashreplace") {
                  s += "\\x" + cp.toString(16);
                } else {
                  let msg = "'ascii' codec can't decode byte 0x" + cp.toString(16) + " in position " + i + ": ordinal not in range(128)";
                  throw _b_2.UnicodeDecodeError.$factory(msg);
                }
              }
            }
            break;
          default:
            try {
              load_decoder(enc);
            } catch (err) {
              throw _b_2.LookupError.$factory("unknown encoding: " + enc);
            }
            var decoded = to_unicode[enc](obj)[0];
            for (let i = 0, len = decoded.length; i < len; i++) {
              if (decoded.codePointAt(i) == 65534) {
                throw _b_2.UnicodeDecodeError.$factory(`'charmap' codec can't decode byte ${_hex(b[i])} in position ${i}: character maps to <undefined>`);
              }
            }
            return decoded;
        }
        return s;
      };
      var encode = $B2.encode = function() {
        var $ = $B2.args("encode", 3, { s: null, encoding: null, errors: null }, ["s", "encoding", "errors"], arguments, { encoding: "utf-8", errors: "strict" }, null, null), s = $.s, encoding = $.encoding, errors = $.errors;
        var t = [], pos2 = 0, enc = normalise(encoding);
        switch (enc) {
          case "utf-8":
          case "utf_8":
          case "utf8":
            if (globalThis.TextEncoder) {
              var encoder = new TextEncoder("utf-8", { fatal: true });
              try {
                var array = encoder.encode(s);
                return fast_bytes(Array.from(array));
              } catch (err) {
              }
            }
            for (let i = 0, len = s.length; i < len; i++) {
              let cp = s.charCodeAt(i);
              if (cp <= 127) {
                t.push(cp);
              } else if (cp <= 2047) {
                t.push(192 + (cp >> 6), 128 + (cp & 63));
              } else if (cp <= 65535) {
                t.push(224 + (cp >> 12), 128 + ((cp & 4095) >> 6), 128 + (cp & 63));
              } else {
                console.log("4 bytes");
              }
            }
            break;
          case "latin":
          case "latin1":
          case "latin-1":
          case "latin_1":
          case "L1":
          case "iso8859_1":
          case "iso_8859_1":
          case "8859":
          case "cp819":
          case "windows1252":
            for (let i = 0, len = s.length; i < len; i++) {
              let cp = s.charCodeAt(i);
              if (cp <= 255) {
                t[pos2++] = cp;
              } else if (errors != "ignore") {
                $UnicodeEncodeError(encoding, i);
              }
            }
            break;
          case "ascii":
            for (let i = 0, len = _b_2.str.__len__(s); i < len; i++) {
              let cp = s.charCodeAt(i), char = _b_2.str.__getitem__(s, i);
              if (cp <= 127) {
                t[pos2++] = cp;
              } else if (errors == "backslashreplace") {
                let hex = _b_2.hex(_b_2.ord(char));
                if (hex.length < 5) {
                  hex = "\\x" + "0".repeat(4 - hex.length) + hex.substr(2);
                } else if (hex.length < 7) {
                  hex = "\\u" + "0".repeat(6 - hex.length) + hex.substr(2);
                } else {
                  hex = "\\U" + "0".repeat(10 - hex.length) + hex.substr(2);
                }
                for (let char2 of hex) {
                  t[pos2++] = char2.charCodeAt(0);
                }
              } else if (errors !== "ignore") {
                $UnicodeEncodeError(encoding, i);
              }
            }
            break;
          case "raw_unicode_escape":
            for (let i = 0, len = s.length; i < len; i++) {
              let cp = s.charCodeAt(i);
              if (cp < 256) {
                t[pos2++] = cp;
              } else {
                let us = cp.toString(16);
                if (us.length % 2) {
                  us = "0" + us;
                }
                us = "\\u" + us;
                for (let j2 = 0; j2 < us.length; j2++) {
                  t[pos2++] = us.charCodeAt(j2);
                }
              }
            }
            break;
          default:
            try {
              load_encoder(enc);
            } catch (err) {
              throw _b_2.LookupError.$factory("unknown encoding: " + encoding);
            }
            return from_unicode[enc](s)[0];
        }
        return fast_bytes(t);
      };
      function fast_bytes(t) {
        return {
          __class__: _b_2.bytes,
          source: t
        };
      }
      $B2.fast_bytes = fast_bytes;
      bytes.$factory = function() {
        return bytes.__new__.bind(null, bytes).apply(null, arguments);
      };
      bytes.__class__ = _b_2.type;
      bytes.$is_class = true;
      $B2.set_func_names(bytes, "builtins");
      bytes.fromhex = _b_2.classmethod.$factory(bytes.fromhex);
      for (var attr in bytes) {
        if (bytearray[attr] === void 0 && typeof bytes[attr] == "function") {
          bytearray[attr] = /* @__PURE__ */ (function(_attr) {
            return function() {
              return bytes[_attr].apply(null, arguments);
            };
          })(attr);
        }
      }
      $B2.set_func_names(bytearray, "builtins");
      bytearray.fromhex = bytes.fromhex;
      _b_2.bytes = bytes;
      _b_2.bytearray = bytearray;
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins, $N = _b_2.None;
      function make_new_set(type) {
        var res = { __class__: type, $store: /* @__PURE__ */ Object.create(null), $version: 0, $used: 0 };
        res[Symbol.iterator] = function* () {
          var version = res.$version;
          for (var item2 of set_iter(res)) {
            yield item2;
            if (res.$version != version) {
              throw _b_2.RuntimeError.$factory(
                "Set changed size during iteration"
              );
            }
          }
        };
        return res;
      }
      function make_new_set_base_type(so) {
        return $B2.$isinstance(so, set) ? set.$factory() : frozenset.$factory();
      }
      function set_add(so, item2, hash) {
        hash = hash ?? $B2.$hash(item2);
        var stored = so.$store[hash];
        if (stored && set_contains(so, item2, hash)) {
          return;
        } else {
          stored = so.$store[hash] = [];
          stored[stored.length] = item2;
          so.$used++;
          so.$version++;
        }
      }
      function set_contains(so, key2, hash) {
        return !!set_lookkey(so, key2, hash);
      }
      function set_copy(obj) {
        var res = make_new_set_base_type(obj);
        for (var hash in obj.$store) {
          res.$store[hash] = obj.$store[hash].slice();
        }
        res.$used = obj.$used;
        return res;
      }
      var set = $B2.make_class("set");
      set.$native = true;
      function set_copy_and_difference(so, other) {
        var result = set_copy(so);
        set_difference_update(result, other);
        return result;
      }
      function set_difference(so, other) {
        var other_size, other_is_dict;
        if ($B2.$isinstance(other, [set, frozenset])) {
          other_size = set.__len__(other);
        } else if ($B2.$isinstance(other, _b_2.dict)) {
          other_size = _b_2.dict.__len__(other);
          other_is_dict = true;
        } else {
          return set_copy_and_difference(so, other);
        }
        if (set.__len__(so) >> 2 > other_size) {
          return set_copy_and_difference(so, other);
        }
        var result = make_new_set();
        if (other_is_dict) {
          for (let entry of set_iter_with_hash(so)) {
            if (!_b_2.dict.$lookup_by_key(other, entry.item, entry.hash).found) {
              set_add(result, entry.item, entry.hash);
            }
          }
          return result;
        }
        for (let entry of set_iter_with_hash(so)) {
          if (!set_contains(other, entry.item, entry.hash)) {
            set_add(result, entry.item, entry.hash);
          }
        }
        result.__class__ = so.__class__;
        return result;
      }
      function set_difference_update(so, other) {
        if (so === other) {
          return set.clear(so);
        }
        if ($B2.$isinstance(other, [set, frozenset])) {
          for (let entry of set_iter_with_hash(other)) {
            set_discard_entry(so, entry.item, entry.hash);
          }
        } else if ($B2.$isinstance(other, _b_2.dict)) {
          for (let entry of _b_2.dict.$iter_items(other)) {
            set_discard_entry(so, entry.key, entry.hash);
          }
        } else {
          var iterator = $B2.make_js_iterator(other);
          for (let key2 of iterator) {
            set_discard_key(so, key2);
          }
        }
      }
      const DISCARD_NOTFOUND = 0;
      function set_discard_entry(so, key2, hash) {
        var entry = set_lookkey(so, key2, hash);
        if (!entry) {
          return DISCARD_NOTFOUND;
        }
        if (so.$store[entry.hash] !== void 0) {
          set_remove(so, entry.hash, entry.index);
        }
      }
      function set_discard_key(so, key2) {
        return set_discard_entry(so, key2);
      }
      function* set_iter(so) {
        var ordered_keys = Object.keys(so.$store).sort();
        for (var hash of ordered_keys) {
          if (so.$store[hash] !== void 0) {
            for (var item2 of so.$store[hash]) {
              yield item2;
            }
          }
        }
      }
      function* set_iter_with_hash(so) {
        for (var hash in so.$store) {
          if (so.$store[hash] !== void 0) {
            for (var item2 of so.$store[hash]) {
              yield { item: item2, hash };
            }
          }
        }
      }
      function set_remove(so, hash, index) {
        so.$store[hash].splice(index, 1);
        if (so.$store[hash].length == 0) {
          delete so.$store[hash];
        }
        so.$used--;
      }
      function set_intersection(so, other) {
        if (so === other) {
          return set_copy(so);
        }
        var result = make_new_set_base_type(so);
        if ($B2.$isinstance(other, [set, frozenset])) {
          if (other.$used > so.$used) {
            var tmp = so;
            so = other;
            other = tmp;
          }
          for (let entry of set_iter_with_hash(other)) {
            if (set_contains(so, entry.item, entry.hash)) {
              set_add(result, entry.item, entry.hash);
            }
          }
        } else if ($B2.$isinstance(other, _b_2.dict)) {
          for (let entry of _b_2.dict.$iter_items(other)) {
            if (set_contains(so, entry.key, entry.hash)) {
              set_add(result, entry.key, entry.hash);
            }
          }
        } else {
          let iterator = $B2.make_js_iterator(other);
          for (var other_item of iterator) {
            var test = set_contains(so, other_item);
            if (test) {
              set_add(result, other_item);
            }
          }
        }
        return result;
      }
      function set_intersection_multi(so, args) {
        var result = set_copy(so);
        if (args.length == 0) {
          return result;
        }
        for (var other of args) {
          result = set_intersection(result, other);
        }
        return result;
      }
      function set_lookkey(so, key2, hash) {
        if (hash === void 0) {
          try {
            hash = $B2.$hash(key2);
          } catch (err) {
            if ($B2.$isinstance(key2, set)) {
              hash = $B2.$hash(frozenset.$factory(key2));
            } else {
              if (err.args && err.args[0]) {
                err.args[0] = `cannot use '${$B2.class_name(key2)}' as a set element (${err.args[0]})`;
              }
              throw err;
            }
          }
        }
        var items = so.$store[hash];
        if (items === void 0) {
          return false;
        }
        for (var index = 0, len = so.$store[hash].length; index < len; index++) {
          if ($B2.is_or_equals(key2, items[index])) {
            return { hash, index };
          }
        }
        return false;
      }
      function set_swap_bodies(a, b) {
        var temp = set_copy(a);
        set.clear(a);
        a.$used = b.$used;
        a.$store = b.$store;
        b.$used = temp.$used;
        b.$store = temp.$store;
      }
      function set_symmetric_difference_update(so, other) {
        if (so == other) {
          return set.clear(so);
        }
        if ($B2.$isinstance(other, _b_2.dict)) {
          for (let entry of _b_2.dict.$iter_items(other)) {
            let rv = set_discard_entry(so, entry.key, entry.hash);
            if (rv == DISCARD_NOTFOUND) {
              set_add(so, entry.key, entry.hash);
            }
          }
        } else if ($B2.$isinstance(other, [set, frozenset])) {
          for (let entry of set_iter_with_hash(other)) {
            let rv = set_discard_entry(so, entry.item, entry.hash);
            if (rv == DISCARD_NOTFOUND) {
              set_add(so, entry.item, entry.hash);
            }
          }
        } else {
          return set_symmetric_difference_update(so, set.$factory(other));
        }
        return _b_2.None;
      }
      set.__and__ = function(self2, other) {
        if (!$B2.$isinstance(other, [set, frozenset])) {
          return _b_2.NotImplemented;
        }
        return set_intersection(self2, other);
      };
      set.__class_getitem__ = $B2.$class_getitem;
      set.__contains__ = function(self2, item2) {
        return set_contains(self2, item2);
      };
      set.__eq__ = function(self2, other) {
        if ($B2.$isinstance(other, [_b_2.set, _b_2.frozenset])) {
          if (self2.$used != other.$used) {
            return false;
          }
          for (var hash in self2.$store) {
            if (other.$store[hash] === void 0) {
              return false;
            }
            var in_self = self2.$store[hash], in_other = other.$store[hash];
            if (in_self === void 0 || in_other === void 0) {
              return false;
            }
            if (in_self.length != in_other.length) {
              return false;
            }
            if (in_self.length == 1) {
              if (!$B2.is_or_equals(in_self[0], in_other[0])) {
                return false;
              }
            } else {
              in_self = in_self.slice();
              in_other = in_other.slice();
              for (var self_item of in_self) {
                var found = false;
                for (var i = 0, len = in_other.length; i < len; i++) {
                  if ($B2.is_or_equals(self_item, in_other[i])) {
                    in_other.splice(i, 1);
                    found = true;
                    break;
                  }
                }
                if (!found) {
                  return false;
                }
              }
            }
          }
          return true;
        }
        return _b_2.NotImplemented;
      };
      set.__format__ = function(self2) {
        return set.__repr__(self2);
      };
      set.__ge__ = function(self2, other) {
        if ($B2.$isinstance(other, [set, frozenset])) {
          return set.__le__(other, self2);
        }
        return _b_2.NotImplemented;
      };
      set.__gt__ = function(self2, other) {
        if ($B2.$isinstance(other, [set, frozenset])) {
          return set.__lt__(other, self2);
        }
        return _b_2.NotImplemented;
      };
      set.__hash__ = _b_2.None;
      set.__init__ = function(self2, iterable) {
        if (iterable === void 0) {
          return _b_2.None;
        }
        $B2.check_nb_args_no_kw("set", 2, arguments);
        if (Object.keys(self2.$store).length > 0) {
          set.clear(self2);
        }
        set.update(self2, iterable);
        return _b_2.None;
      };
      var set_iterator = $B2.make_class(
        "set_iterator",
        function(so) {
          return {
            __class__: set_iterator,
            so,
            it: set_iter(so),
            version: so.$version
          };
        }
      );
      set_iterator.__iter__ = function(self2) {
        return self2;
      };
      set_iterator.__length_hint__ = function(self2) {
        return self2.so.$used;
      };
      set_iterator.__next__ = function(self2) {
        var res = self2.it.next();
        if (res.done) {
          throw _b_2.StopIteration.$factory();
        }
        if (self2.so.$version != self2.version) {
          throw _b_2.RuntimeError.$factory("Set changed size during iteration");
        }
        return res.value;
      };
      set_iterator.__reduce_ex__ = function(self2) {
        return $B2.fast_tuple([_b_2.iter, $B2.fast_tuple([set_make_items(self2.so)])]);
      };
      $B2.set_func_names(set_iterator, "builtins");
      set.__iter__ = function(self2) {
        return set_iterator.$factory(self2);
      };
      function set_make_items(so) {
        var items = [];
        for (var hash in so.$store) {
          items = items.concat(so.$store[hash]);
        }
        return $B2.$list(items);
      }
      set.__le__ = function(self2, other) {
        if ($B2.$isinstance(other, [set, frozenset])) {
          return set.issubset(self2, other);
        }
        return _b_2.NotImplemented;
      };
      set.__len__ = function(self2) {
        return self2.$used;
      };
      set.__lt__ = function(self2, other) {
        if ($B2.$isinstance(other, [set, frozenset])) {
          return set.__le__(self2, other) && set.__len__(self2) < set.__len__(other);
        } else {
          return _b_2.NotImplemented;
        }
      };
      set.__mro__ = [_b_2.object];
      set.__new__ = function(cls, iterable) {
        if (cls === void 0) {
          throw _b_2.TypeError.$factory("set.__new__(): not enough arguments");
        }
        var self2 = make_new_set(cls);
        if (iterable === void 0) {
          return self2;
        }
        if (cls === set) {
          $B2.check_nb_args_no_kw("__new__", 2, arguments);
        }
        return self2;
      };
      set.__or__ = function(self2, other) {
        if ($B2.$isinstance(other, [set, frozenset])) {
          return set.union(self2, other);
        }
        return _b_2.NotImplemented;
      };
      set.__rand__ = function(self2, other) {
        return set.__and__(self2, other);
      };
      set.__reduce__ = function(self2) {
        return $B2.fast_tuple([self2.__class__, $B2.fast_tuple([set_make_items(self2)]), _b_2.None]);
      };
      set.__reduce_ex__ = function(self2) {
        return set.__reduce__(self2);
      };
      set.__repr__ = function(self2) {
        $B2.builtins_repr_check(set, arguments);
        return set_repr(self2);
      };
      function set_repr(self2) {
        var klass_name = $B2.class_name(self2);
        if (self2.$used === 0) {
          return klass_name + "()";
        }
        var head = klass_name + "({", tail = "})";
        if (head == "set({") {
          head = "{";
          tail = "}";
        }
        var res = [];
        if ($B2.repr.enter(self2)) {
          return klass_name + "(...)";
        }
        for (var item2 of set_iter(self2)) {
          var r = _b_2.repr(item2);
          if (r === self2 || r === item2) {
            res.push("{...}");
          } else {
            res.push(r);
          }
        }
        res = res.join(", ");
        $B2.repr.leave(self2);
        return head + res + tail;
      }
      set.__ror__ = function(self2, other) {
        return set.__or__(self2, other);
      };
      set.__rsub__ = function(self2, other) {
        return set.__sub__(self2, other);
      };
      set.__rxor__ = function(self2, other) {
        return set.__xor__(self2, other);
      };
      set.__sub__ = function(self2, other) {
        if (!$B2.$isinstance(other, [set, frozenset])) {
          return _b_2.NotImplemented;
        }
        return set_difference(self2, other);
      };
      set.__xor__ = function(self2, other) {
        if (!$B2.$isinstance(other, [set, frozenset])) {
          return _b_2.NotImplemented;
        }
        var res = make_new_set();
        for (let entry of set_iter_with_hash(self2)) {
          if (!set_contains(other, entry.item, entry.hash)) {
            set_add(res, entry.item, entry.hash);
          }
        }
        for (let entry of set_iter_with_hash(other)) {
          if (!set_contains(self2, entry.item, entry.hash)) {
            set_add(res, entry.item, entry.hash);
          }
        }
        res.__class__ = self2.__class__;
        return res;
      };
      $B2.make_rmethods(set);
      set.add = function(self2, item2) {
        $B2.check_nb_args_no_kw("set.add", 2, arguments);
        set_add(self2, item2);
        return _b_2.None;
      };
      set.clear = function(self2) {
        $B2.check_nb_args_no_kw("set.clear", 1, arguments);
        self2.$used = 0;
        self2.$store = /* @__PURE__ */ Object.create(null);
        self2.$version++;
        return $N;
      };
      set.copy = function(self2) {
        $B2.check_nb_args_no_kw("copy", 1, arguments);
        return set_copy(self2);
      };
      set.difference_update = function(self2) {
        var $ = $B2.args("difference_update", 1, { self: null }, ["self"], arguments, {}, "args", null);
        for (var arg of $.args) {
          set_difference_update(self2, arg);
        }
        self2.$version++;
        return _b_2.None;
      };
      set.discard = function(self2, item2) {
        $B2.check_nb_args_no_kw("set.discard", 2, arguments);
        var result = set_discard_entry(self2, item2);
        if (result != DISCARD_NOTFOUND) {
          self2.$version++;
        }
        return _b_2.None;
      };
      set.intersection_update = function() {
        var $ = $B2.args("intersection_update", 1, { self: null }, ["self"], arguments, {}, "args", null), self2 = $.self, args = $.args;
        var temp = set_intersection_multi(self2, args);
        set_swap_bodies(self2, temp);
        self2.$version++;
        return _b_2.None;
      };
      set.isdisjoint = function(self2, other) {
        $B2.check_nb_args_no_kw("set.isdisjoint", 2, arguments);
        var intersection = set_intersection(self2, other);
        return intersection.$used == 0;
      };
      set.pop = function(self2) {
        if (arguments.length > 1) {
          throw _b_2.TypeError.$factory(`set.pop() takes no arguments (${arguments.length - 1} given)`);
        }
        for (var hash in self2.$store) {
          break;
        }
        if (hash === void 0) {
          throw _b_2.KeyError.$factory("pop from an empty set");
        }
        var item2;
        item2 = self2.$store[hash].pop();
        if (self2.$store[hash].length == 0) {
          delete self2.$store[hash];
        }
        self2.$used--;
        self2.$version++;
        return item2;
      };
      set.remove = function(self2, item2) {
        $B2.check_nb_args_no_kw("set.remove", 2, arguments);
        var result = set_discard_entry(self2, item2);
        if (result == DISCARD_NOTFOUND) {
          throw _b_2.KeyError.$factory(item2);
        }
        self2.$version++;
        return _b_2.None;
      };
      set.symmetric_difference_update = function(self2, s) {
        $B2.check_nb_args_no_kw("set.symmetric_difference_update", 2, arguments);
        return set_symmetric_difference_update(self2, s);
      };
      set.update = function(self2) {
        var $ = $B2.args("update", 1, { self: null }, ["self"], arguments, {}, "args", null);
        for (var iterable of $.args) {
          if (Array.isArray(iterable)) {
            for (let i = 0; i < iterable.length; i++) {
              set_add(self2, iterable[i]);
            }
          } else if ($B2.$isinstance(iterable, [set, frozenset])) {
            for (let entry of set_iter_with_hash(iterable)) {
              set_add(self2, entry.item, entry.hash);
            }
          } else if ($B2.$isinstance(iterable, _b_2.dict)) {
            for (let entry of _b_2.dict.$iter_items(iterable)) {
              set_add(self2, entry.key, entry.hash);
            }
          } else {
            var iterator = $B2.make_js_iterator(iterable);
            for (let item2 of iterator) {
              set_add(self2, item2);
            }
          }
        }
        self2.$version++;
        return _b_2.None;
      };
      set.difference = function() {
        var $ = $B2.args("difference", 1, { self: null }, ["self"], arguments, {}, "args", null);
        if ($.args.length == 0) {
          return set.copy($.self);
        }
        var res = set_copy($.self);
        for (var arg of $.args) {
          if ($B2.$isinstance(arg, [set, frozenset])) {
            for (var entry of set_iter_with_hash(arg)) {
              set_discard_entry(res, entry.item, entry.hash);
            }
          } else {
            var other = set.$factory(arg);
            res = set.difference(res, other);
          }
        }
        return res;
      };
      set.intersection = function() {
        var $ = $B2.args("difference", 1, { self: null }, ["self"], arguments, {}, "args", null);
        if ($.args.length == 0) {
          return set.copy($.self);
        }
        return set_intersection_multi($.self, $.args);
      };
      set.symmetric_difference = function(self2, other) {
        $B2.check_nb_args_no_kw("set.symmetric_difference", 2, arguments);
        var res = set_copy(self2);
        set_symmetric_difference_update(res, other);
        return res;
      };
      set.union = function() {
        var $ = $B2.args("union", 1, { self: null }, ["self"], arguments, {}, "args", null);
        let res = set_copy($.self);
        if ($.args.length == 0) {
          return res;
        }
        for (let arg of $.args) {
          if ($B2.$isinstance(arg, [set, frozenset])) {
            for (let entry of set_iter_with_hash(arg)) {
              set_add(res, entry.item, entry.hash);
            }
          } else if (arg.__class__ === _b_2.dict) {
            for (let entry of _b_2.dict.$iter_items(arg)) {
              set_add(res, entry.key, entry.hash);
            }
          } else {
            let other = set.$factory(arg);
            res = set.union(res, other);
          }
        }
        return res;
      };
      set.issubset = function(self2, other) {
        $B2.check_nb_args_no_kw("set.issubset", 2, arguments);
        if ($B2.$isinstance(other, [set, frozenset])) {
          if (set.__len__(self2) > set.__len__(other)) {
            return false;
          }
          for (let entry of set_iter_with_hash(self2)) {
            if (!set_lookkey(other, entry.item, entry.hash)) {
              return false;
            }
          }
          return true;
        } else if ($B2.$isinstance(other, _b_2.dict)) {
          for (let entry of _b_2.dict.$iter_items(self2)) {
            if (!set_lookkey(other, entry.key, entry.hash)) {
              return false;
            }
          }
          return true;
        } else {
          var member_func = $B2.member_func(other);
          for (let entry of set_iter_with_hash(self2)) {
            if (!member_func(entry.item)) {
              return false;
            }
          }
          return true;
        }
      };
      set.issuperset = function(self2, other) {
        $B2.check_nb_args_no_kw("set.issuperset", 2, arguments);
        if ($B2.$isinstance(other, [set, frozenset])) {
          return set.issubset(other, self2);
        } else {
          return set.issubset(set.$factory(other), self2);
        }
      };
      set.__iand__ = function(self2, other) {
        if (!$B2.$isinstance(other, [set, frozenset])) {
          return _b_2.NotImplemented;
        }
        set.intersection_update(self2, other);
        return self2;
      };
      set.__isub__ = function(self2, other) {
        if (!$B2.$isinstance(other, [set, frozenset])) {
          return _b_2.NotImplemented;
        }
        set_difference_update(self2, other);
        return self2;
      };
      set.__ixor__ = function(self2, other) {
        if (!$B2.$isinstance(other, [set, frozenset])) {
          return _b_2.NotImplemented;
        }
        set.symmetric_difference_update(self2, other);
        return self2;
      };
      set.__ior__ = function(self2, other) {
        if (!$B2.$isinstance(other, [set, frozenset])) {
          return _b_2.NotImplemented;
        }
        set.update(self2, other);
        return self2;
      };
      set.$literal = function(items) {
        let res = make_new_set(set);
        for (let item2 of items) {
          if (item2.constant) {
            set_add(res, item2.constant[0], item2.constant[1]);
          } else if (item2.starred) {
            for (let _item of $B2.make_js_iterator(item2.starred)) {
              set_add(res, _item);
            }
          } else {
            set_add(res, item2.item);
          }
        }
        return res;
      };
      set.$factory = function() {
        var args = [set].concat(Array.from(arguments)), self2 = set.__new__.apply(null, args);
        set.__init__(self2, ...arguments);
        return self2;
      };
      $B2.set_func_names(set, "builtins");
      set.__class_getitem__ = _b_2.classmethod.$factory(set.__class_getitem__);
      var frozenset = $B2.make_class("frozenset");
      frozenset.$native = true;
      for (var attr in set) {
        switch (attr) {
          case "add":
          case "clear":
          case "discard":
          case "pop":
          case "remove":
          case "update":
            break;
          default:
            if (frozenset[attr] == void 0) {
              if (typeof set[attr] == "function") {
                frozenset[attr] = /* @__PURE__ */ (function(x) {
                  return function() {
                    return set[x].apply(null, arguments);
                  };
                })(attr);
              } else {
                frozenset[attr] = set[attr];
              }
            }
        }
      }
      frozenset.__hash__ = function(self2) {
        if (self2 === void 0) {
          return frozenset.__hashvalue__ || $B2.$py_next_hash--;
        }
        if (self2.__hashvalue__ !== void 0) {
          return self2.__hashvalue__;
        }
        var _hash = 1927868237;
        _hash *= self2.$used;
        for (var entry of set_iter_with_hash(self2)) {
          var _h = entry.hash;
          _hash ^= (_h ^ 89869747 ^ _h << 16) * 3644798167;
        }
        _hash = _hash * 69069 + 907133923;
        if (_hash == -1) {
          _hash = 590923713;
        }
        return self2.__hashvalue__ = _hash;
      };
      frozenset.__init__ = function() {
        return _b_2.None;
      };
      frozenset.__new__ = function(cls, iterable) {
        if (cls === void 0) {
          throw _b_2.TypeError.$factory("frozenset.__new__(): not enough arguments");
        }
        var self2 = make_new_set(cls);
        if (iterable === void 0) {
          return self2;
        }
        $B2.check_nb_args_no_kw("__new__", 2, arguments);
        if (cls === frozenset && iterable.__class__ === frozenset) {
          return iterable;
        }
        set.update(self2, iterable);
        return self2;
      };
      frozenset.__repr__ = function(self2) {
        $B2.builtins_repr_check(frozenset, arguments);
        return set_repr(self2);
      };
      frozenset.copy = function(self2) {
        if (self2.__class__ === frozenset) {
          return self2;
        }
        return set_copy(self2);
      };
      frozenset.$factory = function() {
        var args = [frozenset].concat(Array.from(arguments)), self2 = frozenset.__new__.apply(null, args);
        frozenset.__init__(self2, ...arguments);
        return self2;
      };
      $B2.set_func_names(frozenset, "builtins");
      _b_2.set = set;
      _b_2.frozenset = frozenset;
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins, _window = globalThis;
      var Module = $B2.module = $B2.make_class(
        "module",
        function(name2, doc, $package) {
          return {
            $tp_class: Module,
            __builtins__: _b_2.__builtins__,
            __name__: name2,
            __doc__: doc || _b_2.None,
            __package__: $package || _b_2.None
          };
        }
      );
      Module.__annotations__ = _b_2.property.$factory(
        function() {
          return "coucou";
        }
      );
      Module.__dir__ = function(self2) {
        if (self2.__dir__) {
          return $B2.$call(self2.__dir__)();
        }
        var res = [];
        for (var key2 in self2) {
          if (key2.startsWith("$") || key2 == "__class__") {
            continue;
          }
          res[res.length] = key2;
        }
        return $B2.$list(res.sort());
      };
      Module.__new__ = function(cls, name2, doc, $package) {
        return {
          __class__: cls,
          __builtins__: _b_2.__builtins__,
          __name__: name2,
          __doc__: doc || _b_2.None,
          __package__: $package || _b_2.None
        };
      };
      Module.__repr__ = Module.__str__ = function(self2) {
        var res = "<module " + self2.__name__;
        res += self2.__file__ === void 0 ? " (built-in)" : " at " + self2.__file__;
        return res + ">";
      };
      Module.__setattr__ = function(self2, attr, value2) {
        if (self2.__name__ == "__builtins__") {
          $B2.builtins[attr] = value2;
        } else if (self2.__name__ == "builtins") {
          _b_2[attr] = value2;
        } else {
          self2[attr] = value2;
        }
      };
      $B2.set_func_names(Module, "builtins");
      $B2.make_import_paths = function(filename) {
        var filepath = $B2.script_domain ? $B2.script_domain + "/" + filename : filename;
        var elts = filepath.split("/");
        elts.pop();
        var script_dir = elts.join("/"), path = [$B2.brython_path + "Lib", $B2.brython_path + "libs", script_dir, $B2.brython_path + "Lib/site-packages"];
        var meta_path = [], path_hooks = [];
        if ($B2.use_VFS) {
          meta_path.push($B2.finders.VFS);
        }
        var static_stdlib_import = $B2.get_option_from_filename("static_stdlib_import", filename);
        if (static_stdlib_import !== false && $B2.protocol != "file") {
          meta_path.push($B2.finders.stdlib_static);
          if (path.length > 3) {
            path.shift();
            path.shift();
          }
        }
        var pythonpath = $B2.get_option_from_filename("pythonpath", filename);
        if (pythonpath) {
          var ix = path.indexOf(script_dir);
          if (ix === -1) {
            console.log("bizarre, script_dir", script_dir, "not in path", path);
          } else {
            var fullpaths = [];
            for (var p of pythonpath) {
              if (p == ".") {
                fullpaths.push(script_dir);
              } else if (p.startsWith("/")) {
                fullpaths.push($B2.script_domain + p);
              } else if (p.split("://")[0].startsWith("http")) {
                fullpaths.push(p);
              } else if (!p.startsWith($B2.script_domain)) {
                fullpaths.push(script_dir + "/" + p);
              } else {
                fullpaths.push(p);
              }
            }
            path.splice(ix, 1, ...fullpaths);
          }
        }
        if ($B2.protocol !== "file") {
          meta_path.push($B2.finders.path);
          path_hooks.push($B2.url_hook);
        }
        $B2.import_info[filename] = { meta_path, path_hooks, path };
      };
      function $download_module(mod, url) {
        var xhr = new XMLHttpRequest(), fake_qs = "?v=" + (/* @__PURE__ */ new Date()).getTime(), res = null, mod_name = mod.__name__;
        if ($B2.get_option("cache")) {
          xhr.open("GET", url, false);
        } else {
          xhr.open("GET", url + fake_qs, false);
        }
        var timer = _window.setTimeout(function() {
          xhr.abort();
        }, 5e3);
        xhr.send();
        if ($B2.$CORS) {
          if (xhr.status == 200 || xhr.status == 0) {
            res = xhr.responseText;
          } else {
            res = _b_2.ModuleNotFoundError.$factory("No module named '" + mod_name + "'");
          }
        } else {
          if (xhr.readyState == 4) {
            if (xhr.status == 200) {
              res = xhr.responseText;
              mod.$last_modified = xhr.getResponseHeader("Last-Modified");
            } else {
              console.info("Trying to import " + mod_name + ", not found at url " + url);
              res = _b_2.ModuleNotFoundError.$factory("No module named '" + mod_name + "'");
            }
          }
        }
        _window.clearTimeout(timer);
        if (res == null) {
          throw _b_2.ModuleNotFoundError.$factory("No module named '" + mod_name + "' (res is null)");
        }
        if (res.constructor === Error) {
          throw res;
        }
        return res;
      }
      $B2.$download_module = $download_module;
      $B2.addToImported = function(name2, modobj) {
        if ($B2.imported[name2]) {
          for (var attr in $B2.imported[name2]) {
            if (!modobj.hasOwnProperty(attr)) {
              modobj[attr] = $B2.imported[name2][attr];
            }
          }
        }
        $B2.imported[name2] = modobj;
        if (modobj === void 0) {
          throw _b_2.ImportError.$factory("imported not set by module");
        }
        modobj.__class__ = Module;
        modobj.__name__ = name2;
        for (var attr in modobj) {
          if (typeof modobj[attr] == "function" && !modobj[attr].$infos) {
            if (modobj[attr] === _b_2.iter) {
              console.log("set iter", modobj, name2);
            }
            modobj[attr].$infos = { __module__: name2, __name__: attr, __qualname__: attr };
            modobj[attr].$in_js_module = true;
          } else if ($B2.$isinstance(modobj[attr], _b_2.type) && !modobj[attr].hasOwnProperty("__module__")) {
            modobj[attr].__module__ = name2;
          }
        }
      };
      function run_js(module_contents, path, _module) {
        try {
          new Function(module_contents)();
        } catch (err) {
          throw $B2.exception(err);
        }
        var modobj = $B2.imported[_module.__name__];
        if (modobj === void 0) {
          throw _b_2.ImportError.$factory("imported not set by module");
        }
        modobj.__class__ = Module;
        modobj.__name__ = _module.__name__;
        for (var attr in modobj) {
          if (typeof modobj[attr] == "function" && !modobj[attr].$infos) {
            modobj[attr].$infos = { __module__: _module.__name__, __name__: attr, __qualname__: attr };
            modobj[attr].$in_js_module = true;
          } else if ($B2.$isinstance(modobj[attr], _b_2.type) && !modobj[attr].hasOwnProperty("__module__")) {
            modobj[attr].__module__ = _module.__name__;
          }
        }
        return true;
      }
      function run_py(module_contents, path, module2, compiled) {
        var filename = module2.__file__;
        $B2.file_cache[filename] = module_contents;
        $B2.url2name[filename] = module2.__name__;
        var root, js, mod_name = module2.__name__, src;
        if (!compiled) {
          src = { src: module_contents, filename, imported: true };
          try {
            root = $B2.py2js(src, module2, module2.__name__, $B2.builtins_scope);
          } catch (err) {
            err.$frame_obj = $B2.frame_obj;
            if ($B2.get_option("debug", err) > 1) {
              console.log("error in imported module", module2);
              console.log("stack", $B2.make_frames_stack(err.$frame_obj));
            }
            throw err;
          }
        }
        try {
          js = compiled ? module_contents : root.to_js();
          if ($B2.get_option("debug") == 10) {
            console.log("code for module " + module2.__name__);
            console.log($B2.format_indent(js, 0));
          }
          src = js;
          js = "var $module = (function(){\n" + js;
          var prefix = "locals_";
          js += "return " + prefix;
          js += module2.__name__.replace(/\./g, "_") + "})(__BRYTHON__)\nreturn $module";
          var module_id = prefix + module2.__name__.replace(/\./g, "_");
          var mod = new Function(module_id, js)(module2);
        } catch (err) {
          err.$frame_obj = err.$frame_obj || $B2.frame_obj;
          if ($B2.get_option("debug", err) > 2) {
            console.log(err + " for module " + module2.__name__);
            console.log("module", module2);
            console.log(root);
            if ($B2.get_option("debug", err) > 1) {
              console.log($B2.format_indent(js, 0));
            }
            for (let attr in err) {
              console.log(attr, err[attr]);
            }
            console.log("message: " + err.$message);
            console.log("filename: " + err.fileName);
            console.log("linenum: " + err.lineNumber);
            console.log(js.split("\n").slice(err.lineNumber - 3, err.lineNumber + 3).join("\n"));
            console.log(err.stack);
          }
          throw err;
        }
        var imports = Object.keys(root.imports).join(",");
        try {
          for (let attr in mod) {
            module2[attr] = mod[attr];
          }
          module2.__initializing__ = false;
          return {
            content: src,
            name: mod_name,
            imports,
            is_package: module2.$is_package,
            path,
            timestamp: $B2.timestamp,
            source_ts: module2.__spec__.loader_state.timestamp
          };
        } catch (err) {
          console.log("" + err + "  for module " + module2.__name__);
          for (let attr in err) {
            console.log(attr + " " + err[attr]);
          }
          if ($B2.get_option("debug") > 0) {
            console.log("line info " + __BRYTHON__.line_info);
          }
          throw err;
        }
      }
      $B2.run_py = run_py;
      $B2.run_js = run_js;
      var ModuleSpec = $B2.make_class(
        "ModuleSpec",
        function(fields) {
          fields.__class__ = ModuleSpec;
          fields.__dict__ = $B2.empty_dict();
          return fields;
        }
      );
      ModuleSpec.__str__ = ModuleSpec.__repr__ = function(self2) {
        var res = `ModuleSpec(name='${self2.name}', loader=${_b_2.str.$factory(self2.loader)}, origin='${self2.origin}'`;
        if (self2.submodule_search_locations !== _b_2.None) {
          res += `, submodule_search_locations=${_b_2.str.$factory(self2.submodule_search_locations)}`;
        }
        return res + ")";
      };
      $B2.set_func_names(ModuleSpec, "builtins");
      function parent_package(mod_name) {
        var parts = mod_name.split(".");
        parts.pop();
        return parts.join(".");
      }
      var VFSFinder = $B2.make_class(
        "VFSFinder",
        function() {
          return {
            __class__: VFSFinder
          };
        }
      );
      VFSFinder.find_spec = function(cls, fullname) {
        var stored, is_package, timestamp;
        if (!$B2.use_VFS) {
          return _b_2.None;
        }
        stored = $B2.VFS[fullname];
        if (stored === void 0) {
          return _b_2.None;
        }
        is_package = stored[3] || false;
        timestamp = stored.timestamp;
        if (stored) {
          var is_builtin = $B2.builtin_module_names.indexOf(fullname) > -1;
          return ModuleSpec.$factory({
            name: fullname,
            loader: VFSLoader.$factory(),
            origin: is_builtin ? "built-in" : "brython_stdlib",
            submodule_search_locations: is_package ? $B2.$list([]) : _b_2.None,
            loader_state: { stored, timestamp },
            cached: _b_2.None,
            parent: is_package ? fullname : parent_package(fullname),
            has_location: _b_2.False
          });
        }
      };
      $B2.set_func_names(VFSFinder, "<import>");
      for (let method in VFSFinder) {
        if (typeof VFSFinder[method] == "function") {
          VFSFinder[method] = _b_2.classmethod.$factory(
            VFSFinder[method]
          );
        }
      }
      const VFSLoader = $B2.make_class(
        "VFSLoader",
        function() {
          return {
            __class__: VFSLoader
          };
        }
      );
      VFSLoader.create_module = function() {
        return _b_2.None;
      };
      VFSLoader.exec_module = function(self2, modobj) {
        var stored = modobj.__spec__.loader_state.stored, timestamp = modobj.__spec__.loader_state.timestamp;
        var ext = stored[0], module_contents = stored[1], imports = stored[2];
        modobj.$is_package = stored[3] || false;
        var path = "VFS." + modobj.__name__;
        path += modobj.$is_package ? "/__init__.py" : ext;
        modobj.__file__ = path;
        $B2.file_cache[modobj.__file__] = $B2.VFS[modobj.__name__][1];
        $B2.url2name[modobj.__file__] = modobj.__name__;
        if (ext == ".js") {
          run_js(module_contents, modobj.__path__, modobj);
        } else if ($B2.precompiled.hasOwnProperty(modobj.__name__)) {
          if ($B2.get_option("debug") > 1) {
            console.info("load", modobj.__name__, "from precompiled");
          }
          var parts = modobj.__name__.split(".");
          for (var i = 0; i < parts.length; i++) {
            var parent = parts.slice(0, i + 1).join(".");
            if ($B2.imported.hasOwnProperty(parent) && $B2.imported[parent].__initialized__) {
              continue;
            }
            var mod_js = $B2.precompiled[parent], is_package = modobj.$is_package;
            if (mod_js === void 0) {
              continue;
            }
            if (Array.isArray(mod_js)) {
              mod_js = mod_js[0];
            }
            var mod = $B2.imported[parent] = Module.$factory(parent, void 0, is_package);
            mod.__initialized__ = true;
            mod.__spec__ = modobj.__spec__;
            if (is_package) {
              mod.__path__ = "<stdlib>";
              mod.__package__ = parent;
              mod.$is_package = true;
            } else {
              let elts = parent.split(".");
              elts.pop();
              mod.__package__ = elts.join(".");
            }
            mod.__file__ = path;
            try {
              var parent_id = parent.replace(/\./g, "_"), prefix = "locals_";
              mod_js += "return " + prefix + parent_id;
              var $module = new Function(prefix + parent_id, mod_js)(
                mod
              );
            } catch (err) {
              if ($B2.get_option("debug") > 1) {
                console.log("error in module", mod);
                console.log(err);
                for (var k in err) {
                  console.log(k, err[k]);
                }
                console.log(Object.keys($B2.imported));
                console.log(modobj, "mod_js", mod_js);
              }
              throw err;
            }
            for (var attr in $module) {
              mod[attr] = $module[attr];
            }
            $module.__file__ = path;
            if (i > 0) {
              $B2.builtins.setattr(
                $B2.imported[parts.slice(0, i).join(".")],
                parts[i],
                $module
              );
            }
          }
          return $module;
        } else {
          var mod_name = modobj.__name__;
          if ($B2.get_option("debug") > 1) {
            console.log("run Python code from VFS", mod_name);
          }
          var path = $B2.brython_path + "/" + modobj.__file__;
          var record = run_py(module_contents, path, modobj);
          record.imports = imports.join(",");
          record.is_package = modobj.$is_package;
          record.timestamp = $B2.timestamp;
          record.source_ts = timestamp;
          $B2.precompiled[mod_name] = record.is_package ? [record.content] : record.content;
          let elts = mod_name.split(".");
          if (elts.length > 1) {
            elts.pop();
          }
          if ($B2.get_page_option("indexeddb") && $B2.indexedDB && $B2.idb_name) {
            var idb_cx = indexedDB.open($B2.idb_name);
            idb_cx.onsuccess = function(evt) {
              var db = evt.target.result, tx = db.transaction("modules", "readwrite"), store = tx.objectStore("modules"), request = store.put(record);
              request.onsuccess = function() {
                if ($B2.get_option("debug") > 1) {
                  console.info(modobj.__name__, "stored in db");
                }
              };
              request.onerror = function() {
                console.info("could not store " + modobj.__name__);
              };
            };
          }
        }
      };
      $B2.set_func_names(VFSLoader, "builtins");
      var StdlibStaticFinder = $B2.make_class(
        "StdlibStaticFinder",
        function() {
          return {
            __class__: StdlibStaticFinder
          };
        }
      );
      StdlibStaticFinder.find_spec = function(self2, fullname) {
        if ($B2.stdlib && $B2.get_option("static_stdlib_import")) {
          var address = $B2.stdlib[fullname];
          if (address === void 0) {
            var elts = fullname.split(".");
            if (elts.length > 1) {
              elts.pop();
              var $package = $B2.stdlib[elts.join(".")];
              if ($package && $package[1]) {
                address = ["py"];
              }
            }
          }
          if (address !== void 0) {
            var ext = address[0], is_pkg = address[1] !== void 0, path = $B2.brython_path + (ext == "py" ? "Lib/" : "libs/") + fullname.replace(/\./g, "/"), metadata = { ext, is_package: is_pkg, path: path + (is_pkg ? "/__init__.py" : ext == "py" ? ".py" : ".js"), address }, _module = Module.$factory(fullname);
            metadata.code = $download_module(_module, metadata.path);
            var res = ModuleSpec.$factory({
              name: fullname,
              loader: PathLoader.$factory(),
              origin: metadata.path,
              submodule_search_locations: is_pkg ? $B2.$list([path]) : _b_2.None,
              loader_state: metadata,
              cached: _b_2.None,
              parent: is_pkg ? fullname : parent_package(fullname),
              has_location: _b_2.True
            });
            return res;
          }
        }
        return _b_2.None;
      };
      $B2.set_func_names(StdlibStaticFinder, "<import>");
      for (let method in StdlibStaticFinder) {
        if (typeof StdlibStaticFinder[method] == "function") {
          StdlibStaticFinder[method] = _b_2.classmethod.$factory(
            StdlibStaticFinder[method]
          );
        }
      }
      StdlibStaticFinder.$factory = function() {
        return { __class__: StdlibStaticFinder };
      };
      var PathFinder = $B2.make_class(
        "PathFinder",
        function() {
          return {
            __class__: PathFinder
          };
        }
      );
      PathFinder.find_spec = function(cls, fullname, path) {
        if ($B2.VFS && $B2.VFS[fullname]) {
          return _b_2.None;
        }
        if ($B2.is_none(path)) {
          path = get_info("path");
        }
        for (var i = 0, li = path.length; i < li; ++i) {
          var path_entry = path[i];
          if (path_entry[path_entry.length - 1] != "/") {
            path_entry += "/";
          }
          var finder = $B2.path_importer_cache[path_entry];
          if (finder === void 0) {
            var path_hooks = get_info("path_hooks");
            for (var j2 = 0, lj = path_hooks.length; j2 < lj; ++j2) {
              var hook = path_hooks[j2];
              try {
                finder = $B2.$call(hook)(path_entry);
                $B2.path_importer_cache[path_entry] = finder;
                break;
              } catch (e) {
                if (e.__class__ !== _b_2.ImportError) {
                  throw e;
                }
              }
            }
          }
          if ($B2.is_none(finder)) {
            continue;
          }
          var find_spec = $B2.$getattr(finder, "find_spec"), spec = $B2.$call(find_spec)(fullname);
          if (!$B2.is_none(spec)) {
            return spec;
          }
        }
        return _b_2.None;
      };
      $B2.set_func_names(PathFinder, "<import>");
      for (let method in PathFinder) {
        if (typeof PathFinder[method] == "function") {
          PathFinder[method] = _b_2.classmethod.$factory(
            PathFinder[method]
          );
        }
      }
      var PathEntryFinder = $B2.make_class(
        "PathEntryFinder",
        function(path_entry, hint) {
          return {
            __class__: PathEntryFinder,
            path_entry,
            hint
          };
        }
      );
      PathEntryFinder.find_spec = function(self2, fullname) {
        var loader_data = {}, notfound = true, hint = self2.hint, base_path = self2.path_entry + fullname.match(/[^.]+$/g)[0], modpaths = [], py_ext = $B2.get_option("python_extension");
        var tryall = hint === void 0;
        if (tryall || hint == "py") {
          modpaths = modpaths.concat([[base_path + py_ext, "py", false], [base_path + "/__init__" + py_ext, "py", true]]);
        }
        for (var j2 = 0; notfound && j2 < modpaths.length; ++j2) {
          try {
            var file_info = modpaths[j2], module2 = { __name__: fullname, $is_package: false };
            loader_data.code = $download_module(module2, file_info[0], void 0);
            notfound = false;
            loader_data.ext = file_info[1];
            loader_data.is_package = file_info[2];
            loader_data.timestamp = Date.parse(module2.$last_modified);
            if (hint === void 0) {
              self2.hint = file_info[1];
              $B2.path_importer_cache[self2.path_entry] = self2;
            }
            if (loader_data.is_package) {
              $B2.path_importer_cache[base_path + "/"] = $B2.$call(url_hook)(base_path + "/", self2.hint);
            }
            loader_data.path = file_info[0];
          } catch (err) {
            if (err.__class__ !== _b_2.ModuleNotFoundError) {
              throw err;
            }
          }
        }
        if (!notfound) {
          return ModuleSpec.$factory({
            name: fullname,
            loader: PathLoader.$factory(),
            origin: loader_data.path,
            submodule_search_locations: loader_data.is_package ? $B2.$list([base_path]) : _b_2.None,
            loader_state: loader_data,
            cached: _b_2.None,
            parent: loader_data.is_package ? fullname : parent_package(fullname),
            has_location: _b_2.True
          });
        }
        return _b_2.None;
      };
      $B2.set_func_names(PathEntryFinder, "builtins");
      var PathLoader = $B2.make_class(
        "PathLoader",
        function() {
          return {
            __class__: PathLoader
          };
        }
      );
      PathLoader.create_module = function() {
        return _b_2.None;
      };
      PathLoader.exec_module = function(self2, module2) {
        var metadata = module2.__spec__.loader_state;
        module2.$is_package = metadata.is_package;
        if (metadata.ext == "py") {
          run_py(metadata.code, metadata.path, module2);
        } else {
          run_js(metadata.code, metadata.path, module2);
        }
      };
      var url_hook = $B2.url_hook = function(path_entry) {
        path_entry = path_entry.endsWith("/") ? path_entry : path_entry + "/";
        return PathEntryFinder.$factory(path_entry);
      };
      function get_info(info) {
        var filename = $B2.get_filename(), import_info = $B2.import_info[filename];
        if (import_info === void 0 && info == "meta_path") {
          $B2.make_import_paths(filename);
        }
        return $B2.import_info[filename][info];
      }
      function import_engine(mod_name, _path, from_stdlib) {
        var meta_path = get_info("meta_path").slice(), _sys_modules = $B2.imported, _loader, spec;
        if (from_stdlib) {
          var path_ix = meta_path.indexOf($B2.finders["path"]);
          if (path_ix > -1) {
            meta_path.splice(path_ix, 1);
          }
        }
        for (var i = 0, len = meta_path.length; i < len; i++) {
          var _finder = meta_path[i], find_spec = $B2.$getattr(_finder, "find_spec", _b_2.None);
          if (find_spec == _b_2.None) {
            var find_module = $B2.$getattr(_finder, "find_module", _b_2.None);
            if (find_module !== _b_2.None) {
              _loader = find_module(mod_name, _path);
              if (_loader !== _b_2.None) {
                var load_module = $B2.$getattr(_loader, "load_module"), module2 = $B2.$call(load_module)(mod_name);
                _sys_modules[mod_name] = module2;
                return module2;
              }
            }
          } else {
            spec = find_spec(mod_name, _path);
            if (!$B2.is_none(spec)) {
              module2 = $B2.imported[spec.name];
              if (module2 !== void 0) {
                return _sys_modules[spec.name] = module2;
              }
              _loader = $B2.$getattr(spec, "loader", _b_2.None);
              break;
            }
          }
        }
        if (_loader === void 0) {
          var message = mod_name;
          if ($B2.protocol == "file") {
            message += " (warning: cannot import local files with protocol 'file')";
          }
          var exc = _b_2.ModuleNotFoundError.$factory(message);
          exc.name = mod_name;
          throw exc;
        }
        if ($B2.is_none(module2)) {
          if (spec === _b_2.None) {
            throw _b_2.ModuleNotFoundError.$factory(mod_name);
          }
          var _spec_name = $B2.$getattr(spec, "name");
          if (!$B2.is_none(_loader)) {
            var create_module = $B2.$getattr(_loader, "create_module", _b_2.None);
            if (!$B2.is_none(create_module)) {
              module2 = $B2.$call(create_module)(spec);
            }
          }
          if (module2 === void 0) {
            throw _b_2.ImportError.$factory(mod_name);
          }
          if ($B2.is_none(module2)) {
            module2 = $B2.module.$factory(mod_name);
          }
        }
        module2.__name__ = _spec_name;
        module2.__loader__ = _loader;
        module2.__package__ = $B2.$getattr(spec, "parent", "");
        module2.__spec__ = spec;
        var locs = $B2.$getattr(spec, "submodule_search_locations");
        if (module2.$is_package = !$B2.is_none(locs)) {
          module2.__path__ = locs;
        }
        if ($B2.$getattr(spec, "has_location")) {
          module2.__file__ = $B2.$getattr(spec, "origin");
        }
        var cached = $B2.$getattr(spec, "cached");
        if (!$B2.is_none(cached)) {
          module2.__cached__ = cached;
        }
        if ($B2.is_none(_loader)) {
          if (!$B2.is_none(locs)) {
            _sys_modules[_spec_name] = module2;
          } else {
            throw _b_2.ImportError.$factory(mod_name);
          }
        } else {
          var exec_module = $B2.$getattr(_loader, "exec_module", _b_2.None);
          if ($B2.is_none(exec_module)) {
            module2 = $B2.$getattr(_loader, "load_module")(_spec_name);
          } else {
            _sys_modules[_spec_name] = module2;
            try {
              exec_module(module2);
            } catch (e) {
              delete _sys_modules[_spec_name];
              throw e;
            }
          }
        }
        return _sys_modules[_spec_name];
      }
      $B2.path_importer_cache = {};
      function import_error(mod_name) {
        var exc = _b_2.ImportError.$factory(mod_name);
        exc.name = mod_name;
        throw exc;
      }
      $B2.$__import__ = function(mod_name, globals, locals, fromlist) {
        var $test = false;
        if ($test) {
          console.log("__import__", mod_name, "fromlist", fromlist);
          alert();
        }
        var from_stdlib = false;
        if (globals.$jsobj && globals.$jsobj.__file__) {
          var file = globals.$jsobj.__file__;
          if (file.startsWith($B2.brython_path + "Lib/") && !file.startsWith($B2.brython_path + "Lib/site-packages/") || file.startsWith($B2.brython_path + "libs/") || file.startsWith("VFS.")) {
            from_stdlib = true;
          }
        }
        var modobj = $B2.imported[mod_name], parsed_name = mod_name.split("."), has_from = fromlist.length > 0;
        if (modobj == _b_2.None) {
          import_error(mod_name);
        }
        if (modobj === void 0) {
          if ($B2.is_none(fromlist)) {
            fromlist = [];
          }
          for (var i = 0, modsep = "", _mod_name = "", len = parsed_name.length - 1, __path__ = _b_2.None; i <= len; ++i) {
            var _parent_name = _mod_name;
            _mod_name += modsep + parsed_name[i];
            modsep = ".";
            modobj = $B2.imported[_mod_name];
            if ($test) {
              console.log("iter", i, _mod_name, "\nmodobj", modobj, "\n__path__", __path__, Array.isArray(__path__));
              alert();
            }
            if (modobj == _b_2.None) {
              import_error(_mod_name);
            } else if (modobj === void 0) {
              try {
                import_engine(_mod_name, __path__, from_stdlib);
              } catch (err) {
                delete $B2.imported[_mod_name];
                throw err;
              }
              if ($B2.is_none($B2.imported[_mod_name])) {
                import_error(_mod_name);
              } else {
                if (_parent_name) {
                  _b_2.setattr($B2.imported[_parent_name], parsed_name[i], $B2.imported[_mod_name]);
                }
              }
            } else if ($B2.imported[_parent_name] && $B2.imported[_parent_name][parsed_name[i]] === void 0) {
              _b_2.setattr($B2.imported[_parent_name], parsed_name[i], $B2.imported[_mod_name]);
            }
            if (i < len) {
              try {
                __path__ = $B2.$getattr($B2.imported[_mod_name], "__path__");
              } catch (e) {
                if (i == len - 1 && $B2.imported[_mod_name][parsed_name[len]] && $B2.imported[_mod_name][parsed_name[len]].__class__ === $B2.module) {
                  return $B2.imported[_mod_name][parsed_name[len]];
                }
                if (has_from) {
                  import_error(mod_name);
                } else {
                  var exc = _b_2.ModuleNotFoundError.$factory();
                  exc.__traceback__ = $B2.make_tb();
                  exc.msg = "No module named '" + mod_name + "'; '" + _mod_name + "' is not a package";
                  exc.args = $B2.fast_tuple([exc.msg]);
                  exc.name = mod_name;
                  exc.path = _b_2.None;
                  throw exc;
                }
              }
            }
          }
        } else {
          if ($B2.imported[parsed_name[0]] && parsed_name.length == 2) {
            try {
              if ($B2.imported[parsed_name[0]][parsed_name[1]] === void 0) {
                $B2.$setattr($B2.imported[parsed_name[0]], parsed_name[1], modobj);
              }
            } catch (err) {
              console.log("error", parsed_name, modobj);
              throw err;
            }
          }
        }
        if (fromlist.length > 0) {
          return $B2.imported[mod_name];
        } else {
          let package_name = mod_name;
          while (parsed_name.length > 1) {
            var module2 = parsed_name.pop();
            package_name = parsed_name.join(".");
            if ($B2.imported[package_name] === void 0) {
              $B2.$import(package_name, [], {}, locals);
              $B2.imported[package_name][module2] = $B2.imported[mod_name];
              mod_name = module2;
            }
          }
          return $B2.imported[package_name];
        }
      };
      $B2.$import = function(mod_name, fromlist, aliases, locals, inum) {
        var test = false;
        if (test) {
          console.log("import", mod_name, fromlist, aliases);
        }
        if (mod_name == "_frozen_importlib_external") {
          var ns, alias;
          if (aliases[mod_name]) {
            [ns, alias] = aliases[mod_name];
          } else {
            [ns, alias] = [locals, mod_name];
          }
          $B2.$import_from("importlib", ["_bootstrap_external"], { _bootstrap_external: [ns, alias] }, locals, 0);
          let _bootstrap = $B2.imported.importlib._bootstrap, _bootstrap_external = $B2.imported.importlib["_bootstrap_external"];
          _bootstrap_external._set_bootstrap_module(_bootstrap);
          _bootstrap._bootstap_external = _bootstrap_external;
          let _frozen_importlib = $B2.imported._frozen_importlib;
          if (_frozen_importlib) {
            _frozen_importlib._bootstrap_external = _bootstrap_external;
          }
          return;
        }
        var level = 0, frame = $B2.frame_obj.frame, current_module = frame[2], parts = current_module.split(".");
        while (mod_name.length > 0 && mod_name.startsWith(".")) {
          level++;
          mod_name = mod_name.substr(1);
          if (parts.length == 0) {
            throw _b_2.ImportError.$factory("Parent module '' not loaded, cannot perform relative import");
          }
          current_module = parts.join(".");
          parts.pop();
        }
        if (level > 0) {
          mod_name = current_module + (mod_name.length > 0 ? "." + mod_name : "");
        }
        parts = mod_name.split(".");
        if (mod_name[mod_name.length - 1] == ".") {
          parts.pop();
        }
        var norm_parts = [], prefix = true;
        for (var p of parts) {
          if (prefix && p == "") {
            var elt = norm_parts.pop();
            if (elt === void 0) {
              throw _b_2.ImportError.$factory("Parent module '' not loaded, cannot perform relative import");
            }
          } else {
            prefix = false;
            norm_parts.push(p);
          }
        }
        mod_name = norm_parts.join(".");
        fromlist = fromlist === void 0 ? [] : fromlist;
        aliases = aliases === void 0 ? {} : aliases;
        locals = locals === void 0 ? {} : locals;
        if (test) {
          console.log("step 2, mod_name", mod_name, "fromlist", fromlist);
        }
        if ($B2.get_option("debug") == 10) {
          console.log("$import " + mod_name);
          console.log("use VFS ? " + $B2.use_VFS);
          console.log("use static stdlib paths ? " + $B2.get_option("static_stdlib_import"));
        }
        var current_frame = $B2.frame_obj.frame, _globals = current_frame[3], __import__ = _globals["__import__"], globals = $B2.obj_dict(_globals);
        if (__import__ === void 0) {
          __import__ = $B2.$__import__;
        }
        var importer = typeof __import__ == "function" ? __import__ : $B2.$getattr(__import__, "__call__");
        if (test) {
          console.log("use importer", importer, "mod_name", mod_name, "fromlist", fromlist);
        }
        try {
          var modobj = importer(mod_name, globals, void 0, fromlist, 0);
        } catch (err) {
          if (test) {
            console.log("set error", err.__class__);
          }
          $B2.set_inum(inum);
          throw err;
        }
        if (test) {
          console.log("step 3, mod_name", mod_name, "fromlist", fromlist);
          console.log("modobj", modobj);
        }
        if (!fromlist || fromlist.length == 0) {
          let alias2 = aliases[mod_name];
          if (alias2) {
            var [ns, name2] = alias2;
            ns[name2] = $B2.imported[mod_name];
          } else {
            locals[norm_parts[0]] = modobj;
          }
        } else {
          var __all__ = fromlist, thunk = {};
          if (fromlist && fromlist[0] == "*") {
            if (test) {
              console.log("import *", modobj);
            }
            __all__ = $B2.$getattr(modobj, "__all__", thunk);
            if (__all__ !== thunk) {
              aliases = {};
            }
          }
          if (__all__ === thunk) {
            for (var attr in modobj) {
              if (attr[0] !== "_") {
                locals[attr] = modobj[attr];
              }
            }
          } else {
            for (let name3 of __all__) {
              var [ns, alias] = [locals, name3];
              if (aliases[name3]) {
                [ns, alias] = aliases[name3];
              }
              try {
                ns[alias] = $B2.$getattr(modobj, name3);
                if (ns[alias] && ns[alias].$js_func) {
                  ns[alias] = ns[alias].$js_func;
                }
              } catch ($err1) {
                if (!$B2.is_exc($err1, [_b_2.AttributeError])) {
                  $B2.set_inum(inum);
                  throw $err1;
                }
                try {
                  $B2.$getattr(__import__, "__call__")(mod_name + "." + name3, globals, void 0, [], 0);
                  ns[alias] = $B2.$getattr(modobj, name3);
                } catch ($err3) {
                  $B2.set_inum(inum);
                  if (mod_name === "__future__") {
                    var exc = _b_2.SyntaxError.$factory(
                      "future feature " + name3 + " is not defined"
                    );
                    throw exc;
                  }
                  var $frame = [mod_name, modobj, mod_name, modobj], suggestion = $B2.offer_suggestions_for_name_error($err3, $frame);
                  if ($err3.$py_error) {
                    $err3.__class__ = _b_2.ImportError;
                    $err3.args[0] = `cannot import name '${name3}' from '${mod_name}'`;
                    if (modobj.__file__) {
                      $err3.args[0] += ` (${modobj.__file__})`;
                    }
                    $err3.$suggestion = suggestion;
                    throw $err3;
                  }
                  if ($B2.get_option("debug") > 1) {
                    console.log($err3);
                    console.log($B2.frame_obj.frame);
                  }
                  throw _b_2.ImportError.$factory(
                    "cannot import name '" + name3 + "'"
                  );
                }
              }
            }
          }
          return locals;
        }
      };
      $B2.$import_from = function(module2, names, aliases, level, locals, inum) {
        var current_module_name = $B2.frame_obj.frame[2], parts = current_module_name.split("."), relative = level > 0, current_module;
        if (relative) {
          current_module = $B2.imported[parts.join(".")];
          if (current_module === void 0) {
            $B2.set_inum(inum);
            throw _b_2.ImportError.$factory(
              "attempted relative import with no known parent package"
            );
          }
          if (!current_module.$is_package) {
            if (parts.length == 1) {
              $B2.set_inum(inum);
              throw _b_2.ImportError.$factory(
                "attempted relative import with no known parent package"
              );
            } else {
              parts.pop();
              current_module = $B2.imported[parts.join(".")];
            }
          }
          while (level > 0) {
            current_module = $B2.imported[parts.join(".")];
            if (!current_module.$is_package) {
              $B2.set_inum(inum);
              throw _b_2.ImportError.$factory(
                "attempted relative import with no known parent package"
              );
            }
            level--;
            parts.pop();
          }
          if (module2) {
            var submodule = current_module.__name__ + "." + module2;
            $B2.$import(submodule, [], {}, {}, inum);
            current_module = $B2.imported[submodule];
          }
          if (names.length > 0 && names[0] == "*") {
            for (var key2 in current_module) {
              if (key2.startsWith("$") || key2.startsWith("_")) {
                continue;
              }
              locals[key2] = current_module[key2];
            }
          } else {
            for (var name2 of names) {
              var ns, alias;
              if (aliases[name2]) {
                [ns, alias] = aliases[name2];
              } else {
                [ns, alias] = [locals, name2];
              }
              if (current_module[name2] !== void 0) {
                ns[alias] = current_module[name2];
              } else {
                var sub_module = current_module.__name__ + "." + name2;
                $B2.$import(sub_module, [], {}, {});
                ns[alias] = $B2.imported[sub_module];
              }
            }
          }
        } else {
          $B2.$import(module2, names, aliases, locals, inum);
        }
      };
      $B2.$meta_path = [VFSFinder, StdlibStaticFinder, PathFinder];
      $B2.finders = { VFS: VFSFinder, stdlib_static: StdlibStaticFinder, path: PathFinder };
      function optimize_import_for_path(path, filetype) {
        if (path.slice(-1) != "/") {
          path = path + "/";
        }
        var value2 = filetype == "none" ? _b_2.None : url_hook(path, filetype);
        $B2.path_importer_cache[path] = value2;
      }
      var Loader = { __class__: $B2.$type, __mro__: [_b_2.object], __name__: "Loader" };
      var _importlib_module = { __class__: Module, __name__: "_importlib", Loader, VFSFinder, StdlibStatic: StdlibStaticFinder, ImporterPath: PathFinder, UrlPathFinder: url_hook, optimize_import_for_path };
      _importlib_module.__repr__ = _importlib_module.__str__ = function() {
        return "<module '_importlib' (built-in)>";
      };
      $B2.imported["_importlib"] = _importlib_module;
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      var escape2cp = $B2.escape2cp = { b: "\b", f: "\f", n: "\n", r: "\r", t: "	", v: "\v" };
      $B2.surrogates = function(s) {
        var s1 = "", escaped = false;
        for (var char of s) {
          if (escaped) {
            var echar = escape2cp[char];
            if (echar !== void 0) {
              s1 += echar;
            } else {
              s1 += "\\" + char;
            }
            escaped = false;
          } else if (char == "\\") {
            escaped = true;
          } else {
            s1 += char;
          }
        }
        var surrogates = [], j2 = 0;
        for (var i = 0, len = s1.length; i < len; i++) {
          var cp2 = s1.codePointAt(i);
          if (cp2 >= 65536) {
            surrogates.push(j2);
            i++;
          }
          j2++;
        }
        return surrogates;
      };
      $B2.String = function(s) {
        var srg = $B2.surrogates(s);
        return srg.length == 0 ? s : $B2.make_String(s, srg);
      };
      $B2.make_String = function(s, surrogates) {
        var res = new String(s);
        res.__class__ = str;
        res.surrogates = surrogates;
        return res;
      };
      function pypos2jspos(s, pypos) {
        if (s.surrogates === void 0) {
          return pypos;
        }
        var nb = 0;
        while (s.surrogates[nb] < pypos) {
          nb++;
        }
        return pypos + nb;
      }
      function jspos2pypos(s, jspos) {
        if (s.surrogates === void 0) {
          return jspos;
        }
        var nb = 0;
        while (s.surrogates[nb] + nb < jspos) {
          nb++;
        }
        return jspos - nb;
      }
      function to_string(args) {
        if (typeof args == "string") {
          return args;
        }
        if (Array.isArray(args)) {
          for (var i = 0, len = args.length; i < len; i++) {
            args[i] = to_string(args[i]);
          }
          return args;
        } else {
          if (args.__class__ && !(args instanceof String)) {
            return args.$brython_value;
          } else {
            return args;
          }
        }
      }
      var str = { __class__: _b_2.type, __dir__: _b_2.object.__dir__, __qualname__: "str", $is_class: true, $is_sequence: true, $native: true };
      str.$to_string = to_string;
      function normalize_start_end($) {
        var len;
        if (typeof $.self == "string") {
          len = $.self.length;
        } else {
          len = str.__len__($.self);
        }
        if ($.start === null || $.start === _b_2.None) {
          $.start = 0;
        } else if ($.start < 0) {
          $.start += len;
          $.start = Math.max(0, $.start);
        }
        if ($.end === null || $.end === _b_2.None) {
          $.end = len;
        } else if ($.end < 0) {
          $.end += len;
          $.end = Math.max(0, $.end);
        }
        if (!$B2.$isinstance($.start, _b_2.int) || !$B2.$isinstance($.end, _b_2.int)) {
          throw _b_2.TypeError.$factory("slice indices must be integers or None or have an __index__ method");
        }
        if ($.self.surrogates) {
          $.js_start = pypos2jspos($.self, $.start);
          $.js_end = pypos2jspos($.self, $.end);
        }
      }
      function reverse(s) {
        return s.split("").reverse().join("");
      }
      function check_str(obj, prefix2) {
        if (obj instanceof String || typeof obj == "string") {
          return;
        }
        if (!$B2.$isinstance(obj, str)) {
          throw _b_2.TypeError.$factory((prefix2 || "") + "must be str, not " + $B2.class_name(obj));
        }
      }
      function to_chars(s) {
        s = to_string(s);
        return Array.from(s);
      }
      str.__add__ = function(_self, other) {
        if (!$B2.$isinstance(other, str)) {
          try {
            return $B2.$getattr(other, "__radd__")(_self);
          } catch (err) {
            throw _b_2.TypeError.$factory("Can't convert " + $B2.class_name(other) + " to str implicitly");
          }
        }
        [_self, other] = to_string([_self, other]);
        if (typeof _self == "string" && typeof other == "string") {
          return _self + other;
        }
        return $B2.String(_self + other);
      };
      str.__contains__ = function(_self, item2) {
        if (!$B2.$isinstance(item2, str)) {
          throw _b_2.TypeError.$factory("'in <string>' requires string as left operand, not " + $B2.class_name(item2));
        }
        [_self, item2] = to_string([_self, item2]);
        return _self.includes(item2);
      };
      str.__delitem__ = function() {
        throw _b_2.TypeError.$factory("'str' object doesn't support item deletion");
      };
      str.__dir__ = _b_2.object.__dir__;
      str.__eq__ = function(_self, other) {
        if ($B2.$isinstance(other, str)) {
          [_self, other] = to_string([_self, other]);
          return _self + "" == other + "";
        }
        return _b_2.NotImplemented;
      };
      function preformat(_self, fmt) {
        if (fmt.empty) {
          return _b_2.str.$factory(_self);
        }
        if (fmt.type && fmt.type != "s") {
          throw _b_2.ValueError.$factory("Unknown format code '" + fmt.type + "' for object of type 'str'");
        }
        return _self;
      }
      str.__format__ = function(_self, format_spec) {
        [_self, format_spec] = to_string([_self, format_spec]);
        var fmt = new $B2.parse_format_spec(format_spec, _self);
        if (fmt.sign !== void 0) {
          throw _b_2.ValueError.$factory(
            "Sign not allowed in string format specifier"
          );
        }
        if (fmt.precision) {
          _self = _self.substr(0, fmt.precision);
        }
        fmt.align = fmt.align || "<";
        return $B2.format_width(preformat(_self, fmt), fmt);
      };
      str.__getitem__ = function(_self, arg) {
        _self = to_string(_self);
        if ($B2.$isinstance(arg, _b_2.int)) {
          var len = str.__len__(_self);
          var pos2 = arg;
          if (arg < 0) {
            pos2 += len;
          }
          if (pos2 >= 0 && pos2 < len) {
            var jspos = pypos2jspos(_self, pos2);
            if (_self.codePointAt(jspos) >= 65536) {
              return $B2.String(_self.substr(jspos, 2));
            } else {
              return _self[jspos];
            }
          }
          throw _b_2.IndexError.$factory("string index out of range");
        }
        if ($B2.$isinstance(arg, _b_2.slice)) {
          return _b_2.str.$getitem_slice(_self, arg);
        }
        if ($B2.$isinstance(arg, _b_2.bool)) {
          return _self.__getitem__(_b_2.int.$factory(arg));
        }
        throw _b_2.TypeError.$factory("string indices must be integers");
      };
      str.$getitem_slice = function(_self, slice) {
        var len = str.__len__(_self), s = _b_2.slice.$conv_for_seq(slice, len), start = pypos2jspos(_self, s.start), stop = pypos2jspos(_self, s.stop), step = s.step;
        var res = "";
        if (step > 0) {
          if (stop <= start) {
            return "";
          }
          for (let i = start; i < stop; i += step) {
            res += _self[i];
          }
        } else {
          if (stop >= start) {
            return "";
          }
          for (let i = start; i > stop; i += step) {
            res += _self[i];
          }
        }
        return $B2.String(res);
      };
      var prefix = 2, suffix = 3;
      str.$getnewargs = function(self2) {
        return $B2.fast_tuple([to_string(self2)]);
      };
      str.__getnewargs__ = function() {
        return str.$getnewargs($B2.single_arg("__getnewargs__", "self", arguments));
      };
      function cyrb53(str2) {
        let h1 = 3735928559, h2 = 1103547991;
        for (let i = 0, ch; i < str2.length; i++) {
          ch = str2.charCodeAt(i);
          h1 = Math.imul(h1 ^ ch, 2654435761);
          h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);
        h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
        h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
        h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);
        return 4294967296 * (2097151 & h2) + (h1 >>> 0);
      }
      ;
      str.__hash__ = function(_self) {
        var s = to_string(_self);
        let h1 = 3735928559, h2 = 1103547991;
        for (let i = 0, ch; i < s.length; i++) {
          ch = s.charCodeAt(i);
          h1 = Math.imul(h1 ^ ch, 2654435761);
          h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);
        h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
        h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
        h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);
        return 4294967296 * (2097151 & h2) + (h1 >>> 0);
      };
      str.__init__ = function() {
        return _b_2.None;
      };
      var str_iterator = $B2.make_class(
        "str_iterator",
        function(s) {
          return {
            __class__: str_iterator,
            it: s[Symbol.iterator]()
          };
        }
      );
      str_iterator.__iter__ = function(_self) {
        return _self;
      };
      str_iterator.__next__ = function(_self) {
        var res = _self.it.next();
        if (res.done) {
          throw _b_2.StopIteration.$factory("");
        }
        return res.value;
      };
      $B2.set_func_names(str_iterator, "builtins");
      str.__iter__ = function(_self) {
        return str_iterator.$factory(_self);
      };
      str.__len__ = function(_self) {
        _self = to_string(_self);
        if (_self.surrogates === void 0) {
          return _self.length;
        }
        if (_self.len !== void 0) {
          return _self.len;
        }
        var len = _self.len = _self.length - _self.surrogates.length;
        return len;
      };
      var number_check = function(s, flags) {
        if (!$B2.$isinstance(s, [_b_2.int, _b_2.float])) {
          var type = flags.conversion_type;
          throw _b_2.TypeError.$factory(`%${type} format: a real number is required, not ${$B2.class_name(s)}`);
        }
      };
      var get_char_array = function(size, char) {
        if (size <= 0) {
          return "";
        }
        return new Array(size + 1).join(char);
      };
      var format_padding = function(s, flags, minus_one) {
        var padding = flags.padding;
        if (!padding) {
          return s;
        }
        s = s.toString();
        padding = parseInt(padding, 10);
        if (minus_one) {
          padding -= 1;
        }
        if (!flags.left) {
          return get_char_array(padding - s.length, flags.pad_char) + s;
        } else {
          return s + get_char_array(padding - s.length, flags.pad_char);
        }
      };
      const max_precision = 2 ** 31 - 4, max_repeat = 2 ** 30 - 1;
      var format_int_precision = function(val, flags) {
        var precision = flags.precision;
        if (!precision) {
          return _b_2.str.$factory(val);
        }
        precision = parseInt(precision, 10);
        if (precision > max_precision) {
          throw _b_2.OverflowError.$factory("precision too large");
        }
        var s;
        if (val.__class__ === $B2.long_int) {
          s = $B2.long_int.to_base(val, 10);
        } else {
          s = val.toString();
        }
        if (precision - s.length > max_repeat) {
          throw _b_2.OverflowError.$factory("precision too large");
        }
        if (s[0] === "-") {
          return "-" + "0".repeat(Math.max(0, precision - s.length + 1)) + s.slice(1);
        }
        return "0".repeat(Math.max(0, precision - s.length)) + s;
      };
      var format_float_precision = function(val, upper, flags, modifier) {
        var precision = flags.precision;
        if (isFinite(val)) {
          return modifier(val, precision, flags, upper);
        }
        if (val === Infinity) {
          val = "inf";
        } else if (val === -Infinity) {
          val = "-inf";
        } else {
          val = "nan";
        }
        if (upper) {
          return val.toUpperCase();
        }
        return val;
      };
      var format_sign = function(val, flags) {
        if (flags.sign) {
          if (val >= 0 || isNaN(val) || val === Number.POSITIVE_INFINITY) {
            return "+";
          }
        } else if (flags.space) {
          if (val >= 0 || isNaN(val)) {
            return " ";
          }
        }
        return "";
      };
      var str_format = function(val, flags) {
        flags.pad_char = " ";
        return format_padding(str.$factory(val), flags);
      };
      var num_format = function(val, flags) {
        number_check(val, flags);
        if ($B2.$isinstance(val, _b_2.float)) {
          val = parseInt(val.value);
        } else if (!$B2.$isinstance(val, _b_2.int)) {
          val = parseInt(val);
        } else if ($B2.$isinstance(val, _b_2.bool)) {
          val = val ? 1 : 0;
        }
        var s = format_int_precision(val, flags);
        if (flags.pad_char === "0") {
          if (val < 0) {
            s = s.substring(1);
            return "-" + format_padding(s, flags, true);
          }
          var sign = format_sign(val, flags);
          if (sign !== "") {
            return sign + format_padding(s, flags, true);
          }
        }
        return format_padding(format_sign(val, flags) + s, flags);
      };
      var repr_format = function(val, flags) {
        flags.pad_char = " ";
        return format_padding(_b_2.repr(val), flags);
      };
      var ascii_format = function(val, flags, type) {
        flags.pad_char = " ";
        var ascii;
        if (type == "bytes") {
          var repr = _b_2.repr(val);
          ascii = _b_2.str.encode(repr, "ascii", "backslashreplace");
          ascii = _b_2.bytes.decode(ascii, "ascii");
        } else {
          ascii = _b_2.ascii(val);
        }
        return format_padding(ascii, flags);
      };
      var _float_helper = function(val, flags) {
        number_check(val, flags);
        if (flags.precision === void 0) {
          if (!flags.decimal_point) {
            flags.precision = 6;
          } else {
            flags.precision = 0;
          }
        } else {
          flags.precision = parseInt(flags.precision, 10);
          validate_precision(flags.precision);
        }
        return $B2.$isinstance(val, _b_2.int) ? val : val.value;
      };
      var validate_precision = function(precision) {
        if (precision > 20) {
          precision = 20;
        }
      };
      function handle_special_values(value2, upper) {
        var special;
        if (isNaN(value2)) {
          special = upper ? "NAN" : "nan";
        } else if (value2 == Number.POSITIVE_INFINITY) {
          special = upper ? "INF" : "inf";
        } else if (value2 == Number.NEGATIVE_INFINITY) {
          special = upper ? "-INF" : "-inf";
        }
        return special;
      }
      var floating_point_format = function(val, upper, flags) {
        val = _float_helper(val, flags);
        var special = handle_special_values(val, upper);
        if (special) {
          return format_padding(format_sign(val, flags) + special, flags);
        }
        var p = flags.precision;
        if (p == 0) {
          p = 1;
        }
        var exp_format = val.toExponential(p - 1), e_index = exp_format.indexOf("e"), exp = parseInt(exp_format.substr(e_index + 1)), res;
        function remove_zeros(v) {
          if (flags.alternate) {
            return v;
          }
          if (v.indexOf(".") > -1) {
            while (v.endsWith("0")) {
              v = v.substr(0, v.length - 1);
            }
            if (v.endsWith(".")) {
              v = v.substr(0, v.length - 1);
            }
          }
          return v;
        }
        if (-4 <= exp && exp < p) {
          flags.precision = Math.max(0, p - 1 - exp);
          res = floating_point_decimal_format(val, upper, flags);
          res = remove_zeros(res);
        } else {
          flags.precision = Math.max(0, p - 1);
          var delim = upper ? "E" : "e", exp_fmt = floating_point_exponential_format(val, upper, flags), parts = exp_fmt.split(delim);
          parts[0] = remove_zeros(parts[0]);
          res = parts.join(delim);
        }
        return format_padding(format_sign(val, flags) + res, flags);
      };
      var roundDownToFixed = $B2.roundDownToFixed = function(v, d) {
        if (d == 0 && v.toString().indexOf("e") > -1) {
          return BigInt(v).toString();
        }
        const mul = Math.pow(10, d);
        var is_neg = v < 0;
        if (is_neg) {
          v = -v;
        }
        var res_floor = (Math.floor(v * mul) / mul).toFixed(d), res_ceil = (Math.ceil(v * mul) / mul).toFixed(d), res;
        if (v - res_floor == res_ceil - v) {
          var last = res_floor[res_floor.length - 1];
          res = last.match(/[02468]/) ? res_floor : res_ceil;
        } else {
          res = v - res_floor < res_ceil - v ? res_floor : res_ceil;
        }
        return is_neg ? "-" + res : res;
      };
      var floating_point_decimal_format = function(val, upper, flags) {
        val = _float_helper(val, flags);
        var unpadded = format_float_precision(val, upper, flags, function(val2, precision, flags2) {
          var res = roundDownToFixed(val2, precision);
          if (precision === 0 && flags2.alternate) {
            res += ".";
          }
          if (Object.is(val2, -0)) {
            res = "-" + res;
          }
          return res;
        });
        return format_padding(format_sign(val, flags) + unpadded, flags);
      };
      var _floating_exp_helper = function(val, precision, flags, upper) {
        var is_neg = false, val_pos = val.toString();
        if (val < 0) {
          is_neg = true;
          val_pos = val_pos.substr(1);
        } else if (Object.is(val, -0)) {
          is_neg = true;
        }
        var parts = val_pos.split("."), exp = 0, exp_sign = "+", mant;
        if (parts[0] == "0") {
          if (parts[1]) {
            exp_sign = "-";
            exp++;
            var i = 0;
            while (parts[1][i] == "0") {
              i++;
            }
            exp += i;
            mant = parts[1][i];
            if (parts[1][i + 1]) {
              mant += "." + parts[1].substr(i + 1);
            }
          } else {
            mant = "0";
          }
        } else {
          exp = parts[0].length - 1;
          mant = parts[0][0];
          if (parts[0].length > 1) {
            mant += "." + parts[0].substr(1) + (parts[1] || "");
          } else if (parts[1]) {
            mant += "." + parts[1];
          }
        }
        mant = parseFloat(mant);
        mant = roundDownToFixed(parseFloat(mant), precision);
        if (parseFloat(mant) == 10) {
          parts = mant.split(".");
          parts[0] = "1";
          mant = parts.join(".");
          exp = parseInt(exp) + (exp_sign == "+" ? 1 : -1);
          if (exp == 0) {
            exp_sign = "+";
          }
        }
        if (flags.alternate && mant.indexOf(".") == -1) {
          mant += ".";
        }
        if (exp.toString().length == 1) {
          exp = "0" + exp;
        }
        return `${is_neg ? "-" : ""}${mant}${upper ? "E" : "e"}${exp_sign}${exp}`;
      };
      var floating_point_exponential_format = function(val, upper, flags) {
        val = _float_helper(val, flags);
        return format_padding(format_sign(val, flags) + format_float_precision(val, upper, flags, _floating_exp_helper), flags);
      };
      $B2.formatters = { floating_point_format, floating_point_decimal_format, floating_point_exponential_format };
      var signed_hex_format = function(val, upper, flags) {
        var ret;
        if (!$B2.$isinstance(val, _b_2.int)) {
          throw _b_2.TypeError.$factory(
            `%X format: an integer is required, not ${$B2.class_name(val)}`
          );
        } else if ($B2.$isinstance(val, _b_2.bool)) {
          val = val ? 1 : 0;
        }
        if (val.__class__ === $B2.long_int) {
          ret = val.value.toString(16);
        } else {
          ret = parseInt(val);
          ret = ret.toString(16);
        }
        ret = format_int_precision(ret, flags);
        if (upper) {
          ret = ret.toUpperCase();
        }
        if (flags.pad_char === "0") {
          if (val < 0) {
            ret = ret.substring(1);
            ret = "-" + format_padding(ret, flags, true);
          }
          var sign = format_sign(val, flags);
          if (sign !== "") {
            ret = sign + format_padding(ret, flags, true);
          }
        }
        if (flags.alternate) {
          if (ret.charAt(0) === "-") {
            if (upper) {
              ret = "-0X" + ret.slice(1);
            } else {
              ret = "-0x" + ret.slice(1);
            }
          } else {
            if (upper) {
              ret = "0X" + ret;
            } else {
              ret = "0x" + ret;
            }
          }
        }
        return format_padding(format_sign(val, flags) + ret, flags);
      };
      var octal_format = function(val, flags) {
        number_check(val, flags);
        var ret;
        if (val.__class__ === $B2.long_int) {
          ret = $B2.long_int.to_base(8);
        } else {
          ret = parseInt(val);
          ret = ret.toString(8);
        }
        ret = format_int_precision(ret, flags);
        if (flags.pad_char === "0") {
          if (val < 0) {
            ret = ret.substring(1);
            ret = "-" + format_padding(ret, flags, true);
          }
          var sign = format_sign(val, flags);
          if (sign !== "") {
            ret = sign + format_padding(ret, flags, true);
          }
        }
        if (flags.alternate) {
          if (ret.charAt(0) === "-") {
            ret = "-0o" + ret.slice(1);
          } else {
            ret = "0o" + ret;
          }
        }
        return format_padding(ret, flags);
      };
      function series_of_bytes(val, flags) {
        if (val.__class__ && val.__class__.$buffer_protocol) {
          var it = _b_2.iter(val), ints = [];
          while (true) {
            try {
              ints.push(_b_2.next(it));
            } catch (err) {
              if (err.__class__ === _b_2.StopIteration) {
                var b = _b_2.bytes.$factory(ints);
                return format_padding(_b_2.bytes.decode(b, "ascii"), flags);
              }
              throw err;
            }
          }
        } else {
          try {
            var bytes_obj = $B2.$getattr(val, "__bytes__")();
            return format_padding(_b_2.bytes.decode(bytes_obj), flags);
          } catch (err) {
            if (err.__class__ === _b_2.AttributeError) {
              throw _b_2.TypeError.$factory("%b does not accept '" + $B2.class_name(val) + "'");
            }
            throw err;
          }
        }
      }
      var single_char_format = function(val, flags, type) {
        if (type == "bytes") {
          if ($B2.$isinstance(val, _b_2.int)) {
            if (val.__class__ === $B2.long_int || val < 0 || val > 255) {
              throw _b_2.OverflowError.$factory("%c arg not in range(256)");
            }
          } else if ($B2.$isinstance(val, [_b_2.bytes, _b_2.bytearray])) {
            if (val.source.length > 1) {
              throw _b_2.TypeError.$factory(
                "%c requires an integer in range(256) or a single byte"
              );
            }
            val = val.source[0];
          }
        } else {
          if ($B2.$isinstance(val, _b_2.str)) {
            if (_b_2.str.__len__(val) == 1) {
              return val;
            }
            throw _b_2.TypeError.$factory("%c requires int or char");
          } else if (!$B2.$isinstance(val, _b_2.int)) {
            throw _b_2.TypeError.$factory("%c requires int or char");
          }
          if (val.__class__ === $B2.long_int && (val.value < 0 || val.value >= 1114112) || (val < 0 || val >= 1114112)) {
            throw _b_2.OverflowError.$factory("%c arg not in range(0x110000)");
          }
        }
        return format_padding(_b_2.chr(val), flags);
      };
      var num_flag = function(c, flags) {
        if (c === "0" && !flags.padding && !flags.decimal_point && !flags.left) {
          flags.pad_char = "0";
          return;
        }
        if (!flags.decimal_point) {
          flags.padding = (flags.padding || "") + c;
        } else {
          flags.precision = (flags.precision || "") + c;
        }
      };
      var decimal_point_flag = function(val, flags) {
        if (flags.decimal_point) {
          throw new UnsupportedChar();
        }
        flags.decimal_point = true;
      };
      var neg_flag = function(val, flags) {
        flags.pad_char = " ";
        flags.left = true;
      };
      var space_flag = function(val, flags) {
        flags.space = true;
      };
      var sign_flag = function(val, flags) {
        flags.sign = true;
      };
      var alternate_flag = function(val, flags) {
        flags.alternate = true;
      };
      var char_mapping = { "b": series_of_bytes, "s": str_format, "d": num_format, "i": num_format, "u": num_format, "o": octal_format, "r": repr_format, "a": ascii_format, "g": function(val, flags) {
        return floating_point_format(val, false, flags);
      }, "G": function(val, flags) {
        return floating_point_format(val, true, flags);
      }, "f": function(val, flags) {
        return floating_point_decimal_format(val, false, flags);
      }, "F": function(val, flags) {
        return floating_point_decimal_format(val, true, flags);
      }, "e": function(val, flags) {
        return floating_point_exponential_format(val, false, flags);
      }, "E": function(val, flags) {
        return floating_point_exponential_format(val, true, flags);
      }, "x": function(val, flags) {
        return signed_hex_format(val, false, flags);
      }, "X": function(val, flags) {
        return signed_hex_format(val, true, flags);
      }, "c": single_char_format, "0": function(val, flags) {
        return num_flag("0", flags);
      }, "1": function(val, flags) {
        return num_flag("1", flags);
      }, "2": function(val, flags) {
        return num_flag("2", flags);
      }, "3": function(val, flags) {
        return num_flag("3", flags);
      }, "4": function(val, flags) {
        return num_flag("4", flags);
      }, "5": function(val, flags) {
        return num_flag("5", flags);
      }, "6": function(val, flags) {
        return num_flag("6", flags);
      }, "7": function(val, flags) {
        return num_flag("7", flags);
      }, "8": function(val, flags) {
        return num_flag("8", flags);
      }, "9": function(val, flags) {
        return num_flag("9", flags);
      }, "-": neg_flag, " ": space_flag, "+": sign_flag, ".": decimal_point_flag, "#": alternate_flag };
      var UnsupportedChar = function() {
        this.name = "UnsupportedChar";
      };
      const conversion_flags = "#0- +", length_modifiers = "hlL", conversion_types = "diouxXeEfFgGcrsa";
      function parse_mod_format(s, type, pos2) {
        var flags = { pad_char: " " }, len = s.length, start_pos = pos2, mo;
        pos2++;
        while (pos2 < len) {
          var char = s[pos2];
          if (char == "(") {
            var end = s.substr(pos2).indexOf(")");
            if (end == -1) {
              throw _b_2.ValueError.$factory("incomplete format key");
            } else {
              flags.mapping_key = s.substr(pos2 + 1, end - 1);
              pos2 += end + 1;
            }
          } else if (conversion_flags.indexOf(char) > -1) {
            flags.conversion_flag = char;
            if (char == "#") {
              flags.alternate = true;
            } else if (char == "-") {
              flags.left = true;
            } else if (char == "+") {
              flags.sign = "+";
            } else if (char == "0") {
              flags.pad_char = "0";
            } else if (char == " ") {
              flags.space = true;
            }
            pos2++;
          } else if (char == "*") {
            flags.padding = "*";
            pos2++;
          } else if (mo = /^\d+/.exec(s.substr(pos2))) {
            flags.padding = mo[0];
            pos2 += mo[0].length;
          } else if (char == ".") {
            pos2++;
            if (s[pos2] == "*") {
              flags.precision = "*";
              pos2++;
            } else if (mo = /^\d+/.exec(s.substr(pos2))) {
              flags.precision = mo[0];
              pos2 += mo[0].length;
            } else {
              flags.precision = "0";
            }
          } else if (length_modifiers.indexOf(char) > -1) {
            flags.length_modifier = char;
            pos2++;
          } else if (conversion_types.indexOf(char) > -1 || char == "b" && type == "bytes") {
            if (type == "bytes") {
              if (char == "s") {
                char = "b";
              } else if (char == "r") {
                char = "a";
              }
            }
            flags.conversion_type = char;
            flags.end = pos2;
            flags.string = s.substring(start_pos, pos2 + 1);
            if (flags.left && flags.pad_char == "0") {
              flags.pad_char = " ";
            }
            return flags;
          } else {
            throw _b_2.ValueError.$factory(`invalid character in format: ${char}`);
          }
        }
        throw _b_2.ValueError.$factory("invalid format");
      }
      function is_mapping(obj) {
        return _b_2.hasattr(obj, "keys") && _b_2.hasattr(obj, "__getitem__");
      }
      $B2.printf_format = function(s, type, args) {
        var argpos = null, getitem;
        if ($B2.$isinstance(args, _b_2.tuple)) {
          argpos = 0;
        } else {
          getitem = $B2.$getattr(args, "__getitem__", _b_2.None);
        }
        var ret = "", nbph = 0, pos2 = 0, len = s.length;
        while (pos2 < len) {
          var fmtpos = s.indexOf("%", pos2);
          if (fmtpos < 0) {
            ret += s.substring(pos2);
            break;
          }
          ret += s.substring(pos2, fmtpos);
          pos2 = fmtpos;
          if (s[pos2 + 1] == "%") {
            ret += "%";
            pos2 += 2;
          } else {
            nbph++;
            if (nbph > 1) {
              if (!$B2.$isinstance(args, _b_2.tuple) && !is_mapping(args)) {
                throw _b_2.TypeError.$factory(
                  "not enough arguments for format string"
                );
              }
            }
            var fmt = parse_mod_format(s, type, pos2);
            pos2 = fmt.end + 1;
            if (fmt.padding == "*") {
              if (args[argpos] === void 0) {
                throw _b_2.ValueError.$factory("no value for field width *");
              }
              fmt.padding = args[argpos];
              argpos++;
            }
            if (fmt.precision == "*") {
              if (args[argpos] === void 0) {
                throw _b_2.ValueError.$factory("no value for precision *");
              }
              fmt.precision = args[argpos];
              argpos++;
            }
            var func = char_mapping[fmt.conversion_type], value2;
            if (fmt.mapping_key !== void 0) {
              value2 = getitem(fmt.mapping_key);
            } else {
              if (argpos === null) {
                value2 = args;
              } else {
                value2 = args[argpos];
                if (value2 === void 0) {
                  throw _b_2.TypeError.$factory(
                    "not enough arguments for format string"
                  );
                }
                argpos++;
              }
            }
            ret += func(value2, fmt, type);
          }
        }
        if (argpos !== null) {
          if (args.length > argpos) {
            throw _b_2.TypeError.$factory(
              "not enough arguments for format string"
            );
          } else if (args.length < argpos) {
            throw _b_2.TypeError.$factory(
              "not all arguments converted during string formatting"
            );
          }
        } else if (nbph == 0) {
          throw _b_2.TypeError.$factory(
            "not all arguments converted during string formatting"
          );
        }
        return ret;
      };
      str.__mod__ = function(_self, args) {
        _self = to_string(_self);
        var res = $B2.printf_format(_self, "str", args);
        return $B2.String(res);
      };
      str.__mro__ = [_b_2.object];
      str.__mul__ = function(self2, other) {
        $B2.check_nb_args_no_kw("str.__mul__", 2, arguments);
        var _self = to_string(self2);
        if (!$B2.$isinstance(other, _b_2.int)) {
          throw _b_2.TypeError.$factory(
            "Can't multiply sequence by non-int of type '" + $B2.class_name(other) + "'"
          );
        }
        return _self.repeat(other < 0 ? 0 : other);
      };
      str.__ne__ = function(_self, other) {
        var eq = str.__eq__(_self, other);
        return eq === _b_2.NotImplemented ? eq : !eq;
      };
      str.__new__ = function(cls, value2) {
        if (cls === void 0) {
          throw _b_2.TypeError.$factory("str.__new__(): not enough arguments");
        } else if (cls === _b_2.str) {
          return value2;
        } else {
          return {
            __class__: cls,
            $brython_value: str.$factory(value2),
            __dict__: $B2.empty_dict()
          };
        }
      };
      str.__repr__ = function(_self) {
        _self = to_string(_self);
        var t = $B2.special_string_repr, repl = "", chars = to_chars(_self);
        for (var i = 0; i < chars.length; i++) {
          var cp2 = _b_2.ord(chars[i]);
          if (t[cp2] !== void 0) {
            repl += t[cp2];
          } else if (new RegExp("\\p{Cn}", "u").test(chars[i])) {
            var s = cp2.toString(16);
            while (s.length < 4) {
              s = "0" + s;
            }
            repl += "\\u" + s;
          } else if (cp2 < 32 || cp2 >= 127 && cp2 < 160) {
            cp2 = cp2.toString(16);
            if (cp2.length < 2) {
              cp2 = "0" + cp2;
            }
            repl += "\\x" + cp2;
          } else if (cp2 >= 768 && cp2 <= 879) {
            repl += "​" + chars[i] + " ";
          } else if (cp2.toString(16) == "feff") {
            repl += "\\ufeff";
          } else {
            repl += chars[i];
          }
        }
        var res = repl;
        if (res.search('"') == -1 && res.search("'") == -1) {
          return "'" + res + "'";
        } else if (_self.search('"') == -1) {
          return '"' + res + '"';
        }
        var qesc = new RegExp("'", "g");
        res = "'" + res.replace(qesc, "\\'") + "'";
        return res;
      };
      str.__rmod__ = function(self2, other) {
        $B2.check_nb_args_no_kw("str.__rmod__", 2, arguments);
        if (!$B2.$isinstance(other, str)) {
          return _b_2.NotImplemented;
        }
        return str.__mod__(other, self2);
      };
      str.__rmul__ = function(_self, other) {
        _self = to_string(_self);
        if ($B2.$isinstance(other, _b_2.int)) {
          other = _b_2.int.numerator(other);
          var res = "";
          while (other > 0) {
            res += _self;
            other--;
          }
          return res;
        }
        return _b_2.NotImplemented;
      };
      str.__setattr__ = function(_self, attr, value2) {
        if (typeof _self === "string") {
          if (str.hasOwnProperty(attr)) {
            throw _b_2.AttributeError.$factory("'str' object attribute '" + attr + "' is read-only");
          } else {
            throw _b_2.AttributeError.$factory(
              `'str' object has no attribute '${attr}' and no __dict__ for setting new attributes`
            );
          }
        }
        _b_2.dict.$setitem(_self.__dict__, attr, value2);
        return _b_2.None;
      };
      str.__setitem__ = function() {
        throw _b_2.TypeError.$factory(
          "'str' object does not support item assignment"
        );
      };
      var combining = [];
      for (var cp = 768; cp <= 879; cp++) {
        combining.push(String.fromCharCode(cp));
      }
      var combining_re = new RegExp("(" + combining.join("|") + ")", "g");
      str.__str__ = function(_self) {
        _self = to_string(_self);
        var repl = "", chars = to_chars(_self);
        if (chars.length == _self.length) {
          return _self.replace(combining_re, "​$1");
        }
        for (var i = 0; i < chars.length; i++) {
          var cp2 = _b_2.ord(chars[i]);
          if (cp2 >= 768 && cp2 <= 879) {
            repl += "​" + chars[i];
          } else {
            repl += chars[i];
          }
        }
        return repl;
      };
      var body = `var _b_ = __BRYTHON__.builtins
if(typeof other !== typeof _self){
    return _b_.NotImplemented}else if(typeof _self == "string"){
    return _self > other}else{
    return _self.$brython_value > other.$brython_value}`;
      var comps = { ">": "gt", ">=": "ge", "<": "lt", "<=": "le" };
      for (var op in comps) {
        str[`__${comps[op]}__`] = Function("_self", "other", body.replace(/>/gm, op));
      }
      str.capitalize = function(self2) {
        $B2.check_nb_args_no_kw("str.capitalize", 1, arguments);
        var _self = to_string(self2);
        if (_self.length == 0) {
          return "";
        }
        return _self.charAt(0).toUpperCase() + _self.substr(1).toLowerCase();
      };
      str.casefold = function(self2) {
        $B2.check_nb_args_no_kw("set.remove", 1, arguments);
        var res = "", char, cf, _self = to_string(self2), chars = to_chars(_self);
        for (var i = 0, len = chars.length; i < len; i++) {
          char = chars[i];
          cf = $B2.unicode_casefold[char];
          if (cf) {
            cf.forEach(function(cp2) {
              res += String.fromCharCode(cp2);
            });
          } else {
            res += char.toLowerCase();
          }
        }
        return res;
      };
      str.center = function() {
        var $ = $B2.args("center", 3, { self: null, width: null, fillchar: null }, ["self", "width", "fillchar"], arguments, { fillchar: " " }, null, null), _self = to_string($.self);
        if ($.width <= _self.length) {
          return _self;
        }
        var pad = parseInt(($.width - _self.length) / 2), res = $.fillchar.repeat(pad);
        res += _self + res;
        if (res.length < $.width) {
          res += $.fillchar;
        }
        return res;
      };
      str.count = function() {
        var $ = $B2.args("count", 4, { self: null, sub: null, start: null, stop: null }, ["self", "sub", "start", "stop"], arguments, { start: null, stop: null }, null, null), _self, sub;
        if (!$B2.$isinstance($.sub, str)) {
          throw _b_2.TypeError.$factory("Can't convert '" + $B2.class_name($.sub) + "' object to str implicitly");
        }
        [_self, sub] = to_string([$.self, $.sub]);
        var substr = _self;
        if ($.start !== null) {
          var _slice;
          if ($.stop !== null) {
            _slice = _b_2.slice.$factory($.start, $.stop);
          } else {
            _slice = _b_2.slice.$factory($.start, _self.length);
          }
          substr = str.__getitem__.apply(null, [_self].concat(_slice));
        } else {
          if (_self.length + sub.length == 0) {
            return 1;
          }
        }
        if (sub.length == 0) {
          if ($.start == _self.length) {
            return 1;
          } else if (substr.length == 0) {
            return 0;
          }
          return substr.length + 1;
        }
        var n = 0, pos2 = 0;
        while (pos2 < substr.length) {
          pos2 = substr.indexOf(sub, pos2);
          if (pos2 >= 0) {
            n++;
            pos2 += sub.length;
          } else {
            break;
          }
        }
        return n;
      };
      str.encode = function() {
        var $ = $B2.args("encode", 3, { self: null, encoding: null, errors: null }, ["self", "encoding", "errors"], arguments, { encoding: "utf-8", errors: "strict" }, null, null), _self = to_string($.self);
        if ($.encoding == "rot13" || $.encoding == "rot_13") {
          var res = "";
          for (var i = 0, len = _self.length; i < len; i++) {
            var char = _self.charAt(i);
            if ("a" <= char && char <= "m" || "A" <= char && char <= "M") {
              res += String.fromCharCode(char.charCodeAt(0) + 13);
            } else if ("m" < char && char <= "z" || "M" < char && char <= "Z") {
              res += String.fromCharCode(char.charCodeAt(0) - 13);
            } else {
              res += char;
            }
          }
          return res;
        }
        return _b_2.bytes.__new__(_b_2.bytes, $.self, $.encoding, $.errors);
      };
      str.endswith = function() {
        var $ = $B2.args("endswith", 4, { self: null, suffix: null, start: null, end: null }, ["self", "suffix", "start", "end"], arguments, { start: 0, end: null }, null, null), _self;
        normalize_start_end($);
        _self = to_string($.self);
        var suffixes = $.suffix;
        if (!$B2.$isinstance(suffixes, _b_2.tuple)) {
          suffixes = [suffixes];
        }
        var chars = to_chars(_self), s = chars.slice($.start, $.end);
        for (var i = 0, len = suffixes.length; i < len; i++) {
          var suffix2 = suffixes[i];
          if (!$B2.$isinstance(suffix2, str)) {
            throw _b_2.TypeError.$factory(
              "endswith first arg must be str or a tuple of str, not int"
            );
          }
          suffix2 = suffix2.__class__ ? suffix2.$brython_value : suffix2;
          if (suffix2.length <= s.length && s.slice(s.length - suffix2.length).join("") == suffix2) {
            return true;
          }
        }
        return false;
      };
      str.expandtabs = function() {
        var $ = $B2.args("expandtabs", 2, { self: null, tabsize: null }, ["self", "tabsize"], arguments, { tabsize: 8 }, null, null), _self = to_string($.self);
        var s = $B2.PyNumber_Index($.tabsize), col = 0, pos2 = 0, res = "", chars = to_chars(_self);
        if (s == 1) {
          return _self.replace(/\t/g, " ");
        }
        while (pos2 < chars.length) {
          var car = chars[pos2];
          switch (car) {
            case "	":
              while (col % s > 0) {
                res += " ";
                col++;
              }
              break;
            case "\r":
            case "\n":
              res += car;
              col = 0;
              break;
            default:
              res += car;
              col++;
              break;
          }
          pos2++;
        }
        return res;
      };
      str.find = function() {
        var $ = $B2.args("str.find", 4, { self: null, sub: null, start: null, end: null }, ["self", "sub", "start", "end"], arguments, { start: 0, end: null }, null, null), _self, sub;
        check_str($.sub);
        normalize_start_end($);
        [_self, sub] = to_string([$.self, $.sub]);
        var len = str.__len__(_self), sub_len = str.__len__(sub);
        if (sub_len == 0 && $.start == len) {
          return len;
        }
        if (len + sub_len == 0) {
          return -1;
        }
        var js_start = pypos2jspos(_self, $.start), js_end = pypos2jspos(_self, $.end), ix = _self.slice(js_start, js_end).indexOf(sub);
        if (ix == -1) {
          return -1;
        }
        return jspos2pypos(_self, js_start + ix);
      };
      $B2.parse_format = function(fmt_string) {
        var elts = fmt_string.split(":"), name2, conv, spec, name_ext = [];
        if (elts.length == 1) {
          name2 = fmt_string;
        } else {
          name2 = elts[0];
          spec = elts.splice(1).join(":");
        }
        elts = name2.split("!");
        if (elts.length > 1) {
          name2 = elts[0];
          conv = elts[1];
        }
        if (name2 !== void 0) {
          let name_repl2 = function(match) {
            name_ext.push(match);
            return "";
          };
          var name_repl = name_repl2;
          var name_ext_re = /\.[_a-zA-Z][_a-zA-Z0-9]*|\[[_a-zA-Z][_a-zA-Z0-9]*\]|\[[0-9]+\]/g;
          name2 = name2.replace(name_ext_re, name_repl2);
        }
        return { name: name2, name_ext, conv, spec: spec || "", string: fmt_string };
      };
      $B2.split_format = function(s) {
        var pos2 = 0, _len = s.length, car, text = "", parts = [], rank = 0;
        while (pos2 < _len) {
          car = s.charAt(pos2);
          if (car == "{" && s.charAt(pos2 + 1) == "{") {
            text += "{";
            pos2 += 2;
          } else if (car == "}" && s.charAt(pos2 + 1) == "}") {
            text += "}";
            pos2 += 2;
          } else if (car == "{") {
            parts.push(text);
            var end = pos2 + 1, nb = 1;
            while (end < _len) {
              if (s.charAt(end) == "{") {
                nb++;
                end++;
              } else if (s.charAt(end) == "}") {
                nb--;
                end++;
                if (nb == 0) {
                  var fmt_string = s.substring(pos2 + 1, end - 1);
                  var fmt_obj = $B2.parse_format(fmt_string);
                  fmt_obj.raw_name = fmt_obj.name;
                  fmt_obj.raw_spec = fmt_obj.spec;
                  if (!fmt_obj.name) {
                    fmt_obj.name = rank + "";
                    rank++;
                  }
                  if (fmt_obj.spec !== void 0) {
                    let replace_nested2 = function(name2, key2) {
                      if (key2 == "") {
                        return "{" + rank++ + "}";
                      }
                      return "{" + key2 + "}";
                    };
                    var replace_nested = replace_nested2;
                    fmt_obj.spec = fmt_obj.spec.replace(/\{(.*?)\}/g, replace_nested2);
                  }
                  parts.push(fmt_obj);
                  text = "";
                  break;
                }
              } else {
                end++;
              }
            }
            if (nb > 0) {
              throw _b_2.ValueError.$factory("wrong format " + s);
            }
            pos2 = end;
          } else {
            text += car;
            pos2++;
          }
        }
        if (text) {
          parts.push(text);
        }
        return parts;
      };
      str.format = function() {
        var last_arg = $B2.last(arguments), $, mapping, getitem;
        if (last_arg.$nat == "mapping") {
          mapping = last_arg.mapping;
          getitem = $B2.$getattr(mapping, "__getitem__");
          var args = [];
          for (let i = 0, len = arguments.length - 1; i < len; i++) {
            args.push(arguments[i]);
          }
          $ = $B2.args("format", 1, { self: null }, ["self"], args, {}, "$args", null);
        } else {
          $ = $B2.args("format", 1, { self: null }, ["self"], arguments, {}, "$args", "$kw");
          mapping = $.$kw, getitem = function(key3) {
            return _b_2.dict.$getitem(mapping, key3);
          };
        }
        var _self = to_string($.self), parts = $B2.split_format(_self);
        var res = "", fmt;
        for (let i = 0; i < parts.length; i++) {
          if (typeof parts[i] == "string") {
            res += parts[i];
            continue;
          }
          fmt = parts[i];
          if (fmt.spec !== void 0) {
            let replace_nested2 = function(name2, key3) {
              if (/\d+/.exec(key3)) {
                return _b_2.tuple.__getitem__($.$args, parseInt(key3));
              } else {
                return _b_2.dict.__getitem__($.$kw, key3);
              }
            };
            var replace_nested = replace_nested2;
            fmt.spec = fmt.spec.replace(/\{(.*?)\}/g, replace_nested2);
          }
          var value2;
          if (fmt.name.charAt(0).search(/\d/) > -1) {
            let pos2 = parseInt(fmt.name);
            value2 = _b_2.tuple.__getitem__($.$args, pos2);
          } else {
            value2 = getitem(fmt.name);
          }
          for (var j2 = 0; j2 < fmt.name_ext.length; j2++) {
            var ext = fmt.name_ext[j2];
            if (ext.charAt(0) == ".") {
              value2 = $B2.$getattr(value2, ext.substr(1));
            } else {
              var key2 = ext.substr(1, ext.length - 2);
              if (key2.charAt(0).search(/\d/) > -1) {
                key2 = parseInt(key2);
              }
              value2 = $B2.$getattr(value2, "__getitem__")(key2);
            }
          }
          if (fmt.conv == "a") {
            value2 = _b_2.ascii(value2);
          } else if (fmt.conv == "r") {
            value2 = _b_2.repr(value2);
          } else if (fmt.conv == "s") {
            value2 = _b_2.str.$factory(value2);
          }
          if (value2.$is_class || value2.$factory) {
            res += value2.__class__.__format__(value2, fmt.spec);
          } else {
            res += $B2.$getattr(value2, "__format__")(fmt.spec);
          }
        }
        return res;
      };
      str.format_map = function(self2, mapping) {
        $B2.check_nb_args_no_kw("str.format_map", 2, arguments);
        var _self = to_string(self2);
        return str.format(_self, { $nat: "mapping", mapping });
      };
      str.index = function() {
        var res = str.find.apply(null, arguments);
        if (res === -1) {
          throw _b_2.ValueError.$factory("substring not found");
        }
        return res;
      };
      str.isascii = function(self2) {
        $B2.check_nb_args_no_kw("str.isascii", 1, arguments);
        var _self = to_string(self2);
        for (var i = 0, len = _self.length; i < len; i++) {
          if (_self.charCodeAt(i) > 127) {
            return false;
          }
        }
        return true;
      };
      var unicode_categories_contain_character = function(categories, cp2) {
        for (var cat of categories) {
          if ($B2.in_unicode_category(cat, cp2)) {
            return true;
          }
        }
        return false;
      };
      var alpha_categories = ["Ll", "Lu", "Lm", "Lt", "Lo"];
      var alnum_categories = ["Ll", "Lu", "Lm", "Lt", "Lo", "Nd"];
      str.isalnum = function(self2) {
        $B2.check_nb_args_no_kw("str.isalnum", 1, arguments);
        var _self = to_string(self2);
        if (_self.length == 0) {
          return false;
        }
        for (var char of _self) {
          if (!unicode_categories_contain_character(alnum_categories, _b_2.ord(char))) {
            return false;
          }
        }
        return true;
      };
      str.isalpha = function(self2) {
        $B2.check_nb_args_no_kw("str.isalpha", 1, arguments);
        var _self = to_string(self2);
        if (_self.length == 0) {
          return false;
        }
        for (var char of _self) {
          if (!unicode_categories_contain_character(alpha_categories, _b_2.ord(char))) {
            return false;
          }
        }
        return true;
      };
      str.isdecimal = function(self2) {
        $B2.check_nb_args_no_kw("str.isdecimal", 1, arguments);
        var cp2, _self = to_string(self2);
        for (var char of _self) {
          cp2 = _b_2.ord(char);
          if (!$B2.in_unicode_category("Nd", cp2)) {
            return false;
          }
        }
        return _self.length > 0;
      };
      str.isdigit = function(self2) {
        $B2.check_nb_args_no_kw("str.isdigit", 1, arguments);
        var cp2, _self = to_string(self2);
        for (var char of _self) {
          if (new RegExp("\\p{Nd}", "u").test(char)) {
            continue;
          }
          cp2 = _b_2.ord(char);
          if (!$B2.in_unicode_category("No_digits", cp2)) {
            return false;
          }
        }
        return _self.length > 0;
      };
      str.isidentifier = function(self2) {
        $B2.check_nb_args_no_kw("str.isidentifier", 1, arguments);
        var _self = to_string(self2);
        if (_self.length == 0) {
          return false;
        }
        var chars = to_chars(_self);
        if (!$B2.is_XID_Start(_b_2.ord(chars[0]))) {
          return false;
        } else {
          for (var char of chars) {
            var cp2 = _b_2.ord(char);
            if (!$B2.is_XID_Continue(cp2)) {
              return false;
            }
          }
        }
        return true;
      };
      str.islower = function(self2) {
        $B2.check_nb_args_no_kw("str.islower", 1, arguments);
        var has_cased = false, cp2, _self = to_string(self2);
        for (var char of _self) {
          cp2 = _b_2.ord(char);
          if ($B2.in_unicode_category("Ll", cp2)) {
            has_cased = true;
            continue;
          } else if ($B2.in_unicode_category("Lu", cp2) || $B2.in_unicode_category("Lt", cp2)) {
            return false;
          }
        }
        return has_cased;
      };
      const numeric_re = new RegExp("\\p{Nd}|\\p{Nl}|\\p{No}", "u");
      str.isnumeric = function(self2) {
        $B2.check_nb_args_no_kw("str.isnumeric", 1, arguments);
        var _self = to_string(self2);
        for (var char of _self) {
          if (!numeric_re.test(char) && !$B2.in_unicode_category("Lo_numeric", _b_2.ord(char))) {
            return false;
          }
        }
        return _self.length > 0;
      };
      var unprintable_re = new RegExp("\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}|\\p{Zl}|\\p{Zp}|\\p{Zs}", "u");
      str.isprintable = function(self2) {
        $B2.check_nb_args_no_kw("str.isprintable", 1, arguments);
        var _self = to_string(self2);
        for (var char of _self) {
          if (char == " ") {
            continue;
          }
          if (unprintable_re.test(char)) {
            return false;
          }
        }
        return true;
      };
      str.isspace = function(self2) {
        $B2.check_nb_args_no_kw("str.isspace", 1, arguments);
        var cp2, _self = to_string(self2);
        for (var char of _self) {
          cp2 = _b_2.ord(char);
          if (!$B2.in_unicode_category("Zs", cp2) && $B2.unicode_bidi_whitespace.indexOf(cp2) == -1) {
            return false;
          }
        }
        return _self.length > 0;
      };
      str.istitle = function(self2) {
        $B2.check_nb_args_no_kw("str.istitle", 1, arguments);
        var _self = to_string(self2);
        return _self.length > 0 && str.title(_self) == _self;
      };
      str.isupper = function(self2) {
        $B2.check_nb_args_no_kw("str.isupper", 1, arguments);
        var is_upper = false, cp2, _self = to_string(self2);
        for (var char of _self) {
          cp2 = _b_2.ord(char);
          if ($B2.in_unicode_category("Lu", cp2)) {
            is_upper = true;
            continue;
          } else if ($B2.in_unicode_category("Ll", cp2) || $B2.in_unicode_category("Lt", cp2)) {
            return false;
          }
        }
        return is_upper;
      };
      str.join = function(self2, iterable) {
        $B2.check_nb_args_no_kw("str.join", 2, arguments);
        var _self = to_string(self2);
        iterable = _b_2.iter(iterable);
        var res = [], count = 0;
        while (1) {
          try {
            var obj2 = _b_2.next(iterable);
            if (!$B2.$isinstance(obj2, str)) {
              throw _b_2.TypeError.$factory("sequence item " + count + ": expected str instance, " + $B2.class_name(obj2) + " found");
            }
            res.push(obj2);
          } catch (err) {
            if ($B2.$isinstance(err, _b_2.StopIteration)) {
              break;
            } else {
              throw err;
            }
          }
        }
        return res.join(_self);
      };
      str.ljust = function() {
        var $ = $B2.args("ljust", 3, { self: null, width: null, fillchar: null }, ["self", "width", "fillchar"], arguments, { fillchar: " " }, null, null), _self = to_string($.self), len = str.__len__(_self);
        if ($.width <= len) {
          return _self;
        }
        return _self + $.fillchar.repeat($.width - len);
      };
      str.lower = function(self2) {
        $B2.check_nb_args_no_kw("str.lower", 1, arguments);
        var _self = to_string(self2);
        return _self.toLowerCase();
      };
      str.lstrip = function() {
        var $ = $B2.args("lstrip", 2, { self: null, chars: null }, ["self", "chars"], arguments, { chars: _b_2.None }, null, null), _self = $.self, chars = $.chars;
        if (chars === _b_2.None) {
          return _self.trimStart();
        }
        [_self, chars] = to_string([_self, chars]);
        while (_self.length > 0) {
          var flag = false;
          for (var char of chars) {
            if (_self.startsWith(char)) {
              _self = _self.substr(char.length);
              flag = true;
              break;
            }
          }
          if (!flag) {
            return $.self.surrogates ? $B2.String(_self) : _self;
          }
        }
        return "";
      };
      str.maketrans = function() {
        var $ = $B2.args("maketrans", 3, { x: null, y: null, z: null }, ["x", "y", "z"], arguments, { y: null, z: null }, null, null);
        var _t = $B2.empty_dict();
        if ($.y === null && $.z === null) {
          if (!$B2.$isinstance($.x, _b_2.dict)) {
            throw _b_2.TypeError.$factory(
              "maketrans only argument must be a dict"
            );
          }
          var items = _b_2.list.$factory(_b_2.dict.items($.x));
          for (let i = 0, len = items.length; i < len; i++) {
            let k = items[i][0], v = items[i][1];
            if (!$B2.$isinstance(k, _b_2.int)) {
              if ($B2.$isinstance(k, _b_2.str) && k.length == 1) {
                k = _b_2.ord(k);
              } else {
                throw _b_2.TypeError.$factory("dictionary key " + k + " is not int or 1-char string");
              }
            }
            if (v !== _b_2.None && !$B2.$isinstance(v, [_b_2.int, _b_2.str])) {
              throw _b_2.TypeError.$factory("dictionary value " + v + " is not None, integer or string");
            }
            _b_2.dict.$setitem(_t, k, v);
          }
          return _t;
        } else {
          if (!($B2.$isinstance($.x, _b_2.str) && $B2.$isinstance($.y, _b_2.str))) {
            throw _b_2.TypeError.$factory("maketrans arguments must be strings");
          } else if ($.x.length !== $.y.length) {
            throw _b_2.TypeError.$factory(
              "maketrans arguments must be strings or same length"
            );
          } else {
            var toNone = {};
            if ($.z !== null) {
              if (!$B2.$isinstance($.z, _b_2.str)) {
                throw _b_2.TypeError.$factory(
                  "maketrans third argument must be a string"
                );
              }
              for (let i = 0, len = $.z.length; i < len; i++) {
                toNone[_b_2.ord($.z.charAt(i))] = true;
              }
            }
            for (let i = 0, len = $.x.length; i < len; i++) {
              var key2 = _b_2.ord($.x.charAt(i)), value2 = $.y.charCodeAt(i);
              _b_2.dict.$setitem(_t, key2, value2);
            }
            for (let k in toNone) {
              _b_2.dict.$setitem(_t, parseInt(k), _b_2.None);
            }
            return _t;
          }
        }
      };
      str.maketrans.$type = "staticmethod";
      str.partition = function(self2, sep) {
        $B2.check_nb_args_no_kw("str.partition", 2, arguments);
        var _self;
        if (sep == "") {
          throw _b_2.ValueError.$factory("empty separator");
        }
        check_str(sep);
        [_self, sep] = to_string([self2, sep]);
        var chars = to_chars(_self), i = _self.indexOf(sep);
        if (i == -1) {
          return _b_2.tuple.$factory([_self, "", ""]);
        }
        return _b_2.tuple.$factory([chars.slice(0, i).join(""), sep, chars.slice(i + sep.length).join("")]);
      };
      str.removeprefix = function(self2, prefix2) {
        $B2.check_nb_args_no_kw("str.removeprefix", 2, arguments);
        var _self;
        if (!$B2.$isinstance(prefix2, str)) {
          throw _b_2.ValueError.$factory(`prefix should be str, not '${$B2.class_name(prefix2)}'`);
        }
        [_self, prefix2] = to_string([self2, prefix2]);
        if (str.startswith(_self, prefix2)) {
          return _self.substr(prefix2.length);
        }
        return _self.substr(0);
      };
      str.removesuffix = function(self2, suffix2) {
        $B2.check_nb_args_no_kw("str.removesuffix", 2, arguments);
        var _self;
        if (!$B2.$isinstance(suffix2, str)) {
          throw _b_2.ValueError.$factory(`suffix should be str, not '${$B2.class_name(suffix2)}'`);
        }
        [_self, suffix2] = to_string([self2, suffix2]);
        if (suffix2.length > 0 && str.endswith(_self, suffix2)) {
          return _self.substr(0, _self.length - suffix2.length);
        }
        return _self.substr(0);
      };
      str.replace = function() {
        var $ = $B2.args("replace", 4, { self: null, old: null, new: null, count: null }, ["self", "old", "new", "count"], arguments, { count: -1 }, null, null), count = $.count, _self = $.self, old = $.old, _new = $.new;
        check_str(old, "replace() argument 1 ");
        check_str(_new, "replace() argument 2 ");
        if (!$B2.$isinstance(count, [_b_2.int, _b_2.float])) {
          throw _b_2.TypeError.$factory("'" + $B2.class_name(count) + "' object cannot be interpreted as an integer");
        } else if ($B2.$isinstance(count, _b_2.float)) {
          throw _b_2.TypeError.$factory("integer argument expected, got float");
        }
        if (count == 0) {
          return _self;
        }
        if (count.__class__ == $B2.long_int) {
          count = parseInt(count.value);
        }
        [old, _new] = to_string([old, _new]);
        var elts;
        if (old == "") {
          if (_new == "") {
            return _self;
          }
          if (_self == "") {
            return _new;
          }
          elts = _self.split("");
          if (count > -1 && elts.length >= count) {
            var rest = elts.slice(count).join("");
            return _new + elts.slice(0, count).join(_new) + rest;
          } else {
            return _new + elts.join(_new) + _new;
          }
        } else {
          elts = str.split(_self, old, count);
        }
        var res = _self, pos2 = -1;
        if (old.length == 0) {
          res = _new;
          for (var i = 0; i < elts.length; i++) {
            res += elts[i] + _new;
          }
          return res + rest;
        }
        if (count < 0) {
          count = res.length;
        }
        while (count > 0) {
          pos2 = res.indexOf(old, pos2);
          if (pos2 < 0) {
            break;
          }
          res = res.substr(0, pos2) + _new + res.substr(pos2 + old.length);
          pos2 = pos2 + _new.length;
          count--;
        }
        return res;
      };
      str.rfind = function() {
        var $ = $B2.args("rfind", 4, { self: null, sub: null, start: null, end: null }, ["self", "sub", "start", "end"], arguments, { start: 0, end: null }, null, null), _self, sub;
        normalize_start_end($);
        check_str($.sub);
        [_self, sub] = to_string([$.self, $.sub]);
        var len = str.__len__(_self), sub_len = str.__len__(sub);
        if (sub_len == 0) {
          if ($.js_start > len) {
            return -1;
          } else {
            return str.__len__(_self);
          }
        }
        var js_start = pypos2jspos(_self, $.start), js_end = pypos2jspos(_self, $.end), ix = _self.substring(js_start, js_end).lastIndexOf(sub);
        if (ix == -1) {
          return -1;
        }
        return jspos2pypos(_self, js_start + ix) - $.start;
      };
      str.rindex = function() {
        var res = str.rfind.apply(null, arguments);
        if (res == -1) {
          throw _b_2.ValueError.$factory("substring not found");
        }
        return res;
      };
      str.rjust = function() {
        var $ = $B2.args("rjust", 3, { self: null, width: null, fillchar: null }, ["self", "width", "fillchar"], arguments, { fillchar: " " }, null, null), _self = to_string($.self);
        var len = str.__len__(_self);
        if ($.width <= len) {
          return _self;
        }
        return $B2.String($.fillchar.repeat($.width - len) + _self);
      };
      str.rpartition = function(self2, sep) {
        $B2.check_nb_args_no_kw("str.rpartition", 2, arguments);
        check_str(sep);
        var _self = reverse(self2), sep = reverse(sep);
        var items = str.partition(_self, sep).reverse();
        for (var i = 0; i < items.length; i++) {
          items[i] = items[i].split("").reverse().join("");
        }
        return items;
      };
      str.rsplit = function() {
        var $ = $B2.args("rsplit", 3, { self: null, sep: null, maxsplit: null }, ["self", "sep", "maxsplit"], arguments, { sep: _b_2.None, maxsplit: -1 }, null, null), sep = $.sep, _self;
        [_self, sep] = to_string([$.self, $.sep]);
        var rev_str = reverse(_self), rev_sep = sep === _b_2.None ? sep : reverse(sep), rev_res = str.split(rev_str, rev_sep, $.maxsplit);
        rev_res.reverse();
        for (var i = 0; i < rev_res.length; i++) {
          rev_res[i] = reverse(rev_res[i]);
        }
        return $B2.$list(rev_res);
      };
      str.rstrip = function() {
        var $ = $B2.args("rstrip", 2, { self: null, chars: null }, ["self", "chars"], arguments, { chars: _b_2.None }, null, null), chars = $.chars, _self = to_string($.self);
        if (chars === _b_2.None) {
          return _self.trimEnd();
        }
        chars = to_string(chars);
        while (_self.length > 0) {
          var flag = false;
          for (var char of chars) {
            if (_self.endsWith(char)) {
              _self = _self.substr(0, _self.length - char.length);
              flag = true;
              break;
            }
          }
          if (!flag) {
            return _self.surrogates ? $B2.String(_self) : _self;
          }
        }
        return "";
      };
      str.split = function() {
        var $ = $B2.args("split", 3, { self: null, sep: null, maxsplit: null }, ["self", "sep", "maxsplit"], arguments, { sep: _b_2.None, maxsplit: -1 }, null, null), maxsplit = $.maxsplit, sep = $.sep, pos2 = 0, _self = to_string($.self);
        if (maxsplit.__class__ === $B2.long_int) {
          maxsplit = parseInt(maxsplit.value);
        }
        if (sep == "") {
          throw _b_2.ValueError.$factory("empty separator");
        }
        if (sep === _b_2.None) {
          let res = [];
          while (pos2 < _self.length && _self.charAt(pos2).search(/\s/) > -1) {
            pos2++;
          }
          if (pos2 === _self.length - 1) {
            return $B2.$list([_self]);
          }
          let name2 = "";
          while (1) {
            if (_self.charAt(pos2).search(/\s/) == -1) {
              if (name2 == "") {
                name2 = _self.charAt(pos2);
              } else {
                name2 += _self.charAt(pos2);
              }
            } else {
              if (name2 !== "") {
                res.push(name2);
                if (maxsplit !== -1 && res.length == maxsplit + 1) {
                  res.pop();
                  res.push(name2 + _self.substr(pos2));
                  return res;
                }
                name2 = "";
              }
            }
            pos2++;
            if (pos2 > _self.length - 1) {
              if (name2) {
                res.push(name2);
              }
              break;
            }
          }
          return $B2.$list(res.map($B2.String));
        } else {
          if (!$B2.$isinstance(sep, _b_2.str)) {
            throw _b_2.TypeError.$factory("must be str or None, not " + $B2.class_name(sep));
          }
          sep = to_string(sep);
          let res = [], s = "", seplen = sep.length;
          if (maxsplit == 0) {
            return $B2.$list([$.self]);
          }
          while (pos2 < _self.length) {
            if (_self.substr(pos2, seplen) == sep) {
              res.push(s);
              pos2 += seplen;
              if (maxsplit > -1 && res.length >= maxsplit) {
                res.push(_self.substr(pos2));
                return res.map($B2.String);
              }
              s = "";
            } else {
              s += _self.charAt(pos2);
              pos2++;
            }
          }
          res.push(s);
          return $B2.$list(res.map($B2.String));
        }
      };
      str.splitlines = function() {
        var $ = $B2.args("splitlines", 2, { self: null, keepends: null }, ["self", "keepends"], arguments, { keepends: false }, null, null);
        if (!$B2.$isinstance($.keepends, [_b_2.bool, _b_2.int])) {
          throw _b_2.TypeError("integer argument expected, got " + $B2.get_class($.keepends).__name);
        }
        var keepends = _b_2.int.$factory($.keepends), res = $B2.$list([]), start = 0, pos2 = 0, _self = to_string($.self);
        if (!_self.length) {
          return res;
        }
        while (pos2 < _self.length) {
          if (_self.substr(pos2, 2) == "\r\n") {
            res.push(_self.slice(start, keepends ? pos2 + 2 : pos2));
            start = pos2 = pos2 + 2;
          } else if (_self[pos2] == "\r" || _self[pos2] == "\n") {
            res.push(_self.slice(start, keepends ? pos2 + 1 : pos2));
            start = pos2 = pos2 + 1;
          } else {
            pos2++;
          }
        }
        if (start < _self.length) {
          res.push(_self.slice(start));
        }
        return $B2.$list(res.map($B2.String));
      };
      str.startswith = function() {
        var $ = $B2.args("startswith", 4, { self: null, prefix: null, start: null, end: null }, ["self", "prefix", "start", "end"], arguments, { start: 0, end: null }, null, null), _self;
        normalize_start_end($);
        var prefixes = $.prefix;
        if (!$B2.$isinstance(prefixes, _b_2.tuple)) {
          prefixes = [prefixes];
        }
        _self = to_string($.self);
        prefixes = to_string(prefixes);
        var s = _self.substring($.start, $.end);
        for (var prefix2 of prefixes) {
          if (!$B2.$isinstance(prefix2, str)) {
            throw _b_2.TypeError.$factory("endswith first arg must be str or a tuple of str, not int");
          }
          if (s.substr(0, prefix2.length) == prefix2) {
            return true;
          }
        }
        return false;
      };
      str.strip = function() {
        var $ = $B2.args("strip", 2, { self: null, chars: null }, ["self", "chars"], arguments, { chars: _b_2.None }, null, null);
        var _self = to_string($.self);
        if ($.chars === _b_2.None) {
          return _self.trim();
        }
        return str.rstrip(str.lstrip(_self, $.chars), $.chars);
      };
      str.swapcase = function(self2) {
        $B2.check_nb_args_no_kw("str.swapcase", 1, arguments);
        var res = "", cp2, _self = to_string(self2);
        for (var char of _self) {
          cp2 = _b_2.ord(char);
          if ($B2.in_unicode_category("Ll", cp2)) {
            res += char.toUpperCase();
          } else if ($B2.in_unicode_category("Lu", cp2)) {
            res += char.toLowerCase();
          } else {
            res += char;
          }
        }
        return res;
      };
      str.title = function(self2) {
        $B2.check_nb_args_no_kw("str.title", 1, arguments);
        var state, cp2, res = "", _self = to_string(self2);
        for (var char of _self) {
          cp2 = _b_2.ord(char);
          if ($B2.in_unicode_category("Ll", cp2)) {
            if (!state) {
              res += char.toUpperCase();
              state = "word";
            } else {
              res += char;
            }
          } else if ($B2.in_unicode_category("Lu", cp2) || $B2.in_unicode_category("Lt", cp2)) {
            res += state ? char.toLowerCase() : char;
            state = "word";
          } else {
            state = null;
            res += char;
          }
        }
        return res;
      };
      str.translate = function(self2, table) {
        $B2.check_nb_args_no_kw("str.translate", 2, arguments);
        var res = [], getitem = $B2.$getattr(table, "__getitem__"), cp2, _self = to_string(self2);
        for (var char of _self) {
          cp2 = _b_2.ord(char);
          try {
            var repl = getitem(cp2);
            if (repl !== _b_2.None) {
              if (typeof repl == "string") {
                res.push(repl);
              } else if (typeof repl == "number") {
                res.push(String.fromCharCode(repl));
              }
            }
          } catch (err) {
            res.push(char);
          }
        }
        return res.join("");
      };
      str.upper = function(self2) {
        $B2.check_nb_args_no_kw("str.upper", 1, arguments);
        var _self = to_string(self2);
        return _self.toUpperCase();
      };
      str.zfill = function(self2, width) {
        $B2.check_nb_args_no_kw("str.zfill", 2, arguments);
        var _self = to_string(self2);
        var len = str.__len__(_self);
        if (width <= len) {
          return _self;
        }
        switch (_self.charAt(0)) {
          case "+":
          case "-":
            return _self.charAt(0) + "0".repeat(width - len) + _self.substr(1);
          default:
            return "0".repeat(width - len) + _self;
        }
      };
      str.$factory = function(arg, encoding) {
        if (arguments.length == 0) {
          return "";
        }
        if (arg === void 0) {
          return $B2.UndefinedType.__str__();
        } else if (arg === null) {
          return "<Javascript null>";
        }
        if (encoding !== void 0) {
          var $ = $B2.args("str", 3, { arg: null, encoding: null, errors: null }, ["arg", "encoding", "errors"], arguments, { encoding: "utf-8", errors: "strict" }, null, null);
          encoding = $.encoding;
        }
        if (typeof arg == "string" || arg instanceof String) {
          return arg.toString();
        } else if (typeof arg == "number" && Number.isInteger(arg)) {
          return arg.toString();
        }
        try {
          if (arg.__class__ && arg.__class__ === _b_2.bytes && encoding !== void 0) {
            return _b_2.bytes.decode(arg, $.encoding, $.errors);
          }
          var klass = arg.__class__ || $B2.get_class(arg);
          if (klass === void 0) {
            return $B2.JSObj.__str__($B2.jsobj2pyobj(arg));
          }
          var method = $B2.$getattr(klass, "__str__", null);
          if (method === null) {
            method = $B2.$getattr(klass, "__repr__");
          }
        } catch (err) {
          console.log("no __str__ for", arg);
          console.log("err ", err);
          if ($B2.get_option("debug") > 1) {
            console.log(err);
          }
          console.log("Warning - no method __str__ or __repr__, default to toString", arg);
          throw err;
        }
        var res = $B2.$call(method)(arg);
        if (typeof res == "string" || $B2.$isinstance(res, str)) {
          return res;
        }
        throw _b_2.TypeError.$factory(`__str__ returned non-string (type ${$B2.class_name(res)})`);
      };
      $B2.set_func_names(str, "builtins");
      _b_2.str = str;
      $B2.parse_format_spec = function(spec, obj) {
        if (spec == "") {
          this.empty = true;
        } else {
          var pos2 = 0, aligns = "<>=^", digits = "0123456789", types = "bcdeEfFgGnosxX%", align_pos = aligns.indexOf(spec.charAt(0));
          if (align_pos != -1) {
            if (spec.charAt(1) && aligns.indexOf(spec.charAt(1)) != -1) {
              this.fill = spec.charAt(0);
              this.align = spec.charAt(1);
              pos2 = 2;
            } else {
              this.align = aligns[align_pos];
              this.fill = " ";
              pos2++;
            }
          } else {
            align_pos = aligns.indexOf(spec.charAt(1));
            if (spec.charAt(1) && align_pos != -1) {
              this.align = aligns[align_pos];
              this.fill = spec.charAt(0);
              pos2 = 2;
            }
          }
          var car = spec.charAt(pos2);
          if (car == "+" || car == "-" || car == " ") {
            this.sign = car;
            pos2++;
            car = spec.charAt(pos2);
          }
          if (car == "z") {
            this.z = true;
            pos2++;
            car = spec.charAt(pos2);
          }
          if (car == "#") {
            this.alternate = true;
            pos2++;
            car = spec.charAt(pos2);
          }
          if (car == "0") {
            this.fill = "0";
            if (align_pos == -1) {
              this.align = "=";
            }
            pos2++;
            car = spec.charAt(pos2);
          }
          while (car && digits.indexOf(car) > -1) {
            if (this.width === void 0) {
              this.width = car;
            } else {
              this.width += car;
            }
            pos2++;
            car = spec.charAt(pos2);
          }
          if (this.width !== void 0) {
            this.width = parseInt(this.width);
          }
          if (this.width === void 0 && car == "{") {
            var end_param_pos = spec.substr(pos2).search("}");
            this.width = spec.substring(pos2, end_param_pos);
            pos2 += end_param_pos + 1;
          }
          if (car == "," || car == "_") {
            this.comma = true;
            this.grouping_option = car;
            pos2++;
            car = spec.charAt(pos2);
            if (car == "," || car == "_") {
              if (car == this.grouping_option) {
                throw _b_2.ValueError.$factory(
                  `Cannot specify '${car}' with '${car}'.`
                );
              } else {
                throw _b_2.ValueError.$factory(
                  "Cannot specify both ',' and '_'."
                );
              }
            }
          }
          if (car == ".") {
            if (digits.indexOf(spec.charAt(pos2 + 1)) == -1) {
              throw _b_2.ValueError.$factory(
                "Missing precision in format spec"
              );
            }
            this.precision = spec.charAt(pos2 + 1);
            pos2 += 2;
            car = spec.charAt(pos2);
            while (car && digits.indexOf(car) > -1) {
              this.precision += car;
              pos2++;
              car = spec.charAt(pos2);
            }
            this.precision = parseInt(this.precision);
          }
          if (car && types.indexOf(car) > -1) {
            this.type = car;
            pos2++;
            car = spec.charAt(pos2);
          }
          if (pos2 !== spec.length) {
            var err_msg = `Invalid format specifier '${spec}'`;
            if (obj) {
              err_msg += ` for object of type '${$B2.class_name(obj)}'`;
            }
            throw _b_2.ValueError.$factory(err_msg);
          }
        }
        this.toString = function() {
          return (this.fill === void 0 ? "" : _b_2.str.$factory(this.fill)) + (this.align || "") + (this.sign || "") + (this.alternate ? "#" : "") + (this.sign_aware ? "0" : "") + (this.width || "") + (this.comma ? "," : "") + (this.precision ? "." + this.precision : "") + (this.type || "");
        };
      };
      $B2.format_width = function(s, fmt) {
        if (fmt.width && s.length < fmt.width) {
          var fill = fmt.fill || " ", align = fmt.align || "<", missing = fmt.width - s.length;
          switch (align) {
            case "<":
              return s + fill.repeat(missing);
            case ">":
              return fill.repeat(missing) + s;
            case "=":
              if ("+-".indexOf(s.charAt(0)) > -1) {
                return s.charAt(0) + fill.repeat(missing) + s.substr(1);
              } else {
                return fill.repeat(missing) + s;
              }
            case "^":
              var left = parseInt(missing / 2);
              return fill.repeat(left) + s + fill.repeat(missing - left);
          }
        }
        return s;
      };
      function fstring_expression(start) {
        this.type = "expression";
        this.start = start;
        this.expression = "";
        this.conversion = null;
        this.fmt = null;
      }
      function fstring_error(msg, pos2) {
        var error = Error(msg);
        error.position = pos2;
        throw error;
      }
      $B2.parse_fstring = function(string) {
        var elts = [], pos2 = 0, current = "", ctype = null, nb_braces = 0, expr_start, car;
        while (pos2 < string.length) {
          if (ctype === null) {
            car = string.charAt(pos2);
            if (car == "{") {
              if (string.charAt(pos2 + 1) == "{") {
                ctype = "string";
                current = "{";
                pos2 += 2;
              } else {
                ctype = "expression";
                expr_start = pos2 + 1;
                nb_braces = 1;
                pos2++;
              }
            } else if (car == "}") {
              if (string.charAt(pos2 + 1) == car) {
                ctype = "string";
                current = "}";
                pos2 += 2;
              } else {
                fstring_error(" f-string: single '}' is not allowed", pos2);
              }
            } else {
              ctype = "string";
              current = car;
              pos2++;
            }
          } else if (ctype == "string") {
            var i = pos2;
            while (i < string.length) {
              car = string.charAt(i);
              if (car == "{") {
                if (string.charAt(i + 1) == "{") {
                  current += "{";
                  i += 2;
                } else {
                  elts.push(current);
                  ctype = "expression";
                  expr_start = i + 1;
                  pos2 = i + 1;
                  break;
                }
              } else if (car == "}") {
                if (string.charAt(i + 1) == car) {
                  current += car;
                  i += 2;
                } else {
                  fstring_error(" f-string: single '}' is not allowed", pos2);
                }
              } else {
                current += car;
                i++;
              }
            }
            pos2 = i + 1;
          } else if (ctype == "debug") {
            while (string.charAt(i) == " ") {
              i++;
            }
            if (string.charAt(i) == "}") {
              elts.push(current);
              ctype = null;
              current = "";
              pos2 = i + 1;
            }
          } else {
            let i2 = pos2, nb_paren = 0;
            nb_braces = 1;
            current = new fstring_expression(expr_start);
            while (i2 < string.length) {
              car = string.charAt(i2);
              if (car == "{" && nb_paren == 0) {
                nb_braces++;
                current.expression += car;
                i2++;
              } else if (car == "}" && nb_paren == 0) {
                nb_braces -= 1;
                if (nb_braces == 0) {
                  if (current.expression == "") {
                    fstring_error("f-string: empty expression not allowed", pos2);
                  }
                  elts.push(current);
                  ctype = null;
                  current = "";
                  pos2 = i2 + 1;
                  break;
                }
                current.expression += car;
                i2++;
              } else if (car == "\\") {
                throw Error("f-string expression part cannot include a backslash");
              } else if (nb_paren == 0 && car == "!" && current.fmt === null && ":}".indexOf(string.charAt(i2 + 2)) > -1) {
                if (current.expression.length == 0) {
                  throw Error("f-string: empty expression not allowed");
                }
                if ("ars".indexOf(string.charAt(i2 + 1)) == -1) {
                  throw Error("f-string: invalid conversion character: expected 's', 'r', or 'a'");
                } else {
                  current.conversion = string.charAt(i2 + 1);
                  i2 += 2;
                }
              } else if (car == "(" || car == "[") {
                nb_paren++;
                current.expression += car;
                i2++;
              } else if (car == ")" || car == "]") {
                nb_paren--;
                current.expression += car;
                i2++;
              } else if (car == '"') {
                if (string.substr(i2, 3) == '"""') {
                  let end = string.indexOf('"""', i2 + 3);
                  if (end == -1) {
                    fstring_error("f-string: unterminated string", pos2);
                  } else {
                    var trs = string.substring(i2, end + 3);
                    trs = trs.replace("\n", "\\n\\");
                    current.expression += trs;
                    i2 = end + 3;
                  }
                } else {
                  let end = string.indexOf('"', i2 + 1);
                  if (end == -1) {
                    fstring_error("f-string: unterminated string", pos2);
                  } else {
                    current.expression += string.substring(i2, end + 1);
                    i2 = end + 1;
                  }
                }
              } else if (nb_paren == 0 && car == ":") {
                current.fmt = true;
                var cb = 0, fmt_complete = false;
                for (var j2 = i2 + 1; j2 < string.length; j2++) {
                  if (string[j2] == "{") {
                    if (string[j2 + 1] == "{") {
                      j2 += 2;
                    } else {
                      cb++;
                    }
                  } else if (string[j2] == "}") {
                    if (string[j2 + 1] == "}") {
                      j2 += 2;
                    } else if (cb == 0) {
                      fmt_complete = true;
                      var fmt = string.substring(i2 + 1, j2);
                      current.format = $B2.parse_fstring(fmt);
                      i2 = j2;
                      break;
                    } else {
                      cb--;
                    }
                  }
                }
                if (!fmt_complete) {
                  fstring_error("invalid format", pos2);
                }
              } else if (car == "=") {
                var ce = current.expression, last_char = ce.charAt(ce.length - 1), last_char_re = ("()".indexOf(last_char) > -1 ? "\\" : "") + last_char;
                if (ce.length == 0 || nb_paren > 0 || string.charAt(i2 + 1) == "=" || "=!<>:".search(last_char_re) > -1) {
                  current.expression += car;
                  i2 += 1;
                } else {
                  var tail = car;
                  while (string.charAt(i2 + 1).match(/\s/)) {
                    tail += string.charAt(i2 + 1);
                    i2++;
                  }
                  elts.push(current.expression + tail);
                  while (ce.match(/\s$/)) {
                    ce = ce.substr(0, ce.length - 1);
                  }
                  current.expression = ce;
                  ctype = "debug";
                  i2++;
                }
              } else {
                current.expression += car;
                i2++;
              }
            }
            if (nb_braces > 0) {
              fstring_error("f-string: expected '}'", pos2);
            }
          }
        }
        if (current.length > 0) {
          elts.push(current);
        }
        for (var elt of elts) {
          if (typeof elt == "object") {
            if (elt.fmt_pos !== void 0 && elt.expression.charAt(elt.fmt_pos) != ":") {
              throw Error();
            }
          }
        }
        return elts;
      };
      $B2.codepoint2jsstring = function(i) {
        if (i >= 65536 && i <= 1114111) {
          var code = i - 65536;
          return String.fromCodePoint(55296 | code >> 10) + String.fromCodePoint(56320 | code & 1023);
        } else {
          return String.fromCodePoint(i);
        }
      };
      $B2.jsstring2codepoint = function(c) {
        if (c.length == 1) {
          return c.charCodeAt(0);
        }
        var code = 65536;
        code += (c.charCodeAt(0) & 1023) << 10;
        code += c.charCodeAt(1) & 1023;
        return code;
      };
      var Interpolation = $B2.make_class(
        "Interpolation",
        function(value2, expression, conversion, format_spec) {
          return {
            __class__: Interpolation,
            value: value2,
            expression,
            conversion,
            format_spec
          };
        }
      );
      Interpolation.__repr__ = function(self2) {
        var res = "Interpolation(", items = [];
        for (var attr of ["value", "expression", "conversion", "format_spec"]) {
          items.push(`${_b_2.repr(self2[attr])}`);
        }
        return res + items.join(", ") + ")";
      };
      $B2.set_func_names(Interpolation, "builtins");
      var Template = $B2.make_class("Template", function() {
        var strings = $B2.fast_tuple([]), interpolations = $B2.fast_tuple([]);
        var expect_str = true;
        for (var item2 of arguments) {
          if (Array.isArray(item2)) {
            if (expect_str) {
              strings.push("");
            }
            interpolations.push(Interpolation.$factory(...item2));
          } else {
            strings.push(item2);
            expect_str = false;
          }
        }
        if (expect_str) {
          strings.push("");
        }
        return {
          __class__: Template,
          strings,
          interpolations
        };
      });
      Template.__iter__ = function(self2) {
        self2.$counter = -1;
        self2.$len = self2.strings.length + self2.interpolations.length;
        return self2;
      };
      Template.__next__ = function(self2) {
        self2.$counter++;
        if (self2.$counter >= self2.$len) {
          throw _b_2.StopIteration.$factory("");
        }
        var type = "si"[self2.$counter % 2];
        var rank = Math.floor(self2.$counter / 2);
        switch (type) {
          case "s":
            var s = self2.strings[rank];
            if (s.length > 0) {
              return s;
            }
            return Template.__next__(self2);
          case "i":
            return self2.interpolations[rank];
        }
      };
      Template.values = _b_2.property.$factory(
        function(self2) {
          var values = [];
          for (var itp of self2.interpolations) {
            values.push(itp.value);
          }
          return $B2.fast_tuple(values);
        }
      );
      $B2.set_func_names(Template, "builtins");
      $B2.Template = function() {
        return Template.$factory(...arguments);
      };
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      function $err(op, other) {
        var msg = "unsupported operand type(s) for " + op + " : 'int' and '" + $B2.class_name(other) + "'";
        throw _b_2.TypeError.$factory(msg);
      }
      function int_value(obj) {
        if (typeof obj == "boolean") {
          return obj ? 1 : 0;
        }
        return obj.$brython_value !== void 0 ? obj.$brython_value : obj;
      }
      function bigint_value(obj) {
        if (typeof obj == "boolean") {
          return obj ? 1n : 0n;
        } else if (typeof obj == "number") {
          return BigInt(obj);
        } else if (obj.__class__ === $B2.long_int) {
          return obj.value;
        } else if ($B2.$isinstance(obj, _b_2.int)) {
          return bigint_value(obj.$brython_value);
        }
      }
      var int = { __class__: _b_2.type, __dir__: _b_2.object.__dir__, __mro__: [_b_2.object], __qualname__: "int", $is_class: true, $native: true, $descriptors: { "numerator": true, "denominator": true, "imag": true, "real": true }, $is_int_subclass: true, $is_number: true };
      var int_or_long = int.$int_or_long = function(bigint) {
        var res = Number(bigint);
        return Number.isSafeInteger(res) ? res : $B2.fast_long_int(bigint);
      };
      int.$to_js_number = function(obj) {
        if (typeof obj == "number") {
          return obj;
        } else if (obj.__class__ === $B2.long_int) {
          return Number(obj.value);
        } else if ($B2.$isinstance(obj, _b_2.int)) {
          return int.$to_js_value(obj.$brython_value);
        }
        return null;
      };
      int.$to_bigint = bigint_value;
      int.$int_value = int_value;
      int.as_integer_ratio = function() {
        var $ = $B2.args("as_integer_ratio", 1, { self: null }, ["self"], arguments, {}, null, null);
        return $B2.fast_tuple([$.self, 1]);
      };
      int.from_bytes = function() {
        var $ = $B2.args("from_bytes", 3, { bytes: null, byteorder: null, signed: null }, ["bytes", "byteorder", "signed"], arguments, { byteorder: "big", signed: false }, null, null);
        var x = $.bytes, byteorder = $.byteorder, signed = $.signed, _bytes, _len;
        if ($B2.$isinstance(x, [_b_2.bytes, _b_2.bytearray])) {
          _bytes = x.source;
          _len = x.source.length;
        } else {
          _bytes = _b_2.list.$factory(x);
          _len = _bytes.length;
          for (let i = 0; i < _len; i++) {
            _b_2.bytes.$factory([_bytes[i]]);
          }
        }
        if (byteorder == "big") {
          _bytes.reverse();
        } else if (byteorder != "little") {
          throw _b_2.ValueError.$factory(
            "byteorder must be either 'little' or 'big'"
          );
        }
        var num = _bytes[0];
        if (signed && num >= 128) {
          num = num - 256;
        }
        num = BigInt(num);
        var _mult = 256n;
        for (let i = 1; i < _len; i++) {
          num += _mult * BigInt(_bytes[i]);
          _mult *= 256n;
        }
        if (!signed) {
          return int_or_long(num);
        }
        if (_bytes[_len - 1] < 128) {
          return int_or_long(num);
        }
        return int_or_long(num - _mult);
      };
      int.to_bytes = function() {
        var $ = $B2.args("to_bytes", 3, { self: null, len: null, byteorder: null, signed: null }, ["self", "len", "byteorder", "signed"], arguments, { len: 1, byteorder: "big", signed: false }, null, null), self2 = $.self, len = $.len, byteorder = $.byteorder, signed = $.signed;
        if (!$B2.$isinstance(len, _b_2.int)) {
          throw _b_2.TypeError.$factory("integer argument expected, got " + $B2.class_name(len));
        }
        if (["little", "big"].indexOf(byteorder) == -1) {
          throw _b_2.ValueError.$factory(
            "byteorder must be either 'little' or 'big'"
          );
        }
        if ($B2.$isinstance(self2, $B2.long_int)) {
          return $B2.long_int.to_bytes(self2, len, byteorder, signed);
        }
        if (self2 < 0) {
          if (!signed) {
            throw _b_2.OverflowError.$factory(
              "can't convert negative int to unsigned"
            );
          }
          self2 = Math.pow(256, len) + self2;
        }
        var res = [], value2 = self2;
        while (value2 > 0) {
          var quotient = Math.floor(value2 / 256), rest = value2 - 256 * quotient;
          res.push(rest);
          if (res.length > len) {
            throw _b_2.OverflowError.$factory("int too big to convert");
          }
          value2 = quotient;
        }
        while (res.length < len) {
          res.push(0);
        }
        if (byteorder == "big") {
          res.reverse();
        }
        return {
          __class__: _b_2.bytes,
          source: res
        };
      };
      int.__abs__ = function(self2) {
        return Math.abs(int_value(self2));
      };
      var op_model = `var _b_ = __BRYTHON__.builtins
if(typeof other == "number"){
    return _b_.int.$int_or_long(BigInt(self) + BigInt(other))}else if(other.__class__ === $B.long_int){
    return _b_.int.$int_or_long(BigInt(self) + other.value)}else if(typeof other == "boolean"){
    return _b_.int.$int_or_long(BigInt(self) + (other ? 1n : 0n))}else if($B.$isinstance(other, _b_.int)){
    return _b_.int.__add__(self, other.$brython_value)}
return _b_.NotImplemented
`;
      int.__add__ = Function("self", "other", op_model);
      int.__bool__ = function(self2) {
        return int_value(self2).valueOf() == 0 ? false : true;
      };
      int.__ceil__ = function(self2) {
        return Math.ceil(int_value(self2));
      };
      int.__divmod__ = function(self2, other) {
        if (!$B2.$isinstance(other, int)) {
          return _b_2.NotImplemented;
        }
        return $B2.fast_tuple([int.__floordiv__(self2, other), int.__mod__(self2, other)]);
      };
      int.__eq__ = function(self2, other) {
        var self_as_int = int_value(self2);
        if (self_as_int.__class__ === $B2.long_int) {
          return $B2.long_int.__eq__(self_as_int, other);
        }
        if ($B2.$isinstance(other, int)) {
          return int_value(self2) == int_value(other);
        }
        return _b_2.NotImplemented;
      };
      int.__float__ = function(self2) {
        return $B2.fast_float(int_value(self2));
      };
      function preformat(self2, fmt) {
        if (fmt.empty) {
          return _b_2.str.$factory(self2);
        }
        if (fmt.type && "bcdoxXn".indexOf(fmt.type) == -1) {
          throw _b_2.ValueError.$factory("Unknown format code '" + fmt.type + "' for object of type 'int'");
        }
        var res;
        switch (fmt.type) {
          case void 0:
          case "d":
            res = self2.toString();
            break;
          case "b":
            res = (fmt.alternate ? "0b" : "") + self2.toString(2);
            break;
          case "c":
            res = _b_2.chr(self2);
            break;
          case "o":
            res = (fmt.alternate ? "0o" : "") + self2.toString(8);
            break;
          case "x":
            res = (fmt.alternate ? "0x" : "") + self2.toString(16);
            break;
          case "X":
            res = (fmt.alternate ? "0X" : "") + self2.toString(16).toUpperCase();
            break;
          case "n":
            return self2;
        }
        if (fmt.sign !== void 0) {
          if ((fmt.sign == " " || fmt.sign == "+") && self2 >= 0) {
            res = fmt.sign + res;
          }
        }
        return res;
      }
      int.__format__ = function(self2, format_spec) {
        var fmt = new $B2.parse_format_spec(format_spec, self2);
        if (fmt.type && "eEfFgG%".indexOf(fmt.type) != -1) {
          return _b_2.float.__format__($B2.fast_float(self2), format_spec);
        }
        fmt.align = fmt.align || ">";
        var res = preformat(self2, fmt);
        if (fmt.comma) {
          var sign = res[0] == "-" ? "-" : "", rest = res.substr(sign.length), len = rest.length, nb = Math.ceil(rest.length / 3), chunks = [];
          for (var i = 0; i < nb; i++) {
            chunks.push(rest.substring(len - 3 * i - 3, len - 3 * i));
          }
          chunks.reverse();
          res = sign + chunks.join(",");
        }
        return $B2.format_width(res, fmt);
      };
      int.__floordiv__ = function(self2, other) {
        if (typeof other == "number") {
          if (other == 0) {
            throw _b_2.ZeroDivisionError.$factory("division by zero");
          }
          return Math.floor(self2 / other);
        } else if (typeof other == "boolean") {
          if (other === false) {
            throw _b_2.ZeroDivisionError.$factory("division by zero");
          }
          return self2;
        } else if (other !== null && other.__class__ === $B2.long_int) {
          return Math.floor(self2 / Number(other.value));
        } else if ($B2.$isinstance(other, _b_2.int)) {
          return int.__floordiv__(self2, other.$brython_value);
        }
        return _b_2.NotImplemented;
      };
      int.$getnewargs = function(self2) {
        return $B2.fast_tuple([int_value(self2)]);
      };
      int.__getnewargs__ = function() {
        return int.$getnewargs($B2.single_arg("__getnewargs__", "self", arguments));
      };
      int.__hash__ = function(self2) {
        if (self2.$brython_value !== void 0) {
          if (self2.__hashvalue__ !== void 0) {
            return self2.__hashvalue__;
          }
          if (typeof self2.$brython_value == "number") {
            return self2.__hashvalue__ = self2.$brython_value;
          } else {
            return self2.__hashvalue__ = $B2.long_int.__hash__(self2.$brython_value);
          }
        }
        return self2.valueOf();
      };
      int.__index__ = (self2) => int_value(self2);
      int.__init__ = () => _b_2.None;
      int.__int__ = (self2) => self2;
      int.__invert__ = function(self2) {
        if (Math.abs(self2) < 2 ** 31) {
          return ~self2;
        }
        return $B2.rich_op("__sub__", $B2.rich_op("__mul__", self2, -1), 1);
      };
      int.__mod__ = function(self2, other) {
        if ($B2.$isinstance(other, _b_2.tuple) && other.length == 1) {
          other = other[0];
        }
        if (other.__class__ === $B2.long_int) {
          self2 = BigInt(self2);
          other = other.value;
          if (other == 0) {
            throw _b_2.ZeroDivisionError.$factory(
              "integer division or modulo by zero"
            );
          }
          return int_or_long((self2 % other + other) % other);
        }
        if ($B2.$isinstance(other, int)) {
          other = int_value(other);
          if (other === false) {
            other = 0;
          } else if (other === true) {
            other = 1;
          }
          if (other == 0) {
            throw _b_2.ZeroDivisionError.$factory(
              "integer division or modulo by zero"
            );
          }
          return (self2 % other + other) % other;
        }
        return _b_2.NotImplemented;
      };
      int.__mul__ = Function("self", "other", op_model.replace(/\+/g, "*").replace(/add/g, "mul"));
      int.__ne__ = function(self2, other) {
        var res = int.__eq__(self2, other);
        return res === _b_2.NotImplemented ? res : !res;
      };
      int.__neg__ = function(self2) {
        var self_as_int = int_value(self2);
        if (self_as_int.__class__ === $B2.long_int) {
          return $B2.long_int.__neg__(self_as_int);
        }
        return -self2;
      };
      int.__new__ = function(cls, value2, base) {
        if (cls === void 0) {
          throw _b_2.TypeError.$factory("int.__new__(): not enough arguments");
        } else if (!$B2.$isinstance(cls, _b_2.type)) {
          throw _b_2.TypeError.$factory("int.__new__(X): X is not a type object");
        }
        if (cls === int) {
          return int.$factory(value2, base);
        }
        if (cls === bool) {
          throw _b_2.TypeError.$factory("int.__new__(bool) is not safe, use bool.__new__()");
        }
        return {
          __class__: cls,
          __dict__: $B2.empty_dict(),
          $brython_value: int.$factory(value2, base),
          toString: function() {
            return value2;
          }
        };
      };
      int.__pos__ = function(self2) {
        return self2;
      };
      function extended_euclidean(a, b) {
        var d, u, v;
        if (b == 0) {
          return [a, 1n, 0n];
        } else {
          [d, u, v] = extended_euclidean(b, a % b);
          return [d, v, u - a / b * v];
        }
      }
      int.__pow__ = function(self2, other, z) {
        if (!$B2.$isinstance(other, int)) {
          return _b_2.NotImplemented;
        }
        if (typeof other == "boolean") {
          other = other ? 1 : 0;
        }
        if (typeof other == "number" || $B2.$isinstance(other, int)) {
          if (z !== void 0 && z !== _b_2.None) {
            self2 = bigint_value(self2);
            other = bigint_value(other);
            z = bigint_value(z);
            if (z == 1) {
              return 0;
            }
            var result = 1n, exponent = other, base = self2 % z;
            if (base < 0) {
              base += z;
            }
            if (exponent < 0) {
              var gcd, inv, _;
              [gcd, inv, _] = extended_euclidean(self2, z);
              if (gcd != 1) {
                throw _b_2.ValueError.$factory("not relative primes: " + self2 + " and " + z);
              }
              return int.__pow__(int_or_long(inv), int_or_long(-exponent), int_or_long(z));
            }
            while (exponent > 0) {
              if (exponent % 2n == 1n) {
                result = result * base % z;
              }
              exponent = exponent >> 1n;
              base = base * base % z;
            }
            return int_or_long(result);
          } else {
            if (typeof other == "number") {
              if (other >= 0) {
                return int_or_long(BigInt(self2) ** BigInt(other));
              } else {
                return $B2.fast_float(Math.pow(self2, other));
              }
            } else if (other.__class__ === $B2.long_int) {
              if (other.value >= 0) {
                return int_or_long(BigInt(self2) ** other.value);
              } else {
                return $B2.fast_float(Math.pow(self2, other));
              }
            } else if ($B2.$isinstance(other, _b_2.int)) {
              return int_or_long(int.__pow__(self2, other.$brython_value));
            }
            return _b_2.NotImplemented;
          }
        }
        if ($B2.$isinstance(other, _b_2.float)) {
          other = _b_2.float.numerator(other);
          if (self2 >= 0) {
            return $B2.fast_float(Math.pow(self2, other));
          } else {
            return _b_2.complex.__pow__($B2.make_complex(self2, 0), other);
          }
        } else if ($B2.$isinstance(other, _b_2.complex)) {
          var preal = Math.pow(self2, other.$real), ln = Math.log(self2);
          return $B2.make_complex(preal * Math.cos(ln), preal * Math.sin(ln));
        }
        var rpow = $B2.$getattr(other, "__rpow__", _b_2.None);
        if (rpow !== _b_2.None) {
          return rpow(self2);
        }
        $err("**", other);
      };
      int.__repr__ = function(self2) {
        $B2.builtins_repr_check(int, arguments);
        var value2 = int_value(self2), x = value2.__class__ === $B2.long_int ? value2.value : value2;
        if ($B2.int_max_str_digits != 0 && x >= 10n ** BigInt($B2.int_max_str_digits)) {
          throw _b_2.ValueError.$factory(`Exceeds the limit (${$B2.int_max_str_digits}) for integer string conversion`);
        }
        return x.toString();
      };
      int.__setattr__ = function(self2, attr2, value2) {
        if (typeof self2 == "number" || typeof self2 == "boolean") {
          var cl_name = $B2.class_name(self2);
          if (_b_2.dir(self2).indexOf(attr2) > -1) {
            throw _b_2.AttributeError.$factory("attribute '" + attr2 + `' of '${cl_name}' objects is not writable`);
          } else {
            throw _b_2.AttributeError.$factory(`'${cl_name}' object has no attribute '${attr2}'`);
          }
        }
        _b_2.dict.$setitem(self2.__dict__, attr2, value2);
        return _b_2.None;
      };
      int.__sub__ = Function("self", "other", op_model.replace(/\+/g, "-").replace(/__add__/g, "__sub__"));
      int.__truediv__ = function(self2, other) {
        if ($B2.$isinstance(other, int)) {
          other = int_value(other);
          if (other == 0) {
            throw _b_2.ZeroDivisionError.$factory("division by zero");
          }
          if (other.__class__ === $B2.long_int) {
            return $B2.fast_float(self2 / parseInt(other.value));
          }
          return $B2.fast_float(self2 / other);
        }
        return _b_2.NotImplemented;
      };
      int.bit_count = function(self2) {
        var s = _b_2.bin(_b_2.abs(self2)), nb = 0;
        for (var x of s) {
          if (x == "1") {
            nb++;
          }
        }
        return nb;
      };
      int.bit_length = function(self2) {
        var s = _b_2.bin(self2);
        s = $B2.$getattr(s, "lstrip")("-0b");
        return s.length;
      };
      int.numerator = (self2) => int_value(self2);
      int.denominator = () => 1;
      int.imag = () => 0;
      int.real = (self2) => self2;
      for (var attr of ["numerator", "denominator", "imag", "real"]) {
        int[attr].setter = /* @__PURE__ */ (function(x) {
          return function(self2) {
            throw _b_2.AttributeError.$factory(`attribute '${x}' of '${$B2.class_name(self2)}' objects is not writable`);
          };
        })(attr);
      }
      var model = `var _b_ = __BRYTHON__.builtins
if(typeof other == "number"){
    // transform into BigInt: JS converts numbers to 32 bits
    return _b_.int.$int_or_long(BigInt(self) & BigInt(other))}else if(typeof other == "boolean"){
    return self & (other ? 1 : 0)}else if(other.__class__ === $B.long_int){
    return _b_.int.$int_or_long(BigInt(self) & other.value)}else if($B.$isinstance(other, _b_.int)){
    // int subclass
    return _b_.int.__and__(self, other.$brython_value)}
return _b_.NotImplemented`;
      int.__and__ = Function("self", "other", model);
      int.__lshift__ = Function("self", "other", model.replace(/&/g, "<<").replace(/__and__/g, "__lshift__"));
      int.__rshift__ = Function("self", "other", model.replace(/&/g, ">>").replace(/__and__/g, "__rshift__"));
      int.__or__ = Function("self", "other", model.replace(/&/g, "|").replace(/__and__/g, "__or__"));
      int.__xor__ = Function("self", "other", model.replace(/&/g, "^").replace(/__and__/g, "__xor__"));
      int.__ge__ = function(self2, other) {
        self2 = int_value(self2);
        if (typeof other == "number") {
          return self2 >= other;
        } else if (other !== null && other.__class__ === $B2.long_int) {
          return self2 >= other.value;
        } else if (typeof other == "boolean") {
          return self2 >= other ? 1 : 0;
        } else if ($B2.$isinstance(other, _b_2.int)) {
          return self2 >= other.$brython_value;
        }
        return _b_2.NotImplemented;
      };
      int.__gt__ = function(self2, other) {
        var res = int.__le__(self2, other);
        return res === _b_2.NotImplemented ? res : !res;
      };
      int.__le__ = function(self2, other) {
        self2 = int_value(self2);
        if (typeof other == "number") {
          return self2 <= other;
        } else if (other !== null && other.__class__ === $B2.long_int) {
          return self2 <= other.value;
        } else if (typeof other == "boolean") {
          return self2 <= other ? 1 : 0;
        } else if ($B2.$isinstance(other, _b_2.int)) {
          return self2 <= other.$brython_value;
        }
        return _b_2.NotImplemented;
      };
      int.__lt__ = function(self2, other) {
        var res = int.__ge__(self2, other);
        return res === _b_2.NotImplemented ? res : !res;
      };
      var r_opnames = ["add", "sub", "mul", "truediv", "floordiv", "mod", "pow", "lshift", "rshift", "and", "xor", "or", "divmod"];
      for (var r_opname of r_opnames) {
        if (int["__r" + r_opname + "__"] === void 0 && int["__" + r_opname + "__"]) {
          int["__r" + r_opname + "__"] = /* @__PURE__ */ (function(name2) {
            return function(self2, other) {
              if ($B2.$isinstance(other, int)) {
                other = int_value(other);
                return int["__" + name2 + "__"](other, self2);
              }
              return _b_2.NotImplemented;
            };
          })(r_opname);
        }
      }
      var $valid_digits = function(base) {
        var digits = "";
        if (base === 0) {
          return "0";
        }
        if (base < 10) {
          for (let i = 0; i < base; i++) {
            digits += String.fromCharCode(i + 48);
          }
          return digits;
        }
        digits = "0123456789";
        for (let i = 10; i < base; i++) {
          digits += String.fromCharCode(i + 55);
        }
        return digits;
      };
      int.$factory = function() {
        var missing = {}, $ = $B2.args("int", 2, { x: null, base: null }, ["x", "base"], arguments, { x: missing, base: missing }, null, null, 1), value2 = $.x, base = $.base === void 0 ? missing : $.base, initial_value = value2, explicit_base = base !== missing;
        if (value2 === missing || value2 === void 0) {
          if (base !== missing) {
            throw _b_2.TypeError.$factory("int() missing string argument");
          }
          return 0;
        }
        if ($B2.$isinstance(value2, [_b_2.bytes, _b_2.bytearray])) {
          value2 = $B2.$getattr(value2, "decode")("latin-1");
        } else if (explicit_base && !$B2.$isinstance(value2, _b_2.str)) {
          throw _b_2.TypeError.$factory(
            "int() can't convert non-string with explicit base"
          );
        } else if ($B2.$isinstance(value2, _b_2.memoryview)) {
          value2 = $B2.$getattr(_b_2.memoryview.tobytes(value2), "decode")("latin-1");
        }
        if (!$B2.$isinstance(value2, _b_2.str)) {
          if (base !== missing) {
            throw _b_2.TypeError.$factory(
              "int() can't convert non-string with explicit base"
            );
          } else {
            for (let special_method of ["__int__", "__index__", "__trunc__"]) {
              let num_value = $B2.$getattr($B2.get_class(value2), special_method, _b_2.None);
              if (num_value !== _b_2.None) {
                let res2 = $B2.$call(num_value)(value2);
                if (special_method == "__trunc__") {
                  $B2.warn(_b_2.DeprecationWarning, "The delegation of int() to __trunc__ is deprecated.");
                  let index_method = $B2.$getattr(res2, "__index__", null);
                  if (index_method === null) {
                    throw _b_2.TypeError.$factory(`__trunc__ returned non-Integral (type ${$B2.class_name(res2)})`);
                  }
                  res2 = $B2.$call(index_method)();
                }
                if ($B2.$isinstance(res2, _b_2.int)) {
                  if (typeof res2 !== "number" && res2.__class__ !== $B2.long_int) {
                    $B2.warn(_b_2.DeprecationWarning, special_method + " returned non-int (type " + $B2.class_name(res2) + ").  The ability to return an instance of a strict subclass of int is deprecated, and may be removed in a future version of Python.");
                  }
                  return int_value(res2);
                } else {
                  let klass = $B2.get_class(res2), index_method = $B2.$getattr(klass, "__index__", null);
                  if (index_method === null) {
                    throw _b_2.TypeError.$factory(special_method + `returned non-int (type ${$B2.class_name(res2)})`);
                  }
                  return int_value(res2);
                }
              }
            }
            throw _b_2.TypeError.$factory(
              `int() argument must be a string, a bytes-like object or a real number, not '${$B2.class_name(value2)}'`
            );
          }
        }
        if (value2.length == 0) {
          throw _b_2.ValueError.$factory(
            `invalid literal for int() with base 10: ${_b_2.repr(value2)}`
          );
        }
        base = base === missing ? 10 : $B2.PyNumber_Index(base);
        if (!(base >= 2 && base <= 36)) {
          if (base != 0) {
            throw _b_2.ValueError.$factory("invalid base");
          }
        }
        function invalid(base2) {
          throw _b_2.ValueError.$factory("invalid literal for int() with base " + base2 + ": " + _b_2.repr(initial_value));
        }
        if (typeof value2 != "string") {
          value2 = _b_2.str.$to_string(value2);
        }
        var _value = value2.trim(), sign = "";
        if (_value.startsWith("+") || _value.startsWith("-")) {
          sign = _value[0];
          _value = _value.substr(1);
        }
        if (_value.length == 2 && base == 0 && (_value == "0b" || _value == "0o" || _value == "0x")) {
          throw _b_2.ValueError.$factory("invalid value");
        }
        if (_value.endsWith("_")) {
          invalid(base);
        }
        if (value2.indexOf("__") > -1) {
          invalid(base);
        }
        if (_value.length > 2) {
          let _pre = _value.substr(0, 2).toUpperCase();
          if (base == 0) {
            if (_pre == "0B") {
              base = 2;
            } else if (_pre == "0O") {
              base = 8;
            } else if (_pre == "0X") {
              base = 16;
            } else if (_value.startsWith("0")) {
              _value = _value.replace(/_/g, "");
              if (_value.match(/^0+$/)) {
                return 0;
              }
              invalid(base);
            }
          } else if (_pre == "0X" && base != 16) {
            invalid(base);
          } else if (_pre == "0O" && base != 8) {
            invalid(base);
          }
          if (_pre == "0B" && base == 2 || _pre == "0O" || _pre == "0X") {
            _value = _value.substr(2);
            if (_value.startsWith("_")) {
              _value = _value.substr(1);
            }
          }
        }
        if (base == 0) {
          base = 10;
        }
        var _digits = $valid_digits(base), _re = new RegExp("^[+-]?[" + _digits + "][" + _digits + "_]*$", "i"), match = _re.exec(_value), res;
        if (match === null) {
          res = 0;
          var digit;
          for (var char of _value) {
            if (new RegExp("\\p{Nd}", "u").test(char)) {
              let cp = char.codePointAt(0);
              for (let start of $B2.digits_starts) {
                if (cp - start < 10) {
                  digit = cp - start;
                  break;
                }
              }
            } else {
              if (base > 10 && _digits.indexOf(char.toUpperCase()) > -1) {
                digit = char.toUpperCase().charCodeAt(0) - 55;
              } else {
                invalid(base);
              }
            }
            if (digit < base) {
              res = $B2.rich_op("__mul__", res, base);
              res = $B2.rich_op("__add__", res, digit);
            } else {
              invalid(base);
            }
          }
          return res;
        } else {
          _value = _value.replace(/_/g, "");
        }
        if (base == 2) {
          res = BigInt("0b" + _value);
        } else if (base == 8) {
          res = BigInt("0o" + _value);
        } else if (base == 16) {
          res = BigInt("0x" + _value);
        } else {
          if ($B2.int_max_str_digits != 0 && _value.length > $B2.int_max_str_digits) {
            throw _b_2.ValueError.$factory(`Exceeds the limit (${$B2.int_max_str_digits}) for integer string conversion: value has ${value2.length} digits; use sys.set_int_max_str_digits() to increase the limit.`);
          }
          if (base == 10) {
            res = BigInt(_value);
          } else {
            base = BigInt(base);
            res = 0n;
            let coef = 1n, char2;
            for (let i = _value.length - 1; i >= 0; i--) {
              char2 = _value[i].toUpperCase();
              res += coef * BigInt(_digits.indexOf(char2));
              coef *= base;
            }
          }
        }
        if (sign == "-") {
          res = -res;
        }
        return int_or_long(res);
      };
      $B2.set_func_names(int, "builtins");
      _b_2.int = int;
      $B2.$bool = function(obj, bool_class) {
        if (obj === null || obj === void 0) {
          return false;
        }
        switch (typeof obj) {
          case "boolean":
            return obj;
          case "number":
          case "string":
            if (obj) {
              return true;
            }
            return false;
          default:
            if (obj.$is_class) {
              return true;
            }
            var klass = $B2.get_class(obj), missing = {}, bool_method = $B2.search_in_mro(klass, "__bool__");
            var test = false;
            if (test) {
              console.log("bool(obj)", obj, "bool_class", bool_class, "klass", klass, "apply bool method", bool_method);
              console.log("$B.$call(bool_method)", bool_method + "");
            }
            if (bool_method === void 0) {
              var len_method = $B2.$getattr(klass, "__len__", missing);
              if (len_method === missing) {
                return true;
              }
              return _b_2.len(obj) > 0;
            } else {
              var res = $B2.$call(bool_method)(obj);
              if (res !== true && res !== false) {
                throw _b_2.TypeError.$factory("__bool__ should return bool, returned " + $B2.class_name(res));
              }
              if (test) {
                console.log("bool method returns", res);
              }
              return res;
            }
        }
      };
      var bool = {
        __bases__: [int],
        __class__: _b_2.type,
        __mro__: [int, _b_2.object],
        __qualname__: "bool",
        $is_class: true,
        $not_basetype: true,
        $is_number: true,
        $native: true,
        $descriptors: { "numerator": true, "denominator": true, "imag": true, "real": true }
      };
      bool.__and__ = function(self2, other) {
        if ($B2.$isinstance(other, bool)) {
          return self2 && other;
        } else if ($B2.$isinstance(other, int)) {
          return int.__and__(bool.__index__(self2), int.__index__(other));
        }
        return _b_2.NotImplemented;
      };
      bool.__float__ = function(self2) {
        return self2 ? $B2.fast_float(1) : $B2.fast_float(0);
      };
      bool.__hash__ = bool.__index__ = bool.__int__ = function(self2) {
        if (self2.valueOf()) return 1;
        return 0;
      };
      bool.__neg__ = function(self2) {
        return -$B2.int_or_bool(self2);
      };
      bool.__or__ = function(self2, other) {
        if ($B2.$isinstance(other, bool)) {
          return self2 || other;
        } else if ($B2.$isinstance(other, int)) {
          return int.__or__(bool.__index__(self2), int.__index__(other));
        }
        return _b_2.NotImplemented;
      };
      bool.__pos__ = $B2.int_or_bool;
      bool.__repr__ = function(self2) {
        $B2.builtins_repr_check(bool, arguments);
        return self2 ? "True" : "False";
      };
      bool.__xor__ = function(self2, other) {
        if ($B2.$isinstance(other, bool)) {
          return self2 ^ other ? true : false;
        } else if ($B2.$isinstance(other, int)) {
          return int.__xor__(bool.__index__(self2), int.__index__(other));
        }
        return _b_2.NotImplemented;
      };
      bool.__invert__ = function(self2) {
        $B2.warn(_b_2.DeprecationWarning, `Bitwise inversion '~' on bool is deprecated.This returns the bitwise inversion of the underlying int object and is usually not what you expect from negating a bool.Use the 'not' operator for boolean negation or ~int(x) if you really want the bitwise inversion of the underlying int.`);
        return int.__invert__(self2);
      };
      bool.$factory = function() {
        var $ = $B2.args("bool", 1, { x: null }, ["x"], arguments, { x: false }, null, null, 1);
        return $B2.$bool($.x, true);
      };
      bool.__new__ = function(cls, value2) {
        if (cls === void 0) {
          throw _b_2.TypeError.$factory("bool.__new__(): not enough arguments");
        } else if (!$B2.$isinstance(cls, _b_2.type)) {
          throw _b_2.TypeError.$factory(`bool.__new__(X): X is not a type object (${$B2.class_name(cls)})`);
        } else if (!_b_2.issubclass(cls, bool)) {
          let class_name = $B2.class_name(cls);
          throw _b_2.TypeError.$factory(`bool.__new__(${class_name}): ${class_name} is not a subtype of bool`);
        }
        if (arguments.length > 2) {
          throw _b_2.TypeError.$factory(`bool expected at most 1 argument, got ${arguments.length - 1}`);
        }
        return bool.$factory(value2);
      };
      bool.from_bytes = function() {
        var $ = $B2.args("from_bytes", 3, { bytes: null, byteorder: null, signed: null }, ["bytes", "byteorder", "signed"], arguments, { byteorder: "big", signed: false }, null, null);
        let int_result = int.from_bytes($.bytes, $.byteorder, $.signed);
        return bool.$factory(int_result);
      };
      bool.numerator = int.numerator;
      bool.denominator = int.denominator;
      bool.real = (self2) => self2 ? 1 : 0;
      bool.imag = int.imag;
      for (var attr of ["real"]) {
        bool[attr].setter = /* @__PURE__ */ (function(x) {
          return function(self2) {
            throw _b_2.AttributeError.$factory(`attribute '${x}' of '${$B2.class_name(self2)}' objects is not writable`);
          };
        })(attr);
      }
      _b_2.bool = bool;
      $B2.set_func_names(bool, "builtins");
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      var long_int = { __class__: _b_2.type, __mro__: [_b_2.int, _b_2.object], __qualname__: "int", $infos: { __module__: "builtins", __name__: "int" }, $is_class: true, $native: true, $descriptors: { "numerator": true, "denominator": true, "imag": true, "real": true } };
      var int_or_long = _b_2.int.$int_or_long;
      function preformat(self2, fmt) {
        if (fmt.empty) {
          return _b_2.str.$factory(self2);
        }
        if (fmt.type && "bcdoxXn".indexOf(fmt.type) == -1) {
          throw _b_2.ValueError.$factory("Unknown format code '" + fmt.type + "' for object of type 'int'");
        }
        var res;
        switch (fmt.type) {
          case void 0:
          case "d":
            res = self2.toString();
            break;
          case "b":
            res = (fmt.alternate ? "0b" : "") + BigInt(self2.value).toString(2);
            break;
          case "c":
            res = _b_2.chr(self2);
            break;
          case "o":
            res = (fmt.alternate ? "0o" : "") + BigInt(self2.value).toString(8);
            break;
          case "x":
            res = (fmt.alternate ? "0x" : "") + BigInt(self2.value).toString(16);
            break;
          case "X":
            res = (fmt.alternate ? "0X" : "") + BigInt(self2.value).toString(16).toUpperCase();
            break;
          case "n":
            return self2;
        }
        if (fmt.sign !== void 0) {
          if ((fmt.sign == " " || fmt.sign == "+") && self2 >= 0) {
            res = fmt.sign + res;
          }
        }
        return res;
      }
      long_int.$to_js_number = function(self2) {
        return Number(self2.value);
      };
      long_int.__format__ = function(self2, format_spec) {
        var fmt = new $B2.parse_format_spec(format_spec, self2);
        if (fmt.type && "eEfFgG%".indexOf(fmt.type) != -1) {
          return _b_2.float.__format__(self2, format_spec);
        }
        fmt.align = fmt.align || ">";
        var res = preformat(self2, fmt);
        if (fmt.comma) {
          var sign = res[0] == "-" ? "-" : "", rest = res.substr(sign.length), len = rest.length, nb = Math.ceil(rest.length / 3), chunks = [];
          for (var i = 0; i < nb; i++) {
            chunks.push(rest.substring(len - 3 * i - 3, len - 3 * i));
          }
          chunks.reverse();
          res = sign + chunks.join(",");
        }
        return $B2.format_width(res, fmt);
      };
      long_int.__abs__ = function(self2) {
        return $B2.fast_long_int(self2.value > 0 ? self2.value : -self2.value);
      };
      long_int.__add__ = function(self2, other) {
        if (typeof other == "number") {
          return int_or_long(self2.value + BigInt(other));
        } else if (other.__class__ === $B2.long_int) {
          return int_or_long(self2.value + other.value);
        } else if (typeof other == "boolean") {
          return int_or_long(self2.value + (other ? 1n : 0n));
        } else if ($B2.$isinstance(other, _b_2.int)) {
          return long_int.__add__(self2, other.$brython_value);
        }
        return _b_2.NotImplemented;
      };
      long_int.__divmod__ = function(self2, other) {
        var a = self2.value, b = _b_2.int.$to_bigint(other), quotient;
        if (a >= 0 && b > 0 || a <= 0 && b < 0) {
          quotient = a / b;
        } else {
          quotient = a / b - 1n;
        }
        var rest = a - quotient * b;
        return $B2.fast_tuple([int_or_long(quotient), int_or_long(rest)]);
      };
      long_int.__eq__ = function(self2, other) {
        if (other.__class__ === $B2.long_int) {
          return self2.value == other.value;
        } else if (typeof other == "number" || typeof other == "boolean") {
          return false;
        } else if ($B2.$isinstance(other, _b_2.int)) {
          return long_int.__eq__(self2, other.$brython_value);
        }
        return _b_2.NotImplemented;
      };
      long_int.__float__ = function(self2) {
        if (!isFinite(Number(self2.value))) {
          throw _b_2.OverflowError.$factory("int too large to convert to float");
        }
        return $B2.fast_float(Number(self2.value));
      };
      long_int.__floordiv__ = function(self2, other) {
        if (typeof other == "number") {
          return int_or_long(self2.value / BigInt(other));
        } else if (other.__class__ === $B2.long_int) {
          return int_or_long(self2.value / other.value);
        } else if (typeof other == "boolean") {
          return int_or_long(self2.value / (other ? 1n : 0n));
        } else if ($B2.$isinstance(other, _b_2.int)) {
          return int_or_long(self2.value / other.$brython_value);
        }
        return _b_2.NotImplemented;
      };
      long_int.__ge__ = function(self2, other) {
        if (typeof other == "number") {
          return self2.value >= other;
        } else if (other.__class__ === $B2.long_int) {
          return self2.value >= other.value;
        } else if (typeof other == "boolean") {
          return self2.value >= (other ? 1 : 0);
        } else if ($B2.$isinstance(other, _b_2.int)) {
          return self2.value >= other.$brython_value;
        }
        return _b_2.NotImplemented;
      };
      long_int.__gt__ = function(self2, other) {
        var res = long_int.__le__(self2, other);
        return res === _b_2.NotImplemented ? res : !res;
      };
      long_int.__hash__ = function(self2) {
        var modulus = 2305843009213693951n, sign = self2.value >= 0 ? 1n : -1n, self_pos = self2.value * sign;
        var _hash = sign * (self_pos % modulus);
        return self2.__hashvalue__ = int_or_long(_hash);
      };
      long_int.__index__ = function(self2) {
        return self2;
      };
      long_int.__invert__ = function(self2) {
        return int_or_long(-1n - self2.value);
      };
      long_int.__le__ = function(self2, other) {
        if (typeof other == "number") {
          return self2.value <= other;
        } else if (other.__class__ === $B2.long_int) {
          return self2.value <= other.value;
        } else if (typeof other == "boolean") {
          return self2.value <= (other ? 1 : 0);
        } else if ($B2.$isinstance(other, _b_2.int)) {
          return self2.value <= other.$brython_value;
        }
        return _b_2.NotImplemented;
      };
      long_int.__lt__ = function(self2, other) {
        var res = long_int.__ge__(self2, other);
        return res === _b_2.NotImplemented ? res : !res;
      };
      long_int.__lshift__ = function(self2, other) {
        if (typeof other == "number") {
          return int_or_long(self2.value << BigInt(other));
        } else if (other.__class__ === $B2.long_int) {
          return int_or_long(self2.value << other.value);
        } else if (typeof other == "boolean") {
          return int_or_long(self2.value << (other ? 1n : 0n));
        } else if ($B2.$isinstance(other, _b_2.int)) {
          return long_int.__lshift__(self2, other.$brython_value);
        }
        return _b_2.NotImplemented;
      };
      long_int.__mod__ = function(self2, other) {
        if (typeof other == "number") {
          return int_or_long(self2.value % BigInt(other));
        } else if (other.__class__ === $B2.long_int) {
          var n = self2.value, m = other.value;
          return int_or_long((n % m + m) % m);
        } else if (typeof other == "boolean") {
          return int_or_long(self2.value % (other ? 1n : 0n));
        } else if ($B2.$isinstance(other, _b_2.int)) {
          return long_int.__mod__(self2, other.$brython_value);
        }
        return _b_2.NotImplemented;
      };
      long_int.__mro__ = [_b_2.int, _b_2.object];
      long_int.__mul__ = function(self2, other) {
        if (typeof other == "number") {
          return int_or_long(self2.value * BigInt(other));
        } else if (typeof other == "boolean") {
          return int_or_long(self2.value * (other ? 1n : 0n));
        } else if (other.__class__ === $B2.long_int) {
          return int_or_long(self2.value * other.value);
        } else if ($B2.$isinstance(other, _b_2.int)) {
          return long_int.__mul__(self2, other.$brython_value);
        }
        return _b_2.NotImplemented;
      };
      long_int.__ne__ = function(self2, other) {
        var res = long_int.__eq__(self2, other);
        return res === _b_2.NotImplemented ? res : !res;
      };
      long_int.__neg__ = function(self2) {
        return $B2.fast_long_int(-self2.value);
      };
      long_int.__pos__ = function(self2) {
        return self2;
      };
      long_int.__pow__ = function(self2, power, z) {
        if (z !== void 0) {
          return _b_2.int.__pow__(self2, power, z);
        }
        if (typeof power == "number") {
          return int_or_long(self2.value ** BigInt(power));
        } else if (typeof power == "boolean") {
          return int_or_long(self2.value ** power ? 1n : 0n);
        } else if (power.__class__ === $B2.long_int) {
          return int_or_long(self2.value ** power.value);
        } else if ($B2.$isinstance(power, _b_2.int)) {
          return long_int.__pow__(self2, power.$brython_value);
        }
        return _b_2.NotImplemented;
      };
      long_int.__rshift__ = function(self2, other) {
        if (typeof other == "number") {
          return int_or_long(self2.value >> BigInt(other));
        } else if (other.__class__ === $B2.long_int) {
          return int_or_long(self2.value >> other.value);
        } else if (typeof other == "boolean") {
          return int_or_long(self2.value >> (other ? 1n : 0n));
        } else if ($B2.$isinstance(other, _b_2.int)) {
          return long_int.__rshift__(self2, other.$brython_value);
        }
        return _b_2.NotImplemented;
      };
      long_int.__repr__ = function(self2) {
        $B2.builtins_repr_check($B2.long_int, arguments);
        if ($B2.int_max_str_digits != 0 && self2.value >= 10n ** BigInt($B2.int_max_str_digits)) {
          throw _b_2.ValueError.$factory(`Exceeds the limit (${$B2.int_max_str_digits}) for integer string conversion`);
        }
        return self2.value.toString();
      };
      long_int.__sub__ = function(self2, other) {
        if (typeof other == "number") {
          return int_or_long(self2.value - BigInt(other));
        } else if (typeof other == "boolean") {
          return int_or_long(self2.value - (other ? 1n : 0n));
        } else if (other.__class__ === $B2.long_int) {
          return int_or_long(self2.value - other.value);
        } else if ($B2.$isinstance(other, _b_2.int)) {
          return long_int.__sub__(self2, other.$brython_value);
        }
        return _b_2.NotImplemented;
      };
      long_int.__truediv__ = function(self2, other) {
        if (typeof other == "number") {
          return $B2.fast_float(Number(self2.value) / other);
        } else if (typeof other == "boolean") {
          return $B2.fast_float(Number(self2.value) * (other ? 1 : 0));
        } else if (other.__class__ === $B2.long_int) {
          return $B2.fast_float(Number(self2.value) / Number(other.value));
        } else if ($B2.$isinstance(other, _b_2.int)) {
          return long_int.__truediv__(self2, other.$brython_value);
        }
        return _b_2.NotImplemented;
      };
      long_int.bit_count = function(self2) {
        var s = self2.value.toString(2), nb = 0;
        for (var x of s) {
          if (x == "1") {
            nb++;
          }
        }
        return nb;
      };
      long_int.bit_length = function(self2) {
        return self2.value.toString(2).length;
      };
      function _infos(self2) {
        var nbits = $B2.long_int.bit_length(self2), pow2 = 2n ** BigInt(nbits - 1), rest = BigInt(self2.value) - pow2, relative_rest = new Number(rest / pow2);
        return { nbits, pow2, rest, relative_rest };
      }
      long_int.$log2 = function(x) {
        if (x.value < 0) {
          throw _b_2.ValueError.$factory("math domain error");
        }
        var infos = _infos(x);
        return _b_2.float.$factory(infos.nbits - 1 + Math.log(1 + infos.relative_rest / Math.LN2));
      };
      long_int.$log10 = function(x) {
        if (x.value < 0) {
          throw _b_2.ValueError.$factory("math domain error");
        }
        var x_string = x.value.toString(), exp = x_string.length - 1, mant = parseFloat(x_string[0] + "." + x_string.substr(1));
        return _b_2.float.$factory(exp + Math.log10(mant));
      };
      long_int.numerator = (self2) => self2;
      long_int.denominator = () => 1;
      long_int.imag = () => 0;
      long_int.real = (self2) => self2;
      var body = `var $B = __BRYTHON__,
    _b_ = $B.builtins
if(typeof other == "number"){
    return _b_.int.$int_or_long(self.value & BigInt(other))}else if(typeof other == "boolean"){
    return _b_.int.$int_or_long(self.value & (other ? 1n : 0n))}else if(other.__class__ === $B.long_int){
    return _b_.int.$int_or_long(self.value & other.value)}else if($B.$isinstance(other, _b_.int)){
    // int subclass
    return $B.long_int.__and__(self, other.$brython_value)}
return _b_.NotImplemented`;
      long_int.__and__ = Function("self", "other", body);
      long_int.__or__ = Function("self", "other", body.replace(/&/g, "|").replace(/__and__/g, "__or__"));
      long_int.__xor__ = Function("self", "other", body.replace(/&/g, "^").replace(/__and__/g, "__xor__"));
      long_int.to_bytes = function(self2, len, byteorder, signed) {
        var res = [], v = self2.value;
        if (!$B2.$bool(signed) && v < 0) {
          throw _b_2.OverflowError.$factory("can't convert negative int to unsigned");
        }
        while (v > 0) {
          var quot = v / 256n, rest = v - quot * 256n;
          v = quot;
          res.push(Number(rest));
          if (res.length > len) {
            throw _b_2.OverflowError.$factory("int too big to convert");
          }
        }
        while (res.length < len) {
          res.push(0);
        }
        if (byteorder == "big") {
          res.reverse();
        }
        return _b_2.bytes.$factory(res);
      };
      function digits(base) {
        var is_digits = {};
        for (let i = 0; i < base; i++) {
          if (i == 10) {
            break;
          }
          is_digits[i] = i;
        }
        if (base > 10) {
          for (let i = 0; i < base - 10; i++) {
            is_digits[String.fromCharCode(65 + i)] = 10 + i;
            is_digits[String.fromCharCode(97 + i)] = 10 + i;
          }
        }
        return is_digits;
      }
      long_int.$from_int = function(value2) {
        return { __class__: long_int, value: value2.toString(), pos: value2 > 0 };
      };
      long_int.$factory = function(value2, base) {
        var is_digits = digits(base);
        for (let i = 0; i < value2.length; i++) {
          if (is_digits[value2.charAt(i)] === void 0) {
            throw _b_2.ValueError.$factory(
              'int argument is not a valid number: "' + value2 + '"'
            );
          }
        }
        var res;
        if (base == 10) {
          res = BigInt(value2);
        } else if (base == 16) {
          res = BigInt("0x" + value2);
        } else if (base == 8) {
          res = BigInt("0o" + value2);
        } else {
          base = BigInt(base);
          res = 0n;
          let coef = 1n, char;
          for (let i = value2.length - 1; i >= 0; i--) {
            char = value2[i].toUpperCase();
            res += coef * BigInt(is_digits[char]);
            coef *= base;
          }
        }
        return { __class__: $B2.long_int, value: res };
      };
      function extended_euclidean_algorithm(a, b) {
        var s = 0, old_s = 1, t = 1, old_t = 0, r = b, old_r = a, quotient, tmp;
        while ($B2.rich_comp("__ne__", r, 0)) {
          quotient = $B2.rich_op("__floordiv__", old_r, r);
          tmp = $B2.rich_op("__sub__", old_r, $B2.rich_op("__mul__", quotient, r));
          old_r = r;
          r = tmp;
          tmp = $B2.rich_op("__sub__", old_s, $B2.rich_op("__mul__", quotient, s));
          old_s = s;
          s = tmp;
          tmp = $B2.rich_op("__sub__", old_t, $B2.rich_op("__mul__", quotient, t));
          old_t = t;
          t = tmp;
        }
        return [old_r, old_s, old_t];
      }
      function inverse_of(n, p) {
        var gcd, x, y;
        [gcd, x, y] = extended_euclidean_algorithm(n, p);
        if ($B2.rich_comp("__ne__", gcd, 1)) {
          throw Error(
            `${n} has no multiplicative inverse '
            'modulo ${p}`
          );
        } else {
          return $B2.rich_op("__mod__", x, p);
        }
      }
      $B2.inverse_of = inverse_of;
      $B2.set_func_names(long_int, "builtins");
      $B2.long_int = long_int;
      $B2.fast_long_int = function(value2) {
        if (typeof value2 !== "bigint") {
          console.log("expected bigint, got", value2);
          throw Error("not a big int");
        }
        return {
          __class__: $B2.long_int,
          value: value2
        };
      };
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      function float_value(obj) {
        return obj.__class__ === float ? obj : fast_float(obj.value);
      }
      function copysign(x, y) {
        var x1 = Math.abs(x);
        var y1 = y;
        var sign = Math.sign(y1);
        sign = sign == 1 || Object.is(sign, 0) ? 1 : -1;
        return x1 * sign;
      }
      var float = { __class__: _b_2.type, __dir__: _b_2.object.__dir__, __qualname__: "float", $is_class: true, $native: true, $descriptors: { "numerator": true, "denominator": true, "imag": true, "real": true } };
      float.$float_value = float_value;
      float.$to_js_number = function(self2) {
        if (self2.__class__ === float) {
          return self2.value;
        } else {
          return float.$to_js_number(self2.value);
        }
      };
      float.numerator = (self2) => self2;
      float.denominator = () => 1;
      float.imag = () => 0;
      float.real = (self2) => self2;
      float.__float__ = function(self2) {
        return self2;
      };
      $B2.shift1_cache = {};
      float.as_integer_ratio = function(self2) {
        if (isinf(self2)) {
          throw _b_2.OverflowError.$factory("Cannot pass infinity to float.as_integer_ratio.");
        }
        if (isnan(self2)) {
          throw _b_2.ValueError.$factory("Cannot pass NaN to float.as_integer_ratio.");
        }
        var tmp = frexp(self2), fp = tmp[0], exponent = tmp[1];
        for (var i = 0; i < 300; i++) {
          if (fp == Math.floor(fp)) {
            break;
          } else {
            fp *= 2;
            exponent--;
          }
        }
        var numerator = _b_2.int.$factory(fp), py_exponent = _b_2.abs(exponent), denominator = 1, x;
        if ($B2.shift1_cache[py_exponent] !== void 0) {
          x = $B2.shift1_cache[py_exponent];
        } else {
          x = $B2.$getattr(1, "__lshift__")(py_exponent);
          $B2.shift1_cache[py_exponent] = x;
        }
        py_exponent = x;
        if (exponent > 0) {
          numerator = $B2.rich_op("__mul__", numerator, py_exponent);
        } else {
          denominator = py_exponent;
        }
        return $B2.fast_tuple([_b_2.int.$factory(numerator), _b_2.int.$factory(denominator)]);
      };
      function check_self_is_float(x, method) {
        if (x.__class__ === _b_2.float || $B2.$isinstance(x, _b_2.float)) {
          return true;
        }
        throw _b_2.TypeError.$factory(`descriptor '${method}' requires a 'float' object but received a '${$B2.class_name(x)}'`);
      }
      float.__abs__ = function(self2) {
        check_self_is_float(self2, "__abs__");
        return fast_float(Math.abs(self2.value));
      };
      float.__bool__ = function(self2) {
        check_self_is_float(self2, "__bool__");
        return _b_2.bool.$factory(self2.value);
      };
      float.__ceil__ = function(self2) {
        check_self_is_float(self2, "__ceil__");
        if (isnan(self2)) {
          throw _b_2.ValueError.$factory("cannot convert float NaN to integer");
        } else if (isinf(self2)) {
          throw _b_2.OverflowError.$factory("cannot convert float infinity to integer");
        }
        return Math.ceil(self2.value);
      };
      function _float_div_mod(vx, wx) {
        var mod = vx % wx;
        var div = (vx - mod) / wx;
        if (mod) {
          if (wx < 0 != mod < 0) {
            mod += wx;
            div -= 1;
          }
        } else {
          mod = copysign(0, wx);
        }
        var floordiv;
        if (div) {
          floordiv = Math.floor(div);
          if (div - floordiv > 0.5) {
            floordiv += 1;
          }
        } else {
          floordiv = copysign(0, vx / wx);
        }
        return { floordiv, mod };
      }
      float.__divmod__ = function(self2, other) {
        check_self_is_float(self2, "__divmod__");
        if (!$B2.$isinstance(other, [_b_2.int, float])) {
          return _b_2.NotImplemented;
        }
        var vx = self2.value, wx = float.$factory(other).value;
        var divmod = _float_div_mod(vx, wx);
        return $B2.fast_tuple([$B2.fast_float(divmod.floordiv), $B2.fast_float(divmod.mod)]);
      };
      float.__eq__ = function(self2, other) {
        check_self_is_float(self2, "__eq__");
        if (isNaN(self2.value) && ($B2.$isinstance(other, float) && isNaN(other.value))) {
          return false;
        }
        if ($B2.$isinstance(other, _b_2.int)) {
          return self2.value == other;
        }
        if ($B2.$isinstance(other, float)) {
          return self2.value == other.value;
        }
        if ($B2.$isinstance(other, _b_2.complex)) {
          if (!$B2.rich_comp("__eq__", 0, other.$imag)) {
            return false;
          }
          return float.__eq__(self2, other.$real);
        }
        return _b_2.NotImplemented;
      };
      float.__floor__ = function(self2) {
        check_self_is_float(self2, "__floor__");
        if (isnan(self2)) {
          throw _b_2.ValueError.$factory("cannot convert float NaN to integer");
        } else if (isinf(self2)) {
          throw _b_2.OverflowError.$factory("cannot convert float infinity to integer");
        }
        return Math.floor(self2.value);
      };
      float.__floordiv__ = function(self2, other) {
        check_self_is_float(self2, "__floordiv__");
        if (!$B2.$isinstance(other, [_b_2.int, float])) {
          return _b_2.NotImplemented;
        }
        var vx = self2.value, wx = float.$factory(other).value;
        var divmod = _float_div_mod(vx, wx);
        return $B2.fast_float(divmod.floordiv);
      };
      const DBL_MANT_DIG = 53, LONG_MAX = $B2.MAX_VALUE, DBL_MAX_EXP = 2 ** 10, LONG_MIN = $B2.MIN_VALUE, DBL_MIN_EXP = -1021;
      float.fromhex = function(klass, s) {
        function hex_from_char(char) {
          return parseInt(char, 16);
        }
        function finished() {
          while (s[pos2] && s[pos2].match(/\s/)) {
            pos2++;
          }
          if (pos2 != s.length) {
            throw parse_error();
          }
          if (negate) {
            x = float.__neg__(x);
          }
          return klass === _b_2.float ? x : $B2.$call(klass)(x);
        }
        function overflow_error() {
          throw _b_2.OverflowError.$factory(
            "hexadecimal value too large to represent as a float"
          );
        }
        function parse_error() {
          throw _b_2.ValueError.$factory(
            "invalid hexadecimal floating-point string"
          );
        }
        function insane_length_error() {
          throw _b_2.ValueError.$factory(
            "hexadecimal string too long to convert"
          );
        }
        s = s.trim();
        if (s.match(/^\+?inf(inity)?$/i)) {
          return INF;
        } else if (s.match(/^-inf(inity)?$/i)) {
          return NINF;
        } else if (s.match(/^[+-]?nan$/i)) {
          return NAN;
        }
        var pos2 = 0, negate, ldexp2 = _b_2.float.$funcs.ldexp;
        if (s[pos2] == "-") {
          pos2++;
          negate = 1;
        } else if (s[pos2] == "+") {
          pos2++;
        }
        if (s.substr(pos2, 2).toLowerCase() == "0x") {
          pos2 += 2;
        }
        var coeff_start = pos2, coeff_end;
        while (hex_from_char(s[pos2]) >= 0) {
          pos2++;
        }
        var save_pos = pos2;
        if (s[pos2] == ".") {
          pos2++;
          while (hex_from_char(s[pos2]) >= 0) {
            pos2++;
          }
          coeff_end = pos2 - 1;
        } else {
          coeff_end = pos2;
        }
        var ndigits = coeff_end - coeff_start, fdigits = coeff_end - save_pos;
        if (ndigits == 0) {
          throw parse_error();
        }
        if (ndigits > Math.min(DBL_MIN_EXP - DBL_MANT_DIG - LONG_MIN / 2, LONG_MAX / 2 + 1 - DBL_MAX_EXP) / 4) {
          throw insane_length_error();
        }
        var exp;
        if (s[pos2] == "p" || s[pos2] == "P") {
          pos2++;
          var exp_start = pos2;
          if (s[pos2] == "-" || s[pos2] == "+") {
            pos2++;
          }
          if (!("0" <= s[pos2] && s[pos2] <= "9")) {
            throw parse_error();
          }
          pos2++;
          while ("0" <= s[pos2] && s[pos2] <= "9") {
            pos2++;
          }
          exp = parseInt(s.substr(exp_start));
        } else {
          exp = 0;
        }
        function HEX_DIGIT(j2) {
          if (!Number.isInteger(j2)) {
            throw Error("j pas entier");
          }
          return hex_from_char(s[j2 < fdigits ? coeff_end - j2 : coeff_end - 1 - j2]);
        }
        while (ndigits > 0 && HEX_DIGIT(ndigits - 1) == 0) {
          ndigits--;
        }
        if (ndigits == 0 || exp < LONG_MIN / 2) {
          x = ZERO;
          return finished();
        }
        if (exp > LONG_MAX / 2) {
          console.log("overflow, exp", exp);
          throw overflow_error();
        }
        exp = exp - 4 * fdigits;
        var top_exp = exp + 4 * (ndigits - 1);
        for (let digit2 = BigInt(HEX_DIGIT(ndigits - 1)); digit2 != 0; digit2 /= 2n) {
          top_exp++;
        }
        if (top_exp < DBL_MIN_EXP - DBL_MANT_DIG) {
          x = ZERO;
          return finished();
        }
        if (top_exp > DBL_MAX_EXP) {
          throw overflow_error();
        }
        var lsb = Math.max(top_exp, DBL_MIN_EXP) - DBL_MANT_DIG;
        var x = 0;
        if (exp >= lsb) {
          for (let i = ndigits - 1; i >= 0; i--) {
            x = 16 * x + HEX_DIGIT(i);
          }
          x = ldexp2($B2.fast_float(x), exp);
          return finished();
        }
        var half_eps = 1 << (lsb - exp - 1) % 4, key_digit = parseInt((lsb - exp - 1) / 4);
        for (let i = ndigits - 1; i > key_digit; i--) {
          x = 16 * x + HEX_DIGIT(i);
        }
        let digit = HEX_DIGIT(key_digit);
        x = 16 * x + (digit & 16 - 2 * half_eps);
        if ((digit & half_eps) != 0) {
          var round_up = 0;
          if ((digit & 3 * half_eps - 1) != 0 || half_eps == 8 && key_digit + 1 < ndigits && (HEX_DIGIT(key_digit + 1) & 1) != 0) {
            round_up = 1;
          } else {
            for (let i = key_digit - 1; i >= 0; i--) {
              if (HEX_DIGIT(i) != 0) {
                round_up = 1;
                break;
              }
            }
          }
          if (round_up) {
            x += 2 * half_eps;
            if (top_exp == DBL_MAX_EXP && x == ldexp2(2 * half_eps, DBL_MANT_DIG).value) {
              throw overflow_error();
            }
          }
        }
        x = ldexp2(x, exp + 4 * key_digit);
        return finished();
      };
      float.__getformat__ = function(arg) {
        if (arg == "double" || arg == "float") {
          return "IEEE, little-endian";
        }
        if (typeof arg !== "string") {
          throw _b_2.TypeError.$factory(
            " __getformat__() argument must be str, not " + $B2.class_name(arg)
          );
        }
        throw _b_2.ValueError.$factory("__getformat__() argument 1 must be 'double' or 'float'");
      };
      var format_sign = function(val, flags) {
        switch (flags.sign) {
          case "+":
            return val >= 0 || isNaN(val) ? "+" : "";
          case "-":
            return "";
          case " ":
            return val >= 0 || isNaN(val) ? " " : "";
        }
        if (flags.space) {
          if (val >= 0) {
            return " ";
          }
        }
        return "";
      };
      function preformat(self2, fmt) {
        var value2 = self2.value;
        if (fmt.empty) {
          return _b_2.str.$factory(self2);
        }
        if (fmt.type && "eEfFgGn%".indexOf(fmt.type) == -1) {
          throw _b_2.ValueError.$factory("Unknown format code '" + fmt.type + "' for object of type 'float'");
        }
        var special;
        if (isNaN(value2)) {
          special = "efg".indexOf(fmt.type) > -1 ? "nan" : "NAN";
        } else if (value2 == Number.POSITIVE_INFINITY) {
          special = "efg".indexOf(fmt.type) > -1 ? "inf" : "INF";
        } else if (value2 == Number.NEGATIVE_INFINITY) {
          special = "efg".indexOf(fmt.type) > -1 ? "-inf" : "-INF";
        }
        if (special) {
          return format_sign(value2, fmt) + special;
        }
        if (fmt.precision === void 0 && fmt.type !== void 0) {
          fmt.precision = 6;
        }
        if (fmt.type == "%") {
          value2 *= 100;
        }
        if (fmt.type == "e") {
          let res2 = value2.toExponential(fmt.precision), exp = parseInt(res2.substr(res2.search("e") + 1));
          if (Math.abs(exp) < 10) {
            res2 = res2.substr(0, res2.length - 1) + "0" + res2.charAt(res2.length - 1);
          }
          return res2;
        }
        var res;
        if (fmt.precision !== void 0) {
          let prec = fmt.precision;
          if (prec == 0) {
            return Math.round(value2) + "";
          }
          res = $B2.roundDownToFixed(value2, prec);
          let pt_pos = res.indexOf(".");
          if (fmt.type !== void 0 && (fmt.type == "%" || fmt.type.toLowerCase() == "f")) {
            if (pt_pos == -1) {
              res += "." + "0".repeat(fmt.precision);
            } else {
              var missing = fmt.precision - res.length + pt_pos + 1;
              if (missing > 0) {
                res += "0".repeat(missing);
              }
            }
          } else if (fmt.type && fmt.type.toLowerCase() == "g") {
            let exp_fmt = preformat(self2, { type: "e" }).split("e"), exp = parseInt(exp_fmt[1]);
            if (-4 <= exp && exp < fmt.precision) {
              res = preformat(self2, { type: "f", precision: fmt.precision - 1 - exp });
            } else {
              res = preformat(self2, { type: "e", precision: fmt.precision - 1 });
            }
            let parts = res.split("e");
            if (fmt.alternate) {
              if (parts[0].search(/\./) == -1) {
                parts[0] += ".";
              }
            } else {
              let signif = parts[0];
              if (signif.indexOf(".") > 0) {
                while (signif.endsWith("0")) {
                  signif = signif.substr(0, signif.length - 1);
                }
              }
              if (signif.endsWith(".")) {
                signif = signif.substr(0, signif.length - 1);
              }
              parts[0] = signif;
            }
            res = parts.join("e");
            if (fmt.type == "G") {
              res = res.toUpperCase();
            }
            return res;
          } else if (fmt.type === void 0) {
            fmt.type = "g";
            res = preformat(self2, fmt);
            if (res.indexOf(".") == -1) {
              let exp = res.length - 1;
              exp = exp < 10 ? "0" + exp : exp;
              let is_neg = res.startsWith("-"), point_pos = is_neg ? 2 : 1, mant = res.substr(0, point_pos) + "." + res.substr(point_pos);
              return `${mant}e+${exp}`;
            }
            fmt.type = void 0;
          } else {
            let res1 = value2.toExponential(fmt.precision - 1), exp = parseInt(res1.substr(res1.search("e") + 1));
            if (exp < -4 || exp >= fmt.precision - 1) {
              var elts = res1.split("e");
              while (elts[0].endsWith("0")) {
                elts[0] = elts[0].substr(0, elts[0].length - 1);
              }
              res = elts.join("e");
            }
          }
        } else {
          res = _b_2.str.$factory(self2);
        }
        if (fmt.type === void 0 || "gGn".indexOf(fmt.type) != -1) {
          if (res.search("e") == -1) {
            while (res.charAt(res.length - 1) == "0") {
              res = res.substr(0, res.length - 1);
            }
          }
          if (res.charAt(res.length - 1) == ".") {
            if (fmt.type === void 0) {
              res += "0";
            } else {
              res = res.substr(0, res.length - 1);
            }
          }
        }
        if (fmt.sign !== void 0) {
          if ((fmt.sign == " " || fmt.sign == "+") && value2 > 0) {
            res = fmt.sign + res;
          }
        }
        if (fmt.type == "%") {
          res += "%";
        }
        return res;
      }
      float.__format__ = function(self2, format_spec) {
        check_self_is_float(self2, "__format__");
        var fmt = new $B2.parse_format_spec(format_spec, self2);
        return float.$format(self2, fmt);
      };
      float.$format = function(self2, fmt) {
        fmt.align = fmt.align || ">";
        var pf = preformat(self2, fmt);
        if (fmt.z && Object.is(parseFloat(pf), -0)) {
          pf = pf.substr(1);
        }
        var raw = pf.split("."), _int = raw[0];
        if (fmt.comma) {
          var len = _int.length, nb = Math.ceil(_int.length / 3), chunks = [];
          for (var i = 0; i < nb; i++) {
            chunks.push(_int.substring(len - 3 * i - 3, len - 3 * i));
          }
          chunks.reverse();
          raw[0] = chunks.join(",");
        }
        return $B2.format_width(raw.join("."), fmt);
      };
      float.$getnewargs = function(self2) {
        return $B2.fast_tuple([float_value(self2)]);
      };
      float.__getnewargs__ = function() {
        return float.$getnewargs($B2.single_arg("__getnewargs__", "self", arguments));
      };
      var nan_hash = $B2.$py_next_hash--;
      var mp2_31 = Math.pow(2, 31);
      $B2.float_hash_cache = /* @__PURE__ */ new Map();
      float.__hash__ = function(self2) {
        check_self_is_float(self2, "__hash__");
        return float.$hash_func(self2);
      };
      float.$hash_func = function(self2) {
        if (self2.__hashvalue__ !== void 0) {
          return self2.__hashvalue__;
        }
        var _v = self2.value;
        var in_cache = $B2.float_hash_cache.get(_v);
        if (in_cache !== void 0) {
          return in_cache;
        }
        if (_v === Infinity) {
          return 314159;
        } else if (_v === -Infinity) {
          return -314159;
        } else if (isNaN(_v)) {
          return self2.__hashvalue__ = nan_hash;
        } else if (_v === Number.MAX_VALUE) {
          return self2.__hashvalue__ = $B2.fast_long_int(2234066890152476671n);
        }
        if (Number.isInteger(_v)) {
          return _b_2.int.__hash__(_v);
        }
        var r = frexp(self2);
        r[0] *= mp2_31;
        var hipart = parseInt(r[0]);
        r[0] = (r[0] - hipart) * mp2_31;
        var x = hipart + parseInt(r[0]) + (r[1] << 15);
        x &= 4294967295;
        $B2.float_hash_cache.set(_v, x);
        if ($B2.float_hash_cache.size > 1e4) {
          $B2.float_hash_cache.clear();
        }
        return self2.__hashvalue__ = x;
      };
      function isninf(x) {
        var x1 = float_value(x).value;
        return x1 == -Infinity || x1 == Number.NEGATIVE_INFINITY;
      }
      function isinf(x) {
        var x1 = float_value(x).value;
        return x1 == Infinity || x1 == -Infinity || x1 == Number.POSITIVE_INFINITY || x1 == Number.NEGATIVE_INFINITY;
      }
      function isnan(x) {
        var x1 = float_value(x).value;
        return isNaN(x1);
      }
      function fabs(x) {
        if (x == 0) {
          return fast_float(0);
        }
        return x > 0 ? float.$factory(x) : float.$factory(-x);
      }
      function frexp(x) {
        var x1 = x;
        if ($B2.$isinstance(x, float)) {
          if (isnan(x) || isinf(x)) {
            return [x, 0];
          }
          x1 = float_value(x).value;
        } else if ($B2.$isinstance(x, $B2.long_int)) {
          var exp = x.value.toString(2).length, power = 2n ** BigInt(exp);
          return [$B2.fast_float(Number(x.value) / Number(power)), exp];
        }
        if (x1 == 0) {
          return [0, 0];
        }
        var sign = 1, ex = 0, man = x1;
        if (man < 0) {
          sign = -sign;
          man = -man;
        }
        while (man < 0.5) {
          man *= 2;
          ex--;
        }
        while (man >= 1) {
          man *= 0.5;
          ex++;
        }
        man *= sign;
        return [man, ex];
      }
      function ldexp(mantissa, exponent) {
        if (isninf(mantissa)) {
          return NINF;
        } else if (isinf(mantissa)) {
          return INF;
        }
        if ($B2.$isinstance(mantissa, _b_2.float)) {
          mantissa = mantissa.value;
        }
        if (mantissa == 0) {
          return ZERO;
        } else if (isNaN(mantissa)) {
          return NAN;
        }
        if ($B2.$isinstance(exponent, $B2.long_int)) {
          if (exponent.value < 0) {
            return ZERO;
          } else {
            throw _b_2.OverflowError.$factory("overflow");
          }
        } else if (!isFinite(mantissa * Math.pow(2, exponent))) {
          throw _b_2.OverflowError.$factory("overflow");
        }
        var steps = Math.min(3, Math.ceil(Math.abs(exponent) / 1023));
        var result = mantissa;
        for (var i = 0; i < steps; i++) {
          result *= Math.pow(2, Math.floor((exponent + i) / steps));
        }
        return fast_float(result);
      }
      float.$funcs = { isinf, isninf, isnan, fabs, frexp, ldexp };
      float.hex = function(self2) {
        self2 = float_value(self2);
        var TOHEX_NBITS = DBL_MANT_DIG + 3 - (DBL_MANT_DIG + 2) % 4;
        if (isNaN(self2.value) || !isFinite(self2.value)) {
          return _b_2.repr(self2);
        }
        if (self2.value == 0) {
          return Object.is(self2.value, 0) ? "0x0.0p0" : "-0x0.0p0";
        }
        var _a = frexp(fabs(self2.value)), _m = _a[0], _e = _a[1], _shift = 1 - Math.max(-1021 - _e, 0);
        _m = ldexp(fast_float(_m), _shift).value;
        _e -= _shift;
        var _int2hex = "0123456789ABCDEF".split(""), _s = _int2hex[Math.floor(_m)];
        _s += ".";
        _m -= Math.floor(_m);
        for (var i = 0; i < (TOHEX_NBITS - 1) / 4; i++) {
          _m *= 16;
          _s += _int2hex[Math.floor(_m)];
          _m -= Math.floor(_m);
        }
        var _esign = "+";
        if (_e < 0) {
          _esign = "-";
          _e = -_e;
        }
        if (self2.value < 0) {
          return "-0x" + _s + "p" + _esign + _e;
        }
        return "0x" + _s + "p" + _esign + _e;
      };
      float.__init__ = function() {
        return _b_2.None;
      };
      float.__int__ = function(self2) {
        check_self_is_float(self2, "__int__");
        if (Number.isInteger(self2.value)) {
          var res = BigInt(self2.value), res_num = Number(res);
          return Number.isSafeInteger(res_num) ? res_num : $B2.fast_long_int(res);
        }
        return Math.trunc(self2.value);
      };
      float.is_integer = function(self2) {
        return Number.isInteger(self2.value);
      };
      float.__mod__ = function(self2, other) {
        check_self_is_float(self2, "__mod__");
        if (other == 0) {
          throw _b_2.ZeroDivisionError.$factory("float modulo");
        }
        if ($B2.$isinstance(other, _b_2.int)) {
          other = _b_2.int.numerator(other);
          return fast_float((self2.value % other + other) % other);
        }
        if ($B2.$isinstance(other, float)) {
          var q = Math.floor(self2.value / other.value), r = self2.value - other.value * q;
          if (r == 0 && other.value < 0) {
            return fast_float(-0);
          }
          return fast_float(r);
        }
        return _b_2.NotImplemented;
      };
      float.__mro__ = [_b_2.object];
      float.__mul__ = function(self2, other) {
        if ($B2.$isinstance(other, _b_2.int)) {
          if (other.__class__ == $B2.long_int) {
            return fast_float(self2.value * parseFloat(other.value));
          }
          other = _b_2.int.numerator(other);
          return fast_float(self2.value * other);
        }
        if ($B2.$isinstance(other, float)) {
          return fast_float(self2.value * other.value);
        }
        return _b_2.NotImplemented;
      };
      float.__ne__ = function(self2, other) {
        var res = float.__eq__(self2, other);
        return res === _b_2.NotImplemented ? res : !res;
      };
      float.__neg__ = function(self2) {
        return fast_float(-self2.value);
      };
      float.__new__ = function(cls, value2) {
        if (cls === void 0) {
          throw _b_2.TypeError.$factory("float.__new__(): not enough arguments");
        } else if (!$B2.$isinstance(cls, _b_2.type)) {
          throw _b_2.TypeError.$factory("float.__new__(X): X is not a type object");
        }
        return {
          __class__: cls,
          value: float.$factory(value2).value
        };
      };
      float.__pos__ = function(self2) {
        return fast_float(+self2.value);
      };
      float.__pow__ = function(self2, other) {
        var other_int = $B2.$isinstance(other, _b_2.int);
        if (other_int || $B2.$isinstance(other, float)) {
          if (!other_int) {
            other = other.value;
          }
          if (self2.value == 1) {
            return fast_float(1);
          } else if (other == 0) {
            return fast_float(1);
          }
          if (isNaN(other)) {
            return fast_float(Number.NaN);
          }
          if (isNaN(self2.value)) {
            return fast_float(Number.NaN);
          }
          if (self2.value == -1 && !isFinite(other)) {
            return fast_float(1);
          } else if (self2.value == 0 && isFinite(other) && other < 0) {
            throw _b_2.ZeroDivisionError.$factory("0.0 cannot be raised to a negative power");
          } else if (self2.value == 0 && isFinite(other) && other >= 0) {
            if (Number.isInteger(other) && other % 2 == 1) {
              return self2;
            }
            return fast_float(0);
          } else if (self2.value == Number.NEGATIVE_INFINITY && !isNaN(other)) {
            if (other % 2 == -1) {
              return fast_float(-0);
            } else if (other < 0) {
              return fast_float(0);
            } else if (other % 2 == 1) {
              return fast_float(Number.NEGATIVE_INFINITY);
            } else {
              return fast_float(Number.POSITIVE_INFINITY);
            }
          } else if (self2.value == Number.POSITIVE_INFINITY && !isNaN(other)) {
            return other > 0 ? self2 : fast_float(0);
          }
          if (other == Number.NEGATIVE_INFINITY && !isNaN(self2.value)) {
            return Math.abs(self2.value) < 1 ? fast_float(Number.POSITIVE_INFINITY) : fast_float(0);
          } else if (other == Number.POSITIVE_INFINITY && !isNaN(self2.value)) {
            return Math.abs(self2.value) < 1 ? fast_float(0) : fast_float(Number.POSITIVE_INFINITY);
          }
          if (self2.value < 0 && !Number.isInteger(other)) {
            return _b_2.complex.__pow__($B2.make_complex(self2.value, 0), fast_float(other));
          }
          return fast_float(Math.pow(self2.value, other));
        }
        return _b_2.NotImplemented;
      };
      float.__repr__ = function(self2) {
        $B2.builtins_repr_check(float, arguments);
        self2 = self2.value;
        if (self2 == Infinity) {
          return "inf";
        } else if (self2 == -Infinity) {
          return "-inf";
        } else if (isNaN(self2)) {
          return "nan";
        } else if (self2 === 0) {
          if (1 / self2 === -Infinity) {
            return "-0.0";
          }
          return "0.0";
        }
        var res = self2 + "";
        if (res.search(/[.eE]/) == -1) {
          res += ".0";
        }
        var split_e = res.split(/e/i);
        if (split_e.length == 2) {
          let mant = split_e[0], exp = split_e[1];
          if (exp.startsWith("-")) {
            let exp_str = parseInt(exp.substr(1)) + "";
            if (exp_str.length < 2) {
              exp_str = "0" + exp_str;
            }
            return mant + "e-" + exp_str;
          }
        }
        var x, y;
        [x, y] = res.split(".");
        var sign = "";
        if (x[0] == "-") {
          x = x.substr(1);
          sign = "-";
        }
        if (x.length > 16) {
          let exp = x.length - 1, int_part = x[0], dec_part = x.substr(1) + y;
          while (dec_part.endsWith("0")) {
            dec_part = dec_part.substr(0, dec_part.length - 1);
          }
          let mant = int_part;
          if (dec_part.length > 0) {
            mant += "." + dec_part;
          }
          return sign + mant + "e+" + exp;
        } else if (x == "0") {
          let exp = 0;
          while (exp < y.length && y.charAt(exp) == "0") {
            exp++;
          }
          if (exp > 3) {
            let rest = y.substr(exp);
            exp = (exp + 1).toString();
            while (rest.endsWith("0")) {
              rest = rest.substr(0, res.length - 1);
            }
            let mant = rest[0];
            if (rest.length > 1) {
              mant += "." + rest.substr(1);
            }
            if (exp.length == 1) {
              exp = "0" + exp;
            }
            return sign + mant + "e-" + exp;
          }
        }
        return _b_2.str.$factory(res);
      };
      float.__round__ = function() {
        var $ = $B2.args("__round__", 2, { self: null, ndigits: null }, ["self", "ndigits"], arguments, { ndigits: _b_2.None }, null, null);
        return float.$round($.self, $.ndigits);
      };
      float.$round = function(x, ndigits) {
        function overflow() {
          throw _b_2.OverflowError.$factory(
            "cannot convert float infinity to integer"
          );
        }
        var no_digits = ndigits === _b_2.None;
        if (isnan(x)) {
          if (ndigits === _b_2.None) {
            throw _b_2.ValueError.$factory(
              "cannot convert float NaN to integer"
            );
          }
          return NAN;
        } else if (isninf(x)) {
          return ndigits === _b_2.None ? overflow() : NINF;
        } else if (isinf(x)) {
          return ndigits === _b_2.None ? overflow() : INF;
        }
        x = float_value(x);
        ndigits = ndigits === _b_2.None ? 0 : ndigits;
        if (ndigits == 0) {
          var res = Math.round(x.value);
          if (Math.abs(x.value - res) == 0.5) {
            if (res % 2) {
              return res - 1;
            }
          }
          if (no_digits) {
            return res;
          }
          return $B2.fast_float(res);
        }
        if (ndigits.__class__ === $B2.long_int) {
          ndigits = Number(ndigits.value);
        }
        var pow1, pow2, y, z;
        if (ndigits >= 0) {
          if (ndigits > 22) {
            pow1 = 10 ** (ndigits - 22);
            pow2 = 1e22;
          } else {
            pow1 = 10 ** ndigits;
            pow2 = 1;
          }
          y = x.value * pow1 * pow2;
          if (!isFinite(y)) {
            return x;
          }
        } else {
          pow1 = 10 ** -ndigits;
          pow2 = 1;
          if (isFinite(pow1)) {
            y = x.value / pow1;
          } else {
            return ZERO;
          }
        }
        z = Math.round(y);
        if (fabs(y - z).value == 0.5) {
          z = 2 * Math.round(y / 2);
        }
        if (ndigits >= 0) {
          z = z / pow2 / pow1;
        } else {
          z *= pow1;
        }
        if (!isFinite(z)) {
          throw _b_2.OverflowError.$factory(
            "overflow occurred during round"
          );
        }
        return fast_float(z);
      };
      float.__setattr__ = function(self2, attr, value2) {
        if (self2.__class__ === float) {
          if (float[attr] === void 0) {
            throw _b_2.AttributeError.$factory("'float' object has no attribute '" + attr + "'");
          } else {
            throw _b_2.AttributeError.$factory("'float' object attribute '" + attr + "' is read-only");
          }
        }
        self2[attr] = value2;
        return _b_2.None;
      };
      float.__truediv__ = function(self2, other) {
        if ($B2.$isinstance(other, _b_2.int)) {
          if (other.valueOf() == 0) {
            throw _b_2.ZeroDivisionError.$factory("division by zero");
          } else if ($B2.$isinstance(other, $B2.long_int)) {
            return float.$factory(self2.value / Number(other.value));
          }
          return float.$factory(self2.value / other);
        } else if ($B2.$isinstance(other, float)) {
          if (other.value == 0) {
            throw _b_2.ZeroDivisionError.$factory("division by zero");
          }
          return float.$factory(self2.value / other.value);
        }
        return _b_2.NotImplemented;
      };
      var op_func_body = `var $B = __BRYTHON__,
        _b_ = __BRYTHON__.builtins
    if($B.$isinstance(other, _b_.int)){
        if(typeof other == "boolean"){
            return other ? $B.fast_float(self.value - 1) : self
        }else if(other.__class__ === $B.long_int){
            return _b_.float.$factory(self.value - parseInt(other.value))
        }else{
            return $B.fast_float(self.value - other)
        }
    }
    if($B.$isinstance(other, _b_.float)){
        return $B.fast_float(self.value - other.value)
    }
    return _b_.NotImplemented`;
      var ops = { "+": "add", "-": "sub" };
      for (let op in ops) {
        let body = op_func_body.replace(/-/gm, op);
        float[`__${ops[op]}__`] = Function("self", "other", body);
      }
      var comp_func_body = `
var $B = __BRYTHON__,
    _b_ = $B.builtins
if($B.$isinstance(other, _b_.int)){
    if(other.__class__ === $B.long_int){
        return self.value > parseInt(other.value)
    }
    return self.value > other.valueOf()}
if($B.$isinstance(other, _b_.float)){
    return self.value > other.value}
if($B.$isinstance(other, _b_.bool)) {
    return self.value > _b_.bool.__hash__(other)}
var int_method = $B.$getattr(other, "__int__", null)
if(int_method !== null){
    var v = int_method()
    return _b_.int.__gt__(self.value, v)}
var index_method = $B.$getattr(other, "__index__", null)
if(index_method !== null){
    var v = index_method()
    return _b_.int.__gt__(self.value, v)}
// See if other has the opposite operator, eg <= for >
var inv_op = $B.$getattr(other, "__le__", _b_.None)
if(inv_op !== _b_.None){
    return inv_op(self)}
throw _b_.TypeError.$factory(
    "unorderable types: float() > " + $B.class_name(other) + "()")
`;
      for (let op in $B2.$comps) {
        let body = comp_func_body.replace(/>/gm, op).replace(/__gt__/gm, `__${$B2.$comps[op]}__`).replace(/__le__/, `__${$B2.$inv_comps[op]}__`);
        float[`__${$B2.$comps[op]}__`] = Function("self", "other", body);
      }
      var r_opnames = ["add", "sub", "mul", "truediv", "floordiv", "mod", "pow", "lshift", "rshift", "and", "xor", "or", "divmod"];
      for (var r_opname of r_opnames) {
        if (float["__r" + r_opname + "__"] === void 0 && float["__" + r_opname + "__"]) {
          float["__r" + r_opname + "__"] = /* @__PURE__ */ (function(name2) {
            return function(self2, other) {
              var other_as_num = _b_2.int.$to_js_number(other);
              if (other_as_num !== null) {
                var other_as_float = $B2.fast_float(other_as_num);
                return float["__" + name2 + "__"](other_as_float, self2);
              }
              return _b_2.NotImplemented;
            };
          })(r_opname);
        }
      }
      function to_digits(s) {
        var arabic_digits = "٠١٢٣٤٥٦٧٨٩", res = "";
        for (var i = 0; i < s.length; i++) {
          var x = arabic_digits.indexOf(s[i]);
          if (x > -1) {
            res += x;
          } else {
            res += s[i];
          }
        }
        return res;
      }
      const fast_float = $B2.fast_float = function(value2) {
        return { __class__: _b_2.float, value: value2 };
      };
      float.$factory = function(value2) {
        if (value2 === void 0) {
          return fast_float(0);
        }
        $B2.check_nb_args_no_kw("float", 1, arguments);
        switch (value2) {
          case true:
            return fast_float(1);
          case false:
            return fast_float(0);
        }
        var original_value = value2;
        if (typeof value2 == "number") {
          return fast_float(value2);
        }
        if (value2.__class__ === float) {
          return value2;
        }
        if ($B2.$isinstance(value2, _b_2.memoryview)) {
          value2 = _b_2.memoryview.tobytes(value2);
        }
        if ($B2.$isinstance(value2, _b_2.bytes)) {
          try {
            value2 = $B2.$getattr(value2, "decode")("utf-8");
          } catch (err) {
            throw _b_2.ValueError.$factory(
              "could not convert string to float: " + _b_2.repr(original_value)
            );
          }
        }
        if (typeof value2 == "string") {
          if (value2.trim().length == 0) {
            throw _b_2.ValueError.$factory(
              `could not convert string to float: ${_b_2.repr(value2)}`
            );
          }
          value2 = value2.trim();
          switch (value2.toLowerCase()) {
            case "+inf":
            case "inf":
            case "+infinity":
            case "infinity":
              return fast_float(Number.POSITIVE_INFINITY);
            case "-inf":
            case "-infinity":
              return fast_float(Number.NEGATIVE_INFINITY);
            case "+nan":
            case "nan":
              return fast_float(Number.NaN);
            case "-nan":
              return fast_float(-Number.NaN);
            default:
              var parts = value2.split("e");
              if (parts[1]) {
                if (parts[1].startsWith("+") || parts[1].startsWith("-")) {
                  parts[1] = parts[1].substr(1);
                }
              }
              parts = parts[0].split(".").concat(parts.splice(1));
              for (var part of parts) {
                if (part.startsWith("_") || part.endsWith("_")) {
                  throw _b_2.ValueError.$factory("invalid float literal " + value2);
                }
              }
              if (value2.indexOf("__") > -1) {
                throw _b_2.ValueError.$factory("invalid float literal " + value2);
              }
              value2 = value2.charAt(0) + value2.substr(1).replace(/_/g, "");
              value2 = to_digits(value2);
              if (isFinite(value2)) {
                return fast_float(parseFloat(value2));
              } else {
                throw _b_2.ValueError.$factory(
                  "could not convert string to float: " + _b_2.repr(original_value)
                );
              }
          }
        }
        let klass = $B2.get_class(value2), float_method = $B2.$getattr(klass, "__float__", null);
        if (float_method === null) {
          var index_method = $B2.$getattr(klass, "__index__", null);
          if (index_method === null) {
            throw _b_2.TypeError.$factory("float() argument must be a string or a real number, not '" + $B2.class_name(value2) + "'");
          }
          let index = $B2.$call(index_method)(value2), index_klass = $B2.get_class(index);
          if (index_klass === _b_2.int) {
            return fast_float(index);
          } else if (index_klass === $B2.long_int) {
            return $B2.long_int.__float__(index);
          } else if (index_klass.__mro__.indexOf(_b_2.int) > -1) {
            let msg = `${$B2.class_name(value2)}.__index__ returned non-int (type ${$B2.class_name(index)}).  The ability to return an instance of a strict subclass of int is deprecated, and may be removed in a future version of Python.`;
            $B2.warn(_b_2.DeprecationWarning, msg);
            return fast_float(index);
          }
          throw _b_2.TypeError.$factory(`__index__ returned non-int (type ${$B2.class_name(index)})`);
        }
        let res = $B2.$call(float_method)(value2);
        klass = $B2.get_class(res);
        if (klass !== _b_2.float) {
          if (klass.__mro__.indexOf(_b_2.float) > -1) {
            let msg = `${$B2.class_name(value2)}.__float__ returned non-float (type ${$B2.class_name(res)}).  The ability to return an instance of a strict subclass of float is deprecated, and may be removed in a future version of Python.`;
            $B2.warn(_b_2.DeprecationWarning, msg);
            return float.$factory(res.value);
          }
          throw _b_2.TypeError.$factory(`__float__ returned non-float (type ${$B2.class_name(res)})`);
        }
        return res;
      };
      $B2.set_func_names(float, "builtins");
      float.fromhex = _b_2.classmethod.$factory(float.fromhex);
      _b_2.float = float;
      $B2.MAX_VALUE = fast_float(Number.MAX_VALUE);
      $B2.MIN_VALUE = fast_float(22250738585072014e-324);
      const NINF = fast_float(Number.NEGATIVE_INFINITY), INF = fast_float(Number.POSITIVE_INFINITY), NAN = fast_float(Number.NaN), ZERO = fast_float(0);
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      function $UnsupportedOpType(op, class1, class2) {
        throw _b_2.TypeError.$factory("unsupported operand type(s) for " + op + ": '" + class1 + "' and '" + class2 + "'");
      }
      var complex = { __class__: _b_2.type, __dir__: _b_2.object.__dir__, __qualname__: "complex", $is_class: true, $native: true, $descriptors: { real: true, imag: true } };
      complex.__abs__ = function(self2) {
        var _rf = isFinite(self2.$real.value), _if = isFinite(self2.$imag.value);
        if (_rf && isNaN(self2.$imag.value) || _if && isNaN(self2.$real.value) || isNaN(self2.$imag.value) && isNaN(self2.$real.value)) {
          return $B2.fast_float(NaN);
        }
        if (!_rf || !_if) {
          return $B2.fast_float(Infinity);
        }
        var mag = Math.sqrt(Math.pow(self2.$real.value, 2) + Math.pow(self2.$imag.value, 2));
        if (!isFinite(mag) && _rf && _if) {
          throw _b_2.OverflowError.$factory("absolute value too large");
        }
        return $B2.fast_float(mag);
      };
      complex.__add__ = function(self2, other) {
        if ($B2.$isinstance(other, complex)) {
          return make_complex(self2.$real.value + other.$real.value, self2.$imag.value + other.$imag.value);
        }
        if ($B2.$isinstance(other, _b_2.int)) {
          other = _b_2.int.numerator(other);
          return make_complex(
            $B2.rich_op("__add__", self2.$real, other).value,
            self2.$imag.value
          );
        }
        if ($B2.$isinstance(other, _b_2.float)) {
          return make_complex(self2.$real.value + other.value, self2.$imag.value);
        }
        return _b_2.NotImplemented;
      };
      complex.__bool__ = function(self2) {
        return !$B2.rich_comp("__eq__", self2.$real, 0) || !$B2.rich_comp("__eq__", self2.$imag, 0);
      };
      complex.__complex__ = function(self2) {
        if (self2.__class__ === complex) {
          return self2;
        }
        return $B2.make_complex(self2.$real, self2.$imag);
      };
      complex.__eq__ = function(self2, other) {
        if ($B2.$isinstance(other, complex)) {
          return self2.$real.value == other.$real.value && self2.$imag.value == other.$imag.value;
        }
        if ($B2.$isinstance(other, _b_2.int)) {
          if (self2.$imag.value != 0) {
            return false;
          }
          return self2.$real.value == other.valueOf();
        }
        if ($B2.$isinstance(other, _b_2.float)) {
          if (!$B2.rich_comp("__eq__", 0, self2.$imag)) {
            return false;
          }
          return self2.$real.value == other.value;
        }
        return _b_2.NotImplemented;
      };
      const max_precision = 2 ** 31 - 4;
      complex.__format__ = function(self2, format_spec) {
        if (format_spec.length == 0) {
          return _b_2.str.$factory(self2);
        }
        var fmt = new $B2.parse_format_spec(format_spec, self2), type = fmt.conversion_type;
        var skip_re, add_parens;
        if (type === void 0 || "eEfFgGn".indexOf(type) > -1) {
          if (fmt.precision > max_precision) {
            throw _b_2.ValueError.$factory("precision too big");
          }
          if (fmt.fill_char == "0") {
            throw _b_2.ValueError.$factory(
              "Zero padding is not allowed in complex format specifier"
            );
          }
          if (fmt.align == "=") {
            throw _b_2.ValueError.$factory(
              "'=' alignment flag is not allowed in complex format specifier"
            );
          }
          var re = self2.$real.value, precision = parseInt(fmt.precision, 10);
          if (type === void 0) {
            type = "r";
            if (re == 0 && Object.is(re, 0)) {
              skip_re = 1;
            } else {
              add_parens = 1;
            }
          } else if (type == "n") {
            type = "g";
          }
          if (precision < 0) {
            precision = 6;
          } else if (type == "r") {
            type = "g";
          }
          var format = $B2.clone(fmt);
          format.conversion_type = type;
          format.precision = precision;
          var res = "";
          if (!skip_re) {
            res += _b_2.float.$format(self2.$real, format);
            if (self2.$imag.value >= 0) {
              res += "+";
            }
          }
          var formatted_im = _b_2.float.$format(self2.$imag, format);
          var pos2 = -1, last_num;
          for (var char of formatted_im) {
            pos2++;
            if (char.match(/\d/)) {
              last_num = pos2;
            }
          }
          formatted_im = formatted_im.substr(0, last_num + 1) + "j" + formatted_im.substr(last_num + 1);
          res += formatted_im;
          if (add_parens) {
            res = "(" + res + ")";
          }
          return res;
        }
        throw _b_2.ValueError.$factory(`invalid type for complex: ${type}`);
      };
      complex.$getnewargs = function(self2) {
        return $B2.fast_tuple([self2.$real, self2.$imag]);
      };
      complex.__getnewargs__ = function() {
        return complex.$getnewargs($B2.single_arg("__getnewargs__", "self", arguments));
      };
      complex.__hash__ = function(self2) {
        return $B2.$hash(self2.$real) + $B2.$hash(self2.$imag) * 1000003;
      };
      complex.__init__ = function() {
        return _b_2.None;
      };
      complex.__invert__ = function(self2) {
        return ~self2;
      };
      complex.__mro__ = [_b_2.object];
      complex.__mul__ = function(self2, other) {
        if ($B2.$isinstance(other, complex)) {
          return make_complex(self2.$real.value * other.$real.value - self2.$imag.value * other.$imag.value, self2.$imag.value * other.$real.value + self2.$real.value * other.$imag.value);
        } else if ($B2.$isinstance(other, _b_2.int)) {
          return make_complex(self2.$real.value * other.valueOf(), self2.$imag.value * other.valueOf());
        } else if ($B2.$isinstance(other, _b_2.float)) {
          return make_complex(self2.$real.value * other.value, self2.$imag.value * other.value);
        } else if ($B2.$isinstance(other, _b_2.bool)) {
          if (other.valueOf()) {
            return self2;
          }
          return make_complex(0, 0);
        }
        return _b_2.NotImplemented;
      };
      complex.__ne__ = function(self2, other) {
        var res = complex.__eq__(self2, other);
        return res === _b_2.NotImplemented ? res : !res;
      };
      complex.__neg__ = function(self2) {
        return make_complex(-self2.$real.value, -self2.$imag.value);
      };
      complex.__new__ = function(cls) {
        if (cls === void 0) {
          throw _b_2.TypeError.$factory("complex.__new__(): not enough arguments");
        }
        var res, missing = {}, $ = $B2.args("complex", 3, { cls: null, real: null, imag: null }, ["cls", "real", "imag"], arguments, { real: 0, imag: missing }, null, null);
        cls = $.cls;
        var first = $.real, second = $.imag;
        if (typeof first == "string") {
          if (second !== missing) {
            throw _b_2.TypeError.$factory("complex() can't take second arg if first is a string");
          } else {
            let to_num2 = function(s) {
              var res2 = parseFloat(s.charAt(0) + s.substr(1).replace(/_/g, ""));
              if (isNaN(res2)) {
                throw _b_2.ValueError.$factory("could not convert string to complex: '" + arg + "'");
              }
              return res2;
            };
            var to_num = to_num2;
            var arg = first;
            first = first.trim();
            if (first.startsWith("(") && first.endsWith(")")) {
              first = first.substr(1);
              first = first.substr(0, first.length - 1);
            }
            var complex_re = /^\s*([+-]*[0-9_]*\.?[0-9_]*(e[+-]*[0-9_]*)?)([+-]?)([0-9_]*\.?[0-9_]*(e[+-]*[0-9_]*)?)(j?)\s*$/i;
            var parts = complex_re.exec(first);
            if (parts === null) {
              throw _b_2.ValueError.$factory("complex() arg is a malformed string");
            }
            if (parts[_real] && parts[_imag].startsWith(".") && parts[_sign] == "") {
              throw _b_2.ValueError.$factory("complex() arg is a malformed string");
            } else if (parts[_real] == "." || parts[_imag] == "." || parts[_real] == ".e" || parts[_imag] == ".e" || parts[_real] == "e" || parts[_imag] == "e") {
              throw _b_2.ValueError.$factory("complex() arg is a malformed string");
            } else if (parts[_j] != "") {
              if (parts[_sign] == "") {
                first = 0;
                if (parts[_real] == "+" || parts[_real] == "") {
                  second = 1;
                } else if (parts[_real] == "-") {
                  second = -1;
                } else {
                  second = to_num2(parts[_real]);
                }
              } else {
                first = to_num2(parts[_real]);
                second = parts[_imag] == "" ? 1 : to_num2(parts[_imag]);
                second = parts[_sign] == "-" ? -second : second;
              }
            } else {
              if (parts[_sign] && parts[_imag] == "") {
                throw _b_2.ValueError.$factory("complex() arg is a malformed string");
              }
              first = to_num2(parts[_real]);
              second = 0;
            }
            res = make_complex(first, second);
            res.__class__ = cls;
            res.__dict__ = $B2.empty_dict();
            return res;
          }
        }
        if (first.__class__ === complex && cls === complex && second === missing) {
          return first;
        }
        var arg1 = _convert(first), r, i;
        if (arg1 === null) {
          throw _b_2.TypeError.$factory(`complex() first argument must be a string or a number, not '${$B2.class_name(first)}'`);
        }
        if (typeof second == "string") {
          throw _b_2.TypeError.$factory("complex() second arg can't be a string");
        }
        var arg2 = _convert(second === missing ? 0 : second);
        if (arg2 === null) {
          throw _b_2.TypeError.$factory(`complex() second argument must be a number, not '${$B2.class_name(second)}'`);
        }
        if (arg1.method == "__complex__") {
          if (arg2.method == "__complex__") {
            r = $B2.rich_op("__sub__", arg1.result.$real, arg2.result.$imag);
            i = $B2.rich_op("__add__", arg1.result.$imag, arg2.result.$real);
          } else {
            r = arg1.result.$real;
            i = $B2.rich_op("__add__", arg1.result.$imag, arg2.result);
          }
        } else {
          if (arg2.method == "__complex__") {
            r = $B2.rich_op("__sub__", arg1.result, arg2.result.$imag);
            i = arg2.result.$real;
          } else {
            r = arg1.result;
            i = arg2.result;
          }
        }
        res = make_complex(r, i);
        res.__class__ = cls;
        res.__dict__ = $B2.empty_dict();
        return res;
      };
      complex.__pos__ = function(self2) {
        return self2;
      };
      function complex2expo(cx) {
        var norm = Math.sqrt(cx.$real.value * cx.$real.value + cx.$imag.value * cx.$imag.value), sin = cx.$imag.value / norm, cos = cx.$real.value / norm, angle;
        if (cos == 0) {
          angle = sin == 1 ? Math.PI / 2 : 3 * Math.PI / 2;
        } else if (sin == 0) {
          angle = cos == 1 ? 0 : Math.PI;
        } else {
          angle = Math.atan(sin / cos);
        }
        return { norm, angle };
      }
      function c_powi(x, n) {
        if (n > 0) {
          return c_powu(x, n);
        } else {
          return c_quot(c_1, c_powu(x, -n));
        }
      }
      function c_powu(x, n) {
        var mask = 1, r = c_1, p = x;
        while (mask > 0 && n >= mask) {
          if (n & mask) {
            r = c_prod(r, p);
          }
          mask <<= 1;
          p = c_prod(p, p);
        }
        return r;
      }
      function c_prod(a, b) {
        return make_complex(
          a.$real.value * b.$real.value - a.$imag.value * b.$imag.value,
          a.$real.value * b.$imag.value + a.$imag.value * b.$real.value
        );
      }
      function c_quot(a, b) {
        var abs_breal = Math.abs(b.$real.value), abs_bimag = Math.abs(b.$imag.value);
        if ($B2.rich_comp("__ge__", abs_breal, abs_bimag)) {
          if (abs_breal == 0) {
            throw _b_2.ZeroDivisionError.$factory();
          } else {
            let ratio = b.$imag.value / b.$real.value, denom = b.$real.value + b.$imag.value * ratio;
            return make_complex((a.$real.value + a.$imag.value * ratio) / denom, (a.$imag.value - a.$real.value * ratio) / denom);
          }
        } else if (abs_bimag >= abs_breal) {
          let ratio = b.$real.value / b.$imag.value, denom = b.$real.value * ratio + b.$imag.value;
          if (b.$imag.value == 0) {
            throw _b_2.ZeroDivisionError.$factory();
          }
          return make_complex(
            (a.$real.value * ratio + a.$imag.value) / denom,
            (a.$imag.value * ratio - a.$real.value) / denom
          );
        } else {
          return $B2.make_complex("nan", "nan");
        }
      }
      complex.__pow__ = function(self2, other, mod) {
        if (mod !== void 0 && mod !== _b_2.None) {
          throw _b_2.ValueError.$factory("complex modulo");
        }
        if ($B2.rich_comp("__eq__", other, 1)) {
          var funcs = _b_2.float.$funcs;
          if (funcs.isinf(self2.$real) || funcs.isninf(self2.$real) || funcs.isinf(self2.$imag) || funcs.isninf(self2.$imag)) {
            throw _b_2.OverflowError.$factory("complex exponentiation");
          }
          return self2;
        }
        var small_int = null;
        if ($B2.$isinstance(other, _b_2.int) && _b_2.abs(other) < 100) {
          small_int = other;
        } else if ($B2.$isinstance(other, _b_2.float) && Number.isInteger(other.value) && Math.abs(other.value < 100)) {
          small_int = other.value;
        } else if ($B2.$isinstance(other, complex) && other.$imag.value == 0 && Number.isInteger(other.$real.value) && Math.abs(other.$real.value) < 100) {
          small_int = other.$real.value;
        }
        if (small_int !== null) {
          return c_powi(self2, small_int);
        }
        if ($B2.$isinstance(other, _b_2.float)) {
          other = _b_2.float.$to_js_number(other);
        }
        if (self2.$real.value == 0 && self2.$imag.value == 0) {
          if ($B2.$isinstance(other, complex) && (other.$imag.value != 0 || other.$real.value < 0)) {
            throw _b_2.ZeroDivisionError.$factory(
              "0.0 to a negative or complex power"
            );
          }
          return $B2.make_complex(0, 0);
        }
        var exp = complex2expo(self2), angle = exp.angle, res = Math.pow(exp.norm, other);
        if ($B2.$isinstance(other, _b_2.int)) {
          return make_complex(res * Math.cos(angle * other), res * Math.sin(angle * other));
        } else if ($B2.$isinstance(other, _b_2.float)) {
          return make_complex(res * Math.cos(angle * other.value), res * Math.sin(angle * other.value));
        } else if ($B2.$isinstance(other, complex)) {
          var x = other.$real.value, y = other.$imag.value;
          var pw = Math.pow(exp.norm, x) * Math.pow(Math.E, -y * angle), theta = y * Math.log(exp.norm) - x * angle;
          if (pw == Number.POSITIVE_INFINITY || pw === Number.NEGATIVE_INFINITY) {
            throw _b_2.OverflowError.$factory("complex exponentiation");
          }
          return make_complex(pw * Math.cos(theta), pw * Math.sin(theta));
        } else {
          throw _b_2.TypeError.$factory("unsupported operand type(s) for ** or pow(): 'complex' and '" + $B2.class_name(other) + "'");
        }
      };
      complex.__radd__ = function(self2, other) {
        if ($B2.$isinstance(other, _b_2.bool)) {
          other = other ? 1 : 0;
        }
        if ($B2.$isinstance(other, _b_2.int)) {
          return make_complex(other + self2.$real.value, self2.$imag.value);
        } else if ($B2.$isinstance(other, _b_2.float)) {
          return make_complex(other.value + self2.$real.value, self2.$imag.value);
        }
        return _b_2.NotImplemented;
      };
      complex.__repr__ = function(self2) {
        $B2.builtins_repr_check(complex, arguments);
        var real = Number.isInteger(self2.$real.value) ? self2.$real.value + "" : _b_2.str.$factory(self2.$real), imag = Number.isInteger(self2.$imag.value) ? self2.$imag.value + "" : _b_2.str.$factory(self2.$imag);
        if (imag.endsWith(".0")) {
          imag = imag.substr(0, imag.length - 2);
        }
        if (Object.is(self2.$imag.value, -0)) {
          imag = "-0";
        }
        var sign = imag.startsWith("-") ? "" : "+";
        if (self2.$real.value == 0) {
          if (Object.is(self2.$real.value, -0)) {
            return "(-0" + sign + imag + "j)";
          } else {
            return imag + "j";
          }
        }
        if (self2.$imag.value > 0 || isNaN(self2.$imag.value)) {
          return "(" + real + "+" + imag + "j)";
        }
        if (self2.$imag.value == 0) {
          if (1 / self2.$imag.value < 0) {
            return "(" + real + "-0j)";
          }
          return "(" + real + "+0j)";
        }
        return "(" + real + sign + imag + "j)";
      };
      complex.__rmul__ = function(self2, other) {
        if ($B2.$isinstance(other, _b_2.bool)) {
          other = other ? 1 : 0;
        }
        if ($B2.$isinstance(other, _b_2.int)) {
          return make_complex(other * self2.$real.value, other * self2.$imag.value);
        } else if ($B2.$isinstance(other, _b_2.float)) {
          return make_complex(other.value * self2.$real.value, other.value * self2.$imag.value);
        }
        return _b_2.NotImplemented;
      };
      complex.__sub__ = function(self2, other) {
        if ($B2.$isinstance(other, complex)) {
          return make_complex(self2.$real.value - other.$real.value, self2.$imag.value - other.$imag.value);
        }
        if ($B2.$isinstance(other, _b_2.int)) {
          other = _b_2.int.numerator(other);
          return make_complex(self2.$real.value - other.valueOf(), self2.$imag.value);
        }
        if ($B2.$isinstance(other, _b_2.float)) {
          return make_complex(self2.$real.value - other.value, self2.$imag.value);
        }
        return _b_2.NotImplemented;
      };
      complex.__truediv__ = function(self2, other) {
        if ($B2.$isinstance(other, complex)) {
          if (other.$real.value == 0 && other.$imag.value == 0) {
            throw _b_2.ZeroDivisionError.$factory("division by zero");
          }
          var _num = self2.$real.value * other.$real.value + self2.$imag.value * other.$imag.value, _div = other.$real.value * other.$real.value + other.$imag.value * other.$imag.value;
          var _num2 = self2.$imag.value * other.$real.value - self2.$real.value * other.$imag.value;
          return make_complex($B2.fast_float(_num / _div), $B2.fast_float(_num2 / _div));
        }
        if ($B2.$isinstance(other, _b_2.int)) {
          if (!other.valueOf()) {
            throw _b_2.ZeroDivisionError.$factory("division by zero");
          }
          return complex.__truediv__(self2, complex.$factory(other.valueOf()));
        }
        if ($B2.$isinstance(other, _b_2.float)) {
          if (!other.value) {
            throw _b_2.ZeroDivisionError.$factory("division by zero");
          }
          return complex.$factory(_b_2.float.__truediv__(self2.$real, other), _b_2.float.__truediv__(self2.$imag, other));
        }
        return _b_2.NotImplemented;
      };
      complex.conjugate = function(self2) {
        return make_complex(self2.$real.value, -self2.$imag.value);
      };
      complex.__ior__ = complex.__or__;
      var r_opnames = ["add", "sub", "mul", "truediv", "floordiv", "mod", "pow", "lshift", "rshift", "and", "xor", "or"];
      for (var r_opname of r_opnames) {
        if (complex["__r" + r_opname + "__"] === void 0 && complex["__" + r_opname + "__"]) {
          complex["__r" + r_opname + "__"] = /* @__PURE__ */ (function(name2) {
            return function(self2, other) {
              if ($B2.$isinstance(other, _b_2.int)) {
                other = make_complex(other, 0);
                return complex["__" + name2 + "__"](other, self2);
              } else if ($B2.$isinstance(other, _b_2.float)) {
                other = make_complex(other.value, 0);
                return complex["__" + name2 + "__"](other, self2);
              } else if ($B2.$isinstance(other, complex)) {
                return complex["__" + name2 + "__"](other, self2);
              }
              return _b_2.NotImplemented;
            };
          })(r_opname);
        }
      }
      var comp_func_body = `
    var _b_ = __BRYTHON__.builtins
    if(other === undefined || other == _b_.None){
        return _b_.NotImplemented
    }
    throw _b_.TypeError.$factory("no ordering relation " +
        "is defined for complex numbers")`;
      for (var $op in $B2.$comps) {
        complex["__" + $B2.$comps[$op] + "__"] = Function("self", "other", comp_func_body.replace(/>/gm, $op));
      }
      complex.real = function(self2) {
        return self2.$real;
      };
      complex.real.setter = function() {
        throw _b_2.AttributeError.$factory("readonly attribute");
      };
      complex.imag = function(self2) {
        return self2.$imag;
      };
      complex.imag.setter = function() {
        throw _b_2.AttributeError.$factory("readonly attribute");
      };
      var _real = 1, _real_mantissa = 2, _sign = 3, _imag = 4, _imag_mantissa = 5, _j = 6;
      var expected_class = { "__complex__": complex, "__float__": _b_2.float, "__index__": _b_2.int };
      function _convert(obj) {
        var klass = obj.__class__ || $B2.get_class(obj);
        for (var method_name in expected_class) {
          var missing = {}, method = $B2.$getattr(klass, method_name, missing);
          if (method !== missing) {
            var res = method(obj);
            if (!$B2.$isinstance(res, expected_class[method_name])) {
              throw _b_2.TypeError.$factory(method_name + "returned non-" + expected_class[method_name].__name__ + "(type " + $B2.get_class(res) + ")");
            }
            if (method_name == "__index__" && $B2.rich_comp("__gt__", res, __BRYTHON__.MAX_VALUE)) {
              throw _b_2.OverflowError.$factory("int too large to convert to float");
            }
            if (method_name == "__complex__" && res.__class__ !== complex) {
              $B2.warn(_b_2.DeprecationWarning, `__complex__ returned non-complex (type ${$B2.class_name(res)}). The ability to return an instance of a strict subclass of complex is deprecated, and may be removed in a future version of Python.`);
            }
            return { result: res, method: method_name };
          }
        }
        return null;
      }
      var make_complex = $B2.make_complex = function(real, imag) {
        return {
          __class__: complex,
          $real: _b_2.float.$factory(real),
          $imag: _b_2.float.$factory(imag)
        };
      };
      var c_1 = make_complex(1, 0);
      complex.$factory = function() {
        return complex.__new__(complex, ...arguments);
      };
      $B2.set_func_names(complex, "builtins");
      _b_2.complex = complex;
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      var set_ops = ["eq", "le", "lt", "ge", "gt", "sub", "rsub", "and", "rand", "or", "ror", "xor", "rxor"];
      function is_sublist(t1, t2) {
        for (var i = 0, ilen = t1.length; i < ilen; i++) {
          var x = t1[i], flag = false;
          for (var j2 = 0, jlen = t2.length; j2 < jlen; j2++) {
            if ($B2.rich_comp("__eq__", x, t2[j2])) {
              t2.splice(j2, 1);
              flag = true;
              break;
            }
          }
          if (!flag) {
            return false;
          }
        }
        return true;
      }
      const dict_view_op = { __eq__: function(t1, t2) {
        return t1.length == t2.length && is_sublist(t1, t2);
      }, __ne__: function(t1, t2) {
        return !dict_view_op.__eq__(t1, t2);
      }, __lt__: function(t1, t2) {
        return t1.length < t2.length && is_sublist(t1, t2);
      }, __gt__: function(t1, t2) {
        return dict_view_op.__lt__(t2, t1);
      }, __le__: function(t1, t2) {
        return t1.length <= t2.length && is_sublist(t1, t2);
      }, __ge__: function(t1, t2) {
        return dict_view_op.__le__(t2, t1);
      }, __and__: function(t1, t2) {
        var items = [];
        for (var i = 0, ilen = t1.length; i < ilen; i++) {
          var x = t1[i];
          for (var j2 = 0, jlen = t2.length; j2 < jlen; j2++) {
            if ($B2.rich_comp("__eq__", x, t2[j2])) {
              t2.splice(j2, 1);
              items.push(x);
              break;
            }
          }
        }
        return $B2.$list(items);
      }, __or__: function(t1, t2) {
        var items = t1;
        for (var j2 = 0, jlen = t2.length; j2 < jlen; j2++) {
          var y = t2[j2], flag = false;
          for (var i = 0, ilen = t1.length; i < ilen; i++) {
            if ($B2.rich_comp("__eq__", y, t1[i])) {
              t2.splice(j2, 1);
              flag = true;
              break;
            }
          }
          if (!flag) {
            items.push(y);
          }
        }
        return items;
      } };
      function make_view_comparison_methods(klass) {
        for (var i = 0, len = set_ops.length; i < len; i++) {
          var op = "__" + set_ops[i] + "__";
          klass[op] = /* @__PURE__ */ (function(op2) {
            return function(self2, other) {
              if (self2.__class__.__name__ == "dict_keys" || self2.__class__.__name__ == "dict_items" && dict.$set_like(self2.dict)) {
                return _b_2.set[op2](_b_2.set.$factory(self2), _b_2.set.$factory(other));
              } else {
                if (other.__class__ !== klass) {
                  return false;
                }
                var other_items = _b_2.list.$factory(other);
                return dict_view_op[op2](self2.items, other_items);
              }
            };
          })(op);
        }
      }
      $B2.str_dict = function() {
      };
      var dict = { __class__: _b_2.type, __mro__: [_b_2.object], __qualname__: "dict", $is_class: true, $native: true, $match_mapping_pattern: true };
      dict.$to_obj = function(d) {
        var res = {};
        for (var entry of dict.$iter_items(d)) {
          res[entry.key] = entry.value;
        }
        return res;
      };
      dict.$iter_keys_check = function* (d) {
        for (var entry of dict.$iter_items(d)) {
          yield entry.key;
        }
      };
      dict.$iter_values_check = function* (d) {
        for (var entry of dict.$iter_items(d)) {
          yield entry.value;
        }
      };
      dict.$set_like = function(self2) {
        for (var v of self2._values) {
          if (v === void 0) {
            continue;
          } else if (typeof v == "string" || typeof v == "number" || typeof v == "boolean") {
            continue;
          } else if ([_b_2.tuple, _b_2.float, _b_2.complex].indexOf(v.__class__) > -1) {
            continue;
          } else if (!_b_2.hasattr(v.__class__, "__hash__")) {
            return false;
          }
        }
        return true;
      };
      dict.$iter_items = function* (d) {
        if (d.$all_str) {
          for (let key2 in d.$strings) {
            if (key2 != "$dict_strings") {
              yield { key: key2, value: d.$strings[key2] };
            }
          }
        }
        if (d.$jsobj) {
          for (let key2 in d.$jsobj) {
            if (!d.$exclude || !d.$exclude(key2)) {
              yield { key: key2, value: d.$jsobj[key2] };
            }
          }
        } else {
          var version = d.$version;
          for (var i = 0, len = d._keys.length; i < len; i++) {
            if (d._keys[i] !== void 0) {
              yield { key: d._keys[i], value: d._values[i], hash: d._hashes[i] };
              if (d.$version !== version) {
                throw _b_2.RuntimeError.$factory("changed in iteration");
              }
            }
          }
          if (d.$version !== version) {
            throw _b_2.RuntimeError.$factory("changed in iteration");
          }
        }
      };
      dict.$iter_items_check = function* (d) {
        if (d.$jsobj) {
          for (var key2 in d.$jsobj) {
            yield [key2, d.$jsobj[key2]];
          }
        } else {
          var version = d.$version;
          for (var i = 0, len = d._keys.length; i < len; i++) {
            if (d._keys[i] !== void 0) {
              yield [d._keys[i], d._values[i]];
              if (d.$version !== version) {
                throw _b_2.RuntimeError.$factory("changed in iteration");
              }
            }
          }
          if (d.$version !== version) {
            throw _b_2.RuntimeError.$factory("changed in iteration");
          }
        }
      };
      var $copy_dict = function(left, right) {
        right.$version = right.$version || 0;
        var right_version = right.$version;
        if (right.$all_str) {
          if (left.$all_str) {
            for (let key2 in right.$strings) {
              left.$strings[key2] = right.$strings[key2];
            }
          } else {
            for (let key2 in right.$strings) {
              dict.$setitem(left, key2, right.$strings[key2]);
            }
          }
        } else {
          for (var entry of dict.$iter_items(right)) {
            dict.$setitem(left, entry.key, entry.value, entry.hash);
            if (right.$version != right_version) {
              throw _b_2.RuntimeError.$factory("dict mutated during update");
            }
          }
        }
      };
      dict.__bool__ = function() {
        var $ = $B2.args("__bool__", 1, { self: null }, ["self"], arguments, {}, null, null);
        return dict.__len__($.self) > 0;
      };
      dict.__class_getitem__ = $B2.$class_getitem;
      dict.$lookup_by_key = function(d, key2, hash) {
        hash = hash === void 0 ? _b_2.hash(key2) : hash;
        var indices = d.table[hash], index;
        if (indices !== void 0) {
          for (var i = 0, len = indices.length; i < len; i++) {
            index = indices[i];
            if (d._keys[index] === void 0) {
              d.table[hash].splice(i, 1);
              if (d.table[hash].length == 0) {
                delete d.table[hash];
                return { found: false, hash };
              }
              continue;
            }
            if ($B2.is_or_equals(d._keys[index], key2)) {
              return { found: true, key: d._keys[index], value: d._values[index], hash, rank: i, index };
            }
          }
        }
        return { found: false, hash };
      };
      dict.__contains__ = function() {
        var $ = $B2.args("__contains__", 2, { self: null, key: null }, ["self", "key"], arguments, {}, null, null), self2 = $.self, key2 = $.key;
        return _b_2.dict.$contains(self2, key2);
      };
      dict.$contains = function(self2, key2) {
        if (self2.$all_str) {
          if (typeof key2 == "string") {
            return self2.$strings.hasOwnProperty(key2);
          }
          var hash = $B2.$getattr($B2.get_class(key2), "__hash__");
          if (hash === _b_2.object.__hash__) {
            return false;
          }
          convert_all_str(self2);
        }
        if (self2.$jsobj) {
          return self2.$jsobj[key2] !== void 0;
        }
        return dict.$lookup_by_key(self2, key2).found;
      };
      dict.__delitem__ = function() {
        var $ = $B2.args("__eq__", 2, { self: null, key: null }, ["self", "key"], arguments, {}, null, null), self2 = $.self, key2 = $.key;
        if (self2[$B2.JSOBJ]) {
          delete self2[$B2.JSOBJ][key2];
        }
        if (self2.$all_str) {
          if (typeof key2 == "string") {
            if (self2.$strings.hasOwnProperty(key2)) {
              dict.$delete_string(self2, key2);
              return _b_2.None;
            } else {
              throw _b_2.KeyError.$factory(key2);
            }
          }
          if (!dict.__contains__(self2, key2)) {
            throw _b_2.KeyError.$factory(_b_2.str.$factory(key2));
          }
        }
        if (self2.$jsobj) {
          if (self2.$jsobj[key2] === void 0) {
            throw _b_2.KeyError.$factory(key2);
          }
          delete self2.$jsobj[key2];
          return _b_2.None;
        }
        var lookup = dict.$lookup_by_key(self2, key2);
        if (lookup.found) {
          self2.table[lookup.hash].splice(lookup.rank, 1);
          if (self2.table[lookup.hash].length == 0) {
            delete self2.table[lookup.hash];
          }
          delete self2._values[lookup.index];
          delete self2._keys[lookup.index];
          delete self2._hashes[lookup.index];
          self2.$version++;
          return _b_2.None;
        }
        throw _b_2.KeyError.$factory(_b_2.str.$factory(key2));
      };
      dict.__eq__ = function() {
        var $ = $B2.args("__eq__", 2, { self: null, other: null }, ["self", "other"], arguments, {}, null, null), self2 = $.self, other = $.other;
        return dict.$eq(self2, other);
      };
      dict.$eq = function(self2, other) {
        if (!$B2.$isinstance(other, dict)) {
          return _b_2.NotImplemented;
        }
        if (self2.$all_str && other.$all_str) {
          if (dict.__len__(self2) !== dict.__len__(other)) {
            return false;
          }
          for (let k2 in self2.$strings) {
            if (!other.$strings.hasOwnProperty(k2)) {
              return false;
            }
            if (!$B2.is_or_equals(self2.$strings[k2], other.$strings[k2])) {
              return false;
            }
          }
          return true;
        }
        if (self2.$jsobj && other.$jsobj) {
          if (dict.__len__(self2) !== dict.__len__(other)) {
            return false;
          }
          for (var k in self2.$jsobj) {
            if (!other.$jsobj.hasOwnProperty(k)) {
              return false;
            }
            if (!$B2.is_or_equals(self2.$jsobj[k], other.$jsobj[k])) {
              return false;
            }
          }
          return true;
        }
        if (self2.$all_str) {
          let d = dict.copy(self2);
          convert_all_str(d);
          return dict.$eq(d, other);
        }
        if (other.$all_str) {
          let d = dict.copy(other);
          convert_all_str(d);
          return dict.$eq(self2, d);
        }
        if (self2.$jsobj) {
          return dict.$eq(jsobj2dict(self2.$jsobj), other);
        }
        if (other.$jsobj) {
          return dict.$eq(self2, jsobj2dict(other.$jsobj));
        }
        if (dict.__len__(self2) != dict.__len__(other)) {
          return false;
        }
        for (var hash in self2.table) {
          var self_pairs = [];
          for (let index of self2.table[hash]) {
            self_pairs.push([self2._keys[index], self2._values[index]]);
          }
          var other_pairs = [];
          if (other.table[hash] !== void 0) {
            for (let index of other.table[hash]) {
              other_pairs.push([other._keys[index], other._values[index]]);
            }
          }
          for (let self_pair of self_pairs) {
            let flag = false, key2 = self_pair[0], value2 = self_pair[1];
            for (let other_pair of other_pairs) {
              if ($B2.is_or_equals(key2, other_pair[0]) && $B2.is_or_equals(value2, other_pair[1])) {
                flag = true;
                break;
              }
            }
            if (!flag) {
              return false;
            }
          }
        }
        return true;
      };
      dict.__getitem__ = function() {
        var $ = $B2.args("__getitem__", 2, { self: null, arg: null }, ["self", "arg"], arguments, {}, null, null), self2 = $.self, arg = $.arg;
        return dict.$getitem(self2, arg);
      };
      dict.$contains_string = function(self2, key2) {
        if (self2.$all_str) {
          return self2.$strings.hasOwnProperty(key2);
        }
        if (self2.$jsobj && self2.$jsobj.hasOwnProperty(key2)) {
          return true;
        }
        if (self2.table && self2.table[_b_2.hash(key2)] !== void 0) {
          return true;
        }
        return false;
      };
      dict.$delete_string = function(self2, key2) {
        if (self2.$all_str) {
          var ix = self2.$strings[key2];
          if (ix !== void 0) {
            delete self2.$strings[key2];
          }
        }
        if (self2.$jsobj) {
          delete self2.$jsobj[key2];
        }
        if (self2.table) {
          delete self2.table[_b_2.hash(key2)];
        }
      };
      dict.$missing = {};
      dict.$get_string = function(self2, key2, _default) {
        if (self2.$all_str && self2.$strings.hasOwnProperty(key2)) {
          return self2.$strings[key2];
        }
        if (self2.$jsobj && self2.$jsobj.hasOwnProperty(key2)) {
          return self2.$jsobj[key2];
        }
        if (self2.table && dict.__len__(self2)) {
          var indices = self2.table[_b_2.hash(key2)];
          if (indices !== void 0) {
            return self2._values[indices[0]];
          }
        }
        return _default ?? _b_2.dict.$missing;
      };
      dict.$getitem_string = function(self2, key2) {
        if (self2.$all_str && self2.$strings.hasOwnProperty(key2)) {
          return self2.$strings[key2];
        }
        if (self2.$jsobj && self2.$jsobj.hasOwnProperty(key2)) {
          return self2.$jsobj[key2];
        }
        if (self2.table) {
          var indices = self2.table[_b_2.hash(key2)];
          if (indices !== void 0) {
            return self2._values[indices[0]];
          }
        }
        throw _b_2.KeyError.$factory(key2);
      };
      dict.$keys_string = function(self2) {
        var res = [];
        if (self2.$all_str) {
          return Object.keys(self2.$strings);
        }
        if (self2.$jsobj) {
          res = res.concat(Object.keys(self2.$jsobj));
        }
        if (self2.table) {
          res = res.concat(self2._keys.filter((x) => x !== void 0));
        }
        return res;
      };
      dict.$setitem_string = function(self2, key2, value2) {
        if (self2.$all_str) {
          self2.$strings[key2] = value2;
          return _b_2.None;
        } else {
          var h = _b_2.hash(key2), indices = self2.table[h];
          if (indices !== void 0) {
            self2._values[indices[0]] = value2;
            return _b_2.None;
          }
        }
        var index = self2._keys.length;
        self2.$strings[key2] = index;
        self2._keys.push(key2);
        self2._values.push(value2);
        self2.$version++;
        return _b_2.None;
      };
      dict.$getitem = function(self2, key2, ignore_missing) {
        if (self2.$all_str) {
          if (typeof key2 == "string") {
            if (self2.$strings.hasOwnProperty(key2)) {
              return self2.$strings[key2];
            }
          } else {
            var hash_method = $B2.$getattr($B2.get_class(key2), "__hash__");
            if (hash_method !== _b_2.object.__hash__) {
              convert_all_str(self2);
              let lookup = dict.$lookup_by_key(self2, key2);
              if (lookup.found) {
                return lookup.value;
              }
            }
          }
        } else if (self2.$jsobj) {
          if (self2.$exclude && self2.$exclude(key2)) {
            throw _b_2.KeyError.$factory(key2);
          }
          if (self2.$jsobj.hasOwnProperty(key2)) {
            return self2.$jsobj[key2];
          }
          if (!self2.table) {
            throw _b_2.KeyError.$factory(key2);
          }
        } else {
          let lookup = dict.$lookup_by_key(self2, key2);
          if (lookup.found) {
            return lookup.value;
          }
        }
        if (!ignore_missing) {
          if (self2.__class__ !== dict && !ignore_missing) {
            try {
              var missing_method = $B2.$getattr(self2.__class__, "__missing__", _b_2.None);
            } catch (err) {
              console.log(err);
            }
            if (missing_method !== _b_2.None) {
              return missing_method(self2, key2);
            }
          }
        }
        throw _b_2.KeyError.$factory(key2);
      };
      dict.__hash__ = _b_2.None;
      function init_from_list(self2, args) {
        var i = 0;
        for (var item2 of args) {
          if (item2.length != 2) {
            throw _b_2.ValueError.$factory(`dictionary update sequence element #${i} has length ${item2.length}; 2 is required`);
          }
          dict.$setitem(self2, item2[0], item2[1]);
          i++;
        }
      }
      dict.$set_string_no_duplicate = function(d, keys, string, value2) {
        if (typeof string !== "string") {
          throw _b_2.TypeError.$factory(
            "keywords must be strings"
          );
        }
        if (keys.has(string)) {
          throw _b_2.TypeError.$factory(`dict() got multiple values for keyword argument '${string}'`);
        }
        d.$strings[string] = value2;
        keys.add(string);
      };
      function add_mapping(d, obj) {
        for (var entry of _b_2.dict.$iter_items(obj)) {
          dict.$setitem(d, entry.key, entry.value, entry.hash);
        }
      }
      function add_iterable(d, js_iterable) {
        var i = 0;
        for (var entry of js_iterable) {
          var items = Array.from($B2.make_js_iterator(entry));
          if (items.length !== 2) {
            throw _b_2.ValueError.$factory(`dictionary update sequence element #${i} has length ${items.length}; 2 is required`);
          }
          dict.$setitem(d, items[0], items[1]);
          i++;
        }
      }
      dict.__init__ = function(self2, first, second) {
        if (first === void 0) {
          return _b_2.None;
        }
        if (second === void 0) {
          if (!first.$kw && $B2.$isinstance(first, $B2.JSObj)) {
            for (let key2 in first) {
              dict.$setitem(self2, key2, first[key2]);
            }
            return _b_2.None;
          } else if (first.$kw) {
            var keys = /* @__PURE__ */ new Set();
            for (let item2 of first.$kw) {
              if ($B2.$isinstance(item2, dict)) {
                for (let subitem of dict.$iter_items(item2)) {
                  dict.$set_string_no_duplicate(self2, keys, subitem.key, subitem.value);
                }
              } else {
                for (let key2 in item2) {
                  dict.$set_string_no_duplicate(self2, keys, key2, item2[key2]);
                }
              }
            }
            return _b_2.None;
          } else if (first[Symbol.iterator]) {
            init_from_list(self2, first);
            return _b_2.None;
          } else if (first.__class__ === $B2.generator) {
            init_from_list(self2, first.js_gen);
            return _b_2.None;
          }
        }
        var $ = $B2.args("dict", 1, { self: null }, ["self"], arguments, {}, "first", "second");
        var args = $.first;
        if (args.length > 1) {
          if ($B2._experimental_dict) {
            console.log("try dict(*args)");
            for (var arg of args) {
              if (_b_2.isinstance(arg, _b_2.dict)) {
                add_mapping(self2, arg);
              } else {
                try {
                  var js_iterable = $B2.make_js_iterator(arg);
                } catch (err) {
                  console.log(arg);
                  console.log(err);
                  throw _b_2.TypeError.$factory(`expected mapping or iterable, got ${$B2.class_name(arg)}`);
                }
                add_iterable(self2, js_iterable);
              }
            }
          } else {
            throw _b_2.TypeError.$factory(`dict expected at most 1 argument, got ${args.length}`);
          }
        } else if (args.length == 1) {
          args = args[0];
          if (args.__class__ === dict) {
            for (let entry of dict.$iter_items(args)) {
              dict.$setitem(self2, entry.key, entry.value, entry.hash);
            }
          } else {
            var keys = $B2.$getattr(args, "keys", null);
            if (keys !== null) {
              var gi = $B2.$getattr(args, "__getitem__", null);
              if (gi !== null) {
                gi = $B2.$call(gi);
                let kiter = _b_2.iter($B2.$call(keys)());
                while (true) {
                  try {
                    let key2 = _b_2.next(kiter), value2 = gi(key2);
                    dict.__setitem__(self2, key2, value2);
                  } catch (err) {
                    if (err.__class__ === _b_2.StopIteration) {
                      break;
                    }
                    throw err;
                  }
                }
              }
            } else {
              if (!Array.isArray(args)) {
                args = _b_2.list.$factory(args);
              }
              init_from_list(self2, args);
            }
          }
        }
        for (let item2 of _b_2.dict.$iter_items($.second)) {
          dict.$setitem(self2, item2.key, item2.value);
        }
        return _b_2.None;
      };
      dict.__iter__ = function(self2) {
        return _b_2.iter(dict.keys(self2));
      };
      dict.__ior__ = function(self2, other) {
        dict.update(self2, other);
        return self2;
      };
      dict.__len__ = function(self2) {
        var _count = 0;
        if (self2.$all_str) {
          return Object.keys(self2.$strings).length;
        }
        if (self2.$jsobj) {
          for (var attr2 in self2.$jsobj) {
            if (attr2.charAt(0) != "$" && (!self2.$exclude || !self2.$exclude(attr2))) {
              _count++;
            }
          }
          return _count;
        }
        for (var d of self2._keys) {
          if (d !== void 0) {
            _count++;
          }
        }
        return _count;
      };
      dict.__ne__ = function(self2, other) {
        var res = dict.__eq__(self2, other);
        return res === _b_2.NotImplemented ? res : !res;
      };
      dict.__new__ = function(cls) {
        if (cls === void 0) {
          throw _b_2.TypeError.$factory("int.__new__(): not enough arguments");
        }
        var instance = $B2.empty_dict();
        instance.__class__ = cls;
        if (cls !== dict) {
          instance.__dict__ = $B2.empty_dict();
        }
        return instance;
      };
      dict.__or__ = function(self2, other) {
        if (!$B2.$isinstance(other, dict)) {
          return _b_2.NotImplemented;
        }
        var res = dict.copy(self2);
        dict.update(res, other);
        return res;
      };
      dict.__repr__ = function(self2) {
        $B2.builtins_repr_check(dict, arguments);
        if (self2.$jsobj) {
          return dict.__repr__(jsobj2dict(self2.$jsobj, self2.$exclude));
        }
        if ($B2.repr.enter(self2)) {
          return "{...}";
        }
        let res = [];
        for (let entry of dict.$iter_items(self2)) {
          res.push(_b_2.repr(entry.key) + ": " + _b_2.repr(entry.value));
        }
        $B2.repr.leave(self2);
        return "{" + res.join(", ") + "}";
      };
      dict.$iter_items_reversed = function* (d) {
        var version = d.$version;
        if (d.$all_str) {
          for (var item2 of Object.entries(d.$strings).reverse()) {
            yield $B2.fast_tuple(item2);
            if (d.$version !== version) {
              throw _b_2.RuntimeError.$factory("changed in iteration");
            }
          }
        } else {
          for (var i = d._keys.length - 1; i >= 0; i--) {
            var key2 = d._keys[i];
            if (key2 !== void 0) {
              yield $B2.fast_tuple([key2, d._values[i]]);
              if (d.$version !== version) {
                throw _b_2.RuntimeError.$factory("changed in iteration");
              }
            }
          }
        }
        if (d.$version !== version) {
          throw _b_2.RuntimeError.$factory("changed in iteration");
        }
      };
      dict.$iter_keys_reversed = function* (d) {
        for (var entry of dict.$iter_items_reversed(d)) {
          yield entry[0];
        }
      };
      dict.$iter_values_reversed = function* (d) {
        for (var entry of dict.$iter_items_reversed(d)) {
          yield entry[1];
        }
      };
      function make_reverse_iterator(name2, iter_func) {
        var klass = $B2.make_class(
          name2,
          function(d) {
            return {
              __class__: klass,
              d,
              iter: iter_func(d),
              make_iter: function() {
                return iter_func(d);
              }
            };
          }
        );
        klass.__iter__ = function(self2) {
          self2[Symbol.iterator] = self2.make_iter;
          return self2;
        };
        klass.__next__ = function(self2) {
          var res = self2.iter.next();
          if (res.done) {
            throw _b_2.StopIteration.$factory("");
          }
          return res.value;
        };
        klass.__reduce_ex__ = function(self2) {
          return $B2.fast_tuple([_b_2.iter, $B2.fast_tuple([$B2.$list(Array.from(self2.make_iter()))])]);
        };
        $B2.set_func_names(klass, "builtins");
        return klass;
      }
      const dict_reversekeyiterator = make_reverse_iterator(
        "dict_reversekeyiterator",
        dict.$iter_keys_reversed
      );
      dict.__reversed__ = function(self2) {
        return dict_reversekeyiterator.$factory(self2);
      };
      dict.__ror__ = function(self2, other) {
        if (!$B2.$isinstance(other, dict)) {
          return _b_2.NotImplemented;
        }
        var res = dict.copy(other);
        dict.update(res, self2);
        return res;
      };
      dict.__setitem__ = function() {
        var $ = $B2.args("__setitem__", 3, { self: null, key: null, value: null }, ["self", "key", "value"], arguments, {}, null, null);
        return dict.$setitem($.self, $.key, $.value);
      };
      function convert_all_str(d) {
        d.$all_str = false;
        for (var key2 in d.$strings) {
          dict.$setitem(d, key2, d.$strings[key2]);
        }
      }
      dict.$setitem = function(self2, key2, value2, $hash, from_setdefault) {
        if (self2[$B2.JSOBJ]) {
          value2 = $B2.pyobj2jsobj(value2);
          self2[$B2.JSOBJ][key2] = value2;
        }
        if (self2.$all_str) {
          if (typeof key2 == "string") {
            var int = parseInt(key2);
            if (isNaN(int) || int >= 0) {
              self2.$strings[key2] = value2;
              return _b_2.None;
            } else {
              convert_all_str(self2);
            }
          } else {
            convert_all_str(self2);
          }
        }
        if (self2.$jsobj) {
          if (self2.$from_js) {
            value2 = $B2.pyobj2jsobj(value2);
          }
          if (self2.$jsobj.__class__ === _b_2.type) {
            self2.$jsobj[key2] = value2;
            if (key2 == "__init__" || key2 == "__new__") {
              self2.$jsobj.$factory = $B2.$instance_creator(self2.$jsobj);
            }
          } else {
            self2.$jsobj[key2] = value2;
          }
          return _b_2.None;
        }
        if (key2 instanceof String) {
          key2 = key2.valueOf();
        }
        var hash = $hash !== void 0 ? $hash : $B2.$hash(key2);
        var index;
        if (self2.table[hash] === void 0) {
          index = self2._keys.length;
          self2.table[hash] = [index];
        } else {
          if (!from_setdefault) {
            var lookup = dict.$lookup_by_key(self2, key2, hash);
            if (lookup.found) {
              self2._values[lookup.index] = value2;
              return _b_2.None;
            }
          }
          index = self2._keys.length;
          if (self2.table[hash] === void 0) {
            self2.table[hash] = [index];
          } else {
            self2.table[hash].push(index);
          }
        }
        self2._keys.push(key2);
        self2._values.push(value2);
        self2._hashes.push(hash);
        self2.$version++;
        return _b_2.None;
      };
      $B2.make_rmethods(dict);
      dict.clear = function() {
        var $ = $B2.args("clear", 1, { self: null }, ["self"], arguments, {}, null, null), self2 = $.self;
        self2.table = /* @__PURE__ */ Object.create(null);
        self2._keys = [];
        self2._values = [];
        self2.$all_str = true;
        self2.$strings = new $B2.str_dict();
        if (self2.$jsobj) {
          for (var attr2 in self2.$jsobj) {
            if (attr2.charAt(0) !== "$" && attr2 !== "__class__") {
              delete self2.$jsobj[attr2];
            }
          }
        }
        self2.$version++;
        return _b_2.None;
      };
      dict.copy = function() {
        var $ = $B2.args("copy", 1, { self: null }, ["self"], arguments, {}, null, null), self2 = $.self, res = $B2.empty_dict();
        if (self2.__class__ === _b_2.dict) {
          $copy_dict(res, self2);
          return res;
        }
        var it = $B2.make_js_iterator(self2);
        for (var k of it) {
          console.log("iteration yields key", k);
        }
        return res;
      };
      dict.fromkeys = function() {
        var $ = $B2.args("fromkeys", 3, { cls: null, keys: null, value: null }, ["cls", "keys", "value"], arguments, { value: _b_2.None }, null, null), keys = $.keys, value2 = $.value;
        var cls = $.cls, res = $B2.$call(cls)(), klass = $B2.get_class(res), keys_iter = $B2.$iter(keys), setitem = klass === dict ? dict.$setitem : $B2.$getattr(klass, "__setitem__");
        while (1) {
          try {
            var key2 = _b_2.next(keys_iter);
            setitem(res, key2, value2);
          } catch (err) {
            if ($B2.is_exc(err, [_b_2.StopIteration])) {
              return res;
            }
            throw err;
          }
        }
      };
      dict.get = function() {
        var $ = $B2.args("get", 3, { self: null, key: null, _default: null }, ["self", "key", "_default"], arguments, { _default: _b_2.None }, null, null);
        try {
          return dict.$getitem($.self, $.key, true);
        } catch (err) {
          if ($B2.$isinstance(err, _b_2.KeyError)) {
            return $._default;
          } else {
            throw err;
          }
        }
      };
      var dict_items = $B2.make_class(
        "dict_items",
        function(d) {
          return {
            __class__: dict_items,
            dict: d,
            make_iter: function* () {
              for (var entry of dict.$iter_items(d)) {
                yield $B2.fast_tuple([entry.key, entry.value]);
              }
            }
          };
        }
      );
      dict_items.__iter__ = function(self2) {
        return dict_itemiterator.$factory(self2.make_iter);
      };
      dict_items.__len__ = function(self2) {
        return dict.__len__(self2.dict);
      };
      dict_items.__reduce__ = function(self2) {
        var items = $B2.$list(Array.from(self2.make_iter()));
        return $B2.fast_tuple([_b_2.iter, $B2.fast_tuple([items])]);
      };
      dict_items.__repr__ = function(self2) {
        var items = Array.from(self2.make_iter());
        items = items.map($B2.fast_tuple);
        return "dict_items(" + _b_2.repr(items) + ")";
      };
      const dict_reverseitemiterator = make_reverse_iterator(
        "dict_reverseitemiterator",
        dict.$iter_items_reversed
      );
      dict_items.__reversed__ = function(self2) {
        return dict_reverseitemiterator.$factory(self2.dict);
      };
      make_view_comparison_methods(dict_items);
      $B2.set_func_names(dict_items, "builtins");
      var dict_itemiterator = $B2.make_class(
        "dict_itemiterator",
        function(make_iter) {
          return {
            __class__: dict_itemiterator,
            iter: make_iter(),
            make_iter
          };
        }
      );
      dict_itemiterator.__iter__ = function(self2) {
        self2[Symbol.iterator] = function() {
          return self2.iter;
        };
        return self2;
      };
      dict_itemiterator.__next__ = function(self2) {
        var res = self2.iter.next();
        if (res.done) {
          throw _b_2.StopIteration.$factory("");
        }
        return $B2.fast_tuple(res.value);
      };
      dict_itemiterator.__reduce_ex__ = function(self2) {
        return $B2.fast_tuple([_b_2.iter, $B2.fast_tuple([$B2.$list(Array.from(self2.make_iter()))])]);
      };
      $B2.set_func_names(dict_itemiterator, "builtins");
      dict.items = function(self2) {
        $B2.args("items", 1, { self: null }, ["self"], arguments, {}, null, null);
        return dict_items.$factory(self2);
      };
      var dict_keys = $B2.make_class(
        "dict_keys",
        function(d) {
          return {
            __class__: dict_keys,
            dict: d,
            make_iter: function() {
              return dict.$iter_keys_check(d);
            }
          };
        }
      );
      dict_keys.__iter__ = function(self2) {
        return dict_keyiterator.$factory(self2.make_iter);
      };
      dict_keys.__len__ = function(self2) {
        return dict.__len__(self2.dict);
      };
      dict_keys.__reduce__ = function(self2) {
        var items = $B2.$list(Array.from(self2.make_iter()));
        return $B2.fast_tuple([_b_2.iter, $B2.fast_tuple([items])]);
      };
      dict_keys.__repr__ = function(self2) {
        var items = Array.from(self2.make_iter());
        return "dict_keys(" + _b_2.repr(items) + ")";
      };
      dict_keys.__reversed__ = function(self2) {
        return dict_reversekeyiterator.$factory(self2.dict);
      };
      make_view_comparison_methods(dict_keys);
      $B2.set_func_names(dict_keys, "builtins");
      var dict_keyiterator = $B2.make_class(
        "dict_keyiterator",
        function(make_iter) {
          return {
            __class__: dict_keyiterator,
            iter: make_iter(),
            make_iter
          };
        }
      );
      dict_keyiterator.__iter__ = function(self2) {
        self2[Symbol.iterator] = function() {
          return self2.iter;
        };
        return self2;
      };
      dict_keyiterator.__next__ = function(self2) {
        var res = self2.iter.next();
        if (res.done) {
          throw _b_2.StopIteration.$factory("");
        }
        return res.value;
      };
      dict_keyiterator.__reduce_ex__ = function(self2) {
        return $B2.fast_tuple([_b_2.iter, $B2.fast_tuple([$B2.$list(Array.from(self2.make_iter()))])]);
      };
      $B2.set_func_names(dict_keyiterator, "builtins");
      dict.keys = function(self2) {
        $B2.args("keys", 1, { self: null }, ["self"], arguments, {}, null, null);
        return dict_keys.$factory(self2);
      };
      dict.pop = function() {
        var missing = {}, $ = $B2.args("pop", 3, { self: null, key: null, _default: null }, ["self", "key", "_default"], arguments, { _default: missing }, null, null), self2 = $.self, key2 = $.key, _default = $._default;
        try {
          var res = dict.__getitem__(self2, key2);
          dict.__delitem__(self2, key2);
          return res;
        } catch (err) {
          if (err.__class__ === _b_2.KeyError) {
            if (_default !== missing) {
              return _default;
            }
            throw err;
          }
          throw err;
        }
      };
      dict.popitem = function(self2) {
        $B2.check_nb_args_no_kw("popitem", 1, arguments);
        if (dict.__len__(self2) == 0) {
          throw _b_2.KeyError.$factory("'popitem(): dictionary is empty'");
        }
        if (self2.$all_str) {
          for (var key2 in self2.$strings) {
          }
          let res = $B2.fast_tuple([key2, self2.$strings[key2]]);
          delete self2.$strings[key2];
          self2.$version++;
          return res;
        }
        var index = self2._keys.length - 1;
        while (index >= 0) {
          if (self2._keys[index] !== void 0) {
            let res = $B2.fast_tuple([self2._keys[index], self2._values[index]]);
            delete self2._keys[index];
            delete self2._values[index];
            self2.$version++;
            return res;
          }
          index--;
        }
      };
      dict.setdefault = function() {
        var $ = $B2.args("setdefault", 3, { self: null, key: null, _default: null }, ["self", "key", "_default"], arguments, { _default: _b_2.None }, null, null), self2 = $.self, key2 = $.key, _default = $._default;
        _default = _default === void 0 ? _b_2.None : _default;
        if (self2.$all_str) {
          if (!self2.$strings.hasOwnProperty(key2)) {
            self2.$strings[key2] = _default;
          }
          return self2.$strings[key2];
        }
        if (self2.$jsobj) {
          if (!self2.$jsobj.hasOwnProperty(key2)) {
            self2.$jsobj[key2] = _default;
          }
          return self2.$jsobj[key2];
        }
        var lookup = dict.$lookup_by_key(self2, key2);
        if (lookup.found) {
          return lookup.value;
        }
        var hash = lookup.hash;
        dict.$setitem(self2, key2, _default, hash, true);
        return _default;
      };
      dict.update = function() {
        var $ = $B2.args("update", 1, { "self": null }, ["self"], arguments, {}, "args", "kw"), self2 = $.self, args = $.args, kw = $.kw;
        if (args.length > 0) {
          var o = args[0];
          if ($B2.$isinstance(o, dict)) {
            if (o.$jsobj) {
              o = jsobj2dict(o.$jsobj);
            }
            $copy_dict(self2, o);
          } else if (_b_2.hasattr(o, "keys")) {
            var _keys = _b_2.list.$factory($B2.$call($B2.$getattr(o, "keys"))());
            for (let i = 0, len = _keys.length; i < len; i++) {
              var _value = $B2.$getattr(o, "__getitem__")(_keys[i]);
              dict.$setitem(self2, _keys[i], _value);
            }
          } else {
            let it = _b_2.iter(o), i = 0, key_value;
            while (true) {
              try {
                var item2 = _b_2.next(it);
              } catch (err) {
                if (err.__class__ === _b_2.StopIteration) {
                  break;
                }
                throw err;
              }
              try {
                key_value = _b_2.list.$factory(item2);
              } catch (err) {
                throw _b_2.TypeError.$factory("cannot convert dictionary update sequence element #" + i + " to a sequence");
              }
              if (key_value.length !== 2) {
                throw _b_2.ValueError.$factory("dictionary update sequence element #" + i + " has length " + key_value.length + "; 2 is required");
              }
              dict.$setitem(self2, key_value[0], key_value[1]);
              i++;
            }
          }
        }
        $copy_dict(self2, kw);
        return _b_2.None;
      };
      var dict_values = $B2.make_class(
        "dict_values",
        function(d) {
          return {
            __class__: dict_values,
            dict: d,
            make_iter: function() {
              return dict.$iter_values_check(d);
            }
          };
        }
      );
      dict_values.__iter__ = function(self2) {
        return dict_valueiterator.$factory(self2.make_iter);
      };
      dict_values.__len__ = function(self2) {
        return dict.__len__(self2.dict);
      };
      dict_values.__reduce__ = function(self2) {
        var items = $B2.$list(Array.from(self2.make_iter()));
        return $B2.fast_tuple([_b_2.iter, $B2.fast_tuple([items])]);
      };
      dict_values.__repr__ = function(self2) {
        var items = Array.from(self2.make_iter());
        return "dict_values(" + _b_2.repr(items) + ")";
      };
      const dict_reversevalueiterator = make_reverse_iterator(
        "dict_reversevalueiterator",
        dict.$iter_values_reversed
      );
      dict_values.__reversed__ = function(self2) {
        return dict_reversevalueiterator.$factory(self2.dict);
      };
      make_view_comparison_methods(dict_values);
      $B2.set_func_names(dict_values, "builtins");
      var dict_valueiterator = $B2.make_class(
        "dict_valueiterator",
        function(make_iter) {
          return {
            __class__: dict_valueiterator,
            iter: make_iter(),
            make_iter
          };
        }
      );
      dict_valueiterator.__iter__ = function(self2) {
        self2[Symbol.iterator] = function() {
          return self2.iter;
        };
        return self2;
      };
      dict_valueiterator.__next__ = function(self2) {
        var res = self2.iter.next();
        if (res.done) {
          throw _b_2.StopIteration.$factory("");
        }
        return res.value;
      };
      dict_valueiterator.__reduce_ex__ = function(self2) {
        return $B2.fast_tuple([_b_2.iter, $B2.fast_tuple([$B2.$list(Array.from(self2.make_iter()))])]);
      };
      $B2.set_func_names(dict_valueiterator, "builtins");
      dict.values = function(self2) {
        $B2.args("values", 1, { self: null }, ["self"], arguments, {}, null, null);
        return dict_values.$factory(self2);
      };
      dict.$literal = function(items) {
        var res = $B2.empty_dict();
        for (var item2 of items) {
          dict.$setitem(res, item2[0], item2[1], item2[2]);
        }
        return res;
      };
      dict.$factory = function() {
        var res = $B2.empty_dict();
        var args = [res];
        for (var arg of arguments) {
          args.push(arg);
        }
        dict.__init__.apply(null, args);
        return res;
      };
      dict.$from_array = function(arrays) {
        var res = $B2.empty_dict();
        for (var item2 of arrays) {
          dict.$setitem(res, item2[0], item2[1]);
        }
        return res;
      };
      _b_2.dict = dict;
      $B2.set_func_names(dict, "builtins");
      dict.__class_getitem__ = _b_2.classmethod.$factory(dict.__class_getitem__);
      $B2.empty_dict = function() {
        return {
          __class__: dict,
          table: /* @__PURE__ */ Object.create(null),
          _keys: [],
          _values: [],
          _hashes: [],
          $strings: new $B2.str_dict(),
          $version: 0,
          $order: 0,
          $all_str: true
        };
      };
      dict.$from_js = function(jsobj) {
        var res = $B2.empty_dict();
        for (var key2 in jsobj) {
          dict.$setitem(res, key2, jsobj[key2]);
        }
        return res;
      };
      dict.fromkeys = _b_2.classmethod.$factory(dict.fromkeys);
      var mappingproxy = $B2.mappingproxy = $B2.make_class(
        "mappingproxy",
        function(obj) {
          var res;
          if ($B2.$isinstance(obj, dict)) {
            res = $B2.obj_dict(dict.$to_obj(obj));
          } else {
            res = $B2.obj_dict(obj);
          }
          res.__class__ = mappingproxy;
          res.$version = 0;
          return res;
        }
      );
      mappingproxy.$match_mapping_pattern = true;
      mappingproxy.__repr__ = function(self2) {
        var d = $B2.empty_dict();
        for (var key2 in self2.$jsobj) {
          dict.$setitem(d, key2, self2.$jsobj[key2]);
        }
        return dict.__repr__(d);
      };
      mappingproxy.__setitem__ = function() {
        throw _b_2.TypeError.$factory("'mappingproxy' object does not support item assignment");
      };
      for (var attr in dict) {
        if (mappingproxy[attr] !== void 0 || ["__class__", "__mro__", "__new__", "__init__", "__delitem__", "clear", "fromkeys", "pop", "popitem", "setdefault", "update"].indexOf(attr) > -1) {
          continue;
        }
        if (typeof dict[attr] == "function") {
          mappingproxy[attr] = /* @__PURE__ */ (function(key2) {
            return function() {
              return dict[key2].apply(null, arguments);
            };
          })(attr);
        } else {
          mappingproxy[attr] = dict[attr];
        }
      }
      $B2.set_func_names(mappingproxy, "builtins");
      function jsobj2dict(x, exclude) {
        exclude = exclude || function() {
          return false;
        };
        var d = $B2.empty_dict();
        for (var attr2 in x) {
          if (attr2.charAt(0) != "$" && !exclude(attr2)) {
            if (x[attr2] === null) {
              dict.$setitem(d, attr2, _b_2.None);
            } else if (x[attr2] === void 0) {
              continue;
            } else if (x[attr2].$jsobj === x) {
              dict.$setitem(d, attr2, d);
            } else {
              dict.$setitem(d, attr2, $B2.jsobj2pyobj(x[attr2]));
            }
          }
        }
        return d;
      }
      $B2.obj_dict = function(obj, exclude) {
        var klass = obj.__class__ || $B2.get_class(obj);
        if (!(obj instanceof $B2.str_dict) && klass !== void 0 && klass.$native) {
          throw $B2.attr_error("__dict__", obj);
        }
        var res = { __class__: dict, $jsobj: obj, $exclude: exclude || function() {
          return false;
        } };
        return res;
      };
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins, isinstance = $B2.$isinstance;
      function check_not_tuple(self2, attr) {
        if (self2.__class__ === tuple) {
          throw $B2.attr_error(attr, self2);
        }
      }
      var list = {
        __class__: _b_2.type,
        __qualname__: "list",
        __mro__: [_b_2.object],
        $is_class: true,
        $native: true,
        $match_sequence_pattern: true,
        $is_sequence: true,
        __dir__: _b_2.object.__dir__
      };
      list.__add__ = function(self2, other) {
        if ($B2.get_class(self2) !== $B2.get_class(other)) {
          var this_name = $B2.class_name(self2);
          var radd = $B2.$getattr(other, "__radd__", null);
          if (radd === null) {
            throw _b_2.TypeError.$factory("can only concatenate " + this_name + ' (not "' + $B2.class_name(other) + '") to ' + this_name);
          }
          return _b_2.NotImplemented;
        }
        var res = self2.slice();
        for (const item2 of other) {
          res.push(item2);
        }
        if (isinstance(self2, tuple)) {
          return tuple.$factory(res);
        } else {
          return $B2.$list(res);
        }
      };
      list.__bool__ = function(self2) {
        return list.__len__(self2) > 0;
      };
      list.__class_getitem__ = $B2.$class_getitem;
      list.__contains__ = function() {
        var $ = $B2.args("__contains__", 2, { self: null, item: null }, ["self", "item"], arguments, {}, null, null), self2 = $.self, item2 = $.item;
        for (var _item of self2) {
          if ($B2.is_or_equals(_item, item2)) {
            return true;
          }
        }
        return false;
      };
      list.__delitem__ = function(self2, arg) {
        if (isinstance(arg, _b_2.int)) {
          let pos2 = arg;
          if (arg < 0) {
            pos2 = self2.length + pos2;
          }
          if (pos2 >= 0 && pos2 < self2.length) {
            self2.splice(pos2, 1);
            return _b_2.None;
          }
          throw _b_2.IndexError.$factory($B2.class_name(self2) + " index out of range");
        }
        if (isinstance(arg, _b_2.slice)) {
          var step = arg.step;
          if (step === _b_2.None) {
            step = 1;
          }
          var start = arg.start;
          if (start === _b_2.None) {
            start = step > 0 ? 0 : self2.length;
          }
          var stop = arg.stop;
          if (stop === _b_2.None) {
            stop = step > 0 ? self2.length : 0;
          }
          if (start < 0) {
            start = self2.length + start;
          }
          if (stop < 0) {
            stop = self2.length + stop;
          }
          let res = [], pos2 = 0;
          if (step > 0) {
            if (stop > start) {
              for (let i2 = start; i2 < stop; i2 += step) {
                if (self2[i2] !== void 0) {
                  res[pos2++] = i2;
                }
              }
            }
          } else {
            if (stop < start) {
              for (let i2 = start; i2 > stop; i2 += step) {
                if (self2[i2] !== void 0) {
                  res[pos2++] = i2;
                }
              }
              res.reverse();
            }
          }
          let i = res.length;
          while (i--) {
            self2.splice(res[i], 1);
          }
          return _b_2.None;
        }
        if (_b_2.hasattr(arg, "__int__") || _b_2.hasattr(arg, "__index__")) {
          list.__delitem__(self2, _b_2.int.$factory(arg));
          return _b_2.None;
        }
        throw _b_2.TypeError.$factory($B2.class_name(self2) + " indices must be integer, not " + $B2.class_name(arg));
      };
      list.__eq__ = function(self2, other) {
        if (other[$B2.PYOBJ]) {
          other = other[$B2.PYOBJ];
        }
        var klass = isinstance(self2, list) ? list : tuple;
        if (isinstance(other, klass)) {
          if (other.length == self2.length) {
            var i = self2.length;
            while (i--) {
              if (!$B2.is_or_equals(self2[i], other[i])) {
                return false;
              }
            }
            return true;
          }
          return false;
        }
        return _b_2.NotImplemented;
      };
      list.__getitem__ = function(self2, key2) {
        $B2.check_nb_args_no_kw("__getitem__", 2, arguments);
        return list.$getitem(self2, key2);
      };
      list.$getitem = function(self2, key2) {
        var klass = self2.__class__ || $B2.get_class(self2);
        var factory2 = function(list_res) {
          list_res.__class__ = klass;
          return list_res;
        };
        var int_key;
        try {
          int_key = $B2.PyNumber_Index(key2);
        } catch (err) {
        }
        if (int_key !== void 0) {
          let items = self2.valueOf(), pos2 = int_key;
          if (int_key < 0) {
            pos2 = items.length + pos2;
          }
          if (pos2 >= 0 && pos2 < items.length) {
            return items[pos2];
          }
          throw _b_2.IndexError.$factory($B2.class_name(self2) + " index out of range");
        }
        if (key2.__class__ === _b_2.slice || isinstance(key2, _b_2.slice)) {
          return _b_2.list.$getitem_slice(self2, key2);
        }
        throw _b_2.TypeError.$factory($B2.class_name(self2) + " indices must be integer, not " + $B2.class_name(key2));
      };
      list.$getitem_slice = function(self2, key2) {
        var klass = self2.__class__ ?? $B2.get_class(self2);
        if (key2.start === _b_2.None && key2.stop === _b_2.None && key2.step === _b_2.None) {
          let res2 = self2.slice();
          res2.__class__ = klass;
          return res2;
        }
        let s = _b_2.slice.$conv_for_seq(key2, self2.length);
        let res = [], items = self2.valueOf(), pos2 = 0, start = s.start, stop = s.stop, step = s.step;
        res.__class__ = klass;
        if (step > 0) {
          if (stop <= start) {
            return res;
          }
          for (let i = start; i < stop; i += step) {
            res[pos2++] = items[i];
          }
          return res;
        } else {
          if (stop > start) {
            return res;
          }
          for (let i = start; i > stop; i += step) {
            res[pos2++] = items[i];
          }
          return res;
        }
      };
      list.__ge__ = function(self2, other) {
        if (!isinstance(other, list)) {
          return _b_2.NotImplemented;
        }
        var res = list.__le__(other, self2);
        if (res === _b_2.NotImplemented) {
          return res;
        }
        return res;
      };
      list.__gt__ = function(self2, other) {
        if (!isinstance(other, list)) {
          return _b_2.NotImplemented;
        }
        var res = list.__lt__(other, self2);
        if (res === _b_2.NotImplemented) {
          return res;
        }
        return res;
      };
      list.__hash__ = _b_2.None;
      list.__iadd__ = function() {
        var $ = $B2.args("__iadd__", 2, { self: null, x: null }, ["self", "x"], arguments, {}, null, null);
        var x = list.$factory($.x);
        for (var i = 0; i < x.length; i++) {
          $.self.push(x[i]);
        }
        return $.self;
      };
      list.__imul__ = function() {
        var $ = $B2.args("__imul__", 2, { self: null, x: null }, ["self", "x"], arguments, {}, null, null), len = $.self.length, pos2 = len;
        try {
          var x = $B2.PyNumber_Index($.x);
        } catch (err) {
          throw _b_2.TypeError.$factory(`can't multiply sequence by non-int of type '${$B2.class_name($.x)}'`);
        }
        if (x == 0) {
          list.clear($.self);
          return $.self;
        }
        for (var i = 1; i < x; i++) {
          for (var j2 = 0; j2 < len; j2++) {
            $.self[pos2++] = $.self[j2];
          }
        }
        return $.self;
      };
      list.__init__ = function() {
        var $ = $B2.args("__init__", 1, { self: null }, ["self"], arguments, {}, "args", "kw"), self2 = $.self, args = $.args, kw = $.kw;
        if (args.length > 1) {
          throw _b_2.TypeError.$factory("expected at most 1 argument, got " + args.length);
        }
        if (_b_2.dict.__len__(kw) > 0) {
          throw _b_2.TypeError.$factory("list() takes no keyword arguments");
        }
        while (self2.length > 0) {
          self2.pop();
        }
        var arg = args[0];
        if (arg === void 0) {
          return _b_2.None;
        }
        var pos2 = 0;
        for (var item2 of $B2.make_js_iterator(arg)) {
          self2[pos2++] = item2;
        }
        return _b_2.None;
      };
      var list_iterator = $B2.make_iterator_class("list_iterator");
      list_iterator.__reduce__ = list_iterator.__reduce_ex__ = function(self2) {
        return $B2.fast_tuple([_b_2.iter, $B2.fast_tuple([list.$factory(self2)]), 0]);
      };
      list.__iter__ = function(self2) {
        return list_iterator.$factory(self2);
      };
      list.__le__ = function(self2, other) {
        if (!isinstance(other, [list, _b_2.tuple])) {
          return _b_2.NotImplemented;
        }
        var i = 0;
        while (i < self2.length && i < other.length && $B2.is_or_equals(self2[i], other[i])) {
          i++;
        }
        if (i == self2.length) {
          return self2.length <= other.length;
        }
        if (i == other.length) {
          return false;
        }
        return $B2.rich_comp("__le__", self2[i], other[i]);
      };
      list.__len__ = function(self2) {
        return self2.length;
      };
      list.__lt__ = function(self2, other) {
        if (!isinstance(other, [list, _b_2.tuple])) {
          return _b_2.NotImplemented;
        }
        var i = 0;
        while (i < self2.length && i < other.length && $B2.is_or_equals(self2[i], other[i])) {
          i++;
        }
        if (i == self2.length) {
          return self2.length < other.length;
        }
        if (i == other.length) {
          return false;
        }
        return $B2.rich_comp("__lt__", self2[i], other[i]);
      };
      list.__mul__ = function(self2, other) {
        if ($B2.$isinstance(other, [_b_2.float, _b_2.complex])) {
          throw _b_2.TypeError.$factory("'" + $B2.class_name(other) + "' object cannot be interpreted as an integer");
        }
        if (self2.length == 0) {
          return list.__new__(list);
        }
        try {
          other = $B2.PyNumber_Index(other);
        } catch (err) {
          return _b_2.NotImplemented;
        }
        if (typeof other == "number") {
          if (other < 0) {
            return list.__new__(list);
          }
          if (self2.length > $B2.max_array_size / other) {
            throw _b_2.OverflowError.$factory(`cannot fit '${$B2.class_name(other)}' into an index-sized integer`);
          }
          var res = [], $temp = self2.slice(), len = $temp.length;
          for (var i = 0; i < other; i++) {
            for (var j2 = 0; j2 < len; j2++) {
              res.push($temp[j2]);
            }
          }
          res.__class__ = self2.__class__;
          return res;
        } else if (isinstance(other, $B2.long_int)) {
          throw _b_2.OverflowError.$factory(`cannot fit '${$B2.class_name(other)}' into an index-sized integer`);
        } else {
          return _b_2.NotImplemented;
        }
      };
      list.__new__ = function(cls) {
        if (cls === void 0) {
          throw _b_2.TypeError.$factory("list.__new__(): not enough arguments");
        }
        var res = [];
        res.__class__ = cls;
        res.__dict__ = $B2.empty_dict();
        return res;
      };
      list.__repr__ = function(self2) {
        $B2.builtins_repr_check(list, arguments);
        return list_repr(self2);
      };
      function list_repr(self2) {
        if ($B2.repr.enter(self2)) {
          return "[...]";
        }
        var _r = [], res;
        for (var i = 0; i < self2.length; i++) {
          _r.push(_b_2.repr(self2[i]));
        }
        if (isinstance(self2, tuple)) {
          if (self2.length == 1) {
            res = "(" + _r[0] + ",)";
          } else {
            res = "(" + _r.join(", ") + ")";
          }
        } else {
          res = "[" + _r.join(", ") + "]";
        }
        $B2.repr.leave(self2);
        return res;
      }
      var list_reverseiterator = $B2.make_iterator_class("list_reverseiterator", true);
      list_reverseiterator.__reduce__ = list_reverseiterator.__reduce_ex__ = function(self2) {
        return $B2.fast_tuple([_b_2.iter, $B2.fast_tuple([list.$factory(self2)]), 0]);
      };
      list.__reversed__ = function(self2) {
        return list_reverseiterator.$factory(self2);
      };
      list.__rmul__ = function(self2, other) {
        return list.__mul__(self2, other);
      };
      list.__setattr__ = function(self2, attr, value2) {
        if (self2.__class__ === list || self2.__class__ === tuple) {
          var cl_name = $B2.class_name(self2);
          if (list.hasOwnProperty(attr)) {
            throw _b_2.AttributeError.$factory("'" + cl_name + "' object attribute '" + attr + "' is read-only");
          } else {
            throw _b_2.AttributeError.$factory(
              "'" + cl_name + " object has no attribute '" + attr + "'"
            );
          }
        }
        _b_2.dict.$setitem(self2.__dict__, attr, value2);
        return _b_2.None;
      };
      list.__setitem__ = function() {
        var $ = $B2.args("__setitem__", 3, { self: null, key: null, value: null }, ["self", "key", "value"], arguments, {}, null, null), self2 = $.self, arg = $.key, value2 = $.value;
        list.$setitem(self2, arg, value2);
      };
      function set_list_slice(obj, start, stop, value2) {
        var res = _b_2.list.$factory(value2);
        obj.splice.apply(obj, [start, stop - start].concat(res));
      }
      function set_list_slice_step(obj, start, stop, step, value2) {
        if (step == 1) {
          return set_list_slice(obj, start, stop, value2);
        }
        if (step == 0) {
          throw _b_2.ValueError.$factory("slice step cannot be zero");
        }
        var repl = _b_2.list.$factory(value2), j2 = 0, test, nb = 0;
        if (step > 0) {
          test = function(i2) {
            return i2 < stop;
          };
        } else {
          test = function(i2) {
            return i2 > stop;
          };
        }
        for (var i = start; test(i); i += step) {
          nb++;
        }
        if (nb != repl.length) {
          throw _b_2.ValueError.$factory(
            "attempt to assign sequence of size " + repl.length + " to extended slice of size " + nb
          );
        }
        for (var i = start; test(i); i += step) {
          obj[i] = repl[j2];
          j2++;
        }
      }
      list.$setitem = function(self2, arg, value2) {
        if (typeof arg == "number" || isinstance(arg, _b_2.int)) {
          var pos2 = $B2.PyNumber_Index(arg);
          if (arg < 0) {
            pos2 = self2.length + pos2;
          }
          if (pos2 >= 0 && pos2 < self2.length) {
            self2[pos2] = value2;
          } else {
            throw _b_2.IndexError.$factory("list assignment index out of range");
          }
          return _b_2.None;
        }
        if (isinstance(arg, _b_2.slice)) {
          var s = _b_2.slice.$conv_for_seq(arg, self2.length);
          if (arg.step === null) {
            set_list_slice(self2, s.start, s.stop, value2);
          } else {
            set_list_slice_step(self2, s.start, s.stop, s.step, value2);
          }
          return _b_2.None;
        }
        if (_b_2.hasattr(arg, "__int__") || _b_2.hasattr(arg, "__index__")) {
          list.__setitem__(self2, _b_2.int.$factory(arg), value2);
          return _b_2.None;
        }
        throw _b_2.TypeError.$factory("list indices must be integer, not " + $B2.class_name(arg));
      };
      list.append = function(self2, x) {
        $B2.check_nb_args_no_kw("append", 2, arguments);
        if (self2[$B2.PYOBJ]) {
          self2[$B2.PYOBJ].push(x);
          self2.push($B2.pyobj2jsobj(x));
        } else if (self2.$is_js_array) {
          self2.push($B2.pyobj2jsobj(x));
        } else {
          self2[self2.length] = x;
        }
        return _b_2.None;
      };
      list.clear = function() {
        var $ = $B2.args("clear", 1, { self: null }, ["self"], arguments, {}, null, null);
        while ($.self.length) {
          $.self.pop();
        }
        return _b_2.None;
      };
      list.copy = function() {
        var $ = $B2.args("copy", 1, { self: null }, ["self"], arguments, {}, null, null);
        var res = $.self.slice();
        res.__class__ = $.self.__class__;
        return res;
      };
      list.count = function() {
        var $ = $B2.args("count", 2, { self: null, x: null }, ["self", "x"], arguments, {}, null, null);
        var res = 0;
        for (var _item of $.self) {
          if ($B2.is_or_equals(_item, $.x)) {
            res++;
          }
        }
        return res;
      };
      list.extend = function() {
        var $ = $B2.args("extend", 2, { self: null, t: null }, ["self", "t"], arguments, {}, null, null);
        if (self.$is_js_array) {
          for (var item2 of $B2.make_js_iterator($.t)) {
            $.self[$.self.length] = $B2.pyobj2jsobj(item2);
          }
        } else {
          for (var item2 of $B2.make_js_iterator($.t)) {
            $.self[$.self.length] = item2;
          }
        }
        return _b_2.None;
      };
      list.index = function() {
        var missing = {}, $ = $B2.args("index", 4, { self: null, x: null, start: null, stop: null }, ["self", "x", "start", "stop"], arguments, { start: 0, stop: missing }, null, null), self2 = $.self, start = $.start, stop = $.stop;
        if (start.__class__ === $B2.long_int) {
          start = parseInt(start.value) * (start.pos ? 1 : -1);
        }
        if (start < 0) {
          start = Math.max(0, start + self2.length);
        }
        if (stop === missing) {
          stop = self2.length;
        } else {
          if (stop.__class__ === $B2.long_int) {
            stop = parseInt(stop.value) * (stop.pos ? 1 : -1);
          }
          if (stop < 0) {
            stop = Math.min(self2.length, stop + self2.length);
          }
          stop = Math.min(stop, self2.length);
        }
        for (var i = start; i < stop; i++) {
          if ($B2.rich_comp("__eq__", $.x, self2[i])) {
            return i;
          }
        }
        throw _b_2.ValueError.$factory(_b_2.repr($.x) + " is not in " + $B2.class_name(self2));
      };
      list.insert = function() {
        var $ = $B2.args("insert", 3, { self: null, i: null, item: null }, ["self", "i", "item"], arguments, {}, null, null);
        if (self.$is_js_array) {
          $.self.splice($.i, 0, $B2.pyobj2jsobj($.item));
        } else {
          $.self.splice($.i, 0, $.item);
        }
        return _b_2.None;
      };
      list.pop = function() {
        var missing = {};
        var $ = $B2.args("pop", 2, { self: null, pos: null }, ["self", "pos"], arguments, { pos: missing }, null, null), self2 = $.self, pos2 = $.pos;
        check_not_tuple(self2, "pop");
        if (pos2 === missing) {
          pos2 = self2.length - 1;
        }
        pos2 = $B2.PyNumber_Index(pos2);
        if (pos2 < 0) {
          pos2 += self2.length;
        }
        var res = self2[pos2];
        if (res === void 0) {
          throw _b_2.IndexError.$factory("pop index out of range");
        }
        self2.splice(pos2, 1);
        return res;
      };
      list.remove = function() {
        var $ = $B2.args("remove", 2, { self: null, x: null }, ["self", "x"], arguments, {}, null, null);
        for (var i = 0, len = $.self.length; i < len; i++) {
          if ($B2.rich_comp("__eq__", $.self[i], $.x)) {
            $.self.splice(i, 1);
            return _b_2.None;
          }
        }
        throw _b_2.ValueError.$factory(_b_2.str.$factory($.x) + " is not in list");
      };
      list.reverse = function() {
        var $ = $B2.args("reverse", 1, { self: null }, ["self"], arguments, {}, null, null), _len = $.self.length - 1, i = parseInt($.self.length / 2);
        while (i--) {
          var buf = $.self[i];
          $.self[i] = $.self[_len - i];
          $.self[_len - i] = buf;
        }
        return _b_2.None;
      };
      function $elts_class(self2) {
        if (self2.length == 0) {
          return null;
        }
        var cl = $B2.get_class(self2[0]), i = self2.length;
        while (i--) {
          if ($B2.get_class(self2[i]) !== cl) {
            return false;
          }
        }
        return cl;
      }
      list.sort = function(self2) {
        var $ = $B2.args("sort", 1, { self: null }, ["self"], arguments, {}, null, "kw");
        check_not_tuple(self2, "sort");
        var func = _b_2.None, reverse = false;
        for (var item2 of _b_2.dict.$iter_items($.kw)) {
          if (item2.key == "key") {
            func = item2.value;
          } else if (item2.key == "reverse") {
            reverse = item2.value;
          } else {
            throw _b_2.TypeError.$factory("'" + item2.key + "' is an invalid keyword argument for this function");
          }
        }
        if (self2.length == 0) {
          return _b_2.None;
        }
        if (func !== _b_2.None) {
          func = $B2.$call(func);
        }
        self2.$cl = $elts_class(self2);
        var cmp = null;
        function basic_cmp(a, b) {
          return $B2.rich_comp("__lt__", a, b) ? -1 : $B2.rich_comp("__eq__", a, b) ? 0 : 1;
        }
        function reverse_cmp(a, b) {
          return basic_cmp(b, a);
        }
        if (func === _b_2.None && self2.$cl === _b_2.str) {
          if (reverse) {
            cmp = function(b, a) {
              return $B2.$AlphabeticalCompare(a, b);
            };
          } else {
            cmp = function(a, b) {
              return $B2.$AlphabeticalCompare(a, b);
            };
          }
        } else if (func === _b_2.None && self2.$cl === _b_2.int) {
          if (reverse) {
            cmp = function(b, a) {
              return a - b;
            };
          } else {
            cmp = function(a, b) {
              return a - b;
            };
          }
        } else {
          cmp = reverse ? function(t1, t2) {
            return basic_cmp(t2[0], t1[0]);
          } : function(t1, t2) {
            return basic_cmp(t1[0], t2[0]);
          };
          if (func === _b_2.None) {
            cmp = reverse ? reverse_cmp : basic_cmp;
            self2.sort(cmp);
          } else {
            var temp = [], saved = self2.slice();
            for (let i = 0, len = self2.length; i < len; i++) {
              temp.push([func(self2[i]), i]);
            }
            temp.sort(cmp);
            for (let i = 0, len = temp.length; i < len; i++) {
              self2[i] = saved[temp[i][1]];
            }
          }
          return self2.$is_js_array ? self2 : _b_2.None;
        }
        $B2.$TimSort(self2, cmp);
        return self2.$is_js_array ? self2 : _b_2.None;
      };
      $B2.$list = function(t) {
        t.__class__ = _b_2.list;
        return t;
      };
      var factory = function() {
        var klass = this;
        if (arguments.length == 0) {
          return $B2.$list([]);
        }
        var $ = $B2.args(klass.__name__, 1, { obj: null }, ["obj"], arguments, {}, null, null), obj = $.obj;
        if (Array.isArray(obj) && obj.__class__) {
          obj = obj.slice();
          obj.__class__ = klass;
          return obj;
        }
        let res = Array.from($B2.make_js_iterator(obj));
        res.__class__ = klass;
        return res;
      };
      list.$factory = function() {
        return factory.apply(list, arguments);
      };
      list.$unpack = function(obj) {
        try {
          return _b_2.list.$factory(obj);
        } catch (err) {
          try {
            var it = $B2.$iter(obj);
            $B2.$call($B2.$getattr(it, "__next__"));
          } catch (err1) {
            if ($B2.is_exc(err1, [_b_2.TypeError])) {
              throw _b_2.TypeError.$factory(
                `Value after * must be an iterable, not ${$B2.class_name(obj)}`
              );
            }
            throw err1;
          }
          throw err;
        }
      };
      $B2.set_func_names(list, "builtins");
      var tuple = {
        __class__: _b_2.type,
        __mro__: [_b_2.object],
        __qualname__: "tuple",
        $is_class: true,
        $native: true,
        $match_sequence_pattern: true,
        $is_sequence: true
      };
      var tuple_iterator = $B2.make_iterator_class("tuple_iterator");
      tuple.__iter__ = function(self2) {
        return tuple_iterator.$factory(self2);
      };
      tuple.$factory = function() {
        var obj = factory.apply(tuple, arguments);
        obj.__class__ = tuple;
        return obj;
      };
      $B2.fast_tuple = function(array) {
        array.__class__ = tuple;
        return array;
      };
      for (let attr in list) {
        switch (attr) {
          case "__delitem__":
          case "__iadd__":
          case "__imul__":
          case "__setitem__":
          case "append":
          case "extend":
          case "insert":
          case "pop":
          case "remove":
          case "reverse":
          case "sort":
            break;
          default:
            if (tuple[attr] === void 0) {
              if (typeof list[attr] == "function") {
                tuple[attr] = /* @__PURE__ */ (function(x) {
                  return function() {
                    return list[x].apply(null, arguments);
                  };
                })(attr);
              }
            }
        }
      }
      tuple.__class_getitem__ = function(cls, item2) {
        if (!Array.isArray(item2)) {
          item2 = [item2];
        }
        return $B2.GenericAlias.$factory(cls, item2);
      };
      tuple.__eq__ = function(self2, other) {
        if (other === void 0) {
          return self2 === tuple;
        }
        return list.__eq__(self2, other);
      };
      function c_mul(a, b) {
        var s = (parseInt(a) * b & 4294967295).toString(16);
        return parseInt(s.substr(0, s.length - 1), 16);
      }
      tuple.$getnewargs = function(self2) {
        return $B2.fast_tuple([$B2.fast_tuple(self2.slice())]);
      };
      tuple.__getnewargs__ = function() {
        return tuple.$getnewargs($B2.single_arg("__getnewargs__", "self", arguments));
      };
      tuple.__hash__ = function(self2) {
        var x = 54880137;
        for (var i = 0, len = self2.length; i < len; i++) {
          var y = _b_2.hash(self2[i]);
          x = c_mul(1000003, x) ^ y & 4294967295;
        }
        return x;
      };
      tuple.__init__ = function() {
        return _b_2.None;
      };
      tuple.__new__ = function() {
        if (arguments.length === void 0) {
          throw _b_2.TypeError.$factory("tuple.__new__(): not enough arguments");
        }
        var $ = $B2.args("__new__", 1, { cls: null }, ["cls"], arguments, {}, "args", "kw"), cls = $.cls, args = $.args, kw = $.kw;
        var self2 = [];
        self2.__class__ = cls;
        self2.__dict__ = $B2.empty_dict();
        if (args.length > 0) {
          if (args.length == 1) {
            for (var item2 of $B2.make_js_iterator(args[0])) {
              self2.push(item2);
            }
          } else {
            throw _b_2.TypeError.$factory(`tuple expected at most 1 argument, got ${args.length}`);
          }
        }
        if (cls === tuple && _b_2.dict.__len__(kw) > 0) {
          throw _b_2.TypeError.$factory("tuple() takes no keyword arguments");
        }
        return self2;
      };
      tuple.__repr__ = function(self2) {
        $B2.builtins_repr_check(tuple, arguments);
        return list_repr(self2);
      };
      $B2.set_func_names(tuple, "builtins");
      _b_2.list = list;
      _b_2.tuple = tuple;
      _b_2.object.__bases__ = tuple.$factory();
      _b_2.type.__bases__ = $B2.fast_tuple([_b_2.object]);
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      function to_simple(value2) {
        switch (typeof value2) {
          case "string":
          case "number":
            return value2;
          case "boolean":
            return value2 ? "true" : "false";
          case "object":
            if (value2 === _b_2.None) {
              return "null";
            } else if (value2 instanceof Number) {
              return value2.valueOf();
            } else if (value2 instanceof String) {
              return value2.valueOf();
            }
            break;
          default:
            throw _b_2.TypeError.$factory("keys must be str, int, float, bool or None, not " + $B2.class_name(value2));
        }
      }
      $B2.pyobj2structuredclone = function(obj, strict) {
        strict = strict === void 0 ? true : strict;
        if (typeof obj == "boolean" || typeof obj == "number" || typeof obj == "string" || obj instanceof String) {
          return obj;
        } else if (obj.__class__ === _b_2.float) {
          return obj.value;
        } else if (obj === _b_2.None) {
          return null;
        } else if (Array.isArray(obj) || obj.__class__ === _b_2.list || obj.__class__ === _b_2.tuple || obj.__class__ === js_array) {
          let res2 = new Array(obj.length);
          for (var i = 0, len = obj.length; i < len; ++i) {
            res2[i] = $B2.pyobj2structuredclone(obj[i]);
          }
          return res2;
        } else if ($B2.$isinstance(obj, _b_2.dict)) {
          if (strict) {
            for (var key2 of $B2.make_js_iterator(_b_2.dict.keys(obj))) {
              if (typeof key2 !== "string") {
                throw _b_2.TypeError.$factory("a dictionary with non-string keys does not support structured clone");
              }
            }
          }
          let res2 = {};
          for (var entry of $B2.make_js_iterator(_b_2.dict.items(obj))) {
            res2[to_simple(entry[0])] = $B2.pyobj2structuredclone(entry[1]);
          }
          return res2;
        } else if (obj.__class__ === $B2.long_int) {
          return obj.value;
        } else if (Object.getPrototypeOf(obj).constructor === Object) {
          var res = {};
          for (var key2 in obj) {
            res[key2] = $B2.pyobj2structuredclone(obj[key2]);
          }
          return res;
        } else {
          return obj;
        }
        throw _b_2.TypeError.$factory(`cannot send '${$B2.class_name(obj)}' object`);
      };
      $B2.structuredclone2pyobj = function(obj) {
        if (obj === null) {
          return _b_2.None;
        } else if (obj === void 0) {
          return $B2.Undefined;
        } else if (typeof obj == "boolean") {
          return obj;
        } else if (typeof obj == "string" || obj instanceof String) {
          return $B2.String(obj);
        } else if (typeof obj == "number" || obj instanceof Number) {
          obj += 0;
          return Number.isInteger(obj) ? obj : { __class__: _b_2.float, value: obj };
        } else if (Array.isArray(obj) || obj.__class__ === _b_2.list || obj.__class__ === _b_2.tuple) {
          let res = _b_2.list.$factory();
          for (var i = 0, len = obj.length; i < len; i++) {
            res.push($B2.structuredclone2pyobj(obj[i]));
          }
          return res;
        } else if (typeof obj == "object") {
          if (Object.getPrototypeOf(obj) === Object.prototype) {
            if (!$B2.$isinstance(obj, $B2.JSObj)) {
              return obj;
            }
            let res = $B2.empty_dict();
            for (var key2 in obj) {
              _b_2.dict.$setitem(res, key2, $B2.structuredclone2pyobj(obj[key2]));
            }
            return res;
          } else {
            return obj;
          }
        } else {
          throw _b_2.TypeError.$factory(_b_2.str.$factory(obj) + " does not support the structured clone algorithm");
        }
      };
      const JSOBJ = $B2.JSOBJ = Symbol("JSOBJ");
      const PYOBJ = $B2.PYOBJ = Symbol("PYOBJ");
      const PYOBJFCT = Symbol("PYOBJFCT");
      const PYOBJFCTS = Symbol("PYOBJFCTS");
      var jsobj2pyobj = $B2.jsobj2pyobj = function(jsobj, _this) {
        if (jsobj === null) {
          return null;
        }
        switch (typeof jsobj) {
          case "boolean":
            return jsobj;
          case "undefined":
            return $B2.Undefined;
          case "number":
            if (jsobj % 1 === 0) {
              return Number.isSafeInteger(jsobj) ? jsobj : $B2.fast_long_int(jsobj);
            }
            return _b_2.float.$factory(jsobj);
          case "bigint":
            return jsobj;
          case "string":
            return $B2.String(jsobj);
        }
        if (Array.isArray(jsobj)) {
          try {
            Object.defineProperty(jsobj, "$is_js_array", { value: true });
          } catch (err) {
          }
          return jsobj;
        }
        let pyobj = jsobj[PYOBJ];
        if (pyobj !== void 0) {
          return pyobj;
        }
        if (jsobj instanceof Promise || typeof jsobj.then == "function") {
          return jsobj;
        }
        if (typeof jsobj === "function") {
          _this = _this === void 0 ? null : _this;
          if (_this === null) {
            const pyobj2 = jsobj[PYOBJFCT];
            if (pyobj2 !== void 0) {
              return pyobj2;
            }
          } else {
            const pyobjfcts = _this[PYOBJFCTS];
            if (pyobjfcts !== void 0) {
              const pyobj2 = pyobjfcts.get(jsobj);
              if (pyobj2 !== void 0) {
                return pyobj2;
              }
            } else {
              try {
                _this[PYOBJFCTS] = /* @__PURE__ */ new Map();
              } catch (err) {
              }
            }
          }
          var res = function() {
            var args = new Array(arguments.length);
            for (var i = 0, len = arguments.length; i < len; ++i) {
              var arg = arguments[i];
              if (arg !== null && arg.constructor === Object && arg.$kw) {
                throw _b_2.TypeError.$factory(
                  "keyword arguments are not supported for Javascript functions"
                );
              }
              args[i] = pyobj2jsobj(arg);
            }
            try {
              return jsobj2pyobj(jsobj.apply(_this, args));
            } catch (err) {
              throw $B2.exception(err);
            }
          };
          if (_this === null) {
            jsobj[PYOBJFCT] = res;
          } else if (_this[PYOBJFCTS] !== void 0) {
            _this[PYOBJFCTS].set(jsobj, res);
          }
          res[JSOBJ] = jsobj;
          Object.defineProperty(res, "$js_func", { value: jsobj });
          Object.defineProperty(res, "$infos", { value: { __name__: jsobj.name, __qualname__: jsobj.name }, writable: true });
          let value2 = [];
          value2[$B2.func_attrs.name] = jsobj.name;
          value2[$B2.func_attrs.qualname] = jsobj.name;
          Object.defineProperty(
            res,
            "$function_infos",
            { value: value2, writable: true }
          );
          return res;
        }
        if (jsobj.$kw) {
          return jsobj;
        }
        if ($B2.$isNode(jsobj)) {
          const res2 = $B2.DOMNode.$factory(jsobj);
          jsobj[PYOBJ] = res2;
          res2[JSOBJ] = jsobj;
          return res2;
        }
        return jsobj;
      };
      var pyobj2jsobj = $B2.pyobj2jsobj = function(pyobj) {
        switch (pyobj) {
          case true:
          case false:
            return pyobj;
          case $B2.Undefined:
            return void 0;
          case null:
            return null;
        }
        let _jsobj = pyobj[JSOBJ];
        if (_jsobj !== void 0) {
          return _jsobj;
        }
        var klass = $B2.get_class(pyobj);
        function has_type(cls, base) {
          return cls === base || cls.__mro__.includes(base);
        }
        if (has_type(klass, $B2.DOMNode)) {
          return pyobj;
        }
        if (has_type(klass, _b_2.list) || has_type(klass, _b_2.tuple)) {
          var jsobj = pyobj.map(pyobj2jsobj);
          jsobj[PYOBJ] = pyobj;
          return jsobj;
        }
        if (has_type(klass, _b_2.dict)) {
          let jsobj2 = {};
          for (var entry of _b_2.dict.$iter_items(pyobj)) {
            var key2 = entry.key;
            if (typeof key2 !== "string") {
              key2 = _b_2.str.$factory(key2);
            }
            if (typeof entry.value === "function") {
              entry.value.bind(jsobj2);
            }
            jsobj2[key2] = pyobj2jsobj(entry.value);
          }
          pyobj[JSOBJ] = jsobj2;
          return jsobj2;
        }
        if (has_type(klass, _b_2.str)) {
          return pyobj.valueOf();
        }
        if (klass === $B2.long_int) {
          return pyobj.value;
        }
        if (has_type(klass, _b_2.float)) {
          return pyobj.value;
        }
        if (klass === $B2.function || klass === $B2.method) {
          if (typeof pyobj == "function" && pyobj.prototype && pyobj.prototype.constructor === pyobj && !pyobj.$function_infos) {
            return pyobj;
          }
          if (pyobj.$is_async) {
            let jsobj3 = function() {
              var res = pyobj.apply(null, arguments);
              return $B2.coroutine.send(res);
            };
            pyobj[JSOBJ] = jsobj3;
            jsobj3[PYOBJ] = pyobj;
            return jsobj3;
          }
          let jsobj2 = function() {
            try {
              var args = new Array(arguments.length);
              for (var i = 0; i < arguments.length; ++i) {
                args[i] = jsobj2pyobj(arguments[i]);
              }
              let res;
              if (pyobj.prototype && pyobj.prototype.constructor === pyobj && !pyobj.$function_infos) {
                res = new pyobj(...args);
              } else {
                res = pyobj.apply(this, args);
              }
              return pyobj2jsobj(res);
            } catch (err) {
              $B2.handle_error(err);
            }
          };
          pyobj[JSOBJ] = jsobj2;
          jsobj2[PYOBJ] = pyobj;
          return jsobj2;
        }
        return pyobj;
      };
      function pyargs2jsargs(pyargs) {
        var args = new Array(pyargs.length);
        for (var i = 0, len = pyargs.length; i < len; i++) {
          var arg = pyargs[i];
          if (arg !== void 0 && arg !== null && arg.$kw !== void 0) {
            throw _b_2.TypeError.$factory(
              "A Javascript function can't take keyword arguments"
            );
          }
          args[i] = $B2.pyobj2jsobj(arg);
        }
        return args;
      }
      $B2.JSObj = $B2.make_class("JSObject", jsobj2pyobj);
      function check_big_int(x, y) {
        if (typeof x != "bigint" || typeof y != "bigint") {
          throw _b_2.TypeError.$factory("unsupported operand type(s) for - : '" + $B2.class_name(x) + "' and '" + $B2.class_name(y) + "'");
        }
      }
      var js_ops = { __add__: function(_self, other) {
        check_big_int(_self, other);
        return _self + other;
      }, __mod__: function(_self, other) {
        check_big_int(_self, other);
        return _self % other;
      }, __mul__: function(_self, other) {
        check_big_int(_self, other);
        return _self * other;
      }, __pow__: function(_self, other) {
        check_big_int(_self, other);
        return _self ** other;
      }, __sub__: function(_self, other) {
        check_big_int(_self, other);
        return _self - other;
      } };
      for (var js_op in js_ops) {
        $B2.JSObj[js_op] = js_ops[js_op];
      }
      $B2.JSObj.__bool__ = function(_self) {
        if (typeof _self == "object") {
          for (var key2 in _self) {
            return true;
          }
          return false;
        }
        return !!_self;
      };
      $B2.JSObj.__contains__ = function(_self, key2) {
        return key2 in _self;
      };
      $B2.JSObj.__delitem__ = function(_self, key2) {
        delete _self[key2];
        return _b_2.None;
      };
      $B2.JSObj.__dir__ = function(_self) {
        var attrs = Object.keys(_self);
        attrs = attrs.sort();
        return attrs;
      };
      $B2.JSObj.__eq__ = function(_self, other) {
        switch (typeof _self) {
          case "string":
            return _self == other;
          case "object":
            if (_self.__eq__ !== void 0) {
              return _self.__eq__(other);
            }
            if (Object.keys(_self).length !== Object.keys(other).length) {
              return false;
            }
            if (_self === other) {
              return true;
            }
            for (var key2 in _self) {
              if (!$B2.rich_comp("__eq__", _self[key2], other[key2])) {
                return false;
              }
            }
            return true;
          case "function":
            if (_self.$js_func && other.$js_func) {
              return _self.$js_func === other.$js_func;
            }
            return _self === other;
          default:
            return _self === other;
        }
      };
      var iterator = $B2.make_class(
        "js_iterator",
        function(obj) {
          return {
            __class__: iterator,
            keys: Object.keys(obj),
            values: Object.values(obj),
            length: Object.keys(obj).length,
            counter: -1
          };
        }
      );
      iterator.__next__ = function(_self) {
        _self.counter++;
        if (_self.counter == _self.length) {
          throw _b_2.StopIteration.$factory("");
        }
        return _self.keys[_self.counter];
      };
      $B2.set_func_names(iterator, "builtins");
      $B2.JSObj.__hash__ = function(_self) {
        return _b_2.object.__hash__(_self);
      };
      $B2.JSObj.__iter__ = function(_self) {
        return iterator.$factory(_self);
      };
      $B2.JSObj.__ne__ = function(_self, other) {
        return !$B2.JSObj.__eq__(_self, other);
      };
      function jsclass2pyclass(js_class) {
        var proto = js_class.prototype, klass = $B2.make_class(js_class.name);
        klass.__init__ = function(self2) {
          var args = pyargs2jsargs(Array.from(arguments).slice(1));
          var js_obj = new proto.constructor(...args);
          for (var attr in js_obj) {
            _b_2.dict.$setitem(self2.__dict__, attr, $B2.jsobj2pyobj(js_obj[attr]));
          }
          return _b_2.None;
        };
        klass.new = function() {
          var args = pyargs2jsargs(arguments);
          return jsobj2pyobj(new proto.constructor(...args));
        };
        var key2, value2;
        for ([key2, value2] of Object.entries(Object.getOwnPropertyDescriptors(proto))) {
          if (key2 == "constructor") {
            continue;
          }
          if (value2.get) {
            var getter = /* @__PURE__ */ (function(v) {
              return function(self2) {
                return v.get.call(self2.__dict__.$jsobj);
              };
            })(value2);
            getter.$infos = { __name__: key2 };
            var setter;
            if (value2.set) {
              setter = /* @__PURE__ */ (function(v) {
                return function(self2, x) {
                  v.set.call(self2.__dict__.$jsobj, x);
                };
              })(value2);
              klass[key2] = _b_2.property.$factory(getter, setter);
            } else {
              klass[key2] = _b_2.property.$factory(getter);
            }
          } else {
            klass[key2] = /* @__PURE__ */ (function(m) {
              return function(self2) {
                var args = Array.from(arguments).slice(1);
                return proto[m].apply(self2.__dict__.$jsobj, args);
              };
            })(key2);
          }
        }
        for (var name2 of Object.getOwnPropertyNames(js_class)) {
          klass[name2] = /* @__PURE__ */ (function(k) {
            return function(self2) {
              var args = Array.from(arguments).map(pyobj2jsobj);
              return js_class[k].apply(self2, args);
            };
          })(name2);
        }
        var js_parent = Object.getPrototypeOf(proto).constructor;
        if (js_parent.toString().startsWith("class ")) {
          var py_parent = jsclass2pyclass(js_parent);
          klass.__mro__ = [py_parent].concat(klass.__mro__);
        }
        var frame = $B2.frame_obj.frame;
        if (frame) {
          $B2.set_func_names(klass, frame[2]);
        }
        return klass;
      }
      $B2.JSObj.__getattribute__ = function(_self, attr) {
        var test = false;
        if (test) {
          console.log("__ga__", _self, attr);
        }
        if (attr == "new" && typeof _self == "function") {
          var new_func;
          if (_self.$js_func) {
            new_func = function() {
              var args = pyargs2jsargs(arguments);
              return new _self.$js_func(...args);
            };
          } else {
            new_func = function() {
              var args = pyargs2jsargs(arguments);
              return new _self(...args);
            };
          }
          Object.defineProperty(
            new_func,
            "$infos",
            { value: { __name__: attr, __qualname__: attr }, writable: true }
          );
          let value2 = [];
          value2[$B2.func_attrs.__name__] = attr;
          value2[$B2.func_attrs.__qualname__] = attr;
          Object.defineProperty(
            new_func,
            "$function_infos",
            { value: value2, writable: true }
          );
          return new_func;
        }
        var js_attr = _self[attr];
        if (js_attr == void 0 && typeof _self == "function") {
          js_attr = _self.$js_func[attr];
        }
        if (test) {
          console.log("js_attr", js_attr, typeof js_attr, "\n is JS class ?", js_attr === void 0 ? false : js_attr.toString().startsWith("class "));
        }
        if (js_attr === void 0) {
          if (typeof _self == "object" && attr in _self) {
            return $B2.Undefined;
          }
          if (typeof _self.getNamedItem == "function") {
            var res = _self.getNamedItem(attr);
            if (res !== void 0) {
              return jsobj2pyobj(res);
            }
          }
          var klass = $B2.get_class(_self), class_attr = $B2.$getattr(klass, attr, null);
          if (class_attr !== null) {
            if (typeof class_attr == "function") {
              return function() {
                var args = new Array(arguments.length + 1);
                args[0] = _self;
                for (var i = 0, len = arguments.length; i < len; i++) {
                  args[i + 1] = arguments[i];
                }
                return jsobj2pyobj(class_attr.apply(null, args));
              };
            } else {
              return class_attr;
            }
          }
          throw $B2.attr_error(attr, _self);
        }
        if (js_attr !== null && js_attr.toString && typeof js_attr == "function" && js_attr.toString().startsWith("class ")) {
          return jsclass2pyclass(js_attr);
        } else if (typeof js_attr === "function") {
          if (!js_attr.$infos && !js_attr.$function_infos) {
            js_attr.$js_func = js_attr;
          }
          return jsobj2pyobj(js_attr, _self.$js_func || _self);
        } else {
          if (test) {
            console.log("jsobj2pyobj on", js_attr);
          }
          var res = jsobj2pyobj(js_attr);
          if (test) {
            console.log("    res", res);
          }
          return res;
        }
      };
      $B2.JSObj.__setattr__ = function(_self, attr, value2) {
        _self[attr] = $B2.pyobj2jsobj(value2);
        return _b_2.None;
      };
      $B2.JSObj.__getitem__ = function(_self, key2) {
        if (typeof key2 == "string") {
          try {
            return $B2.JSObj.__getattribute__(_self, key2);
          } catch (err) {
            if ($B2.is_exc(err, [_b_2.AttributeError])) {
              throw _b_2.KeyError.$factory(err.name);
            }
            throw err;
          }
        } else if (typeof key2 == "number") {
          if (_self[key2] !== void 0) {
            return jsobj2pyobj(_self[key2]);
          }
          if (typeof _self.length == "number") {
            if ((typeof key2 == "number" || typeof key2 == "boolean") && typeof _self.item == "function") {
              var rank = _b_2.int.$factory(key2);
              if (rank < 0) {
                rank += _self.length;
              }
              let res = _self.item(rank);
              if (res === null) {
                throw _b_2.IndexError.$factory(rank);
              }
              return jsobj2pyobj(res);
            }
          }
        } else if (key2.__class__ === _b_2.slice && typeof _self.item == "function") {
          var _slice = _b_2.slice.$conv_for_seq(key2, _self.length);
          let res = new Array(Math.floor((_slice.stop - _slice.start) / _slice.step));
          let offset = 0;
          for (var i = _slice.start; i < _slice.stop; i += _slice.step) {
            res[offset++] = _self.item(i);
          }
          return res;
        }
        throw _b_2.KeyError.$factory(key2);
      };
      $B2.JSObj.__setitem__ = $B2.JSObj.__setattr__;
      $B2.JSObj.__repr__ = $B2.JSObj.__str__ = function(_self) {
        if (typeof _self == "number") {
          return _self + "";
        }
        if (typeof _self == "function" && _self.$js_func.name && globalThis[_self.$js_func.name] === _self.$js_func) {
          return `<function window.${_self.$js_func.name}>`;
        }
        var js_repr = Object.prototype.toString.call(_self);
        return `<Javascript object: ${js_repr}>`;
      };
      $B2.JSObj.bind = function(_self, evt, func) {
        var js_func = function(ev) {
          try {
            return func(jsobj2pyobj(ev));
          } catch (err) {
            if (err.__class__ !== void 0) {
              $B2.handle_error(err);
            } else {
              try {
                $B2.$getattr($B2.get_stderr(), "write")(err);
              } catch (err1) {
                console.log(err);
              }
            }
          }
        };
        Object.defineProperty(
          _self,
          "$brython_events",
          { value: _self.$brython_events || {}, writable: true }
        );
        if (_self.$brython_events) {
          _self.$brython_events[evt] = _self.$brython_events[evt] || [];
          _self.$brython_events[evt].push([func, js_func]);
        }
        _self.addEventListener(evt, js_func);
        return _b_2.None;
      };
      $B2.JSObj.bindings = function(_self) {
        var res = $B2.empty_dict();
        if (_self.$brython_events) {
          for (var key2 in _self.$brython_events) {
            _b_2.dict.$setitem(res, key2, $B2.fast_tuple(_self.$brython_events[key2].map((x) => x[0])));
          }
        }
        return res;
      };
      $B2.JSObj.unbind = function(_self, evt, func) {
        if (!_self.$brython_events) {
          return _b_2.None;
        }
        if (!_self.$brython_events[evt]) {
          return _b_2.None;
        }
        var events = _self.$brython_events[evt];
        if (func === void 0) {
          for (var item2 of events) {
            _self.removeEventListener(evt, item2[1]);
          }
          delete _self.$brython_events[evt];
        } else {
          for (var i = 0, len = events.length; i < len; i++) {
            if (events[i][0] === func) {
              _self.removeEventListener(evt, events[i][1]);
              events.splice(i, 1);
            }
          }
          if (events.length == 0) {
            delete _self.$brython_events[evt];
          }
        }
      };
      $B2.JSObj.to_dict = function(_self) {
        if (typeof _self == "function") {
          throw _b_2.TypeError.$factory(
            "method 'to_dict()' not supported for functions"
          );
        }
        var res = $B2.empty_dict();
        for (var key2 in _self) {
          _b_2.dict.$setitem_string(res, key2, convert_to_python(_self[key2]));
        }
        return res;
      };
      function convert_to_python(obj) {
        if (obj === null || obj === void 0) {
          return $B2.jsobj2pyobj(obj);
        }
        if (obj.__class__) {
          return obj;
        }
        if (Array.isArray(obj)) {
          return obj.map(convert_to_python);
        }
        if ($B2.$isinstance(obj, $B2.JSObj)) {
          if (typeof obj == "number") {
            return $B2.fast_float(obj);
          }
          var res = $B2.empty_dict();
          for (var key2 in obj) {
            _b_2.dict.$setitem_string(res, key2, convert_to_python(obj[key2]));
          }
          return res;
        }
        return $B2.jsobj2pyobj(obj);
      }
      $B2.set_func_names($B2.JSObj, "builtins");
      var js_list_meta = $B2.make_class("js_list_meta");
      js_list_meta.__mro__ = [_b_2.type, _b_2.object];
      js_list_meta.__getattribute__ = function(_self, attr) {
        if (_b_2.list[attr] === void 0) {
          if (js_array.hasOwnProperty(attr)) {
            return js_array[attr];
          }
          throw _b_2.AttributeError.$factory(attr);
        }
        if (["__delitem__", "__setitem__"].indexOf(attr) > -1) {
          return function() {
            var args = new Array(arguments.length);
            args[0] = arguments[0];
            for (var i = 1, len = arguments.length; i < len; i++) {
              args[i] = pyobj2jsobj(arguments[i]);
            }
            return _b_2.list[attr].apply(null, args);
          };
        } else if (["__contains__", "__eq__", "__getitem__", "__ge__", "__gt__", "__le__", "__lt__"].indexOf(attr) > -1) {
          return function() {
            var pylist = $B2.$list(arguments[0].map(jsobj2pyobj));
            return jsobj2pyobj(_b_2.list[attr].call(null, pylist, ...Array.from(arguments).slice(1)));
          };
        } else if (js_array.hasOwnProperty(attr)) {
          return js_array[attr];
        } else if (["__repr__", "__str__"].includes(attr)) {
          return function(js_array2) {
            var t = jsobj2pyobj(js_array2);
            return _b_2.list[attr]($B2.$list(t));
          };
        }
        return function(js_array2) {
          var t = jsobj2pyobj(js_array2);
          return _b_2.list[attr](t);
        };
      };
      $B2.set_func_names(js_list_meta, "builtins");
      $B2.SizedJSObj = $B2.make_class("SizedJavascriptObject");
      $B2.SizedJSObj.__bases__ = [$B2.JSObj];
      $B2.SizedJSObj.__mro__ = [$B2.JSObj, _b_2.object];
      $B2.SizedJSObj.__len__ = function(_self) {
        return _self.length;
      };
      $B2.set_func_names($B2.SizedJSObj, "builtins");
      $B2.IterableJSObj = $B2.make_class("IterableJavascriptObject");
      $B2.IterableJSObj.__bases__ = [$B2.JSObj];
      $B2.IterableJSObj.__mro__ = [$B2.JSObj, _b_2.object];
      $B2.IterableJSObj.__contains__ = function(self2, key2) {
        if (self2.contains !== void 0 && typeof self2.contains == "function") {
          return self2.contains(key2);
        } else {
          for (var item2 of $B2.IterableJSObj.__iter__(self2).it) {
            if ($B2.is_or_equals(item2, key2)) {
              return true;
            }
          }
          return false;
        }
      };
      $B2.IterableJSObj.__iter__ = function(_self) {
        return {
          __class__: $B2.IterableJSObj,
          it: _self[Symbol.iterator]()
        };
      };
      $B2.IterableJSObj.__len__ = function(_self) {
        return _self.length;
      };
      $B2.IterableJSObj.__next__ = function(_self) {
        var value2 = _self.it.next();
        if (!value2.done) {
          return jsobj2pyobj(value2.value);
        }
        throw _b_2.StopIteration.$factory("");
      };
      $B2.set_func_names($B2.IterableJSObj, "builtins");
      var js_array = $B2.js_array = $B2.make_class("Array");
      js_array.__class__ = js_list_meta;
      js_array.__mro__ = [$B2.JSObj, _b_2.object];
      js_array.__add__ = function(_self, other) {
        var res = _self.slice();
        if ($B2.$isinstance(other, js_array)) {
          return _self.slice().concat(other);
        }
        for (var item2 of $B2.make_js_iterator(other)) {
          res.push(pyobj2jsobj(item2));
        }
        return res;
      };
      js_array.__getattribute__ = function(_self, attr) {
        if (_b_2.list[attr] === void 0) {
          var proto = Object.getPrototypeOf(_self), res = proto[attr];
          if (res !== void 0) {
            return jsobj2pyobj(res, _self);
          }
          if (_self.hasOwnProperty(attr)) {
            return jsobj2pyobj(_self[attr]);
          }
          if (js_array.hasOwnProperty(attr)) {
            return js_array[attr];
          }
          throw $B2.attr_error(attr, _self);
        }
        if (js_array.hasOwnProperty(attr)) {
          return function() {
            return js_array[attr](_self, ...arguments);
          };
        }
        return function() {
          var args = pyobj2jsobj(Array.from(arguments));
          return _b_2.list[attr].call(null, _self, ...args);
        };
      };
      js_array.__getitem__ = function(_self, i) {
        i = $B2.PyNumber_Index(i);
        return jsobj2pyobj(_self[i]);
      };
      js_array.__iadd__ = function(_self, other) {
        if ($B2.$isinstance(other, js_array)) {
          for (var item2 of other) {
            _self.push(item2);
          }
        } else {
          for (var item2 of $B2.make_js_iterator(other)) {
            _self.push($B2.pyobj2jsobj(item2));
          }
        }
        return _self;
      };
      js_array.__iter__ = function(_self) {
        return js_array_iterator.$factory(_self);
      };
      js_array.__mul__ = function(_self, nb) {
        var res = _self.slice();
        for (var i = 1; i < nb; i++) {
          res = res.concat(_self);
        }
        return res;
      };
      var js_array_iterator = $B2.make_class(
        "JSArray_iterator",
        function(obj) {
          return {
            __class__: js_array_iterator,
            it: obj[Symbol.iterator]()
          };
        }
      );
      js_array_iterator.__next__ = function(_self) {
        var v = _self.it.next();
        if (v.done) {
          throw _b_2.StopIteration.$factory("");
        }
        return jsobj2pyobj(v.value);
      };
      $B2.set_func_names(js_array_iterator, "builtins");
      js_array.__iter__ = function(_self) {
        return js_array_iterator.$factory(_self);
      };
      js_array.__radd__ = function(_self, other) {
        var res = other.slice();
        if ($B2.$isinstance(other, js_array)) {
          res = res.concat(_self);
          return res;
        }
        for (var item2 of _self) {
          res.push($B2.jsobj2pyobj(item2));
        }
        res.__class__ = other.__class__;
        return res;
      };
      js_array.__repr__ = function(_self) {
        if ($B2.repr.enter(_self)) {
          return "[...]";
        }
        var _r = new Array(_self.length), res;
        for (var i = 0; i < _self.length; ++i) {
          _r[i] = _b_2.str.$factory(_self[i]);
        }
        res = "[" + _r.join(", ") + "]";
        $B2.repr.leave(_self);
        return res;
      };
      js_array.append = function(_self, x) {
        _self.push(pyobj2jsobj(x));
        if (_self[PYOBJ]) {
          _self[PYOBJ].push(x);
        }
        return _b_2.None;
      };
      $B2.set_func_names(js_array, "javascript");
      $B2.get_jsobj_class = function(obj) {
        if (typeof obj == "function") {
          return $B2.JSObj;
        }
        var proto = Object.getPrototypeOf(obj);
        if (proto === null) {
          return $B2.JSObj;
        }
        if (proto[Symbol.iterator] !== void 0) {
          return $B2.IterableJSObj;
        } else if (Object.getOwnPropertyNames(proto).indexOf("length") > -1) {
          return $B2.SizedJSObj;
        }
        return $B2.JSObj;
      };
      $B2.JSMeta = $B2.make_class("JSMeta");
      $B2.JSMeta.__call__ = function(cls) {
        console.log("create", cls);
        var extra_args = new Array(arguments.length - 1), klass = arguments[0];
        for (var i = 1, len = arguments.length; i < len; i++) {
          extra_args[i - 1] = arguments[i];
        }
        var new_func = _b_2.type.__getattribute__(klass, "__new__");
        var instance = new_func.apply(null, arguments);
        if (instance instanceof cls.__mro__[0].$js_func) {
          var init_func = _b_2.type.__getattribute__(klass, "__init__");
          if (init_func !== _b_2.object.__init__) {
            var args = [instance].concat(extra_args);
            init_func.apply(null, args);
          }
        }
        return instance;
      };
      $B2.JSMeta.__mro__ = [_b_2.type, _b_2.object];
      $B2.JSMeta.__getattribute__ = function(cls, attr) {
        if (cls[attr] !== void 0) {
          return cls[attr];
        } else if ($B2.JSMeta[attr] !== void 0) {
          if (attr == "__new__") {
            return function() {
              var res = new cls.$js_func(...Array.from(arguments).slice(1));
              res.__class__ = cls;
              return res;
            };
          }
          return $B2.JSMeta[attr];
        } else {
          return _b_2.type.__getattribute__(cls, attr);
        }
      };
      $B2.JSMeta.__init_subclass__ = function() {
      };
      $B2.JSMeta.__new__ = function(metaclass, class_name, bases, cl_dict) {
        var body = `
    var _b_ = __BRYTHON__.builtins
    return function(){
        if(_b_.dict.$contains_string(cl_dict, '__init__')){
            var args = [this]
            for(var i = 0, len = arguments.length; i < len; i++){
                args.push(arguments[i])
            }
            _b_.dict.$getitem_string(cl_dict, '__init__').apply(this, args)
        }else{
            return new bases[0].$js_func(...arguments)
        }
    }`;
        var proto = bases[0].$js_func.prototype;
        if (proto instanceof Node) {
          throw _b_2.TypeError.$factory(`class ${class_name} cannot inherit a subclass of Node`);
        }
        var new_js_class = Function("cl_dict", "bases", body)(cl_dict, bases);
        new_js_class.prototype = Object.create(bases[0].$js_func.prototype);
        new_js_class.prototype.constructor = new_js_class;
        Object.defineProperty(new_js_class, "$js_func", { value: bases[0].$js_func });
        new_js_class.__class__ = $B2.JSMeta;
        new_js_class.__bases__ = [bases[0]];
        new_js_class.__mro__ = [bases[0], _b_2.object];
        new_js_class.__qualname__ = new_js_class.__name__ = class_name;
        new_js_class.$is_js_class = true;
        for (var item2 of _b_2.dict.$iter_items(cl_dict)) {
          new_js_class[item2.key] = item2.value;
        }
        return new_js_class;
      };
      $B2.set_func_names($B2.JSMeta, "builtins");
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      var $GeneratorReturn = {};
      $B2.generator_return = function(value2) {
        return { __class__: $GeneratorReturn, value: value2 };
      };
      $B2.generator = $B2.make_class(
        "generator",
        function(func, name2) {
          var res = function() {
            var gen = func.apply(null, arguments);
            gen.$name = name2 || "generator";
            gen.$func = func;
            gen.$has_run = false;
            return {
              __class__: $B2.generator,
              js_gen: gen
            };
          };
          res.$infos = func.$infos;
          res.$is_genfunc = true;
          res.$name = name2;
          return res;
        }
      );
      $B2.generator.__iter__ = function(self2) {
        return self2;
      };
      $B2.generator.__next__ = function(self2) {
        return $B2.generator.send(self2, _b_2.None);
      };
      $B2.generator.__str__ = function(self2) {
        var name2 = self2.js_gen.$name || "generator";
        if (self2.js_gen.$func && self2.js_gen.$func.$infos) {
          name2 = self2.js_gen.$func.$infos.__qualname__;
        }
        return `<generator object ${name2}>`;
      };
      $B2.generator.close = function(self2) {
        var save_frame_obj = $B2.frame_obj;
        if (self2.$frame) {
          $B2.frame_obj = $B2.push_frame(self2.$frame);
        }
        try {
          $B2.generator.throw(self2, _b_2.GeneratorExit.$factory());
        } catch (err) {
          if (!$B2.is_exc(err, [_b_2.GeneratorExit, _b_2.StopIteration])) {
            $B2.frame_obj = save_frame_obj;
            throw _b_2.RuntimeError.$factory("generator ignored GeneratorExit");
          }
        }
        $B2.frame_obj = save_frame_obj;
      };
      $B2.generator.send = function(self2, value2) {
        var gen = self2.js_gen;
        gen.$has_run = true;
        if (gen.$finished) {
          throw _b_2.StopIteration.$factory(value2);
        }
        if (gen.gi_running === true) {
          throw _b_2.ValueError.$factory("generator already executing");
        }
        gen.gi_running = true;
        var save_frame_obj = $B2.frame_obj;
        if (self2.$frame) {
          $B2.frame_obj = $B2.push_frame(self2.$frame);
        }
        try {
          var res = gen.next(value2);
        } catch (err) {
          gen.$finished = true;
          $B2.frame_obj = save_frame_obj;
          throw err;
        }
        if ($B2.frame_obj !== null && $B2.frame_obj.frame === self2.$frame) {
          $B2.leave_frame();
        }
        $B2.frame_obj = save_frame_obj;
        if (res.value && res.value.__class__ === $GeneratorReturn) {
          gen.$finished = true;
          throw _b_2.StopIteration.$factory(res.value.value);
        }
        gen.gi_running = false;
        if (res.done) {
          throw _b_2.StopIteration.$factory(res.value);
        }
        return res.value;
      };
      $B2.generator.throw = function() {
        var $ = $B2.args("throw", 4, { self: null, type: null, value: null, traceback: null }, ["self", "type", "value", "traceback"], arguments, { value: _b_2.None, traceback: _b_2.None }, null, null), self2 = $.self, type = $.type, value2 = $.value, traceback = $.traceback;
        var gen = self2.js_gen, exc = type;
        if (exc.$is_class) {
          if (!_b_2.issubclass(type, _b_2.BaseException)) {
            throw _b_2.TypeError.$factory("exception value must be an instance of BaseException");
          } else if (value2 === void 0 || value2 === _b_2.None) {
            exc = $B2.$call(exc)();
          } else if ($B2.$isinstance(value2, type)) {
            exc = value2;
          }
        } else {
          if (value2 === _b_2.None) {
            value2 = exc;
          } else {
            exc = $B2.$call(exc)(value2);
          }
        }
        if (traceback !== _b_2.None) {
          exc.$traceback = traceback;
        }
        var save_frame_obj = $B2.frame_obj;
        if (self2.$frame) {
          $B2.frame_obj = $B2.push_frame(self2.$frame);
        }
        var res = gen.throw(exc);
        $B2.frame_obj = save_frame_obj;
        if (res.done) {
          throw _b_2.StopIteration.$factory(res.value);
        }
        return res.value;
      };
      $B2.set_func_names($B2.generator, "builtins");
      $B2.async_generator = $B2.make_class(
        "async_generator",
        function(func) {
          var f = function() {
            var gen = func.apply(null, arguments);
            var res = /* @__PURE__ */ Object.create(null);
            res.__class__ = $B2.async_generator;
            res.js_gen = gen;
            return res;
          };
          return f;
        }
      );
      $B2.async_generator.__aiter__ = function(self2) {
        return self2;
      };
      $B2.async_generator.__anext__ = function(self2) {
        return $B2.async_generator.asend(self2, _b_2.None);
      };
      $B2.async_generator.aclose = function(self2) {
        self2.js_gen.$finished = true;
        return _b_2.None;
      };
      $B2.async_generator.asend = async function(self2, value2) {
        var gen = self2.js_gen;
        if (gen.$finished) {
          throw _b_2.StopAsyncIteration.$factory(value2);
        }
        if (gen.ag_running === true) {
          throw _b_2.ValueError.$factory("generator already executing");
        }
        gen.ag_running = true;
        var save_frame_obj = $B2.frame_obj;
        if (self2.$frame) {
          $B2.frame_obj = $B2.push_frame(self2.$frame);
        }
        try {
          var res = await gen.next(value2);
        } catch (err) {
          gen.$finished = true;
          $B2.frame_obj = save_frame_obj;
          throw err;
        }
        if ($B2.frame_obj !== null && $B2.frame_obj.frame === self2.$frame) {
          $B2.leave_frame();
        }
        $B2.frame_obj = save_frame_obj;
        if (res.done) {
          throw _b_2.StopAsyncIteration.$factory(value2);
        }
        if (res.value.__class__ === $GeneratorReturn) {
          gen.$finished = true;
          throw _b_2.StopAsyncIteration.$factory(res.value.value);
        }
        gen.ag_running = false;
        return res.value;
      };
      $B2.async_generator.athrow = async function(self2, type, value2, traceback) {
        var gen = self2.js_gen, exc = type;
        if (exc.$is_class) {
          if (!_b_2.issubclass(type, _b_2.BaseException)) {
            throw _b_2.TypeError.$factory("exception value must be an instance of BaseException");
          } else if (value2 === void 0) {
            value2 = $B2.$call(exc)();
          }
        } else {
          if (value2 === void 0) {
            value2 = exc;
          } else {
            exc = $B2.$call(exc)(value2);
          }
        }
        if (traceback !== void 0) {
          exc.$traceback = traceback;
        }
        var save_frame_obj = $B2.frame_obj;
        if (self2.$frame) {
          $B2.frame_obj = $B2.push_frame(self2.$frame);
        }
        await gen.throw(value2);
        $B2.frame_obj = save_frame_obj;
      };
      $B2.set_func_names($B2.async_generator, "builtins");
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins, object = _b_2.object, _window = globalThis;
      function convertDomValue(v) {
        if (v === null || v === void 0) {
          return _b_2.None;
        }
        return $B2.jsobj2pyobj(v);
      }
      var py_immutable_to_js = $B2.py_immutable_to_js = function(pyobj) {
        if ($B2.$isinstance(pyobj, _b_2.float)) {
          return pyobj.value;
        } else if ($B2.$isinstance(pyobj, $B2.long_int)) {
          return $B2.long_int.$to_js_number(pyobj);
        }
        return pyobj;
      };
      function js_immutable_to_py(jsobj) {
        if (typeof jsobj == "number") {
          if (Number.isSafeInteger(jsobj)) {
            return jsobj;
          } else if (Number.isInteger(jsobj)) {
            return $B2.fast_long_int(BigInt(jsobj + ""));
          } else {
            return $B2.fast_float(jsobj);
          }
        }
        return jsobj;
      }
      function $getPosition(e) {
        var left = 0, top = 0, width = e.width || e.offsetWidth, height = e.height || e.offsetHeight;
        while (e.offsetParent) {
          left += e.offsetLeft;
          top += e.offsetTop;
          e = e.offsetParent;
        }
        left += e.offsetLeft || 0;
        top += e.offsetTop || 0;
        if (e.parentElement) {
          var parent_pos = $getPosition(e.parentElement);
          left += parent_pos.left;
          top += parent_pos.top;
        }
        return { left, top, width, height };
      }
      var $mouseCoords = $B2.$mouseCoords = function(ev) {
        if (ev.type.startsWith("touch")) {
          let res2 = {};
          res2.x = _b_2.int.$factory(ev.touches[0].screenX);
          res2.y = _b_2.int.$factory(ev.touches[0].screenY);
          res2.__getattr__ = function(attr) {
            return this[attr];
          };
          res2.__class__ = "MouseCoords";
          return res2;
        }
        var posx = 0, posy = 0;
        if (!ev) {
          ev = _window.event;
        }
        if (ev.pageX || ev.pageY) {
          posx = ev.pageX;
          posy = ev.pageY;
        } else if (ev.clientX || ev.clientY) {
          posx = ev.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
          posy = ev.clientY + document.body.scrollTop + document.documentElement.scrollTop;
        }
        let res = {};
        res.x = _b_2.int.$factory(posx);
        res.y = _b_2.int.$factory(posy);
        res.__getattr__ = function(attr) {
          return this[attr];
        };
        res.__class__ = "MouseCoords";
        return res;
      };
      $B2.$isNode = function(o) {
        return typeof Node === "object" ? o instanceof Node : o && typeof o === "object" && typeof o.nodeType === "number" && typeof o.nodeName === "string";
      };
      $B2.$isNodeList = function(nodes) {
        try {
          var result = Object.prototype.toString.call(nodes);
          var re = new RegExp("^\\[object (HTMLCollection|NodeList)\\]$");
          return typeof nodes === "object" && re.exec(result) !== null && nodes.length !== void 0 && (nodes.length == 0 || typeof nodes[0] === "object" && nodes[0].nodeType > 0);
        } catch (err) {
          return false;
        }
      };
      var $DOMEventAttrs_W3C = ["NONE", "CAPTURING_PHASE", "AT_TARGET", "BUBBLING_PHASE", "type", "target", "currentTarget", "eventPhase", "bubbles", "cancelable", "timeStamp", "stopPropagation", "preventDefault", "initEvent"];
      var $DOMEventAttrs_IE = ["altKey", "altLeft", "button", "cancelBubble", "clientX", "clientY", "contentOverflow", "ctrlKey", "ctrlLeft", "data", "dataFld", "dataTransfer", "fromElement", "keyCode", "nextPage", "offsetX", "offsetY", "origin", "propertyName", "reason", "recordset", "repeat", "screenX", "screenY", "shiftKey", "shiftLeft", "source", "srcElement", "srcFilter", "srcUrn", "toElement", "type", "url", "wheelDelta", "x", "y"];
      $B2.$isEvent = function(obj) {
        var flag = true;
        for (let attr of $DOMEventAttrs_W3C) {
          if (obj[attr] === void 0) {
            flag = false;
            break;
          }
        }
        if (flag) {
          return true;
        }
        for (let attr of $DOMEventAttrs_IE) {
          if (obj[attr] === void 0) {
            return false;
          }
        }
        return true;
      };
      var $NodeTypes = { 1: "ELEMENT", 2: "ATTRIBUTE", 3: "TEXT", 4: "CDATA_SECTION", 5: "ENTITY_REFERENCE", 6: "ENTITY", 7: "PROCESSING_INSTRUCTION", 8: "COMMENT", 9: "DOCUMENT", 10: "DOCUMENT_TYPE", 11: "DOCUMENT_FRAGMENT", 12: "NOTATION" };
      var Attributes = $B2.make_class(
        "Attributes",
        function(elt) {
          return { __class__: Attributes, elt };
        }
      );
      Attributes.__contains__ = function() {
        var $ = $B2.args("__getitem__", 2, { self: null, key: null }, ["self", "key"], arguments, {}, null, null);
        if ($.self.elt instanceof SVGElement) {
          return $.self.elt.hasAttributeNS(null, $.key);
        } else if (typeof $.self.elt.hasAttribute == "function") {
          return $.self.elt.hasAttribute($.key);
        }
        return false;
      };
      Attributes.__delitem__ = function() {
        var $ = $B2.args("__getitem__", 2, { self: null, key: null }, ["self", "key"], arguments, {}, null, null);
        if (!Attributes.__contains__($.self, $.key)) {
          throw _b_2.KeyError.$factory($.key);
        }
        if ($.self.elt instanceof SVGElement) {
          $.self.elt.removeAttributeNS(null, $.key);
          return _b_2.None;
        } else if (typeof $.self.elt.hasAttribute == "function") {
          $.self.elt.removeAttribute($.key);
          return _b_2.None;
        }
      };
      Attributes.__getitem__ = function() {
        var $ = $B2.args("__getitem__", 2, { self: null, key: null }, ["self", "key"], arguments, {}, null, null);
        if ($.self.elt instanceof SVGElement && $.self.elt.hasAttributeNS(null, $.key)) {
          return $.self.elt.getAttributeNS(null, $.key);
        } else if (typeof $.self.elt.hasAttribute == "function" && $.self.elt.hasAttribute($.key)) {
          return $.self.elt.getAttribute($.key);
        }
        throw _b_2.KeyError.$factory($.key);
      };
      Attributes.__iter__ = function(self2) {
        self2.$counter = 0;
        var attrs = self2.elt.attributes, items = [];
        for (var i = 0; i < attrs.length; i++) {
          items.push(attrs[i].name);
        }
        self2.$items = items;
        return self2;
      };
      Attributes.__next__ = function() {
        var $ = $B2.args("__next__", 1, { self: null }, ["self"], arguments, {}, null, null);
        if ($.self.$counter < $.self.$items.length) {
          var res = $.self.$items[$.self.$counter];
          $.self.$counter++;
          return res;
        } else {
          throw _b_2.StopIteration.$factory("");
        }
      };
      Attributes.__setitem__ = function() {
        var $ = $B2.args("__setitem__", 3, { self: null, key: null, value: null }, ["self", "key", "value"], arguments, {}, null, null);
        if ($.self.elt instanceof SVGElement && typeof $.self.elt.setAttributeNS == "function") {
          $.self.elt.setAttributeNS(null, $.key, _b_2.str.$factory($.value));
          return _b_2.None;
        } else if (typeof $.self.elt.setAttribute == "function") {
          $.self.elt.setAttribute($.key, _b_2.str.$factory($.value));
          return _b_2.None;
        }
        throw _b_2.TypeError.$factory("Can't set attributes on element");
      };
      Attributes.__repr__ = Attributes.__str__ = function(self2) {
        var attrs = self2.elt.attributes, items = [];
        for (var i = 0; i < attrs.length; i++) {
          items.push(attrs[i].name + ': "' + self2.elt.getAttributeNS(null, attrs[i].name) + '"');
        }
        return "{" + items.join(", ") + "}";
      };
      Attributes.get = function() {
        var $ = $B2.args("get", 3, { self: null, key: null, deflt: null }, ["self", "key", "deflt"], arguments, { deflt: _b_2.None }, null, null);
        try {
          return Attributes.__getitem__($.self, $.key);
        } catch (err) {
          if (err.__class__ === _b_2.KeyError) {
            return $.deflt;
          } else {
            throw err;
          }
        }
      };
      Attributes.keys = function() {
        return Attributes.__iter__.apply(null, arguments);
      };
      Attributes.items = function() {
        var $ = $B2.args("values", 1, { self: null }, ["self"], arguments, {}, null, null), attrs = $.self.elt.attributes, values = [];
        for (var i = 0; i < attrs.length; i++) {
          values.push($B2.$list([attrs[i].name, attrs[i].value]));
        }
        return _b_2.list.__iter__($B2.$list(values));
      };
      Attributes.values = function() {
        var $ = $B2.args("values", 1, { self: null }, ["self"], arguments, {}, null, null), attrs = $.self.elt.attributes, values = [];
        for (var i = 0; i < attrs.length; i++) {
          values.push(attrs[i].value);
        }
        return _b_2.list.__iter__($B2.$list(values));
      };
      $B2.set_func_names(Attributes, "<dom>");
      var DOMEvent = $B2.DOMEvent = $B2.make_class(
        "DOMEvent",
        function(evt_name) {
          return DOMEvent.__new__(DOMEvent, evt_name);
        }
      );
      DOMEvent.__new__ = function(cls, evt_name) {
        var ev = new Event(evt_name);
        ev.__class__ = DOMEvent;
        if (ev.preventDefault === void 0) {
          ev.preventDefault = function() {
            ev.returnValue = false;
          };
        }
        if (ev.stopPropagation === void 0) {
          ev.stopPropagation = function() {
            ev.cancelBubble = true;
          };
        }
        return ev;
      };
      DOMEvent.__setattr__ = function(self2, attr, value2) {
        self2[attr] = value2;
      };
      function dom2svg(svg_elt, coords) {
        var pt = svg_elt.createSVGPoint();
        pt.x = coords.x;
        pt.y = coords.y;
        return pt.matrixTransform(svg_elt.getScreenCTM().inverse());
      }
      DOMEvent.__getattribute__ = function(ev, attr) {
        switch (attr) {
          case "__repr__":
          case "__str__":
            return function() {
              return "<DOMEvent object>";
            };
          case "x":
            return $mouseCoords(ev).x;
          case "y":
            return $mouseCoords(ev).y;
          case "data":
            if (ev.dataTransfer !== null && ev.dataTransfer !== void 0) {
              return Clipboard.$factory(ev.dataTransfer);
            } else if (typeof Worker !== "undefined" && ev.target instanceof Worker) {
              return $B2.structuredclone2pyobj(ev.data);
            } else if (typeof DedicatedWorkerGlobalScope !== "undefined" && ev.target instanceof DedicatedWorkerGlobalScope) {
              return $B2.structuredclone2pyobj(ev.data);
            }
            return convertDomValue(ev.data);
          case "target":
            if (ev.target !== void 0) {
              return DOMNode.$factory(ev.target);
            }
            break;
          case "char":
            return String.fromCharCode(ev.which);
          case "svgX":
            if (ev.target instanceof SVGSVGElement) {
              return Math.floor(dom2svg(ev.target, $mouseCoords(ev)).x);
            }
            throw _b_2.AttributeError.$factory("event target is not an SVG element");
          case "svgY":
            if (ev.target instanceof SVGSVGElement) {
              return Math.floor(dom2svg(ev.target, $mouseCoords(self)).y);
            }
            throw _b_2.AttributeError.$factory("event target is not an SVG element");
        }
        var res = ev[attr];
        if (res !== void 0) {
          if (typeof res == "function") {
            var func = function() {
              var args = [];
              for (var i = 0; i < arguments.length; i++) {
                args.push($B2.pyobj2jsobj(arguments[i]));
              }
              return res.apply(ev, arguments);
            };
            func.$infos = { __name__: res.name, __qualname__: res.name };
            return func;
          }
          return convertDomValue(res);
        }
        throw $B2.attr_error(attr, ev);
      };
      var $DOMEvent = $B2.$DOMEvent = function(ev) {
        ev.__class__ = DOMEvent;
        ev.$no_dict = true;
        if (ev.preventDefault === void 0) {
          ev.preventDefault = function() {
            ev.returnValue = false;
          };
        }
        if (ev.stopPropagation === void 0) {
          ev.stopPropagation = function() {
            ev.cancelBubble = true;
          };
        }
        return ev;
      };
      $B2.set_func_names(DOMEvent, "browser");
      var Clipboard = $B2.make_class(
        "Clipboard",
        function(data2) {
          return {
            __class__: Clipboard,
            __dict__: $B2.empty_dict(),
            data: data2
          };
        }
      );
      Clipboard.__getitem__ = function(self2, name2) {
        return self2.data.getData(name2);
      };
      Clipboard.__setitem__ = function(self2, name2, value2) {
        self2.data.setData(name2, value2);
      };
      $B2.set_func_names(Clipboard, "<dom>");
      var DOMNode = $B2.make_class(
        "DOMNode",
        function(elt) {
          return elt;
        }
      );
      DOMNode.__add__ = function(self2, other) {
        var res = TagSum.$factory();
        res.children = [self2];
        var pos2 = 1;
        if ($B2.$isinstance(other, TagSum)) {
          res.children = res.children.concat(other.children);
        } else if ($B2.$isinstance(other, [_b_2.str, _b_2.int, _b_2.float, _b_2.list, _b_2.dict, _b_2.set, _b_2.tuple])) {
          res.children[pos2++] = DOMNode.$factory(
            document.createTextNode(_b_2.str.$factory(other))
          );
        } else if ($B2.$isinstance(other, DOMNode)) {
          res.children[pos2++] = other;
        } else {
          try {
            res.children = res.children.concat(_b_2.list.$factory(other));
          } catch (err) {
            throw _b_2.TypeError.$factory("can't add '" + $B2.class_name(other) + "' object to DOMNode instance");
          }
        }
        return res;
      };
      DOMNode.__bool__ = function() {
        return true;
      };
      DOMNode.__contains__ = function(self2, key2) {
        if (self2.nodeType == Node.DOCUMENT_NODE && typeof key2 == "string") {
          return document.getElementById(key2) !== null;
        }
        if (self2.length !== void 0 && typeof self2.item == "function") {
          for (var i = 0, len = self2.length; i < len; i++) {
            if (self2.item(i) === key2) {
              return true;
            }
          }
        }
        return false;
      };
      DOMNode.__del__ = function(self2) {
        if (!self2.parentNode) {
          throw _b_2.ValueError.$factory("can't delete " + _b_2.str.$factory(self2));
        }
        self2.parentNode.removeChild(self2);
      };
      DOMNode.__delattr__ = function(self2, attr) {
        if (self2[attr] === void 0) {
          throw _b_2.AttributeError.$factory(
            `cannot delete DOMNode attribute '${attr}'`
          );
        }
        delete self2[attr];
        return _b_2.None;
      };
      DOMNode.__delitem__ = function(self2, key2) {
        if (self2.nodeType == Node.DOCUMENT_NODE) {
          var res = self2.getElementById(key2);
          if (res) {
            res.parentNode.removeChild(res);
          } else {
            throw _b_2.KeyError.$factory(key2);
          }
        } else {
          self2.parentNode.removeChild(self2);
        }
      };
      DOMNode.__dir__ = function(self2) {
        var res = [];
        for (let attr in self2) {
          if (attr.charAt(0) != "$") {
            res.push(attr);
          }
        }
        for (let attr in DOMNode) {
          if (res.indexOf(attr) == -1) {
            res.push(attr);
          }
        }
        res.sort();
        return $B2.$list(res);
      };
      DOMNode.__eq__ = function(self2, other) {
        return self2 == other;
      };
      DOMNode.__getattribute__ = function(self2, attr) {
        switch (attr) {
          case "attrs":
            return Attributes.$factory(self2);
          case "children":
          case "child_nodes":
          case "class_name":
          case "html":
          case "parent":
          case "text":
            return DOMNode[attr](self2);
          case "height":
          case "left":
          case "top":
          case "width":
            if (self2.tagName == "CANVAS" && self2[attr]) {
              return self2[attr];
            }
            if (self2 instanceof SVGElement) {
              return self2[attr].baseVal.value;
            }
            var computed = window.getComputedStyle(self2).getPropertyValue(attr);
            if (computed !== void 0) {
              if (computed == "") {
                if (self2.style[attr] !== void 0) {
                  return parseInt(self2.style[attr]);
                } else {
                  return 0;
                }
              }
              let prop = Math.floor(parseFloat(computed) + 0.5);
              return isNaN(prop) ? 0 : prop;
            } else if (self2.style[attr]) {
              return parseInt(self2.style[attr]);
            } else {
              throw _b_2.AttributeError.$factory("style." + attr + " is not set for " + _b_2.str.$factory(self2));
            }
          case "x":
          case "y":
            if (!(self2 instanceof SVGElement)) {
              let pos2 = $getPosition(self2);
              return attr == "x" ? pos2.left : pos2.top;
            }
            break;
          case "closest":
            if (!self2[attr]) {
              throw $B2.attr_error(self2, attr);
            }
            return function() {
              return DOMNode[attr].call(null, self2, ...arguments);
            };
          case "headers":
            if (self2.nodeType == Node.DOCUMENT_NODE) {
              let req = new XMLHttpRequest();
              req.open("GET", document.location, false);
              req.send(null);
              var headers = req.getAllResponseHeaders();
              headers = headers.split("\r\n");
              let res2 = $B2.empty_dict();
              for (let header of headers) {
                if (header.strip().length == 0) {
                  continue;
                }
                let pos2 = header.search(":");
                res2.__setitem__(header.substr(0, pos2), header.substr(pos2 + 1).lstrip());
              }
              return res2;
            }
            break;
          case "location":
            attr = "location";
            break;
        }
        if (attr == "select" && self2.nodeType == 1 && ["INPUT", "TEXTAREA"].indexOf(self2.tagName.toUpperCase()) > -1) {
          return function(selector) {
            if (selector === void 0) {
              self2.select();
              return _b_2.None;
            }
            return DOMNode.select(self2, selector);
          };
        }
        if (attr == "query" && self2.nodeType == Node.DOCUMENT_NODE) {
          let res2 = { __class__: Query, _keys: $B2.$list([]), _values: {} };
          let qs = location.search.substr(1).split("&");
          if (location.search != "") {
            for (let i = 0; i < qs.length; i++) {
              let pos2 = qs[i].search("="), elts = [qs[i].substr(0, pos2), qs[i].substr(pos2 + 1)], key2 = decodeURIComponent(elts[0]), value2 = decodeURIComponent(elts[1]);
              if (res2._keys.indexOf(key2) > -1) {
                res2._values[key2].push(value2);
              } else {
                res2._keys.push(key2);
                res2._values[key2] = [value2];
              }
            }
          }
          return res2;
        }
        var klass = $B2.get_class(self2);
        var property = self2[attr];
        if (property !== void 0 && self2.__class__ && klass.__module__ != "browser.html" && klass.__module__ != "browser.svg" && !klass.$webcomponent) {
          var from_class = $B2.$getattr(klass, attr, null);
          if (from_class !== null) {
            property = from_class;
            if (typeof from_class === "function") {
              return property.bind(self2, self2);
            }
          } else {
            var bases = self2.__class__.__bases__;
            var show_message = true;
            for (var base of bases) {
              if (base.__module__ == "browser.html") {
                show_message = false;
                break;
              }
            }
            if (show_message) {
              from_class = $B2.$getattr(self2.__class__, attr, _b_2.None);
              if (from_class !== _b_2.None) {
                var frame = $B2.frame_obj.frame, line = frame.$lineno;
                console.info("Warning: line " + line + ", " + self2.tagName + " element has instance attribute '" + attr + "' set. Attribute of class " + $B2.class_name(self2) + " is ignored.");
              }
            }
          }
        }
        if (property === void 0) {
          if (self2.tagName) {
            var ce = customElements.get(self2.tagName.toLowerCase());
            if (ce !== void 0 && ce.$cls !== void 0) {
              var save_class = self2.__class__;
              self2.__class__ = ce.$cls;
              try {
                let res2 = _b_2.object.__getattribute__(self2, attr);
                self2.__class__ = save_class;
                return res2;
              } catch (err) {
                self2.__class__ = save_class;
                if (!$B2.is_exc(err, [_b_2.AttributeError])) {
                  throw err;
                }
              }
            }
          } else {
            return object.__getattribute__(self2, attr);
          }
        }
        var res = property;
        if (res !== void 0) {
          if (res === null) {
            return res;
          }
          if (typeof res === "function") {
            if (self2.__class__ && self2.__class__.$webcomponent) {
              var method = $B2.$getattr(self2.__class__, attr, null);
              if (method !== null) {
                return res.bind(self2);
              }
            }
            if (res.$function_infos) {
              return res;
            }
            var func = /* @__PURE__ */ (function(f, elt) {
              return function() {
                var args = [];
                for (var i = 0; i < arguments.length; i++) {
                  var arg = arguments[i];
                  if (typeof arg == "function") {
                    var f1;
                    if (arg.$cache) {
                      f1 = arg.$cache;
                    } else {
                      f1 = /* @__PURE__ */ (function(dest_fn) {
                        return function() {
                          try {
                            return dest_fn.apply(null, arguments);
                          } catch (err) {
                            $B2.handle_error(err);
                          }
                        };
                      })(arg);
                      arg.$cache = f1;
                    }
                    args.push(f1);
                  } else {
                    args.push($B2.pyobj2jsobj(arg));
                  }
                }
                var result = f.apply(elt, args);
                return convertDomValue(result);
              };
            })(res, self2);
            func.$infos = { __name__: attr, __qualname__: attr };
            func.$is_func = true;
            func.$python_function = res;
            return func;
          }
          if (attr == "style") {
            return $B2.jsobj2pyobj(self2[attr]);
          }
          if (Array.isArray(res)) {
            return res;
          }
          return js_immutable_to_py(res);
        }
        return object.__getattribute__(self2, attr);
      };
      DOMNode.__getitem__ = function(self2, key2) {
        if (self2.nodeType == Node.DOCUMENT_NODE) {
          if (typeof key2.valueOf() == "string") {
            let res = self2.getElementById(key2);
            if (res) {
              return DOMNode.$factory(res);
            }
            throw _b_2.KeyError.$factory(key2);
          } else {
            try {
              let elts = self2.getElementsByTagName(key2.__name__), res = [];
              for (let i = 0; i < elts.length; i++) {
                res.push(DOMNode.$factory(elts[i]));
              }
              return res;
            } catch (err) {
              throw _b_2.KeyError.$factory(_b_2.str.$factory(key2));
            }
          }
        } else {
          if ((typeof key2 == "number" || typeof key2 == "boolean") && typeof self2.item == "function") {
            var key_to_int = _b_2.int.$factory(key2);
            if (key_to_int < 0) {
              key_to_int += self2.length;
            }
            let res = DOMNode.$factory(self2.item(key_to_int));
            if (res === void 0) {
              throw _b_2.KeyError.$factory(key2);
            }
            return res;
          } else if (typeof key2 == "string" && self2.attributes && typeof self2.attributes.getNamedItem == "function") {
            let attr = self2.attributes.getNamedItem(key2);
            if (attr !== null) {
              return attr.value;
            }
            throw _b_2.KeyError.$factory(key2);
          }
        }
      };
      DOMNode.__hash__ = function(self2) {
        return self2.__hashvalue__ === void 0 ? self2.__hashvalue__ = $B2.$py_next_hash-- : self2.__hashvalue__;
      };
      DOMNode.__iter__ = function(self2) {
        var items = [];
        if (self2.length !== void 0 && typeof self2.item == "function") {
          for (let i = 0, len = self2.length; i < len; i++) {
            items.push(DOMNode.$factory(self2.item(i)));
          }
        } else if (self2.childNodes !== void 0) {
          for (let child of self2.childNodes) {
            items.push(DOMNode.$factory(child));
          }
        }
        return $B2.$iter(items);
      };
      DOMNode.__le__ = function(self2, other) {
        if (self2.nodeType == Node.DOCUMENT_NODE) {
          self2 = self2.body;
        }
        if ($B2.$isinstance(other, TagSum)) {
          for (var i = 0; i < other.children.length; i++) {
            self2.appendChild(other.children[i]);
          }
        } else if (typeof other == "string" || typeof other == "number") {
          var txt = document.createTextNode(other.toString());
          self2.appendChild(txt);
        } else if (other instanceof Node) {
          self2.appendChild(other);
        } else {
          try {
            var items = _b_2.list.$factory(other);
            items.forEach(function(item2) {
              DOMNode.__le__(self2, item2);
            });
          } catch (err) {
            throw _b_2.TypeError.$factory("can't add '" + $B2.class_name(other) + "' object to DOMNode instance");
          }
        }
        return self2;
      };
      DOMNode.__len__ = function(self2) {
        return self2.length;
      };
      DOMNode.__mul__ = function(self2, other) {
        if ($B2.$isinstance(other, _b_2.int) && other.valueOf() > 0) {
          var res = TagSum.$factory();
          var pos2 = res.children.length;
          for (var i = 0; i < other.valueOf(); i++) {
            res.children[pos2++] = DOMNode.clone(self2);
          }
          return res;
        }
        throw _b_2.ValueError.$factory("can't multiply " + self2.__class__ + "by " + other);
      };
      DOMNode.__ne__ = function(self2, other) {
        return !DOMNode.__eq__(self2, other);
      };
      DOMNode.__next__ = function(self2) {
        self2.$counter++;
        if (self2.$counter < self2.childNodes.length) {
          return DOMNode.$factory(self2.childNodes[self2.$counter]);
        }
        throw _b_2.StopIteration.$factory("StopIteration");
      };
      DOMNode.__radd__ = function(self2, other) {
        var res = TagSum.$factory();
        var txt = DOMNode.$factory(document.createTextNode(other));
        res.children = [txt, self2];
        return res;
      };
      DOMNode.__str__ = DOMNode.__repr__ = function(self2) {
        var attrs = self2.attributes, attrs_str = "", items = [];
        if (attrs !== void 0) {
          for (let attr of attrs) {
            items.push(attr.name + '="' + self2.getAttributeNS(null, attr.name) + '"');
          }
        }
        var proto = Object.getPrototypeOf(self2);
        if (proto) {
          var name2 = proto.constructor.name;
          if (name2 === void 0) {
            var proto_str = proto.constructor.toString();
            name2 = proto_str.substring(8, proto_str.length - 1);
          }
          items.splice(0, 0, name2);
          return "<" + items.join(" ") + ">";
        }
        var res = "<DOMNode object type '";
        return res + $NodeTypes[self2.nodeType] + "' name '" + self2.nodeName + "'" + attrs_str + ">";
      };
      DOMNode.__setattr__ = function(self2, attr, value2) {
        switch (attr) {
          case "left":
          case "top":
          case "width":
          case "height":
            if ($B2.$isinstance(value2, [_b_2.int, _b_2.float]) && self2.nodeType == 1) {
              self2.style[attr] = value2 + "px";
              return _b_2.None;
            } else {
              throw _b_2.ValueError.$factory(attr + " value should be an integer or float, not " + $B2.class_name(value2));
            }
        }
        if (DOMNode["set_" + attr] !== void 0) {
          return DOMNode["set_" + attr](self2, value2);
        }
        function warn(msg) {
          console.log(msg);
          var frame = $B2.frame_obj.frame;
          if (!frame) {
            return;
          }
          if ($B2.get_option("debug") > 0) {
            var file = frame.__file__, lineno = frame.$lineno;
            console.log("module", frame[2], "line", lineno);
            if ($B2.file_cache.hasOwnProperty(file)) {
              var src = $B2.file_cache[file];
              console.log(src.split("\n")[lineno - 1]);
            }
          } else {
            console.log("module", frame[2]);
          }
        }
        var proto = Object.getPrototypeOf(self2), nb = 0;
        while (!!proto && proto !== Object.prototype && nb++ < 10) {
          var descriptors = Object.getOwnPropertyDescriptors(proto);
          if (!!descriptors && typeof descriptors.hasOwnProperty == "function") {
            if (descriptors.hasOwnProperty(attr)) {
              if (!descriptors[attr].writable && descriptors[attr].set === void 0) {
                warn("Warning: property '" + attr + "' is not writable. Use element.attrs['" + attr + "'] instead.");
              }
              break;
            }
          } else {
            break;
          }
          proto = Object.getPrototypeOf(proto);
        }
        if (self2.style && self2.style[attr] !== void 0 && attr != "src") {
          warn("Warning: '" + attr + "' is a property of element.style");
        }
        self2[attr] = py_immutable_to_js(value2);
        return _b_2.None;
      };
      DOMNode.__setitem__ = function(self2, key2, value2) {
        if (typeof key2 == "number") {
          self2.childNodes[key2] = value2;
        } else if (typeof key2 == "string") {
          if (self2.attributes) {
            if (self2 instanceof SVGElement) {
              self2.setAttributeNS(null, key2, value2);
            } else if (typeof self2.setAttribute == "function") {
              self2.setAttribute(key2, value2);
            }
          }
        }
      };
      DOMNode.abs_left = { __get__: function(self2) {
        return $getPosition(self2).left;
      }, __set__: function() {
        throw _b_2.AttributeError.$factory("'DOMNode' objectattribute 'abs_left' is read-only");
      } };
      DOMNode.abs_top = { __get__: function(self2) {
        return $getPosition(self2).top;
      }, __set__: function() {
        throw _b_2.AttributeError.$factory("'DOMNode' objectattribute 'abs_top' is read-only");
      } };
      DOMNode.attach = DOMNode.__le__;
      DOMNode.bind = function() {
        var $ = $B2.args("bind", 4, { self: null, event: null, func: null, options: null }, ["self", "event", "func", "options"], arguments, { func: _b_2.None, options: _b_2.None }, null, null), self2 = $.self, event = $.event, func = $.func, options = $.options;
        if (func === _b_2.None) {
          return function(f) {
            return DOMNode.bind(self2, event, f);
          };
        }
        var callback = /* @__PURE__ */ (function(f) {
          return function(ev) {
            try {
              return $B2.$call(f)($DOMEvent(ev));
            } catch (err) {
              if (err.__class__ !== void 0) {
                $B2.handle_error(err);
              } else {
                try {
                  $B2.$getattr($B2.get_stderr(), "write")(err);
                } catch (err1) {
                  console.log(err);
                }
              }
            }
          };
        })(func);
        callback.$infos = func.$infos;
        callback.$attrs = func.$attrs || {};
        callback.$func = func;
        if (typeof options == "boolean") {
          self2.addEventListener(event, callback, options);
        } else if (options.__class__ === _b_2.dict) {
          self2.addEventListener(event, callback, _b_2.dict.$to_obj(options));
        } else if (options === _b_2.None) {
          self2.addEventListener(event, callback, false);
        }
        self2.$events = self2.$events || {};
        self2.$events[event] = self2.$events[event] || [];
        self2.$events[event].push([func, callback]);
        return self2;
      };
      DOMNode.children = function(self2) {
        var res = [];
        if (self2.nodeType == Node.DOCUMENT_NODE) {
          self2 = self2.body;
        }
        for (var child of self2.children) {
          res.push(DOMNode.$factory(child));
        }
        return $B2.$list(res);
      };
      DOMNode.child_nodes = function(self2) {
        var res = [];
        if (self2.nodeType == Node.DOCUMENT_NODE) {
          self2 = self2.body;
        }
        for (var child of self2.childNodes) {
          res.push(DOMNode.$factory(child));
        }
        return $B2.$list(res);
      };
      DOMNode.clear = function() {
        var $ = $B2.args("clear", 1, { self: null }, ["self"], arguments, {}, null, null), self2 = $.self;
        if (self2.nodeType == Node.DOCUMENT_NODE) {
          self2 = self2.body;
        }
        while (self2.firstChild) {
          self2.removeChild(self2.firstChild);
        }
      };
      DOMNode.Class = function(self2) {
        if (self2.className !== void 0) {
          return self2.className;
        }
        return _b_2.None;
      };
      DOMNode.class_name = function(self2) {
        return DOMNode.Class(self2);
      };
      DOMNode.clone = function(self2) {
        var res = DOMNode.$factory(self2.cloneNode(true));
        var events = self2.$events || {};
        for (var event in events) {
          var evt_list = events[event];
          evt_list.forEach(function(evt) {
            var func = evt[0];
            DOMNode.bind(res, event, func);
          });
        }
        return res;
      };
      DOMNode.closest = function() {
        var $ = $B2.args("closest", 2, { self: null, selector: null }, ["self", "selector"], arguments, {}, null, null), self2 = $.self, selector = $.selector;
        if (self2.closest === void 0) {
          throw _b_2.AttributeError.$factory(_b_2.str.$factory(self2) + " has no attribute 'closest'");
        }
        var res = self2.closest(selector);
        if (res === null) {
          throw _b_2.KeyError.$factory("no parent with selector " + selector);
        }
        return DOMNode.$factory(res);
      };
      DOMNode.bindings = function(self2) {
        var res = $B2.empty_dict();
        for (var key2 in self2.$events) {
          _b_2.dict.$setitem(res, key2, self2.$events[key2].map((x) => x[1]));
        }
        return res;
      };
      DOMNode.events = function(self2, event) {
        self2.$events = self2.$events || {};
        var evt_list = self2.$events[event] = self2.$events[event] || [], funcs = evt_list.map((x) => x[0]);
        return $B2.$list(funcs);
      };
      function make_list(node_list) {
        var res = [];
        for (var i = 0; i < node_list.length; i++) {
          res.push(DOMNode.$factory(node_list[i]));
        }
        return $B2.$list(res);
      }
      DOMNode.get = function(self2) {
        var args = [];
        for (var i = 1; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var $ns = $B2.args("get", 0, {}, [], args, {}, null, "kw"), $dict = _b_2.dict.$to_obj($ns.kw);
        if ($dict["name"] !== void 0) {
          if (self2.getElementsByName === void 0) {
            throw _b_2.TypeError.$factory("DOMNode object doesn't support selection by name");
          }
          return make_list(self2.getElementsByName($dict["name"]));
        }
        if ($dict["tag"] !== void 0) {
          if (self2.getElementsByTagName === void 0) {
            throw _b_2.TypeError.$factory("DOMNode object doesn't support selection by tag name");
          }
          return make_list(self2.getElementsByTagName($dict["tag"]));
        }
        if ($dict["classname"] !== void 0) {
          if (self2.getElementsByClassName === void 0) {
            throw _b_2.TypeError.$factory("DOMNode object doesn't support selection by class name");
          }
          return make_list(self2.getElementsByClassName($dict["classname"]));
        }
        if ($dict["id"] !== void 0) {
          if (self2.getElementById === void 0) {
            throw _b_2.TypeError.$factory("DOMNode object doesn't support selection by id");
          }
          var id_res = document.getElementById($dict["id"]);
          if (!id_res) {
            return [];
          }
          return $B2.$list([DOMNode.$factory(id_res)]);
        }
        if ($dict["selector"] !== void 0) {
          if (self2.querySelectorAll === void 0) {
            throw _b_2.TypeError.$factory("DOMNode object doesn't support selection by selector");
          }
          return make_list(self2.querySelectorAll($dict["selector"]));
        }
        return $B2.$list([]);
      };
      DOMNode.getContext = function(self2) {
        if (!("getContext" in self2)) {
          throw _b_2.AttributeError.$factory("object has no attribute 'getContext'");
        }
        return function(ctx) {
          return $B2.jsobj2pyobj(self2.getContext(ctx));
        };
      };
      DOMNode.getSelectionRange = function(self2) {
        if (self2["getSelectionRange"] !== void 0) {
          return self2.getSelectionRange.apply(null, arguments);
        }
      };
      DOMNode.html = function(self2) {
        var res = self2.innerHTML;
        if (res === void 0) {
          if (self2.nodeType == Node.DOCUMENT_NODE && self2.body) {
            res = self2.body.innerHTML;
          } else {
            res = _b_2.None;
          }
        }
        return res;
      };
      DOMNode.index = function(self2, selector) {
        var items;
        if (selector === void 0) {
          items = self2.parentElement.childNodes;
        } else {
          items = self2.parentElement.querySelectorAll(selector);
        }
        var rank = -1;
        for (var i = 0; i < items.length; i++) {
          if (items[i] === self2) {
            rank = i;
            break;
          }
        }
        return rank;
      };
      DOMNode.inside = function(self2, other) {
        var elt = self2;
        while (true) {
          if (other === elt) {
            return true;
          }
          elt = elt.parentNode;
          if (!elt) {
            return false;
          }
        }
      };
      DOMNode.parent = function(self2) {
        if (self2.parentElement) {
          return DOMNode.$factory(self2.parentElement);
        }
        return _b_2.None;
      };
      DOMNode.reset = function(self2) {
        return function() {
          self2.reset();
        };
      };
      DOMNode.scrolled_left = { __get__: function(self2) {
        return $getPosition(self2).left - document.scrollingElement.scrollLeft;
      }, __set__: function() {
        throw _b_2.AttributeError.$factory("'DOMNode' objectattribute 'scrolled_left' is read-only");
      } };
      DOMNode.scrolled_top = { __get__: function(self2) {
        return $getPosition(self2).top - document.scrollingElement.scrollTop;
      }, __set__: function() {
        throw _b_2.AttributeError.$factory("'DOMNode' objectattribute 'scrolled_top' is read-only");
      } };
      DOMNode.select = function(self2, selector) {
        if (self2.querySelectorAll === void 0) {
          throw _b_2.TypeError.$factory("DOMNode object doesn't support selection by selector");
        }
        return make_list(self2.querySelectorAll(selector));
      };
      DOMNode.select_one = function(self2, selector) {
        if (self2.querySelector === void 0) {
          throw _b_2.TypeError.$factory("DOMNode object doesn't support selection by selector");
        }
        var res = self2.querySelector(selector);
        if (res === null) {
          return _b_2.None;
        }
        return DOMNode.$factory(res);
      };
      DOMNode.setSelectionRange = function() {
        if (this["setSelectionRange"] !== void 0) {
          return /* @__PURE__ */ (function(obj) {
            return function() {
              return obj.setSelectionRange.apply(obj, arguments);
            };
          })(this);
        } else if (this["createTextRange"] !== void 0) {
          return /* @__PURE__ */ (function(obj) {
            return function(start_pos, end_pos) {
              if (end_pos == void 0) {
                end_pos = start_pos;
              }
              var range = obj.createTextRange();
              range.collapse(true);
              range.moveEnd("character", start_pos);
              range.moveStart("character", end_pos);
              range.select();
            };
          })(this);
        }
      };
      DOMNode.set_class_name = function(self2, arg) {
        self2.setAttribute("class", arg);
      };
      DOMNode.set_html = function(self2, value2) {
        if (self2.nodeType == Node.DOCUMENT_NODE) {
          self2 = self2.body;
        }
        self2.innerHTML = _b_2.str.$factory(value2);
      };
      DOMNode.set_style = function(self2, style) {
        if (typeof style === "string") {
          self2.style = style;
          return;
        } else if (!$B2.$isinstance(style, _b_2.dict)) {
          throw _b_2.TypeError.$factory("style must be str or dict, not " + $B2.class_name(style));
        }
        var items = _b_2.list.$factory(_b_2.dict.items(style));
        for (var i = 0; i < items.length; i++) {
          var key2 = items[i][0], value2 = items[i][1];
          if (key2.toLowerCase() == "float") {
            self2.style.cssFloat = value2;
            self2.style.styleFloat = value2;
          } else {
            switch (key2) {
              case "top":
              case "left":
              case "width":
              case "height":
              case "borderWidth":
                if ($B2.$isinstance(value2, _b_2.int)) {
                  value2 = value2 + "px";
                }
            }
            self2.style[key2] = value2;
          }
        }
      };
      DOMNode.set_text = function(self2, value2) {
        if (self2.nodeType == Node.DOCUMENT_NODE) {
          self2 = self2.body;
        }
        self2.innerText = _b_2.str.$factory(value2);
        self2.textContent = _b_2.str.$factory(value2);
      };
      DOMNode.set_value = function(self2, value2) {
        self2.value = _b_2.str.$factory(value2);
      };
      DOMNode.submit = function(self2) {
        return function() {
          self2.submit();
        };
      };
      DOMNode.text = function(self2) {
        if (self2.nodeType == Node.DOCUMENT_NODE) {
          self2 = self2.body;
        }
        var res = self2.innerText || self2.textContent;
        if (res === null) {
          res = _b_2.None;
        }
        return res;
      };
      DOMNode.toString = function(self2) {
        if (self2 === void 0) {
          return "DOMNode";
        }
        return self2.nodeName;
      };
      DOMNode.trigger = function(self2, etype) {
        if (self2.fireEvent) {
          self2.fireEvent("on" + etype);
        } else {
          var evObj = document.createEvent("Events");
          evObj.initEvent(etype, true, false);
          self2.dispatchEvent(evObj);
        }
      };
      DOMNode.unbind = function(self2, event) {
        if (!self2.$events) {
          return _b_2.None;
        }
        if (event === void 0) {
          for (let evt in self2.$events) {
            DOMNode.unbind(self2, evt);
          }
          return _b_2.None;
        }
        if (self2.$events[event] === void 0 || self2.$events[event].length == 0) {
          return _b_2.None;
        }
        var events = self2.$events[event];
        if (arguments.length == 2) {
          for (let evt of events) {
            var callback = evt[1];
            self2.removeEventListener(event, callback, false);
          }
          self2.$events[event] = [];
          return _b_2.None;
        }
        for (let i = 2; i < arguments.length; i++) {
          let func = arguments[i], flag = false;
          for (let j2 = 0, len = events.length; j2 < len; j2++) {
            if ($B2.is_or_equals(func, events[j2][0])) {
              let _callback = events[j2][1];
              self2.removeEventListener(event, _callback, false);
              events.splice(j2, 1);
              flag = true;
              break;
            }
          }
          if (!flag) {
            throw _b_2.KeyError.$factory("missing callback for event " + event);
          }
        }
      };
      $B2.set_func_names(DOMNode, "builtins");
      var Query = $B2.make_class("query");
      Query.__contains__ = function(self2, key2) {
        return self2._keys.indexOf(key2) > -1;
      };
      Query.__getitem__ = function(self2, key2) {
        var result = self2._values[key2];
        if (result === void 0) {
          throw _b_2.KeyError.$factory(key2);
        } else if (result.length == 1) {
          return result[0];
        }
        return result;
      };
      var Query_iterator = $B2.make_iterator_class("query string iterator");
      Query.__iter__ = function(self2) {
        return Query_iterator.$factory(self2._keys);
      };
      Query.__setitem__ = function(self2, key2, value2) {
        self2._values[key2] = [value2];
        return _b_2.None;
      };
      Query.__str__ = Query.__repr__ = function(self2) {
        var elts = [];
        for (var key2 in self2._values) {
          for (const val of self2._values[key2]) {
            elts.push(encodeURIComponent(key2) + "=" + encodeURIComponent(val));
          }
        }
        if (elts.length == 0) {
          return "";
        } else {
          return "?" + elts.join("&");
        }
      };
      Query.getfirst = function(self2, key2, _default) {
        var result = self2._values[key2];
        if (result === void 0) {
          if (_default === void 0) {
            return _b_2.None;
          }
          return _default;
        }
        return result[0];
      };
      Query.getlist = function(self2, key2) {
        return $B2.$list(self2._values[key2] ?? []);
      };
      Query.getvalue = function(self2, key2, _default) {
        try {
          return Query.__getitem__(self2, key2);
        } catch (err) {
          if (_default === void 0) {
            return _b_2.None;
          }
          return _default;
        }
      };
      Query.keys = function(self2) {
        return self2._keys;
      };
      $B2.set_func_names(Query, "<dom>");
      var TagSum = $B2.make_class(
        "TagSum",
        function() {
          return {
            __class__: TagSum,
            children: [],
            toString: function() {
              return "(TagSum)";
            }
          };
        }
      );
      TagSum.appendChild = function(self2, child) {
        self2.children.push(child);
      };
      TagSum.__add__ = function(self2, other) {
        if ($B2.get_class(other) === TagSum) {
          self2.children = self2.children.concat(other.children);
        } else if ($B2.$isinstance(other, [_b_2.str, _b_2.int, _b_2.float, _b_2.dict, _b_2.set, _b_2.list])) {
          self2.children = self2.children.concat(
            DOMNode.$factory(document.createTextNode(other))
          );
        } else {
          self2.children.push(other);
        }
        return self2;
      };
      TagSum.__radd__ = function(self2, other) {
        var res = TagSum.$factory();
        res.children = self2.children.slice();
        res.children.splice(0, 0, DOMNode.$factory(document.createTextNode(other)));
        return res;
      };
      TagSum.__repr__ = function(self2) {
        var res = "<object TagSum> ";
        for (var i = 0; i < self2.children.length; i++) {
          res += self2.children[i];
          if (self2.children[i].toString() == "[object Text]") {
            res += " [" + self2.children[i].textContent + "]\n";
          }
        }
        return res;
      };
      TagSum.__str__ = TagSum.toString = TagSum.__repr__;
      TagSum.clone = function(self2) {
        var res = TagSum.$factory();
        for (var i = 0; i < self2.children.length; i++) {
          res.children.push(self2.children[i].cloneNode(true));
        }
        return res;
      };
      $B2.set_func_names(TagSum, "<dom>");
      $B2.TagSum = TagSum;
      $B2.DOMNode = DOMNode;
    })(__BRYTHON__);
    (function($B2) {
      $B2.pattern_match = function(subject, pattern) {
        var _b_2 = $B2.builtins, frame = $B2.frame_obj.frame, locals = frame[1];
        function bind(pattern2, subject2) {
          if (pattern2.alias) {
            locals[pattern2.alias] = subject2;
          }
        }
        if (pattern.sequence) {
          if ($B2.$isinstance(subject, [_b_2.str, _b_2.bytes, _b_2.bytearray])) {
            return false;
          }
          let Sequence;
          if ($B2.imported["collections.abc"]) {
            Sequence = $B2.imported["collections.abc"].Sequence;
          }
          let deque;
          if ($B2.imported["collections"]) {
            deque = $B2.imported["collections"].deque;
          }
          let supported = false;
          let klass = subject.__class__ || $B2.get_class(subject);
          for (let base of [klass].concat(klass.__bases__ || [])) {
            if (base.$match_sequence_pattern) {
              supported = true;
              break;
            } else if (base === Sequence || base == deque) {
              supported = true;
              break;
            }
          }
          if (!supported && Sequence) {
            supported = _b_2.issubclass(klass, Sequence);
          }
          if (!supported) {
            return false;
          }
          if (pattern.sequence.length == 1 && pattern.sequence[0].capture_starred == "_") {
            return true;
          }
          let subject_length = _b_2.len(subject), nb_fixed_length = 0;
          for (let item2 of pattern.sequence) {
            if (!item2.capture_starred) {
              nb_fixed_length++;
            }
          }
          if (subject_length < nb_fixed_length) {
            return false;
          } else if (subject_length == 0 && pattern.sequence.length == 0) {
            return true;
          }
          let it = _b_2.iter(subject), nxt = $B2.$getattr(it, "__next__"), store_starred = [], nb_matched_in_subject = 0;
          for (let i = 0, len = pattern.sequence.length; i < len; i++) {
            if (pattern.sequence[i].capture_starred) {
              if (pattern.sequence[i].capture_starred == "_" && i == len - 1) {
                bind(pattern, subject);
                return true;
              }
              let starred_match_length = subject_length - nb_matched_in_subject - len + i + 1;
              for (let j2 = 0; j2 < starred_match_length; j2++) {
                store_starred.push(nxt());
              }
              locals[pattern.sequence[i].capture_starred] = $B2.$list(store_starred);
              nb_matched_in_subject += starred_match_length;
            } else {
              let subject_item = nxt();
              let m = $B2.pattern_match(subject_item, pattern.sequence[i]);
              if (!m) {
                return false;
              }
              nb_matched_in_subject++;
            }
          }
          if (nb_matched_in_subject != subject_length) {
            return false;
          }
          bind(pattern, subject);
          return true;
        }
        if (pattern.group) {
          if (pattern.group.length == 1) {
            if ($B2.pattern_match(subject, pattern.group[0])) {
              bind(pattern, subject);
              return true;
            }
          } else {
            pattern.sequence = pattern.group;
            return $B2.pattern_match(subject, pattern);
          }
        }
        if (pattern.or) {
          for (let item2 of pattern.or) {
            if ($B2.pattern_match(subject, item2)) {
              bind(pattern, subject);
              return true;
            }
          }
          return false;
        }
        if (pattern.mapping) {
          let supported = false;
          let Mapping;
          if ($B2.imported["collections.abc"]) {
            Mapping = $B2.imported["collections.abc"].Mapping;
          }
          let klass = subject.__class__ || $B2.get_class(subject);
          for (let base of [klass].concat(klass.__bases__ || [])) {
            if (base.$match_mapping_pattern || base === Mapping) {
              supported = true;
              break;
            }
          }
          if (!supported && Mapping) {
            supported = _b_2.issubclass(klass, Mapping);
          }
          if (!supported) {
            return false;
          }
          let matched = [], keys = [];
          for (let item2 of pattern.mapping) {
            let key_pattern = item2[0], value_pattern = item2[1], key2;
            if (key_pattern.hasOwnProperty("literal")) {
              key2 = key_pattern.literal;
            } else if (key_pattern.hasOwnProperty("value")) {
              key2 = key_pattern.value;
            }
            if (_b_2.list.__contains__(keys, key2)) {
              throw _b_2.ValueError.$factory("mapping pattern checks duplicate key (" + _b_2.str.$factory(key2) + ")");
            }
            keys.push(key2);
            let missing = $B2.make_class(
              "missing",
              function() {
                return {
                  __class__: missing
                };
              }
            );
            try {
              let v = $B2.$call($B2.$getattr(subject, "get"))(key2, missing);
              if (v === missing) {
                return false;
              }
              if (!$B2.pattern_match(v, value_pattern)) {
                return false;
              }
              matched.push(key2);
            } catch (err) {
              if ($B2.is_exc(err, [_b_2.KeyError])) {
                return false;
              }
              throw err;
            }
          }
          if (pattern.rest) {
            let rest = $B2.empty_dict(), it = _b_2.iter(subject), next_key;
            while (true) {
              try {
                next_key = _b_2.next(it);
              } catch (err) {
                if ($B2.is_exc(err, [_b_2.StopIteration])) {
                  locals[pattern.rest] = rest;
                  return true;
                }
                throw err;
              }
              if (!_b_2.list.__contains__(matched, next_key)) {
                _b_2.dict.__setitem__(rest, next_key, $B2.$getitem(subject, next_key));
              }
            }
          }
          return true;
        }
        if (pattern.class) {
          let klass = pattern.class;
          if (!$B2.$isinstance(klass, _b_2.type)) {
            throw _b_2.TypeError.$factory("called match pattern must be a type");
          }
          if (!$B2.$isinstance(subject, klass)) {
            return false;
          }
          if (pattern.args.length > 0) {
            if ([_b_2.bool, _b_2.bytearray, _b_2.bytes, _b_2.dict, _b_2.float, _b_2.frozenset, _b_2.int, _b_2.list, _b_2.set, _b_2.str, _b_2.tuple].indexOf(klass) > -1) {
              if (pattern.args.length > 1) {
                throw _b_2.TypeError.$factory("for builtin type " + $B2.class_name(subject) + ", a single positional subpattern is accepted");
              }
              return $B2.pattern_match(subject, pattern.args[0]);
            } else {
              let match_args = $B2.$getattr(klass, "__match_args__", $B2.fast_tuple([]));
              if (!$B2.$isinstance(match_args, _b_2.tuple)) {
                throw _b_2.TypeError.$factory(
                  "__match_args__() did not return a tuple"
                );
              }
              if (pattern.args.length > match_args.length) {
                throw _b_2.TypeError.$factory(
                  "__match_args__() returns " + match_args.length + " names but " + pattern.args.length + " positional arguments were passed"
                );
              }
              for (let i = 0, len = pattern.args.length; i < len; i++) {
                let pattern_arg = pattern.args[i], klass_arg = match_args[i];
                if (typeof klass_arg !== "string") {
                  throw _b_2.TypeError.$factory("item in __match_args__ is not a string: " + klass_arg);
                }
                if (pattern.keywords.hasOwnProperty(klass_arg)) {
                  throw _b_2.TypeError.$factory("__match_arg__ item " + klass_arg + " was passed as keyword pattern");
                }
                pattern.keywords[klass_arg] = pattern_arg;
              }
            }
          }
          for (let key2 in pattern.keywords) {
            let v = $B2.$getattr(subject, key2, null);
            if (v === null) {
              return false;
            } else if (!$B2.pattern_match(v, pattern.keywords[key2])) {
              return false;
            }
          }
          bind(pattern, subject);
          return true;
        }
        if (pattern.capture) {
          if (pattern.capture != "_") {
            locals[pattern.capture] = subject;
          }
          bind(pattern, subject);
          return true;
        } else if (pattern.capture_starred) {
          locals[pattern.capture_starred] = $B2.$list(subject);
          return true;
        } else if (pattern.hasOwnProperty("literal")) {
          let literal = pattern.literal;
          if (literal === _b_2.None || literal === _b_2.True || literal === _b_2.False) {
            return $B2.$is(subject, literal);
          }
          if ($B2.rich_comp("__eq__", subject, literal)) {
            bind(pattern, subject);
            return true;
          }
          return false;
        } else if (pattern.hasOwnProperty("value")) {
          if ($B2.rich_comp("__eq__", subject, pattern.value)) {
            bind(pattern, subject);
            return true;
          }
        } else if (subject == pattern) {
          return true;
        }
        return false;
      };
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      var coroutine = $B2.coroutine = $B2.make_class("coroutine");
      coroutine.close = function(self2) {
        self2.$sent = true;
      };
      coroutine.send = function(self2) {
        self2.$sent = true;
        if (!$B2.$isinstance(self2, coroutine)) {
          var msg = "object is not a coroutine";
          if (typeof self2 == "function" && self2.$function_infos && self2.$function_infos[$B2.func_attrs.flags] & 128) {
            msg += ". Maybe you forgot to call the async function ?";
          }
          throw _b_2.TypeError.$factory(msg);
        }
        var res = self2.$func.apply(null, self2.$args);
        res.then(function() {
          if (self2.$frame_obj) {
            $B2.frame_obj = self2.$frame_obj;
          }
        }).catch(function(err) {
          if (err.$frame_obj) {
            $B2.frame_obj = err.$frame_obj;
          }
        });
        return res;
      };
      coroutine.__repr__ = coroutine.__str__ = function(self2) {
        if (self2.$func.$function_infos) {
          return "<coroutine " + self2.$func.$function_infos[$B2.func_attrs.name] + ">";
        } else {
          return "<coroutine object>";
        }
      };
      $B2.set_func_names(coroutine, "builtins");
      $B2.make_async = (func) => {
        if (func.$is_genfunc) {
          return func;
        }
        var f = function() {
          var args = arguments;
          var res = { __class__: coroutine, $args: args, $func: func };
          if ($B2.frame_obj !== null) {
            var frame = $B2.frame_obj.frame;
            frame.$coroutine = res;
            res.$lineno = frame.$lineno;
          }
          return res;
        };
        f.$function_infos = func.$function_infos;
        f.$is_func = true;
        f.$is_async = true;
        f.$args_parser = func.$args_parser;
        return f;
      };
      $B2.promise = function(obj) {
        if (obj.__class__ === coroutine) {
          obj.$frame_obj = $B2.frame_obj;
          return coroutine.send(obj);
        }
        if (typeof obj == "function") {
          return obj();
        }
        if (obj instanceof Promise || typeof obj.then == "function") {
          obj.frame_obj = $B2.frame_obj;
          return obj.then(function(x) {
            $B2.frame_obj = obj.frame_obj;
            return $B2.jsobj2pyobj(x);
          }).catch(function(err) {
            $B2.frame_obj = obj.frame_obj;
            throw $B2.exception(err);
          });
        }
        var awaitable = $B2.$getattr(obj, "__await__", null);
        if (awaitable !== null) {
          awaitable = $B2.$call(awaitable)();
          if ($B2.$getattr(awaitable, "__next__", null) === null) {
            throw _b_2.TypeError.$factory(`__await__() returned non-iterator of type '${$B2.class_name(awaitable)}'`);
          }
          return awaitable;
        }
        throw _b_2.TypeError.$factory(`object ${$B2.class_name(obj)} can't be used in 'await' expression`);
      };
    })(__BRYTHON__);
    (function($B2) {
      $B2.builtin_class_flags = { builtins: { 1073763586: ["UnicodeWarning", "PythonFinalizationError", "FileExistsError", "TabError", "KeyError", "KeyboardInterrupt", "EncodingWarning", "RuntimeWarning", "UserWarning", "BytesWarning", "SystemExit", "UnicodeDecodeError", "ConnectionAbortedError", "ArithmeticError", "ConnectionRefusedError", "NotADirectoryError", "LookupError", "UnicodeEncodeError", "ConnectionResetError", "DeprecationWarning", "WindowsError", "GeneratorExit", "SystemError", "ProcessLookupError", "UnicodeTranslateError", "Warning", "EOFError", "ConnectionError", "IndexError", "BlockingIOError", "StopIteration", "AttributeError", "SyntaxWarning", "RuntimeError", "SyntaxError", "PendingDeprecationWarning", "ModuleNotFoundError", "NameError", "ImportWarning", "FileNotFoundError", "TimeoutError", "UnicodeError", "BaseExceptionGroup", "FutureWarning", "ChildProcessError", "IOError", "_IncompleteInputError", "IsADirectoryError", "NotImplementedError", "MemoryError", "OSError", "IndentationError", "AssertionError", "RecursionError", "ResourceWarning", "TypeError", "InterruptedError", "FloatingPointError", "BrokenPipeError", "ImportError", "OverflowError", "EnvironmentError", "PermissionError", "ZeroDivisionError", "ValueError", "BaseException", "Exception", "StopAsyncIteration", "BufferError", "UnboundLocalError", "ReferenceError"], 1073763848: ["ExceptionGroup"], 20975874: ["bool"], 4199682: ["float", "bytearray"], 138417410: ["bytes"], 21762: ["enumerate", "super", "staticmethod", "zip", "property", "map", "filter", "reversed", "classmethod"], 5378: ["object", "complex"], 541087042: ["dict"], 4216066: ["frozenset", "set"], 20976898: ["int"], 37770530: ["list"], 20770: ["memoryview"], 4386: ["range"], 20738: ["slice"], 272635138: ["str"], 71324962: ["tuple"], 2155896066: ["type"] }, types: { 20866: ["PyCapsule", "classmethod_descriptor", "generator", "coroutine", "frame", "getset_descriptor", "async_generator", "member_descriptor", "method-wrapper"], 22914: ["builtin_function_or_method"], 20738: ["traceback", "cell"], 4354: ["code", "ellipsis", "NoneType", "NotImplementedType"], 153858: ["function"], 20802: ["mappingproxy"], 153986: ["method_descriptor"], 22786: ["method"], 21762: ["module"], 151938: ["wrapper_descriptor"] } };
    })(__BRYTHON__);
    (function($B) {
      var _b_ = $B.builtins;
      var update = $B.update_obj = function(mod, data2) {
        for (let attr in data2) {
          mod[attr] = data2[attr];
        }
      };
      var modules = {};
      var win = $B.jsobj2pyobj(globalThis);
      var browser = { $package: true, $is_package: true, __initialized__: true, __package__: "browser", __file__: $B.brython_path.replace(new RegExp("/*$", "g"), "") + "/Lib/browser/__init__.py", __BRYTHON__, bind: function() {
        var $ = $B.args("bind", 3, { elt: null, evt: null, options: null }, ["elt", "evt", "options"], arguments, { options: _b_.None }, null, null);
        var options = $.options;
        if (typeof options == "boolean") {
        } else if (options.__class__ === _b_.dict) {
          var _options = {};
          for (var key2 of _b_.dict.$keys_string(options)) {
            _options[key2] = _b_.dict.$getitem_string(options, key2);
          }
          options = _options;
        } else {
          options == false;
        }
        return function(callback) {
          if ($B.get_class($.elt) === $B.JSObj) {
            let f2 = function(ev) {
              try {
                return callback($B.jsobj2pyobj(ev));
              } catch (err) {
                $B.handle_error(err);
              }
            };
            var f = f2;
            $.elt.addEventListener($.evt, f2, options);
            return callback;
          } else if ($B.$isinstance($.elt, $B.DOMNode)) {
            $B.DOMNode.bind($.elt, $.evt, callback, options);
            return callback;
          } else if ($B.$isinstance($.elt, _b_.str)) {
            var items = document.querySelectorAll($.elt);
            for (var i = 0; i < items.length; i++) {
              $B.DOMNode.bind($B.DOMNode.$factory(items[i]), $.evt, callback, options);
            }
            return callback;
          }
          try {
            var it = $B.$iter($.elt);
            while (true) {
              try {
                var elt = _b_.next(it);
                $B.DOMNode.bind(elt, $.evt, callback);
              } catch (err) {
                if ($B.$isinstance(err, _b_.StopIteration)) {
                  break;
                }
                throw err;
              }
            }
          } catch (err) {
            if ($B.$isinstance(err, _b_.AttributeError)) {
              $B.DOMNode.bind($.elt, $.evt, callback);
            }
            throw err;
          }
          return callback;
        };
      }, console: self.console && $B.jsobj2pyobj(self.console), run_script: function() {
        var $ = $B.args("run_script", 2, { src: null, name: null }, ["src", "name"], arguments, { name: "script_" + $B.UUID() }, null, null);
        $B.runPythonSource($.src, $.name);
      }, scope: globalThis, self: win, win, window: win };
      browser.__path__ = browser.__file__;
      if ($B.isNode) {
        delete browser.window;
        delete browser.win;
      } else if ($B.isWebWorker) {
        browser.is_webworker = true;
        delete browser.window;
        delete browser.win;
        browser.self.send = function() {
          var $ = $B.args("send", 1, { message: null }, ["message"], arguments, {}, "args", null), message = $B.pyobj2structuredclone($.message), args = $.args.map($B.pyobj2jsobj);
          self.postMessage(message, ...args);
        };
        browser.document = _b_.property.$factory(
          function() {
            throw _b_.ValueError.$factory(
              "'document' is not available in Web Workers"
            );
          },
          function(self2, value2) {
            browser.document = value2;
          }
        );
      } else {
        browser.is_webworker = false;
        update(browser, {
          "alert": function(message) {
            window.alert($B.builtins.str.$factory(message || ""));
          },
          confirm: $B.jsobj2pyobj(window.confirm),
          "document": $B.DOMNode.$factory(document),
          doc: $B.DOMNode.$factory(document),
          DOMEvent: $B.DOMEvent,
          DOMNode: $B.DOMNode,
          load: function(script_url) {
            var file_obj = $B.builtins.open(script_url);
            var content = $B.$getattr(file_obj, "read")();
            eval(content);
          },
          load1: function(script_url2, callback) {
            var script = document.createElement("SCRIPT");
            script.src = script_url2;
            if (callback) {
              script.addEventListener("load", function() {
                callback();
              });
            }
            document.body.appendChild(script);
          },
          mouseCoords: function(ev) {
            return $B.jsobj2pyobj($B.$mouseCoords(ev));
          },
          prompt: function(message, default_value) {
            return $B.jsobj2pyobj(window.prompt(message, default_value || ""));
          },
          reload: function() {
            var scripts = document.getElementsByTagName("script"), js_scripts = [];
            scripts.forEach(function(script) {
              if (script.type === void 0 || script.type == "text/javascript") {
                js_scripts.push(script);
                if (script.src) {
                  console.log(script.src);
                }
              }
            });
            for (var mod in $B.imported) {
              if ($B.imported[mod].$last_modified) {
                console.log("check", mod, $B.imported[mod].__file__, $B.imported[mod].$last_modified);
              } else {
                console.log("no date for mod", mod);
              }
            }
          },
          URLParameter: function(name2) {
            name2 = name2.replace(/[[]/, "\\[").replace(/[\]]/, "\\]");
            var regex = new RegExp("[\\?&]" + name2 + "=([^&#]*)"), results = regex.exec(location.search);
            results = results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
            return $B.builtins.str.$factory(results);
          }
        });
        modules["browser.html"] = (function($B2) {
          var _b_2 = $B2.builtins;
          var TagSum = $B2.TagSum;
          function makeTagDict(tagName2) {
            var dict = { __class__: _b_2.type, __name__: tagName2, __module__: "browser.html", __qualname__: tagName2 };
            dict.__init__ = function() {
              var $ns = $B2.args("__init__", 1, { self: null }, ["self"], arguments, {}, "args", "kw"), self2 = $ns["self"], args = $ns["args"];
              if (args.length == 1) {
                var first = args[0];
                if ($B2.$isinstance(first, [_b_2.str, _b_2.int, _b_2.float])) {
                  self2.innerHTML = _b_2.str.$factory(first);
                } else if (first.__class__ === TagSum) {
                  for (var i = 0, len = first.children.length; i < len; i++) {
                    self2.appendChild(first.children[i]);
                  }
                } else {
                  if ($B2.$isinstance(first, $B2.DOMNode)) {
                    self2.appendChild(first);
                  } else {
                    try {
                      var items = _b_2.list.$factory(first);
                      for (var item2 of items) {
                        $B2.DOMNode.__le__(self2, item2);
                      }
                    } catch (err) {
                      if ($B2.get_option("debug", err) > 1) {
                        console.log(err, err.__class__, err.args);
                        console.log("first", first);
                        console.log(arguments);
                      }
                      throw err;
                    }
                  }
                }
              }
              for (var item2 of _b_2.dict.$iter_items($ns.kw)) {
                var arg = item2.key, value2 = item2.value;
                if (arg.toLowerCase().substr(0, 2) == "on") {
                  $B2.DOMNode.__setattr__(self2, arg, value2);
                } else if (arg.toLowerCase() == "style") {
                  $B2.DOMNode.set_style(self2, value2);
                } else {
                  if (value2 !== false) {
                    try {
                      arg = $B2.imported["browser.html"].attribute_mapper(arg);
                      self2.setAttribute(arg, $B2.pyobj2jsobj(value2));
                    } catch (err) {
                      throw _b_2.ValueError.$factory(
                        "can't set attribute " + arg
                      );
                    }
                  }
                }
              }
            };
            dict.__mro__ = [$B2.DOMNode, $B2.builtins.object];
            dict.__new__ = function(cls) {
              var res = document.createElement(tagName2);
              if (cls !== html[tagName2]) {
                res.__class__ = cls;
              }
              return res;
            };
            dict.__rmul__ = function(self2, num) {
              return $B2.DOMNode.__mul__(self2, num);
            };
            $B2.set_func_names(dict, "browser.html");
            return dict;
          }
          function makeFactory(klass) {
            return /* @__PURE__ */ (function(k) {
              return function() {
                var res;
                if (k.__name__ == "SVG") {
                  res = $B2.DOMNode.$factory(
                    document.createElementNS("http://www.w3.org/2000/svg", "svg"),
                    true
                  );
                } else {
                  try {
                    res = document.createElement(k.__name__);
                  } catch (err) {
                    console.log("error " + err);
                    console.log("creating element", k.__name__);
                    throw err;
                  }
                }
                var init = $B2.$getattr(k, "__init__", null);
                if (init !== null) {
                  init(res, ...arguments);
                }
                return res;
              };
            })(klass);
          }
          var tags = [
            "A",
            "ABBR",
            "ACRONYM",
            "ADDRESS",
            "APPLET",
            "AREA",
            "B",
            "BASE",
            "BASEFONT",
            "BDO",
            "BIG",
            "BLOCKQUOTE",
            "BODY",
            "BR",
            "BUTTON",
            "CAPTION",
            "CENTER",
            "CITE",
            "CODE",
            "COL",
            "COLGROUP",
            "DD",
            "DEL",
            "DFN",
            "DIR",
            "DIV",
            "DL",
            "DT",
            "EM",
            "FIELDSET",
            "FONT",
            "FORM",
            "FRAME",
            "FRAMESET",
            "H1",
            "H2",
            "H3",
            "H4",
            "H5",
            "H6",
            "HEAD",
            "HR",
            "HTML",
            "I",
            "IFRAME",
            "IMG",
            "INPUT",
            "INS",
            "ISINDEX",
            "KBD",
            "LABEL",
            "LEGEND",
            "LI",
            "LINK",
            "MAP",
            "MENU",
            "META",
            "NOFRAMES",
            "NOSCRIPT",
            "OBJECT",
            "OL",
            "OPTGROUP",
            "OPTION",
            "P",
            "PARAM",
            "PRE",
            "Q",
            "S",
            "SAMP",
            "SCRIPT",
            "SELECT",
            "SMALL",
            "SPAN",
            "STRIKE",
            "STRONG",
            "STYLE",
            "SUB",
            "SUP",
            "SVG",
            "TABLE",
            "TBODY",
            "TD",
            "TEXTAREA",
            "TFOOT",
            "TH",
            "THEAD",
            "TITLE",
            "TR",
            "TT",
            "U",
            "UL",
            "VAR",
            "ARTICLE",
            "ASIDE",
            "AUDIO",
            "BDI",
            "CANVAS",
            "COMMAND",
            "DATA",
            "DATALIST",
            "EMBED",
            "FIGCAPTION",
            "FIGURE",
            "FOOTER",
            "HEADER",
            "KEYGEN",
            "MAIN",
            "MARK",
            "MATH",
            "METER",
            "NAV",
            "OUTPUT",
            "PROGRESS",
            "RB",
            "RP",
            "RT",
            "RTC",
            "RUBY",
            "SECTION",
            "SOURCE",
            "TEMPLATE",
            "TIME",
            "TRACK",
            "VIDEO",
            "WBR",
            "DETAILS",
            "DIALOG",
            "MENUITEM",
            "PICTURE",
            "SUMMARY"
          ];
          var html = {};
          html.tags = $B2.empty_dict();
          function maketag(tagName2, ComponentClass) {
            if (!(typeof tagName2 == "string")) {
              throw _b_2.TypeError.$factory("html.maketag expects a string as argument");
            }
            if (html[tagName2] !== void 0) {
              throw _b_2.ValueError.$factory("cannot reset class for " + tagName2);
            }
            var klass = makeTagDict(tagName2);
            klass.$factory = makeFactory(klass, ComponentClass);
            html[tagName2] = klass;
            _b_2.dict.$setitem(html.tags, tagName2, html[tagName2]);
            return klass;
          }
          for (var tagName of tags) {
            maketag(tagName);
          }
          html.maketag = maketag;
          html.attribute_mapper = function(attr) {
            return attr.replace(/_/g, "-");
          };
          return html;
        })(__BRYTHON__);
      }
      modules["browser"] = browser;
      $B.UndefinedType = $B.make_class(
        "UndefinedType",
        function() {
          return $B.Undefined;
        }
      );
      $B.UndefinedType.__mro__ = [_b_.object];
      $B.UndefinedType.__bool__ = function() {
        return false;
      };
      $B.UndefinedType.__repr__ = function() {
        return "<Javascript undefined>";
      };
      $B.UndefinedType.__str__ = $B.UndefinedType.__repr__;
      $B.Undefined = { __class__: $B.UndefinedType };
      $B.set_func_names($B.UndefinedType, "javascript");
      var super_class = $B.make_class(
        "JavascriptSuper",
        function() {
          var res = _b_.super.$factory();
          var js_constr = res.__thisclass__.__bases__[0];
          return function() {
            var obj = new js_constr.$js_func(...arguments);
            for (var attr in obj) {
              res.__self_class__.__dict__[attr] = $B.jsobj2pyobj(obj[attr]);
            }
            return obj;
          };
        }
      );
      super_class.__getattribute__ = function(self2, attr) {
        if (attr == "__init__" || attr == "__call__") {
          return self2.__init__;
        }
        return $B.$getattr(self2.__self_class__, attr);
      };
      $B.set_func_names(super_class, "javascript");
      modules["javascript"] = { "this": function() {
        if ($B.js_this === void 0) {
          return $B.builtins.None;
        }
        return $B.jsobj2pyobj($B.js_this);
      }, Array: $B.js_array, Date: self.Date && $B.jsobj2pyobj(self.Date), extends: function(js_constr) {
        if (!js_constr.$js_func || !js_constr.$js_func.toString().startsWith("class ")) {
          console.log(js_constr);
          throw _b_.TypeError.$factory(
            "argument of extend must be a Javascript class"
          );
        }
        js_constr.__class__ = _b_.type;
        return function(obj) {
          obj.__bases__.splice(0, 0, js_constr);
          obj.__mro__.splice(0, 0, js_constr);
          return obj;
        };
      }, import_js: function() {
        var $ = $B.args("import_js", 2, { url: null, alias: null }, ["url", "alias"], arguments, { alias: _b_.None }, null, null), url = $.url, alias = $.alias;
        var xhr = new XMLHttpRequest(), result;
        xhr.open("GET", url, false);
        xhr.onreadystatechange = function() {
          if (this.readyState == 4) {
            if (this.status == 200) {
              var js = this.responseText + "\nreturn $module", f = new Function(js);
              var $module = f();
              if (typeof $module !== "undefined") {
                result = $B.module.$factory(alias);
                for (var key2 in $module) {
                  result[key2] = $B.jsobj2pyobj($module[key2]);
                }
                result.__file__ = url;
              } else {
                console.log(this.responseText);
                result = _b_.ImportError.$factory(`Javascript module at ${url} doesn't define $module`);
              }
            } else {
              result = _b_.ModuleNotFoundError.$factory(url);
            }
          }
        };
        xhr.send();
        if ($B.$isinstance(result, _b_.BaseException)) {
          $B.handle_error(result);
        } else {
          if (alias === _b_.None) {
            var name2 = url.split(".");
            if (name2.length > 1) {
              name2.pop();
            }
            alias = name2.join(".");
            result.__name__ = alias;
          }
          $B.imported[alias] = result;
          var frame = $B.frame_obj.frame;
          frame[1][alias] = result;
        }
      }, import_modules: function(refs, callback, loaded) {
        if (loaded === void 0) {
          loaded = [];
        }
        if (!Array.isArray(refs)) {
          throw _b_.TypeError.$factory(
            `first argument must be a list, got ${$B.class_name(refs)}`
          );
        }
        if (refs.length > 1) {
          var ref = refs.shift();
          import(ref).then(function(module2) {
            loaded.push(module2);
            $B.imported.javascript.import_modules(refs, callback, loaded);
          }).catch($B.show_error);
        } else {
          import(refs[0]).then(function(module2) {
            loaded.push(module2);
            return $B.$call(callback).apply(null, loaded);
          }).catch($B.show_error);
        }
      }, import_scripts: function(refs, callback, loaded) {
        console.log("import scripts", refs);
        if (loaded === void 0) {
          loaded = [];
        }
        if (!Array.isArray(refs)) {
          throw _b_.TypeError.$factory(
            `first argument must be a list, got ${$B.class_name(refs)}`
          );
        }
        if (refs.length > 0) {
          var ref = refs.shift();
          var script = document.createElement("script");
          script.src = ref;
          script.addEventListener(
            "load",
            function() {
              loaded.push(script);
              $B.imported.javascript.import_scripts(refs, callback, loaded);
            }
          );
          document.body.appendChild(script);
        } else {
          return $B.$call(callback).apply(null, loaded);
        }
      }, JSObject: $B.JSObj, JSON: { __class__: $B.make_class("JSON"), parse: function() {
        return $B.structuredclone2pyobj(
          JSON.parse.apply(this, arguments)
        );
      }, stringify: function(obj, replacer, space) {
        return JSON.stringify($B.pyobj2structuredclone(obj, false), $B.jsobj2pyobj(replacer), space);
      } }, jsobj2pyobj: function(obj) {
        return $B.jsobj2pyobj(obj);
      }, load: function(script_url) {
        console.log('"javascript.load" is deprecrated. Use browser.load instead.');
        var file_obj = $B.builtins.open(script_url);
        var content = $B.$getattr(file_obj, "read")();
        eval(content);
      }, Math: self.Math && $B.jsobj2pyobj(self.Math), NULL: null, NullType: $B.make_class("NullType"), Number: self.Number && $B.jsobj2pyobj(self.Number), py2js: function(src, module_name) {
        if (module_name === void 0) {
          module_name = "__main__" + $B.UUID();
        }
        var js = $B.py2js({ src, filename: "<string>" }, module_name, module_name, $B.builtins_scope).to_js();
        return $B.format_indent(js, 0);
      }, pyobj2jsobj: function(obj) {
        return $B.pyobj2jsobj(obj);
      }, RegExp: self.RegExp && $B.jsobj2pyobj(self.RegExp), String: self.String && $B.jsobj2pyobj(self.String), "super": super_class, UNDEFINED: $B.Undefined, UndefinedType: $B.UndefinedType };
      modules.javascript.NullType.__module__ = "javascript";
      modules.javascript.NullType.__eq__ = function(_self, other) {
        return other === null || other === $B.Undefined;
      };
      modules.javascript.NullType.__repr__ = function(_self) {
        return "<Javascript null>";
      };
      $B.set_func_names(modules.javascript.NullType, "javascript");
      modules.javascript.UndefinedType.__module__ = "javascript";
      var $io = $B.$io = $B.make_class(
        "io",
        function(out) {
          return {
            __class__: $io,
            __dict__: $B.empty_dict(),
            out,
            encoding: "utf-8"
          };
        }
      );
      $io.flush = function(self2) {
        if (self2.buf) {
          var s = self2.buf.join(""), chr0 = String.fromCodePoint(0);
          s = s.replace(new RegExp(chr0, "g"), " ");
          console[self2.out](s);
          self2.buf = [];
        }
      };
      $io.write = function(self2, msg) {
        if (self2.buf === void 0) {
          self2.buf = [];
        }
        if (typeof msg != "string") {
          throw _b_.TypeError.$factory("write() argument must be str, not " + $B.class_name(msg));
        }
        self2.buf.push(msg);
        return _b_.None;
      };
      modules["_sys"] = { _getframe: function() {
        var $ = $B.args("_getframe", 1, { depth: null }, ["depth"], arguments, { depth: 0 }, null, null), depth = $.depth, frame_obj = $B.frame_obj;
        for (var i = 0; i < depth; i++) {
          frame_obj = frame_obj.prev;
        }
        var res = frame_obj.frame;
        res.$pos = $B.count_frames() - depth - 1;
        return res;
      }, breakpointhook: function() {
        var hookname = $B.$options.breakpoint, modname, dot, funcname, hook;
        if (hookname === void 0) {
          hookname = "pdb.set_trace";
        }
        [modname, dot, funcname] = _b_.str.rpartition(hookname, ".");
        if (dot == "") {
          modname = "builtins";
        }
        try {
          $B.$import(modname);
          hook = $B.$getattr($B.imported[modname], funcname);
        } catch (err) {
          console.warn("cannot import breakpoint", hookname);
          return _b_.None;
        }
        return $B.$call(hook).apply(null, arguments);
      }, exc_info: function() {
        var frame_obj = $B.frame_obj, frame, exc;
        while (frame_obj !== null) {
          frame = frame_obj.frame;
          exc = frame[1].$current_exception;
          if (exc) {
            return _b_.tuple.$factory([exc.__class__, exc, $B.$getattr(exc, "__traceback__")]);
          }
          frame_obj = frame_obj.prev;
        }
        return _b_.tuple.$factory([_b_.None, _b_.None, _b_.None]);
      }, excepthook: function(exc_class, exc_value) {
        $B.show_error(exc_value);
      }, exception: function() {
        var frame_obj = $B.frame_obj, frame, exc;
        while (frame_obj !== null) {
          frame = frame_obj.frame;
          exc = frame[1].$current_exception;
          if (exc !== void 0) {
            return exc;
          }
          frame_obj = frame_obj.prev;
        }
        return _b_.None;
      }, executable: $B.strip_host($B.brython_path + "brython.js"), float_repr_style: "short", getdefaultencoding: function() {
        return "utf-8";
      }, getrecursionlimit: function() {
        return $B.recursion_limit;
      }, getrefcount: function() {
        return 0;
      }, gettrace: function() {
        return $B.tracefunc || _b_.None;
      }, getunicodeinternedsize: function() {
        return 0;
      }, last_exc: _b_.property.$factory(
        function() {
          return $B.imported._sys.exception();
        },
        function(value2) {
          $B.frame_obj.frame.$current_exception = value2;
        }
      ), modules: _b_.property.$factory(
        function() {
          return $B.obj_dict($B.imported);
        },
        function() {
          throw _b_.TypeError.$factory("Read only property 'sys.modules'");
        }
      ), path: _b_.property.$factory(
        function() {
          var filename = $B.get_filename_for_import();
          return $B.$list($B.import_info[filename].path);
        },
        function(self2, value2) {
          var filename = $B.get_filename_for_import();
          $B.import_info[filename].path = value2;
        }
      ), meta_path: _b_.property.$factory(
        function() {
          var filename = $B.get_filename();
          return $B.$list($B.import_info[filename].meta_path);
        },
        function(self2, value2) {
          var filename = $B.get_filename();
          $B.import_info[filename].meta_path = value2;
        }
      ), path_hooks: _b_.property.$factory(
        function() {
          var filename = $B.get_filename();
          return $B.$list($B.import_info[filename].path_hooks);
        },
        function(self2, value2) {
          var filename = $B.get_filename();
          $B.import_info[filename].path_hooks = value2;
        }
      ), path_importer_cache: _b_.property.$factory(
        function() {
          return _b_.dict.$factory($B.jsobj2pyobj($B.path_importer_cache));
        },
        function() {
          throw _b_.TypeError.$factory("Read only property 'sys.path_importer_cache'");
        }
      ), setrecursionlimit: function(value2) {
        $B.recursion_limit = value2;
      }, settrace: function() {
        var $ = $B.args("settrace", 1, { tracefunc: null }, ["tracefunc"], arguments, {}, null, null);
        $B.tracefunc = $.tracefunc;
        $B.frame_obj.frame.$f_trace = $B.tracefunc;
        $B.tracefunc.$current_frame_id = $B.frame_obj.frame[0];
        return _b_.None;
      }, stderr: console.error !== void 0 ? $io.$factory("error") : $io.$factory("log"), stdout: $io.$factory("log"), stdin: _b_.property.$factory(
        function() {
          return $B.stdin;
        },
        function(self2, value2) {
          $B.stdin = value2;
        }
      ), vfs: _b_.property.$factory(
        function() {
          if ($B.hasOwnProperty("VFS")) {
            return $B.obj_dict($B.VFS);
          } else {
            return _b_.None;
          }
        },
        function() {
          throw _b_.TypeError.$factory("Read only property 'sys.vfs'");
        }
      ) };
      var WarningMessage = $B.make_class(
        "WarningMessage",
        function() {
          var $ = $B.make_args("WarningMessage", 8, { message: null, category: null, filename: null, lineno: null, file: null, line: null, source: null }, ["message", "category", "filename", "lineno", "file", "line", "source"], arguments, { file: _b_.None, line: _b_.None, source: _b_.None }, null, null);
          return {
            __class__: WarningMessage,
            message: $.message,
            category: $.category,
            filename: $.filename,
            lineno: $.lineno,
            file: $.file,
            line: $.line,
            source: $.source,
            _category_name: _b_.bool.$factory($.category) ? $B.$getattr($.category, "__name__") : _b_.None
          };
        }
      );
      modules._warnings = { _defaultaction: "default", _filters_mutated: function() {
      }, _onceregistry: $B.empty_dict(), filters: $B.$list([
        $B.fast_tuple(["default", _b_.None, _b_.DeprecationWarning, "__main__", 0]),
        $B.fast_tuple(["ignore", _b_.None, _b_.DeprecationWarning, _b_.None, 0]),
        $B.fast_tuple(["ignore", _b_.None, _b_.PendingDeprecationWarning, _b_.None, 0]),
        $B.fast_tuple(["ignore", _b_.None, _b_.ImportWarning, _b_.None, 0]),
        $B.fast_tuple(["ignore", _b_.None, _b_.ResourceWarning, _b_.None, 0])
      ]), warn: function() {
        var $ = $B.args("warn", 4, { message: null, category: null, stacklevel: null, source: null }, ["message", "category", "stacklevel", "source"], arguments, { category: _b_.UserWarning, stacklevel: 1, source: _b_.None }, null, null), message = $.message, category = $.category, stacklevel = $.stacklevel;
        if ($B.$isinstance(message, _b_.Warning)) {
          category = $B.get_class(message);
        }
        var filters;
        if ($B.imported.warnings) {
          filters = $B.imported.warnings.filters;
        } else {
          filters = modules._warnings.filters;
        }
        if (filters[0][0] == "error") {
          var syntax_error = _b_.SyntaxError.$factory(message.args[0]);
          syntax_error.args[1] = [message.filename, message.lineno, message.offset, message.line];
          syntax_error.filename = message.filename;
          syntax_error.lineno = message.lineno;
          syntax_error.offset = message.offset;
          syntax_error.line = message.line;
          throw syntax_error;
        }
        var warning_message, filename, file, lineno, line;
        if (category === _b_.SyntaxWarning) {
          filename = message.filename, lineno = message.lineno, line = message.text;
          var src = $B.file_cache[file];
          if (src) {
            var lines = src.split("\n"), line = lines[lineno - 1];
          }
          warning_message = { __class__: WarningMessage, message, category, filename, lineno, file: _b_.None, line, source: _b_.None, _category_name: category.__name__ };
        } else {
          let frame_rank = Math.max(0, $B.count_frames() - stacklevel);
          var frame = $B.get_frame_at(frame_rank);
          file = frame.__file__;
          let f_code = $B._frame.f_code.__get__(frame), src2 = $B.file_cache[file];
          lineno = message.lineno || frame.$lineno;
          line = src2 ? src2.split("\n")[lineno - 1] : null;
          warning_message = { __class__: WarningMessage, message, category, filename: message.filename || f_code.co_filename, lineno, file: _b_.None, line: line || _b_.None, source: _b_.None, _category_name: category.__name__ };
        }
        if ($B.imported.warnings) {
          $B.imported.warnings._showwarnmsg_impl(warning_message);
        } else {
          var trace = "";
          if (file && lineno) {
            trace += `${file}:${lineno}: `;
          }
          trace += $B.class_name(message) + ": " + message.args[0];
          if (line) {
            trace += "\n    " + line.trim();
          }
          var stderr2 = $B.get_stderr();
          $B.$getattr(stderr2, "write")(trace + "\n");
          var flush = $B.$getattr(stderr2, "flush", _b_.None);
          if (flush !== _b_.None) {
            flush();
          }
        }
        return _b_.None;
      }, warn_explicit: function() {
        console.log("warn_explicit", arguments);
      } };
      var MAX_CANDIDATE_ITEMS = 750, MOVE_COST = 2, CASE_COST = 1, SIZE_MAX = 65535;
      function LEAST_FIVE_BITS(n) {
        return n & 31;
      }
      function levenshtein_distance(a, b, max_cost) {
        if (a == b) {
          return 0;
        }
        if (a.length < b.length) {
          [a, b] = [b, a];
        }
        while (a.length && a[0] == b[0]) {
          a = a.substr(1);
          b = b.substr(1);
        }
        while (a.length && a[a.length - 1] == b[b.length - 1]) {
          a = a.substr(0, a.length - 1);
          b = b.substr(0, b.length - 1);
        }
        if (b.length == 0) {
          return a.length * MOVE_COST;
        }
        if ((b.length - a.length) * MOVE_COST > max_cost) {
          return max_cost + 1;
        }
        var buffer = [];
        for (var i = 0; i < a.length; i++) {
          buffer[i] = (i + 1) * MOVE_COST;
        }
        var result = 0;
        for (var b_index = 0; b_index < b.length; b_index++) {
          var code = b[b_index];
          var distance = result = b_index * MOVE_COST;
          var minimum = SIZE_MAX;
          for (var index = 0; index < a.length; index++) {
            var substitute = distance + substitution_cost(code, a[index]);
            distance = buffer[index];
            var insert_delete = Math.min(result, distance) + MOVE_COST;
            result = Math.min(insert_delete, substitute);
            buffer[index] = result;
            if (result < minimum) {
              minimum = result;
            }
          }
          if (minimum > max_cost) {
            return max_cost + 1;
          }
        }
        return result;
      }
      function substitution_cost(a, b) {
        if (LEAST_FIVE_BITS(a) != LEAST_FIVE_BITS(b)) {
          return MOVE_COST;
        }
        if (a == b) {
          return 0;
        }
        if (a.toLowerCase() == b.toLowerCase()) {
          return CASE_COST;
        }
        return MOVE_COST;
      }
      modules["_suggestions"] = { _generate_suggestions: function(dir, name2) {
        if (dir.length >= MAX_CANDIDATE_ITEMS) {
          return null;
        }
        var suggestion_distance = 2 ** 52, suggestion = null;
        for (var item2 of dir) {
          var max_distance = (name2.length + item2.length + 3) * MOVE_COST / 6;
          max_distance = Math.min(max_distance, suggestion_distance - 1);
          var current_distance = levenshtein_distance(name2, item2, max_distance);
          if (current_distance > max_distance) {
            continue;
          }
          if (!suggestion || current_distance < suggestion_distance) {
            suggestion = item2;
            suggestion_distance = current_distance;
          }
        }
        if (suggestion == name2) {
          return null;
        }
        return suggestion;
      } };
      var responseType = { "text": "text", "binary": "arraybuffer", "dataURL": "arraybuffer" };
      function handle_kwargs(kw, method) {
        var result = { cache: false, format: "text", mode: "text", headers: {} };
        for (let item2 of _b_.dict.$iter_items(kw)) {
          let key2 = item2.key, value2 = item2.value;
          if (key2 == "data") {
            var params = value2;
            if (typeof params == "string" || params instanceof FormData) {
              result.body = params;
            } else if ($B.$isinstance(params, _b_.bytes)) {
              result.body = new ArrayBuffer(params.source.length);
              var array = new Int8Array(data);
              for (let i = 0, len = params.source.length; i < len; i++) {
                array[i] = params.source[i];
              }
            } else {
              if (params.__class__ !== _b_.dict) {
                throw _b_.TypeError.$factory("wrong type for data, expected dict, bytes or str, got " + $B.class_name(params));
              }
              var items = [];
              for (let subitem of _b_.dict.$iter_items(params)) {
                items.push(encodeURIComponent(subitem.key) + "=" + encodeURIComponent($B.pyobj2jsobj(subitem.value)));
              }
              result.body = items.join("&");
            }
          } else if (key2 == "headers") {
            if (!$B.$isinstance(value2, _b_.dict)) {
              throw _b_.ValueError.$factory(
                "headers must be a dict, not " + $B.class_name(value2)
              );
            }
            for (let subitem of _b_.dict.$iter_items(value2)) {
              result.headers[subitem.key.toLowerCase()] = subitem.value;
            }
          } else if (["cache", "format", "mode"].includes(key2)) {
            result[key2] = value2;
          }
        }
        if (method == "post") {
          if (!result.headers.hasOwnProperty("content-type")) {
            result.headers["Content-Type"] = "application/x-www-form-urlencoded";
          }
        }
        return result;
      }
      var HTTPRequest = $B.make_class("Request");
      HTTPRequest.data = _b_.property.$factory(function(self2) {
        if (self2.format == "binary") {
          var view = new Uint8Array(self2.response);
          return _b_.bytes.$factory(Array.from(view));
        } else if (self2.format == "text") {
          return self2.responseText;
        } else if (self2.format == "dataURL") {
          var base64String = btoa(String.fromCharCode.apply(null, new Uint8Array(self2.response)));
          return "data:" + self2.getResponseHeader("Content-Type") + ";base64," + base64String;
        }
      });
      HTTPRequest.response_headers = _b_.property.$factory(function(self2) {
        var headers = self2.getAllResponseHeaders();
        if (headers === null) {
          return _b_.None;
        }
        var res = $B.empty_dict();
        if (headers.length > 0) {
          var lines = headers.trim().split(/[\r\n]+/);
          lines.forEach(function(line) {
            var parts = line.split(": ");
            var header = parts.shift();
            var value2 = parts.join(": ");
            _b_.dict.$setitem(res, header, value2);
          });
        }
        return res;
      });
      var Future = $B.make_class(
        "Future",
        function() {
          var methods = {};
          var promise = new Promise(function(resolve, reject) {
            methods.resolve = resolve;
            methods.reject = reject;
          });
          promise._methods = methods;
          promise._done = false;
          promise.__class__ = Future;
          return promise;
        }
      );
      Future.done = function() {
        var $ = $B.args("done", 1, { self: null }, ["self"], arguments, {}, null, null);
        return !!$.self._done;
      };
      Future.set_result = function() {
        var $ = $B.args("set_result", 2, { self: null, value: null }, ["self", "value"], arguments, {}, null, null);
        $.self._done = true;
        $.self._methods.resolve($.value);
        return _b_.None;
      };
      Future.set_exception = function() {
        var $ = $B.args("set_exception", 2, { self: null, exception: null }, ["self", "exception"], arguments, {}, null, null);
        $.self._done = true;
        $.self._methods.reject($.exception);
        return _b_.None;
      };
      $B.set_func_names(Future, "browser.aio");
      modules["browser.aio"] = { ajax: function() {
        var $ = $B.args("ajax", 2, { method: null, url: null }, ["method", "url"], arguments, {}, null, "kw"), method = $.method.toUpperCase(), url = $.url, kw = $.kw;
        var args = handle_kwargs(kw, "get");
        if (method == "GET" && !args.cache) {
          url = url + "?ts" + (/* @__PURE__ */ new Date()).getTime() + "=0";
        }
        if (args.body && method == "GET") {
          url = url + (args.cache ? "?" : "&") + args.body;
        }
        var func = function() {
          return new Promise(function(resolve) {
            var xhr = new XMLHttpRequest();
            xhr.open(method, url, true);
            for (var key2 in args.headers) {
              xhr.setRequestHeader(key2, args.headers[key2]);
            }
            xhr.format = args.format;
            xhr.responseType = responseType[args.format];
            xhr.onreadystatechange = function() {
              if (this.readyState == 4) {
                this.__class__ = HTTPRequest;
                resolve(this);
              }
            };
            if (args.body && ["POST", "PUT", "DELETE", "PATCH"].indexOf(method) > -1) {
              xhr.send(args.body);
            } else {
              xhr.send();
            }
          });
        };
        func.$infos = { __name__: "ajax_" + method };
        func.$function_infos = [];
        func.$function_infos[$B.func_attrs.name] = `ajax_${method}`;
        return {
          __class__: $B.coroutine,
          $args: [url, args],
          $func: func
        };
      }, event: function() {
        var $ = $B.args("event", 1, { element: null }, ["element"], arguments, {}, "names", null), element = $.element, names = $.names;
        return new Promise(function(resolve) {
          var callbacks = [];
          names.forEach(function(name2) {
            var callback = function(evt) {
              callbacks.forEach(function(items) {
                $B.DOMNode.unbind(element, items[0], items[1]);
              });
              resolve($B.$DOMEvent(evt));
            };
            callbacks.push([name2, callback]);
            $B.DOMNode.bind(element, name2, callback);
          });
        });
      }, get: function() {
        return $B.imported["browser.aio"].ajax.bind(null, "GET").apply(null, arguments);
      }, iscoroutine: function(f) {
        return f.__class__ === $B.coroutine;
      }, iscoroutinefunction: function(f) {
        return (f.$function_infos[$B.func_attrs.flags] & 128) != 0;
      }, post: function() {
        return $B.imported["browser.aio"].ajax.bind(null, "POST").apply(null, arguments);
      }, run: function() {
        var handle_success = function() {
          $B.leave_frame();
        }, handle_error = $B.show_error;
        var $ = $B.args("run", 3, { coro: null, onsuccess: null, onerror: null }, ["coro", "onsuccess", "onerror"], arguments, { onsuccess: handle_success, onerror: handle_error }, null, null), coro = $.coro, onsuccess = $.onsuccess, onerror = $.onerror;
        var save_frame_obj = $B.frame_obj;
        $B.coroutine.send(coro).then(onsuccess).catch(onerror);
        $B.frame_obj = save_frame_obj;
        return _b_.None;
      }, sleep: function(seconds) {
        if (seconds.__class__ === _b_.float) {
          seconds = seconds.value;
        } else if (typeof seconds != "number") {
          throw _b_.TypeError.$factory("'sleep' argument must be int or float, not " + $B.class_name(seconds));
        }
        var func = function() {
          return new Promise((resolve) => setTimeout(
            function() {
              resolve(_b_.None);
            },
            1e3 * seconds
          ));
        };
        func.$infos = { __name__: "sleep" };
        func.$function_infos = [];
        func.$function_infos[$B.func_attrs.name] = "sleep";
        return {
          __class__: $B.coroutine,
          $args: [seconds],
          $func: func
        };
      }, Future, __getattr__: function(attr) {
        $B.$import("_aio");
        return $B.$getattr($B.imported._aio, attr);
      } };
      function load(name2, module_obj) {
        module_obj.__class__ = $B.module;
        module_obj.__name__ = name2;
        $B.imported[name2] = module_obj;
        for (var attr in module_obj) {
          if (typeof module_obj[attr] == "function") {
            module_obj[attr].$infos = { __module__: name2, __name__: attr, __qualname__: name2 + "." + attr };
            $B.set_function_infos(
              module_obj[attr],
              { __module__: name2, __name__: attr, __qualname__: name2 + "." + attr }
            );
          }
        }
      }
      for (let attr in modules) {
        load(attr, modules[attr]);
      }
      if (!($B.isWebWorker || $B.isNode)) {
        modules["browser"].html = modules["browser.html"];
        modules["browser"].aio = modules["browser.aio"];
      }
      _b_.__builtins__ = $B.module.$factory("__builtins__", "Python builtins");
      for (let attr in _b_) {
        _b_.__builtins__[attr] = _b_[attr];
        $B.builtins_scope.binding[attr] = true;
        if (_b_[attr].$is_class) {
          if (_b_[attr].__bases__) {
            _b_[attr].__bases__.__class__ = _b_.tuple;
          } else {
            _b_[attr].__bases__ = $B.fast_tuple([_b_.object]);
          }
        }
      }
      _b_.__builtins__.__setattr__ = function(attr, value2) {
        _b_[attr] = value2;
      };
      $B.method_descriptor.__getattribute__ = $B.function.__getattribute__;
      $B.wrapper_descriptor.__getattribute__ = $B.function.__getattribute__;
      _b_.type.__dict__ = $B.mappingproxy.$factory(_b_.type.__dict__);
      for (var name in _b_) {
        var builtin = _b_[name];
        if (_b_[name].__class__ === _b_.type) {
          _b_[name].__qualname__ = _b_[name].__qualname__ ?? name;
          _b_[name].__module__ = "builtins";
          _b_[name].__name__ = _b_[name].__name__ ?? name;
          _b_[name].$is_builtin_class = true;
          $B.builtin_classes.push(_b_[name]);
          for (var key in _b_[name]) {
            var value = _b_[name][key];
            if (value === void 0 || value.__class__ || typeof value != "function") {
              continue;
            } else if (key == "__new__") {
              value.__class__ = $B.builtin_function_or_method;
            } else if (key.startsWith("__")) {
              value.__class__ = $B.wrapper_descriptor;
            } else {
              value.__class__ = $B.method_descriptor;
            }
            value.__objclass__ = _b_[name];
          }
        } else if (typeof builtin == "function") {
          builtin.$infos = { __name__: name, __qualname__: name, __dict__: $B.empty_dict() };
          $B.set_function_infos(
            builtin,
            { __name__: name, __qualname__: name }
          );
        }
      }
      for (let attr in $B) {
        if (Array.isArray($B[attr])) {
          $B[attr].__class__ = _b_.list;
        }
      }
      $B.cell = $B.make_class(
        "cell",
        function(value2) {
          return {
            __class__: $B.cell,
            $cell_contents: value2
          };
        }
      );
      $B.cell.cell_contents = $B.$call(_b_.property)(
        function(self2) {
          if (self2.$cell_contents === null) {
            throw _b_.ValueError.$factory("empty cell");
          }
          return self2.$cell_contents;
        },
        function(self2, value2) {
          self2.$cell_contents = value2;
        }
      );
      var $comps = Object.values($B.$comps).concat(["eq", "ne"]);
      $comps.forEach(function(comp) {
        var op = "__" + comp + "__";
        $B.cell[op] = /* @__PURE__ */ (function(op2) {
          return function(self2, other) {
            if (!$B.$isinstance(other, $B.cell)) {
              return _b_.NotImplemented;
            }
            if (self2.$cell_contents === null) {
              if (other.$cell_contents === null) {
                return op2 == "__eq__";
              } else {
                return ["__ne__", "__lt__", "__le__"].indexOf(op2) > -1;
              }
            } else if (other.$cell_contents === null) {
              return ["__ne__", "__gt__", "__ge__"].indexOf(op2) > -1;
            }
            return $B.rich_comp(op2, self2.$cell_contents, other.$cell_contents);
          };
        })(op);
      });
      $B.set_func_names($B.cell, "builtins");
      for (let flag in $B.builtin_class_flags.builtins) {
        for (let key2 of $B.builtin_class_flags.builtins[flag]) {
          if (_b_[key2]) {
            _b_[key2].__flags__ = parseInt(flag);
          } else {
            console.log("not in _b_", key2);
          }
        }
      }
      for (let flag in $B.builtin_class_flags.types) {
        for (let key2 of $B.builtin_class_flags.types[flag]) {
          if ($B[key2]) {
            $B[key2].__flags__ = parseInt(flag);
          }
        }
      }
      $B.AST = { __class__: _b_.type, __mro__: [_b_.object], __name__: "AST", __qualname__: "AST", $is_class: true, $convert: function(js_node) {
        if (js_node === void 0) {
          return _b_.None;
        }
        var constr = js_node.constructor;
        if (constr && constr.$name) {
          $B.create_python_ast_classes();
          return $B.python_ast_classes[constr.$name].$factory(js_node);
        } else if (Array.isArray(js_node)) {
          return js_node.map($B.AST.$convert);
        } else if (js_node.type) {
          switch (js_node.type) {
            case "int":
              var value2 = js_node.value[1], base = js_node.value[0];
              var res = parseInt(value2, base);
              if (!Number.isSafeInteger(res)) {
                res = $B.long_int.$factory(value2, base);
              }
              return res;
            case "float":
              return $B.fast_float(parseFloat(js_node.value));
            case "imaginary":
              return $B.make_complex(0, $B.AST.$convert(js_node.value));
            case "ellipsis":
              return _b_.Ellipsis;
            case "str":
              if (js_node.is_bytes) {
                return _b_.bytes.$factory(js_node.value, "latin-1");
              }
              return js_node.value;
            case "id":
              if (["False", "None", "True"].indexOf(js_node.value) > -1) {
                return _b_[js_node.value];
              }
              break;
          }
        } else if (["string", "number"].indexOf(typeof js_node) > -1) {
          return js_node;
        } else if (js_node.$name) {
          return js_node.$name + "()";
        } else if ([_b_.None, _b_.True, _b_.False].indexOf(js_node) > -1) {
          return js_node;
        } else if (js_node.__class__) {
          return js_node;
        } else {
          console.log("cannot handle", js_node);
          return js_node;
        }
      } };
      $B.stdin = { __class__: $io, __original__: true, closed: false, len: 1, pos: 0, read: function() {
        return "";
      }, readline: function() {
        return "";
      } };
      $B.__ARGV = $B.$list([]);
      $B.tracefunc = _b_.None;
      $B.function.__dict__ = $B.obj_dict($B.function.__dict__);
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      function ast_dump(tree, indent2) {
        var attr, value2;
        indent2 = indent2 || 0;
        if (tree === _b_2.None) {
          return "None";
        } else if (typeof tree == "string") {
          return `'${tree}'`;
        } else if (typeof tree == "number") {
          return tree + "";
        } else if (tree.imaginary) {
          return tree.value + "j";
        } else if (Array.isArray(tree)) {
          if (tree.length == 0) {
            return "[]";
          }
          res = "[\n";
          var items = [];
          for (var x of tree) {
            try {
              items.push(ast_dump(x, indent2 + 1));
            } catch (err) {
              console.log("error", tree);
              console.log("for item", x);
              throw err;
            }
          }
          res += items.join(",\n");
          return res + "]";
        } else if (tree.$name) {
          return tree.$name + "()";
        } else if (tree instanceof $B2.ast.MatchSingleton) {
          return `MatchSingleton(value=${$B2.AST.$convert(tree.value)})`;
        } else if (tree instanceof $B2.ast.Constant) {
          value2 = tree.value;
          if (value2.imaginary) {
            return `Constant(value=${_b_2.repr(value2.value)}j)`;
          }
          return `Constant(value=${$B2.AST.$convert(value2)})`;
        }
        var proto = Object.getPrototypeOf(tree).constructor;
        var res = "  ".repeat(indent2) + proto.$name + "(";
        if ($B2.ast_classes[proto.$name] === void 0) {
          console.log("no ast class", proto);
        }
        var attr_names = $B2.ast_classes[proto.$name].split(","), attrs = [];
        attr_names = attr_names.map((x2) => x2.endsWith("*") || x2.endsWith("?") ? x2.substr(0, x2.length - 1) : x2);
        if ([$B2.ast.Name].indexOf(proto) > -1) {
          for (attr of attr_names) {
            if (tree[attr] !== void 0) {
              attrs.push(`${attr}=${ast_dump(tree[attr])}`);
            }
          }
          return res + attrs.join(", ") + ")";
        }
        for (attr of attr_names) {
          if (tree[attr] !== void 0) {
            value2 = tree[attr];
            attrs.push(attr + "=" + ast_dump(tree[attr], indent2 + 1).trimStart());
          }
        }
        if (attrs.length > 0) {
          res += "\n";
          res += attrs.map((x2) => "  ".repeat(indent2 + 1) + x2).join(",\n");
        }
        res += ")";
        return res;
      }
      function string_from_ast_value(value2) {
        return value2.replace(new RegExp("\\\\'", "g"), "'");
      }
      function compiler_error(ast_obj, message, end) {
        prefix = "";
        var exc = _b_2.SyntaxError.$factory(message);
        exc.filename = state.filename;
        if (exc.filename != "<string>") {
          var src = $B2.file_cache[exc.filename], lines = src.split("\n"), line = lines[ast_obj.lineno - 1];
          exc.text = line;
        } else {
          exc.text = _b_2.None;
        }
        exc.lineno = ast_obj.lineno;
        exc.offset = ast_obj.col_offset + 1;
        end = end || ast_obj;
        exc.end_lineno = end.end_lineno;
        exc.end_offset = end.end_col_offset + 1;
        exc.args[1] = [exc.filename, exc.lineno, exc.offset, exc.text, exc.end_lineno, exc.end_offset];
        exc.__traceback__ = $B2.make_tb();
        throw exc;
      }
      var uuid = Math.floor(Math.random() * 1e6);
      function make_id() {
        uuid += 1;
        return uuid;
      }
      function fast_id(obj) {
        if (obj.$id !== void 0) {
          return obj.$id;
        }
        return obj.$id = make_id();
      }
      function copy_position(target, origin) {
        target.lineno = origin.lineno;
        target.col_offset = origin.col_offset;
        target.end_lineno = origin.end_lineno;
        target.end_col_offset = origin.end_col_offset;
      }
      $B2.copy_position = copy_position;
      function encode_position(lineno, end_lineno, col_offset, end_col_offset) {
        var res;
        if (end_lineno == lineno) {
          res = `[${lineno},${col_offset},${end_col_offset - col_offset}]`;
        } else {
          res = `[${lineno},${end_lineno},${col_offset},${end_col_offset}]`;
        }
        return res;
      }
      $B2.decode_position = function(pos2) {
        if (pos2.length == 3) {
          return [pos2[0], pos2[0], pos2[1], pos2[1] + pos2[2]];
        } else {
          return pos2;
        }
      };
      function get_source_from_position(scopes, ast_obj) {
        scopes.lines = scopes.lines ?? scopes.src.split("\n");
        var lines = scopes.lines, start_line = lines[ast_obj.lineno - 1], res;
        if (ast_obj.end_lineno == ast_obj.lineno) {
          res = start_line.substring(ast_obj.col_offset, ast_obj.end_col_offset);
        } else {
          var res = start_line.substr(ast_obj.col_offset), line_num = ast_obj.lineno + 1;
          while (line_num < ast_obj.end_lineno) {
            res += lines[line_num - 1].trimLeft();
            line_num++;
          }
          res += lines[ast_obj.end_lineno - 1].substr(0, ast_obj.end_col_offset).trimLeft();
        }
        return res.replace(new RegExp("'", "g"), "\\'");
      }
      function get_names(ast_obj) {
        var res = /* @__PURE__ */ new Set();
        if (ast_obj instanceof $B2.ast.Name) {
          res.add(ast_obj);
        } else if (ast_obj instanceof $B2.ast.Subscript) {
          for (var item2 of get_names(ast_obj.value)) {
            res.add(item2);
          }
        }
        return res;
      }
      function last_scope(scopes) {
        var ix = scopes.length - 1;
        while (scopes[ix].parent) {
          ix--;
        }
        return scopes[ix];
      }
      function Scope(name3, type, ast) {
        this.name = name3;
        this.locals = /* @__PURE__ */ new Set();
        this.globals = /* @__PURE__ */ new Set();
        this.nonlocals = /* @__PURE__ */ new Set();
        this.freevars = /* @__PURE__ */ new Set();
        this.type = type;
        this.ast = ast;
      }
      function copy_scope(scope, ast, id) {
        var new_scope = new Scope(scope.name, scope.type, ast);
        if (id !== void 0) {
          new_scope.id = id;
        }
        new_scope.parent = scope;
        return new_scope;
      }
      function qualified_scope_name(scopes, scope) {
        if (scope !== void 0 && !(scope instanceof Scope)) {
          console.log("bizarre", scope);
          throw Error("scope étrange");
        }
        var _scopes;
        if (!scope) {
          _scopes = scopes.slice();
        } else {
          var ix = scopes.indexOf(scope);
          if (ix > -1) {
            _scopes = scopes.slice(0, ix + 1);
          } else {
            _scopes = scopes.concat(scope);
          }
        }
        var names = [];
        for (var _scope of _scopes) {
          if (!_scope.parent) {
            names.push(_scope.name);
          }
        }
        return names.join("_").replace(/\./g, "_");
      }
      function module_name(scopes) {
        var _scopes = scopes.slice();
        var names = [];
        for (var _scope of _scopes) {
          if (!_scope.parent) {
            names.push(_scope.name);
          }
        }
        return names.join(".");
      }
      function make_scope_name(scopes, scope) {
        if (scope === builtins_scope) {
          return `_b_`;
        }
        return "locals_" + qualified_scope_name(scopes, scope);
      }
      function make_search_namespaces(scopes) {
        var namespaces = [];
        for (var scope of scopes.slice().reverse()) {
          if (scope.parent || scope.type == "class") {
            continue;
          } else if (scope.is_exec_scope) {
            namespaces.push("$B.exec_scope");
          }
          namespaces.push(make_scope_name(scopes, scope));
        }
        namespaces.push("_b_");
        return namespaces;
      }
      function mangle(scopes, scope, name3) {
        if (name3.startsWith("__") && !name3.endsWith("__")) {
          var ix = scopes.indexOf(scope);
          while (ix >= 0) {
            if (scopes[ix].ast instanceof $B2.ast.ClassDef) {
              var scope_name = scopes[ix].name;
              while (scope_name.length > 0 && scope_name.startsWith("_")) {
                scope_name = scope_name.substr(1);
              }
              if (scope_name.length == 0) {
                return name3;
              }
              return "_" + scope_name + name3;
            }
            ix--;
          }
        }
        return name3;
      }
      function reference(scopes, scope, name3) {
        return make_scope_name(scopes, scope) + "." + mangle(scopes, scope, name3);
      }
      function bind(name3, scopes) {
        var scope = $B2.last(scopes), up_scope = last_scope(scopes);
        name3 = mangle(scopes, up_scope, name3);
        if (up_scope.globals && up_scope.globals.has(name3)) {
          scope = scopes[0];
        } else if (up_scope.nonlocals.has(name3)) {
          for (var i = scopes.indexOf(up_scope) - 1; i >= 0; i--) {
            if (scopes[i].locals.has(name3) || scopes[i].maybe_locals && scopes[i].maybe_locals.has(name3)) {
              return scopes[i];
            }
          }
        }
        scope.locals.add(name3);
        if (up_scope.type == "class" || up_scope !== scope) {
          up_scope.maybe_locals = up_scope.maybe_locals ?? /* @__PURE__ */ new Set();
          up_scope.maybe_locals.add(name3);
        }
        return scope;
      }
      var SF = $B2.SYMBOL_FLAGS;
      function name_reference(name3, scopes, ast_obj) {
        var scope = name_scope(name3, scopes);
        return make_ref(name3, scopes, scope, ast_obj);
      }
      function make_ref(name3, scopes, scope, ast_obj) {
        var test = false;
        if (test) {
          console.log("make ref", name3, scopes.slice(), scope);
        }
        if (scope.found) {
          var res = reference(scopes, scope.found, name3);
          if (test) {
            console.log("res", res);
          }
          return res;
        } else {
          var inum = add_to_positions(scopes, ast_obj);
          if (scope.resolve == "all") {
            var scope_names = make_search_namespaces(scopes);
            return `$B.resolve_in_scopes('${name3}', [${scope_names}], ${inum})`;
          } else if (scope.resolve == "local") {
            return `$B.resolve_local('${name3}', ${inum})`;
          } else if (scope.resolve == "global") {
            return `$B.resolve_global('${name3}', _frame_obj, ${inum})`;
          } else if (Array.isArray(scope.resolve)) {
            return `$B.resolve_in_scopes('${name3}', [${scope.resolve}], ${inum})`;
          } else if (scope.resolve == "own_class_name") {
            if (scopes.eval_annotation) {
              return `$B.resolve_global('${name3}', _frame_obj, ${inum})`;
            }
            return `$B.own_class_name('${name3}', ${inum})`;
          }
        }
      }
      function local_scope(name3, scope) {
        var s = scope;
        while (true) {
          if (s.locals.has(name3)) {
            return { found: true, scope: s };
          }
          if (!s.parent) {
            return { found: false };
          }
          s = s.parent;
        }
      }
      function name_scope(name3, scopes) {
        var test = false;
        if (test) {
          console.log("name scope", name3, scopes.slice());
        }
        var flags, block;
        if (scopes.length == 0) {
          return { found: false, resolve: "all" };
        }
        var scope = $B2.last(scopes), up_scope = last_scope(scopes);
        name3 = mangle(scopes, scope, name3);
        if (up_scope.ast === void 0) {
          console.log("no ast", scope);
        }
        block = scopes.symtable.table.blocks.get(fast_id(up_scope.ast));
        if (block === void 0) {
          console.log("no block", scope, scope.ast, "id", fast_id(up_scope.ast));
          console.log("scopes", scopes.slice());
          console.log("symtable", scopes.symtable);
        }
        if (test) {
          console.log("block symbols", block.symbols);
        }
        try {
          flags = _b_2.dict.$getitem_string(block.symbols, name3);
        } catch (err) {
          console.log("name", name3, "not in symbols of block", block);
          console.log("symtables", scopes.symtable);
          console.log("scopes", scopes.slice());
          return { found: false, resolve: "all" };
        }
        let __scope = flags >> SF.SCOPE_OFF & SF.SCOPE_MASK, is_local = [SF.LOCAL, SF.CELL].indexOf(__scope) > -1;
        if (test) {
          console.log("block", block, "is local", is_local, "__scope", __scope);
          console.log("flags", flags, "scopeoff", SF.SCOPE_OFF, "scope mask", SF.SCOPE_MASK);
        }
        if (up_scope.ast instanceof $B2.ast.ClassDef && name3 == up_scope.name) {
          return { found: false, resolve: "own_class_name" };
        }
        if (name3 == "__annotations__") {
          if (block.type == SF.TYPE_CLASS && up_scope.has_annotation) {
            is_local = true;
          } else if (block.type == SF.TYPE_MODULE) {
            is_local = true;
          }
        }
        if (test) {
          console.log("is local ???", is_local, "scope", scope);
        }
        if (is_local) {
          var l_scope = local_scope(name3, scope);
          if (test) {
            console.log("l_scope", l_scope);
          }
          if (!l_scope.found) {
            if (block.type == SF.TYPE_CLASS) {
              scope.needs_frames = true;
              if (scope.maybe_locals && scope.maybe_locals.has(name3)) {
                return { found: false, resolve: "local" };
              }
              return { found: false, resolve: "global" };
            } else if (block.type == SF.TYPE_MODULE) {
              scope.needs_frames = true;
              return { found: false, resolve: "global" };
            }
            return { found: false, resolve: "local" };
          } else {
            return { found: l_scope.scope };
          }
        } else if (scope.globals.has(name3)) {
          var global_scope = scopes[0];
          if (global_scope.locals.has(name3)) {
            return { found: global_scope };
          }
          scope.needs_frames = true;
          return { found: false, resolve: "global" };
        } else if (scope.nonlocals.has(name3)) {
          for (let i = scopes.length - 2; i >= 0; i--) {
            block = scopes.symtable.table.blocks.get(fast_id(scopes[i].ast));
            if (block && _b_2.dict.$contains_string(block.symbols, name3)) {
              var fl = _b_2.dict.$getitem_string(block.symbols, name3), local_to_block = [SF.LOCAL, SF.CELL].indexOf(fl >> SF.SCOPE_OFF & SF.SCOPE_MASK) > -1;
              if (!local_to_block) {
                continue;
              }
              return { found: scopes[i] };
            }
          }
        }
        if (scope.has_import_star) {
          if (!is_local) {
            scope.needs_frames = true;
          }
          return { found: false, resolve: is_local ? "all" : "global" };
        }
        for (let i = scopes.length - 2; i >= 0; i--) {
          block = void 0;
          if (scopes[i].ast) {
            block = scopes.symtable.table.blocks.get(fast_id(scopes[i].ast));
          }
          if (scopes[i].globals.has(name3)) {
            scope.needs_frames = true;
            return { found: false, resolve: "global" };
          }
          if (scopes[i].locals.has(name3) && scopes[i].type != "class") {
            if (test) {
              console.log("found in locals of", scopes[i]);
            }
            return { found: scopes[i] };
          } else if (block && _b_2.dict.$contains_string(block.symbols, name3)) {
            flags = _b_2.dict.$getitem_string(block.symbols, name3);
            let __scope2 = flags >> SF.SCOPE_OFF & SF.SCOPE_MASK;
            if ([SF.LOCAL, SF.CELL].indexOf(__scope2) > -1) {
              return { found: false, resolve: "all" };
            }
          }
          if (scopes[i].has_import_star) {
            return { found: false, resolve: "all" };
          }
        }
        if (builtins_scope.locals.has(name3)) {
          return { found: builtins_scope };
        }
        var scope_names = make_search_namespaces(scopes);
        return { found: false, resolve: scope_names };
      }
      function resolve_in_namespace(name3, ns) {
        if (ns.$proxy) {
          return ns[name3] === void 0 ? { found: false } : { found: true, value: ns[name3] };
        }
        if (!ns.hasOwnProperty) {
          if (ns[name3] !== void 0) {
            return { found: true, value: ns[name3] };
          }
        } else if (ns.hasOwnProperty(name3)) {
          return { found: true, value: ns[name3] };
        } else if (ns.$dict) {
          try {
            return { found: true, value: ns.$getitem(ns.$dict, name3) };
          } catch (err) {
            if (ns.$missing) {
              try {
                return {
                  found: true,
                  value: $B2.$call(ns.$missing)(ns.$dict, name3)
                };
              } catch (err2) {
                if (!$B2.is_exc(err2, [_b_2.KeyError])) {
                  throw err2;
                }
              }
            }
          }
        }
        return { found: false };
      }
      $B2.resolve = function(name3) {
        var checked = /* @__PURE__ */ new Set(), current_globals, frame_obj = $B2.frame_obj, frame;
        while (frame_obj !== null) {
          frame = frame_obj.frame;
          if (current_globals === void 0) {
            current_globals = frame[3];
          } else if (frame[3] !== current_globals) {
            let v3 = resolve_in_namespace(name3, current_globals);
            if (v3.found) {
              return v3.value;
            }
            checked.add(current_globals);
            current_globals = frame[3];
          }
          let v2 = resolve_in_namespace(name3, frame[1]);
          if (v2.found) {
            return v2.value;
          }
          frame_obj = frame_obj.prev;
        }
        if (!checked.has(frame[3])) {
          var v = resolve_in_namespace(name3, frame[3]);
          if (v.found) {
            return v.value;
          }
        }
        if (builtins_scope.locals.has(name3)) {
          return _b_2[name3];
        }
        throw $B2.name_error(name3);
      };
      $B2.resolve_local = function(name3, inum) {
        if ($B2.frame_obj !== null) {
          var frame = $B2.frame_obj.frame;
          if (frame[1].hasOwnProperty) {
            if (frame[1].hasOwnProperty(name3)) {
              return frame[1][name3];
            }
          } else {
            var value2 = frame[1][name3];
            if (value2 !== void 0) {
              return value2;
            }
          }
        }
        var exc = _b_2.UnboundLocalError.$factory(`cannot access local variable '${name3}' where it is not associated with a value`);
        $B2.set_inum(inum);
        throw exc;
      };
      $B2.resolve_in_scopes = function(name3, namespaces, inum) {
        for (var ns of namespaces) {
          if (ns === $B2.exec_scope) {
            var exec_top, frame_obj = $B2.frame_obj, frame;
            while (frame_obj !== null) {
              frame = frame_obj.frame;
              if (frame.is_exec_top) {
                exec_top = frame;
                break;
              }
              frame_obj = frame_obj.prev;
            }
            if (exec_top) {
              for (var ns1 of [exec_top[1], exec_top[3]]) {
                let v = resolve_in_namespace(name3, ns1);
                if (v.found) {
                  return v.value;
                }
              }
            }
          } else {
            let v = resolve_in_namespace(name3, ns);
            if (v.found) {
              return v.value;
            }
          }
        }
        var exc = $B2.name_error(name3);
        $B2.set_inum(inum);
        throw exc;
      };
      $B2.resolve_global = function(name3, frame_obj, inum) {
        while (frame_obj !== null) {
          var frame = frame_obj.frame, v = resolve_in_namespace(name3, frame[3]);
          if (v.found) {
            return v.value;
          }
          if (frame.is_exec_top) {
            break;
          }
          frame_obj = frame_obj.prev;
        }
        if (builtins_scope.locals.has(name3)) {
          return _b_2[name3];
        }
        $B2.set_inum(inum);
        throw $B2.name_error(name3);
      };
      $B2.own_class_name = function(name3, inum) {
        $B2.set_inum(inum);
        throw $B2.name_error(name3);
      };
      var $operators = $B2.op2method.subset("all");
      var opname2opsign = {};
      for (var key2 in $operators) {
        opname2opsign[$operators[key2]] = key2;
      }
      var opclass2dunder = {};
      for (var op_type of $B2.op_types) {
        for (var operator in op_type) {
          opclass2dunder[op_type[operator]] = "__" + $operators[operator] + "__";
        }
      }
      opclass2dunder["UAdd"] = "__pos__";
      opclass2dunder["USub"] = "__neg__";
      opclass2dunder["Invert"] = "__invert__";
      var builtins_scope = new Scope("__builtins__");
      for (var name2 in $B2.builtins) {
        builtins_scope.locals.add(name2);
      }
      function mark_parents(node) {
        if (node.body && node.body instanceof Array) {
          for (let child of node.body) {
            child.$parent = node;
            mark_parents(child);
          }
        } else if (node.handlers) {
          var p = { $parent: node, "type": "except_handler" };
          for (let child of node.handlers) {
            child.$parent = p;
            mark_parents(child);
          }
        }
      }
      var prefix = "", tab = "  ";
      function indent(n) {
        n = n ?? 1;
        prefix += tab.repeat(n);
      }
      function dedent(n) {
        n = n ?? 1;
        prefix = prefix.substr(n * tab.length);
      }
      function add_body(body, scopes) {
        var res = "";
        let js;
        for (var item2 of body) {
          js = $B2.js_from_ast(item2, scopes);
          if (js.length > 0) {
            res += js + "\n";
          }
        }
        return res.trimRight();
      }
      function extract_docstring(ast_obj, scopes) {
        var js = "_b_.None";
        if (ast_obj.body.length && ast_obj.body[0] instanceof $B2.ast.Expr && ast_obj.body[0].value instanceof $B2.ast.Constant) {
          var value2 = ast_obj.body[0].value.value;
          if (typeof value2 == "string") {
            js = ast_obj.body[0].value.to_js(scopes);
            ast_obj.body.shift();
          }
        }
        return js;
      }
      function init_comprehension(comp, scopes) {
        if (comp.type == "genexpr") {
          return init_genexpr(comp, scopes);
        }
        return prefix + `var next_func_${comp.id} = $B.make_js_iterator(expr, frame, ${comp.ast.lineno})
`;
      }
      function init_genexpr(comp, scopes) {
        var varnames = Object.keys(comp.varnames || {}).map((x) => `'${x}'`).join(", ");
        return prefix + `var ${comp.locals_name} = {},
` + prefix + tab + tab + `locals = ${comp.locals_name}
` + prefix + `locals['.0'] = expr
` + prefix + `var frame = ["<${comp.type.toLowerCase()}>", ${comp.locals_name}, "${comp.module_name}", ${comp.globals_name}]
` + prefix + `frame.$has_generators = true
` + prefix + `frame.__file__ = '${scopes.filename}'
` + prefix + `frame.$lineno = ${comp.ast.lineno}
` + prefix + `$B.make_f_code(frame, [${varnames}])
` + prefix + `var next_func_${comp.id} = $B.make_js_iterator(expr, frame, ${comp.ast.lineno})
` + prefix + `frame.$f_trace = _b_.None
` + prefix + `var _frame_obj = $B.frame_obj
`;
      }
      function comp_bindings(comp, bindings) {
        if (comp.target instanceof $B2.ast.Name) {
          bindings.add(comp.target.id);
        } else if (comp.target.elts) {
          for (var elt of comp.target.elts) {
            comp_bindings({ target: elt }, bindings);
          }
        }
        return bindings;
      }
      function make_comp(scopes) {
        var bindings = /* @__PURE__ */ new Set();
        for (var gen of this.generators) {
          comp_bindings(gen, bindings);
        }
        var save_locals = /* @__PURE__ */ new Set();
        var plen = prefix.length;
        var comp_prefix = prefix;
        var id = make_id(), type = this.constructor.$name, symtable_block = scopes.symtable.table.blocks.get(fast_id(this)), varnames = Object.keys(symtable_block.symbols.$strings).map((x) => `"${x}"`), comp_iter, comp_scope = $B2.last(scopes), upper_comp_scope = comp_scope;
        for (var name3 of comp_scope.locals) {
          if (bindings.has(name3)) {
            save_locals.add(name3);
          }
        }
        while (upper_comp_scope.parent) {
          upper_comp_scope = upper_comp_scope.parent;
          for (var name3 of upper_comp_scope.locals) {
            if (bindings.has(name3)) {
              save_locals.add(name3);
            }
          }
        }
        var comp_scope_block = scopes.symtable.table.blocks.get(
          fast_id(upper_comp_scope.ast)
        ), comp_scope_symbols = comp_scope_block.symbols;
        var initial_nb_await_in_scope = upper_comp_scope.nb_await === void 0 ? 0 : upper_comp_scope.nb_await;
        for (var symbol of _b_2.dict.$iter_items(symtable_block.symbols)) {
          if (symbol.value & SF.DEF_COMP_ITER) {
            comp_iter = symbol.key;
          }
        }
        var comp_iter_scope = name_scope(comp_iter, scopes);
        var first_for = this.generators[0], outmost_expr = $B2.js_from_ast(first_for.iter, scopes), nb_paren = 1;
        var comp = { ast: this, id, type, varnames, module_name: scopes[0].name, locals_name: make_scope_name(scopes), globals_name: make_scope_name(scopes, scopes[0]) };
        indent();
        if (prefix.length > plen + tab.length) {
          console.warn("JS indentation issue");
        }
        var js = init_comprehension(comp, scopes);
        if (comp_iter_scope.found) {
          js += prefix + `var save_comp_iter = ${name_reference(comp_iter, scopes)}
`;
        }
        for (var name3 of save_locals) {
          js += prefix + `var save_${name3} = ${name_reference(name3, scopes)}
`;
        }
        if (this instanceof $B2.ast.ListComp) {
          js += prefix + `var result_${id} = $B.$list([])
`;
        } else if (this instanceof $B2.ast.SetComp) {
          js += prefix + `var result_${id} = _b_.set.$factory()
`;
        } else if (this instanceof $B2.ast.DictComp) {
          js += prefix + `var result_${id} = $B.empty_dict()
`;
        }
        var first = this.generators[0];
        js += prefix + `try{
`;
        indent();
        js += prefix + `for(var next_${id} of next_func_${id}){
`;
        indent();
        var save_target_flags;
        if (first.target instanceof $B2.ast.Name) {
          var target_name = first.target.id;
          if (comp_scope_symbols.$strings.hasOwnProperty(target_name)) {
            save_target_flags = comp_scope_symbols.$strings[target_name];
            comp_scope_symbols.$strings[target_name] = SF.LOCAL << SF.SCOPE_OFF;
          }
        }
        var name3 = new $B2.ast.Name(`next_${id}`, new $B2.ast.Load());
        copy_position(name3, first_for.iter);
        name3.to_js = function() {
          return `next_${id}`;
        };
        var assign = new $B2.ast.Assign([first.target], name3);
        assign.lineno = this.lineno;
        js += assign.to_js(scopes) + "\n";
        for (let _if of first.ifs) {
          nb_paren++;
          js += prefix + `if($B.$bool(${$B2.js_from_ast(_if, scopes)})){
`;
          indent();
        }
        for (var comprehension of this.generators.slice(1)) {
          js += comprehension.to_js(scopes);
          nb_paren++;
          for (let _if of comprehension.ifs) {
            nb_paren++;
          }
        }
        if (this instanceof $B2.ast.DictComp) {
          var key3 = $B2.js_from_ast(this.key, scopes), value2 = $B2.js_from_ast(this.value, scopes);
        } else {
          var elt = $B2.js_from_ast(this.elt, scopes);
        }
        if (save_target_flags) {
          comp_scope_symbols.$strings[target_name] = save_target_flags;
        }
        var final_nb_await_in_scope = upper_comp_scope.nb_await === void 0 ? 0 : upper_comp_scope.nb_await;
        var has_await = final_nb_await_in_scope > initial_nb_await_in_scope;
        js = `(${has_await ? "async " : ""}function(expr){
` + js;
        js += has_await ? "var save_frame_obj = $B.frame_obj;\n" : "";
        if (this instanceof $B2.ast.ListComp) {
          js += prefix + `result_${id}.push(${elt})
`;
        } else if (this instanceof $B2.ast.SetComp) {
          js += prefix + `_b_.set.add(result_${id}, ${elt})
`;
        } else if (this instanceof $B2.ast.DictComp) {
          js += prefix + `_b_.dict.$setitem(result_${id}, ${key3}, ${value2})
`;
        }
        dedent();
        for (var i = 0; i < nb_paren; i++) {
          js += prefix + "}\n";
          dedent();
        }
        js += prefix + `}catch(err){
`;
        indent();
        js += (has_await ? prefix + `$B.restore_frame_obj(save_frame_obj, ${comp.locals_name})
` : "") + prefix + `$B.set_exc(err, frame)
` + prefix + `throw err
`;
        dedent();
        js += prefix + `}
` + (has_await ? prefix + `
$B.restore_frame_obj(save_frame_obj, ${comp.locals_name});` : "");
        for (var name3 of save_locals) {
          js += prefix + `${name_reference(name3, scopes)} = save_${name3}
`;
        }
        if (comp_iter_scope.found) {
          js += prefix + `${name_reference(comp_iter, scopes)} = save_comp_iter
`;
        }
        js += prefix + `return result_${id}
`;
        dedent();
        js += prefix + `})(${outmost_expr})
`;
        if (prefix.length != plen) {
          console.log("comprehension, prefix length start", plen, "end", prefix.length);
          console.log("file", scopes.filename);
          console.log(this);
          console.log(">>>\n", js, "\n<<<");
        }
        return js;
      }
      function init_scopes(type, scopes) {
        var filename = scopes?.symtable?.table?.filename, name3 = $B2.url2name[filename];
        if (name3) {
          name3 = name3.replace(/-/g, "_");
        } else if (filename === void 0) {
          name3 = "exec";
        } else if (filename.startsWith("<") && filename.endsWith(">")) {
          name3 = "exec";
        } else {
          name3 = filename.replace(/\./g, "_");
        }
        var top_scope = new Scope(name3, `${type}`, this), block = scopes.symtable.table.blocks.get(fast_id(this));
        if (block && block.$has_import_star) {
          top_scope.has_import_star = true;
        }
        scopes.push(top_scope);
        var namespaces = scopes.namespaces;
        if (namespaces) {
          top_scope.is_exec_scope = true;
          for (let key3 in namespaces.exec_globals) {
            if (!key3.startsWith("$")) {
              top_scope.globals.add(key3);
            }
          }
          if (namespaces.exec_locals !== namespaces.exec_globals) {
            if (namespaces.exec_locals[$B2.LOCALS_PROXY]) {
              for (let item2 of $B2.make_js_iterator(namespaces.exec_locals.$target)) {
                top_scope.locals.add(item2);
              }
            } else {
              for (let key3 in namespaces.exec_locals) {
                if (!key3.startsWith("$")) {
                  top_scope.locals.add(key3);
                }
              }
            }
          }
        }
        return name3;
      }
      function compiler_check(obj) {
        var check_func = Object.getPrototypeOf(obj)._check;
        if (check_func) {
          obj._check();
        }
      }
      function check_assign_or_delete(obj, target, action) {
        action = action ?? "assign to";
        if (target instanceof $B2.ast.Attribute) {
          if (target.attr == "__debug__") {
            compiler_error(obj, `cannot ${action} __debug__`, target);
          }
        } else if (target instanceof $B2.ast.Name) {
          if (target.id == "__debug__") {
            compiler_error(obj, `cannot ${action} __debug__`, target);
          }
        } else if (target instanceof $B2.ast.Tuple) {
          for (var elt of target.elts) {
            check_assign_or_delete(elt, elt, action);
          }
        } else if (target instanceof $B2.ast.Starred) {
          check_assign_or_delete(obj, target.value, action);
        }
      }
      function check_is_arg(e) {
        if (!(e instanceof $B2.ast.Constant)) {
          return true;
        }
        var value2 = e.value;
        return value2 === _b_2.None || value2 === false || value2 === true || value2 === _b_2.Ellipsis;
      }
      function check_compare(op_name, left, right, scopes) {
        var test_left = check_is_arg(left), test_right = check_is_arg(right);
        if (!test_left || !test_right) {
          var item2 = test_left ? right : left, name3 = $B2.class_name(item2.value);
          $B2.warn(_b_2.SyntaxWarning, `"${op_name}" with '${name3}' literal. Did you mean "=="?`, scopes.filename, item2);
        }
      }
      function check_type_params(ast_obj) {
        var type_params = ast_obj.type_params;
        if (Array.isArray(type_params)) {
          var has_defaults = false;
          for (var type_param of type_params) {
            if (type_param.default_value === void 0 && has_defaults) {
              throw compiler_error(type_param, `non-default type parameter '${type_param.name}' follows default type parameter`);
            } else if (type_param.default_value) {
              has_defaults = true;
            }
          }
        }
      }
      function maybe_add_static(attr, scopes) {
        var last = last_scope(scopes);
        if (last.type == "def") {
          var ix = scopes.indexOf(last) - 1;
          while (scopes[ix]) {
            last = last_scope(scopes.slice(0, ix + 1));
            if (last.type == "class") {
              last.static_attributes = last.static_attributes ?? /* @__PURE__ */ new Set();
              last.static_attributes.add(attr.attr);
              return;
            } else if (last.type == "def") {
              ix = scopes.indexOf(last) - 1;
            } else {
              return;
            }
          }
        }
      }
      function add_to_positions(scopes, ast_obj) {
        var up_scope = last_scope(scopes);
        up_scope.positions = up_scope.positions ?? [];
        up_scope.positions[up_scope.positions.length] = encode_position(
          ast_obj.lineno,
          ast_obj.end_lineno,
          ast_obj.col_offset,
          ast_obj.end_col_offset
        );
        var inum = 1 + 2 * (up_scope.positions.length - 1);
        ast_obj.inum = inum;
        return inum;
      }
      $B2.ast.Assert.prototype.to_js = function(scopes) {
        var test = $B2.js_from_ast(this.test, scopes), msg = this.msg ? $B2.js_from_ast(this.msg, scopes) : "''";
        var inum = add_to_positions(scopes, this.test);
        var js = prefix + `$B.set_lineno(frame, ${this.lineno})
`;
        return js + prefix + `$B.assert(${test}, ${msg}, ${inum})`;
      };
      function annotation_to_str(obj, scopes) {
        return get_source_from_position(scopes, obj);
      }
      function annotation_code(scope, ref) {
        if (scope.annotate) {
          var annotate = prefix + `var annotate = {
`;
          indent();
          var anns = scope.annotate.map((x) => prefix + x);
          annotate += anns.join(",\n") + "\n";
          dedent();
          annotate += prefix + "}\n";
          return annotate;
        } else {
          return prefix + `var annotate
`;
        }
      }
      $B2.ast.AnnAssign.prototype.to_js = function(scopes) {
        compiler_check(this);
        var scope = last_scope(scopes);
        var js = "";
        if (scopes.postpone_annotations) {
          var inum = add_to_positions(scopes, this);
        }
        if (!scope.has_annotation) {
          scope.has_annotation = true;
          if (scopes.postpone_annotations) {
            scope.locals.add("__annotations__");
            js += prefix + "locals.__annotations__ = $B.empty_dict()\n";
          } else {
            scope.locals.add("__annotate__");
            scope.annotate = [];
            if (scope.type == "module") {
              js += prefix + `$B.make_module_annotate(locals)
`;
            }
          }
        }
        if (this.target instanceof $B2.ast.Name) {
          var ann_value;
          if (scopes.postpone_annotations) {
            ann_value = `'${annotation_to_str(this.annotation, scopes)}'`;
          } else {
            scopes.eval_annotation = true;
            ann_value = $B2.js_from_ast(this.annotation, scopes);
            delete scopes.eval_annotation;
          }
        }
        if (this.value) {
          js += prefix + `var ann = ${$B2.js_from_ast(this.value, scopes)}
`;
          if (this.target instanceof $B2.ast.Name && this.simple) {
            let scope2 = bind(this.target.id, scopes), mangled = mangle(scopes, scope2, this.target.id);
            if (scope2.type != "def") {
              if (!scopes.postpone_annotations) {
                if (scope2.type == "class") {
                  scope2.annotate.push(`${mangled}: [${this.lineno}, () => ${ann_value}]`);
                } else {
                  js += prefix + `locals.$annotations.${mangled} = [${this.lineno}, () => ${ann_value}]
`;
                }
              } else {
                js += prefix + `$B.$setitem(locals.__annotations__, '${mangled}', ${ann_value}, ${inum})
`;
              }
            }
            let target_ref = name_reference(this.target.id, scopes);
            js += prefix + `${target_ref} = ann`;
          } else if (this.target instanceof $B2.ast.Attribute) {
            js += prefix + `$B.$setattr(${$B2.js_from_ast(this.target.value, scopes)}, "${this.target.attr}", ann)`;
          } else if (this.target instanceof $B2.ast.Subscript) {
            js += prefix + `$B.$setitem(${$B2.js_from_ast(this.target.value, scopes)}, ${$B2.js_from_ast(this.target.slice, scopes)}, ann)`;
          }
        } else {
          if (this.target instanceof $B2.ast.Name) {
            if (this.simple && scope.type != "def") {
              let mangled = mangle(scopes, scope, this.target.id);
              if (!scopes.postpone_annotations) {
                if (scope.type == "class") {
                  scope.annotate.push(`${mangled}: [${this.lineno}, () => ${ann_value}]`);
                } else {
                  js += prefix + `locals.$annotations.${mangled} = [${this.lineno}, () => ${ann_value}]
`;
                }
              } else {
                js += prefix + `$B.$setitem(locals.__annotations__, '${mangled}', ${ann_value}, ${inum})
`;
              }
            }
          }
        }
        return prefix + `$B.set_lineno(frame, ${this.lineno})
` + js;
      };
      $B2.ast.AnnAssign.prototype._check = function() {
        check_assign_or_delete(this, this.target);
      };
      $B2.ast.Assign.prototype.to_js = function(scopes) {
        compiler_check(this);
        var js;
        if (!this.lineno || this.$loopvar) {
          js = "";
        } else {
          js = prefix + `$B.set_lineno(frame, ${this.lineno})
`;
        }
        var value2 = $B2.js_from_ast(this.value, scopes);
        function assign_one(target, value3) {
          if (target instanceof $B2.ast.Name) {
            return prefix + $B2.js_from_ast(target, scopes) + " = " + value3;
          } else if (target instanceof $B2.ast.Starred) {
            return assign_one(target.value, value3);
          } else if (target instanceof $B2.ast.Subscript) {
            var inum = add_to_positions(scopes, target);
            return prefix + `$B.$setitem(${$B2.js_from_ast(target.value, scopes)}, ${$B2.js_from_ast(target.slice, scopes)}, ${value3}, ${inum})`;
          } else if (target instanceof $B2.ast.Attribute) {
            if (target.value.id == "self") {
              maybe_add_static(target, scopes);
            }
            var inum = add_to_positions(scopes, target);
            var attr = mangle(scopes, last_scope(scopes), target.attr);
            return prefix + `$B.$setattr1(${$B2.js_from_ast(target.value, scopes)}, "${attr}", ${value3}, ${inum})`;
          }
        }
        function assign_many(target, value3) {
          var js2 = "";
          var nb_targets = target.elts.length, has_starred = false, nb_after_starred;
          for (var i = 0, len = nb_targets; i < len; i++) {
            if (target.elts[i] instanceof $B2.ast.Starred) {
              has_starred = true;
              nb_after_starred = len - i - 1;
              break;
            }
          }
          var iter_id = "it_" + make_id();
          var inum = add_to_positions(scopes, target);
          js2 += prefix + `var ${iter_id} = $B.unpacker(${value3}, ${nb_targets}, ${has_starred}`;
          if (nb_after_starred !== void 0) {
            js2 += `, ${nb_after_starred}`;
          }
          js2 += `, ${inum})
`;
          var assigns2 = [];
          for (var elt of target.elts) {
            if (elt instanceof $B2.ast.Starred) {
              assigns2.push(assign_one(elt, `${iter_id}.read_rest()`));
            } else if (elt instanceof $B2.ast.List || elt instanceof $B2.ast.Tuple) {
              assigns2.push(assign_many(elt, `${iter_id}.read_one()`));
            } else {
              assigns2.push(assign_one(elt, `${iter_id}.read_one()`));
            }
          }
          js2 += assigns2.join("\n");
          return js2;
        }
        if (this.targets.length == 1) {
          let target = this.targets[0];
          if (!(target instanceof $B2.ast.Tuple) && !(target instanceof $B2.ast.List)) {
            js += assign_one(this.targets[0], value2);
            return js;
          }
        }
        var value_id = "v" + make_id();
        js += prefix + `var ${value_id} = ${value2}
`;
        var assigns = [];
        for (let target of this.targets) {
          if (!(target instanceof $B2.ast.Tuple) && !(target instanceof $B2.ast.List)) {
            assigns.push(assign_one(target, value_id));
          } else {
            assigns.push(assign_many(target, value_id));
          }
        }
        js += assigns.join("\n");
        return js;
      };
      $B2.ast.Assign.prototype._check = function() {
        for (var target of this.targets) {
          check_assign_or_delete(this, target);
        }
      };
      $B2.ast.AsyncFor.prototype.to_js = function(scopes) {
        if (!(last_scope(scopes).ast instanceof $B2.ast.AsyncFunctionDef)) {
          compiler_error(this, "'async for' outside async function");
        }
        return $B2.ast.For.prototype.to_js.bind(this)(scopes);
      };
      $B2.ast.AsyncFunctionDef.prototype.to_js = function(scopes) {
        return $B2.ast.FunctionDef.prototype.to_js.bind(this)(scopes);
      };
      $B2.ast.AsyncWith.prototype.to_js = function(scopes) {
        if (!(last_scope(scopes).ast instanceof $B2.ast.AsyncFunctionDef)) {
          compiler_error(this, "'async with' outside async function");
        }
        function bind_vars(vars, scopes2) {
          if (vars instanceof $B2.ast.Name) {
            bind(vars.id, scopes2);
          } else if (vars instanceof $B2.ast.Tuple) {
            for (var var_item of vars.elts) {
              bind_vars(var_item, scopes2);
            }
          }
        }
        function add_item(item2, js2) {
          var id = make_id();
          var s = prefix + `var mgr_${id} = ` + $B2.js_from_ast(item2.context_expr, scopes) + ",\n";
          indent(2);
          s += prefix + `mgr_type_${id} = _b_.type.$factory(mgr_${id}),
` + prefix + `aexit_${id} = $B.$getattr(mgr_type_${id}, '__aexit__'),
` + prefix + `aenter_${id} = $B.$getattr(mgr_type_${id}, '__aenter__'),
` + prefix + `value_${id} = await $B.promise($B.$call(aenter_${id})(mgr_${id})),
` + prefix + `exc_${id} = true
`;
          if (has_generator) {
            s += prefix + `locals.$context_managers = locals.$context_managers || []
locals.$context_managers.push(mgr_${id})
`;
          }
          dedent(2);
          s += prefix + "try{\n";
          indent();
          s += prefix + "try{\n";
          indent();
          if (item2.optional_vars) {
            var value2 = { to_js: function() {
              return `value_${id}`;
            } };
            copy_position(value2, _with);
            var assign = new $B2.ast.Assign([item2.optional_vars], value2);
            copy_position(assign, _with);
            s += assign.to_js(scopes) + "\n";
          }
          s += js2;
          dedent();
          s += prefix + `}catch(err_${id}){
`;
          indent();
          s += prefix + `frame.$lineno = ${lineno}
` + prefix + `exc_${id} = false
` + prefix + `err_${id} = $B.exception(err_${id}, frame)
` + prefix + `var $b = await $B.promise(aexit_${id}(mgr_${id}, err_${id}.__class__, 
` + prefix + tab.repeat(4) + `err_${id}, $B.$getattr(err_${id}, '__traceback__')))
` + prefix + `if(! $B.$bool($b)){
` + prefix + tab + `throw err_${id}
` + prefix + `}
`;
          dedent();
          s += prefix + `}
`;
          dedent();
          s += prefix + `}finally{
`;
          indent();
          s += prefix + `frame.$lineno = ${lineno}
` + prefix + `if(exc_${id}){
` + prefix + tab + `await $B.promise(aexit_${id}(mgr_${id}, _b_.None, _b_.None, _b_.None))
` + prefix + `}
`;
          dedent();
          s += prefix + `}
`;
          return s;
        }
        var _with = this, scope = last_scope(scopes), lineno = this.lineno;
        delete scope.is_generator;
        for (let item2 of this.items.slice().reverse()) {
          if (item2.optional_vars) {
            bind_vars(item2.optional_vars, scopes);
          }
        }
        indent(2);
        var js = add_body(this.body, scopes) + "\n";
        dedent(2);
        var has_generator = scope.is_generator;
        for (let item2 of this.items.slice().reverse()) {
          js = add_item(item2, js);
        }
        return prefix + `$B.set_lineno(frame, ${this.lineno})
` + js;
      };
      $B2.ast.Attribute.prototype.to_js = function(scopes) {
        var attr = mangle(scopes, last_scope(scopes), this.attr);
        var inum = add_to_positions(scopes, this);
        return `$B.$getattr_pep657(${$B2.js_from_ast(this.value, scopes)}, '${attr}', ${inum})`;
      };
      $B2.ast.AugAssign.prototype.to_js = function(scopes) {
        compiler_check(this);
        var js, op_class = this.op.$name ? this.op : this.op.constructor;
        for (var op in $B2.op2ast_class) {
          if ($B2.op2ast_class[op][1] === op_class) {
            var iop = op + "=";
            break;
          }
        }
        var value2 = $B2.js_from_ast(this.value, scopes);
        if (this.target instanceof $B2.ast.Name) {
          var scope = name_scope(this.target.id, scopes);
          if (!scope.found) {
            let left_scope = scope.resolve == "global" ? make_scope_name(scopes, scopes[0]) : "locals";
            js = prefix + `${left_scope}.${this.target.id} = $B.augm_assign(` + make_ref(this.target.id, scopes, scope, this.target) + `, '${iop}', ${value2})`;
          } else {
            let ref = `${make_scope_name(scopes, scope.found)}.${this.target.id}`;
            js = prefix + `${ref} = $B.augm_assign(${ref}, '${iop}', ${value2})`;
          }
        } else if (this.target instanceof $B2.ast.Subscript) {
          js = prefix + `$B.$setitem((locals.$tg = ${this.target.value.to_js(scopes)}), (locals.$key = ${this.target.slice.to_js(scopes)}), $B.augm_assign($B.$getitem(locals.$tg, locals.$key), '${iop}', ${value2}))`;
        } else if (this.target instanceof $B2.ast.Attribute) {
          let mangled = mangle(scopes, last_scope(scopes), this.target.attr);
          js = prefix + `$B.$setattr((locals.$tg = ${this.target.value.to_js(scopes)}), '${mangled}', $B.augm_assign($B.$getattr(locals.$tg, '${mangled}'), '${iop}', ${value2}))`;
        } else {
          let target = $B2.js_from_ast(this.target, scopes), value3 = $B2.js_from_ast(this.value, scopes);
          js = prefix + `${target} = $B.augm_assign(${target}, '${iop}', ${value3})`;
        }
        return prefix + `$B.set_lineno(frame, ${this.lineno})
` + js;
      };
      $B2.ast.AugAssign.prototype._check = function() {
        check_assign_or_delete(this, this.target);
      };
      $B2.ast.Await.prototype.to_js = function(scopes) {
        var ix = scopes.length - 1;
        while (scopes[ix].parent) {
          ix--;
        }
        scopes[ix].nb_await = scopes[ix].nb_await === void 0 ? 1 : scopes[ix].nb_await + 1;
        while (scopes[ix].ast instanceof $B2.ast.ListComp || scopes[ix].ast instanceof $B2.ast.DictComp || scopes[ix].ast instanceof $B2.ast.SetComp || scopes[ix].ast instanceof $B2.ast.GeneratorExp) {
          scopes[ix].has_await = true;
          ix--;
        }
        if (scopes[ix].ast instanceof $B2.ast.AsyncFunctionDef) {
          scopes[ix].has_await = true;
          return prefix + `await $B.promise(${$B2.js_from_ast(this.value, scopes)})`;
        } else if (scopes[ix].ast instanceof $B2.ast.FunctionDef) {
          compiler_error(this, "'await' outside async function", this.value);
        } else {
          compiler_error(this, "'await' outside function", this.value);
        }
      };
      $B2.ast.BinOp.prototype.to_js = function(scopes) {
        var res;
        var inum = add_to_positions(scopes, this);
        var name3 = this.op.constructor.$name;
        var op = opclass2dunder[name3];
        if (this.left instanceof $B2.ast.Constant && this.right instanceof $B2.ast.Constant) {
          try {
            res = $B2.rich_op(op, this.left.value, this.right.value);
            if (typeof res == "string" && op !== "__add__") {
              throw Error();
            }
            var ast_obj = new $B2.ast.Constant(res);
            return ast_obj.to_js(scopes);
          } catch (err) {
          }
        }
        return `$B.rich_op('${op}', ${$B2.js_from_ast(this.left, scopes)}, ${$B2.js_from_ast(this.right, scopes)}, ${inum})`;
      };
      $B2.ast.BoolOp.prototype.to_js = function(scopes) {
        var tests = [];
        if (this.$dont_evaluate) {
          let op = this.op instanceof $B2.ast.And ? " && " : " || ";
          for (let i = 0, len = this.values.length; i < len; i++) {
            let value2 = this.values[i];
            tests.push(`$B.$bool(${$B2.js_from_ast(value2, scopes)})`);
          }
          return "(" + tests.join(op) + ")";
        } else {
          let op = this.op instanceof $B2.ast.And ? "! " : "";
          for (let i = 0, len = this.values.length; i < len; i++) {
            let value2 = this.values[i];
            if (i < len - 1) {
              tests.push(`${op}$B.$bool(locals.$test = ${$B2.js_from_ast(value2, scopes)}) ? locals.$test : `);
            } else {
              tests.push(`${$B2.js_from_ast(value2, scopes)}`);
            }
          }
        }
        return "(" + tests.join("") + ")";
      };
      function in_loop(scopes) {
        for (var scope of scopes.slice().reverse()) {
          if (scope.ast instanceof $B2.ast.For || scope.ast instanceof $B2.ast.While) {
            return true;
          }
        }
        return false;
      }
      $B2.ast.Break.prototype.to_js = function(scopes) {
        if (!in_loop(scopes)) {
          compiler_error(this, "'break' outside loop");
        }
        var js = "";
        for (var scope of scopes.slice().reverse()) {
          if (scope.ast instanceof $B2.ast.For || scope.ast instanceof $B2.ast.While) {
            js += prefix + `no_break_${scope.id} = false
`;
            break;
          }
        }
        js += prefix + `break`;
        return js;
      };
      $B2.ast.Call.prototype.to_js = function(scopes) {
        compiler_check(this);
        var inum = add_to_positions(scopes, this);
        var func = $B2.js_from_ast(this.func, scopes), js = `$B.$call(${func}, ${inum})`;
        var args = make_args.bind(this)(scopes);
        return js + `(${args})`;
      };
      $B2.ast.Call.prototype._check = function() {
        for (var kw of this.keywords) {
          if (kw.arg == "__debug__") {
            compiler_error(this, "cannot assign to __debug__", kw);
          }
        }
      };
      function make_args(scopes) {
        var js = "", named_args = [], named_kwargs = [], starred_kwargs = [];
        var kwds = /* @__PURE__ */ new Set();
        for (var keyword of this.keywords) {
          if (keyword.arg) {
            if (kwds.has(keyword.arg)) {
              compiler_error(keyword, `keyword argument repeated: ${keyword.arg}`);
            }
            kwds.add(keyword.arg);
            named_kwargs.push(
              `${keyword.arg}: ${$B2.js_from_ast(keyword.value, scopes)}`
            );
          } else {
            starred_kwargs.push($B2.js_from_ast(keyword.value, scopes));
          }
        }
        var args_list = [];
        for (let arg of this.args) {
          if (arg instanceof $B2.ast.Starred) {
            var starred_arg = $B2.js_from_ast(arg.value, scopes);
            args_list.push(`...$B.make_js_iterator(${starred_arg})`);
          } else {
            args_list.push($B2.js_from_ast(arg, scopes));
          }
        }
        if (named_kwargs.length + starred_kwargs.length > 0) {
          var kw = `{${named_kwargs.join(", ")}}`;
          for (var starred_kwarg of starred_kwargs) {
            kw += `, ${starred_kwarg}`;
          }
          kw = `{$kw:[${kw}]}`;
          args_list.push(kw);
        }
        return js + `${args_list.join(", ")}`;
      }
      $B2.ast.ClassDef.prototype.to_js = function(scopes) {
        var enclosing_scope = bind(this.name, scopes);
        var class_scope = new Scope(this.name, "class", this);
        var js = "", locals_name = make_scope_name(scopes, class_scope), ref = this.name + make_id(), glob = scopes[0].name, globals_name = make_scope_name(scopes, scopes[0]), decorators = [], decorated = false;
        for (let dec of this.decorator_list) {
          decorated = true;
          var dec_id = "decorator" + make_id();
          decorators.push(dec_id);
          js += prefix + `$B.set_lineno(frame, ${dec.lineno})
` + prefix + `var ${dec_id} = ${$B2.js_from_ast(dec, scopes)}
`;
        }
        js += prefix + `$B.set_lineno(frame, ${this.lineno}, 'ClassDef')
`;
        var qualname = this.name;
        var ix = scopes.length - 1;
        while (ix >= 0) {
          if (scopes[ix].parent) {
            ix--;
          } else if (scopes[ix].ast instanceof $B2.ast.ClassDef) {
            qualname = scopes[ix].name + "." + qualname;
            ix--;
          } else {
            break;
          }
        }
        var bases = this.bases.map((x) => $B2.js_from_ast(x, scopes));
        var has_type_params = this.type_params.length > 0;
        if (has_type_params) {
          check_type_params(this);
          js += prefix + `function TYPE_PARAMS_OF_${this.name}(){
`;
          indent();
          js += prefix + `$B.$import('_typing')
` + prefix + `var _typing = $B.imported._typing
`;
          var params = [], need_typing_module;
          for (let item3 of this.type_params) {
            if (item3 instanceof $B2.ast.TypeVar) {
              params.push(`${item3.name}`);
            } else if (item3 instanceof $B2.ast.TypeVarTuple) {
              params.push(`unpack(${item3.name})`);
              need_typing_module = true;
            } else if (item3 instanceof $B2.ast.ParamSpec) {
              params.push(`${item3.name}`);
            }
          }
          bases.push(`generic_base`);
          if (need_typing_module) {
            js += prefix + `$B.$import('typing')
` + prefix + "var typing = $B.imported.typing\n" + prefix + `var unpack = $B.$call($B.$getattr(typing.Unpack, '__getitem__'))
`;
          }
          var name_map = /* @__PURE__ */ new Map();
          for (let item3 of this.type_params) {
            var name3, param_type2 = item3.constructor.$name;
            if (["TypeVar", "TypeVarTuple", "ParamSpec"].includes(param_type2)) {
              name3 = item3.name;
            } else {
              name3 = item3.name.id;
            }
            name_map.set(item3, name3);
            js += prefix + `var ${name3} = $B.$call(_typing.${param_type2})('${name3}')
`;
          }
          js += prefix + `var generic_base = _typing.Generic.__class_getitem__(_typing.Generic, $B.fast_tuple([${params.join(", ")}]))
`;
        }
        var keywords = [], metaclass, meta = "";
        for (var keyword of this.keywords) {
          if (keyword.arg == "metaclass") {
            metaclass = keyword.value;
            meta = metaclass.to_js(scopes);
          } else {
            keywords.push(`["${keyword.arg}", ` + $B2.js_from_ast(keyword.value, scopes) + "]");
          }
        }
        var docstring = extract_docstring(this, scopes);
        var inum = add_to_positions(scopes, this);
        js += prefix + `var ${ref} = (function(name, module, bases` + (metaclass ? ", meta" : "") + `){
`;
        indent();
        js += prefix + `$B.frame_obj.frame.inum = ${inum}
`;
        js += prefix + `var _frame_obj = $B.frame_obj,
`;
        indent(2);
        js += prefix + `resolved_bases = $B.resolve_mro_entries(bases),
` + prefix + `metaclass = $B.get_metaclass(name, module, resolved_bases`;
        if (metaclass) {
          js += `, meta`;
        }
        js += ")\n";
        dedent(2);
        js += prefix + `var ${locals_name} = $B.make_class_namespace(metaclass, name, module, "${qualname}", bases, resolved_bases),
`;
        indent(2);
        js += prefix + `locals = ${locals_name}
`;
        dedent(2);
        js += prefix + `locals.__doc__ = ${docstring}
`;
        js += prefix + `var frame = [name, locals, module, ${globals_name}]
` + prefix + `$B.enter_frame(frame, __file__, ${this.lineno})
` + prefix + `var _frame_obj = $B.frame_obj
` + prefix + `if(frame.$f_trace !== _b_.None){
` + prefix + tab + `$B.trace_line()
` + prefix + `}
`;
        if (has_type_params) {
          var tp_refs = [];
          for (var item2 of this.type_params) {
            tp_refs.push(`${name_map.get(item2)}`);
          }
          js += prefix + `locals.__type_params__ = $B.fast_tuple([${tp_refs.join(", ")}])
`;
        }
        scopes.push(class_scope);
        var index_for_positions = js.length;
        js += add_body(this.body, scopes) + "\n";
        if (class_scope.positions) {
          js = js.substr(0, index_for_positions) + prefix + `frame.positions = [${class_scope.positions}]
` + js.substr(index_for_positions);
        }
        scopes.pop();
        var static_attrs = [];
        if (class_scope.static_attributes) {
          static_attrs = Array.from(class_scope.static_attributes).map((x) => `"${x}"`);
        }
        js += annotation_code(class_scope, class_ref);
        js += prefix + `var kls = $B.$class_constructor('${this.name}', frame, metaclass, resolved_bases, bases, [${keywords.join(", ")}], [${static_attrs}], annotate, ${this.lineno})
` + prefix + "$B.trace_return_and_leave(frame, _b_.None)\n" + prefix + "return kls\n";
        dedent();
        js += prefix + `})('${this.name}',${globals_name}.__name__ ?? '${glob}', $B.fast_tuple([${bases}])` + (metaclass ? ", " + meta : "") + `)
`;
        if (has_type_params) {
          js += prefix + `return ${ref}
`;
          dedent();
          js += prefix + "}\n";
        }
        var class_ref = reference(scopes, enclosing_scope, this.name);
        js += prefix;
        if (decorated) {
          class_ref = `decorated${make_id()}`;
          js += "var ";
        }
        js += `${class_ref} = `;
        if (has_type_params) {
          js += `TYPE_PARAMS_OF_${this.name}()
`;
        } else {
          js += `${ref}
`;
        }
        if (decorated) {
          js += prefix + reference(scopes, enclosing_scope, this.name) + " = ";
          var decorate = class_ref;
          for (let dec of decorators.reverse()) {
            decorate = `$B.$call(${dec})(${decorate})`;
          }
          js += decorate + "\n";
        }
        return js;
      };
      $B2.ast.Compare.prototype.to_js = function(scopes) {
        var test_left = check_is_arg(this.left);
        var left = $B2.js_from_ast(this.left, scopes), comps = [];
        var len = this.ops.length, prefix2;
        for (var i = 0; i < len; i++) {
          var name3 = this.ops[i].$name ? this.ops[i].$name : this.ops[i].constructor.$name, op = opclass2dunder[name3], right = this.comparators[i];
          if (op === void 0) {
            console.log("op undefined", this.ops[i]);
            alert();
          }
          prefix2 = i < len - 1 ? "locals.$op = " : "";
          if (this.ops[i] instanceof $B2.ast.In) {
            comps.push(`$B.$is_member(${left}, ${prefix2}${$B2.js_from_ast(right, scopes)})`);
          } else if (this.ops[i] instanceof $B2.ast.NotIn) {
            comps.push(`! $B.$is_member(${left}, ${prefix2}${$B2.js_from_ast(right, scopes)})`);
          } else if (this.ops[i] instanceof $B2.ast.Is) {
            check_compare("is", this.left, right, scopes);
            comps.push(`$B.$is(${left}, ${prefix2}${$B2.js_from_ast(right, scopes)})`);
          } else if (this.ops[i] instanceof $B2.ast.IsNot) {
            check_compare("is not", this.left, right, scopes);
            comps.push(`! $B.$is(${left}, ${prefix2}${$B2.js_from_ast(right, scopes)})`);
          } else {
            comps.push(`$B.rich_comp('${op}', ${left}, ${prefix2}${$B2.js_from_ast(right, scopes)})`);
          }
          if (len > 1) {
            left = "locals.$op";
          }
        }
        return comps.join(" && ");
      };
      $B2.ast.comprehension.prototype.to_js = function(scopes) {
        var id = make_id(), iter = $B2.js_from_ast(this.iter, scopes);
        var js = prefix + `var next_func_${id} = $B.make_js_iterator(${iter}, frame, ${this.lineno})
` + prefix + `for(var next_${id} of next_func_${id}){
`;
        indent();
        var name3 = new $B2.ast.Name(`next_${id}`, new $B2.ast.Load());
        copy_position(name3, this.target);
        name3.to_js = function() {
          return `next_${id}`;
        };
        var assign = new $B2.ast.Assign([this.target], name3);
        copy_position(assign, this.target);
        js += assign.to_js(scopes) + "\n";
        for (var _if of this.ifs) {
          js += prefix + `if($B.$bool(${$B2.js_from_ast(_if, scopes)})){
`;
          indent();
        }
        return js;
      };
      $B2.ast.Constant.prototype.to_js = function() {
        if (this.kind) {
          console.log("constant kind", this.kind);
        }
        if (this.value === true || this.value === false) {
          return this.value + "";
        } else if (this.value === _b_2.None) {
          return "_b_.None";
        } else if (typeof this.value == "string") {
          var s = this.value, srg = $B2.surrogates(s);
          if (srg.length == 0) {
            return `'${s}'`;
          }
          return `$B.make_String('${s}', [${srg}])`;
        } else if (this.value.__class__ === _b_2.bytes) {
          return `_b_.bytes.$factory([${this.value.source}])`;
        } else if (typeof this.value == "number") {
          if (Number.isInteger(this.value)) {
            return this.value;
          } else {
            return `({__class__: _b_.float, value: ${this.value}})`;
          }
        } else if (this.value.__class__ === $B2.long_int) {
          return `$B.fast_long_int(${this.value.value}n)`;
        } else if (this.value.__class__ === _b_2.float) {
          return `({__class__: _b_.float, value: ${this.value.value}})`;
        } else if (this.value.__class__ === _b_2.complex) {
          return `$B.make_complex(${this.value.$real.value}, ${this.value.$imag.value})`;
        } else if (this.value === _b_2.Ellipsis) {
          return `_b_.Ellipsis`;
        } else {
          console.log("invalid value", this.value);
          throw SyntaxError("bad value", this.value);
        }
      };
      $B2.ast.Continue.prototype.to_js = function(scopes) {
        if (!in_loop(scopes)) {
          compiler_error(this, "'continue' not properly in loop");
        }
        return prefix + "continue";
      };
      $B2.ast.Delete.prototype.to_js = function(scopes) {
        compiler_check(this);
        var js = "";
        for (var target of this.targets) {
          var inum = add_to_positions(scopes, target);
          if (target instanceof $B2.ast.Name) {
            var scope = name_scope(target.id, scopes);
            var locals_id = "null";
            if (scope.found) {
              scope.found.locals.delete(target.id);
              locals_id = "locals_" + qualified_scope_name(scopes, scope.found);
              js += `$B.$delete("${target.id}", ${locals_id}, ${inum})
`;
            } else {
              js += `$B.$delete('${target.id}', '${scope.resolve}', ${inum})
`;
            }
          } else if (target instanceof $B2.ast.Subscript) {
            js += `$B.$delitem(${$B2.js_from_ast(target.value, scopes)}, ${$B2.js_from_ast(target.slice, scopes)}, ${inum})
`;
          } else if (target instanceof $B2.ast.Attribute) {
            js += `$B.$delattr(${$B2.js_from_ast(target.value, scopes)}, '${target.attr}', ${inum})
`;
          }
        }
        return prefix + `$B.set_lineno(frame, ${this.lineno})
` + prefix + js;
      };
      $B2.ast.Delete.prototype._check = function() {
        for (var target of this.targets) {
          check_assign_or_delete(this, target, "delete");
        }
      };
      $B2.ast.Dict.prototype.to_js = function(scopes) {
        var items = [], keys = this.keys, has_packed = false;
        function no_key(i) {
          return keys[i] === _b_2.None || keys[i] === void 0;
        }
        for (let i = 0, len = this.keys.length; i < len; i++) {
          if (no_key(i)) {
            has_packed = true;
            items.push("_b_.list.$factory(_b_.dict.items(" + $B2.js_from_ast(this.values[i], scopes) + "))");
          } else {
            var item2 = `[${$B2.js_from_ast(this.keys[i], scopes)}, ${$B2.js_from_ast(this.values[i], scopes)}`;
            if (this.keys[i] instanceof $B2.ast.Constant) {
              var v = this.keys[i].value;
              if (typeof v == "string") {
                item2 += ", " + $B2.$hash(string_from_ast_value(v));
              } else {
                try {
                  var hash = $B2.$hash(this.keys[i].value);
                  item2 += `, ${hash}`;
                } catch (err) {
                }
              }
            }
            items.push(item2 + "]");
          }
        }
        if (!has_packed) {
          return `_b_.dict.$literal([${items}])`;
        }
        var first = no_key(0) ? items[0] : `[${items[0]}]`, js = "_b_.dict.$literal(" + first;
        for (let i = 1, len = items.length; i < len; i++) {
          let arg = no_key(i) ? items[i] : `[${items[i]}]`;
          js += `.concat(${arg})`;
        }
        return js + ")";
      };
      $B2.ast.DictComp.prototype.to_js = function(scopes) {
        return make_comp.bind(this)(scopes);
      };
      $B2.ast.Expr.prototype.to_js = function(scopes) {
        return prefix + `$B.set_lineno(frame, ${this.lineno});
` + prefix + $B2.js_from_ast(this.value, scopes);
      };
      $B2.ast.Expression.prototype.to_js = function(scopes) {
        init_scopes.bind(this)("expression", scopes);
        var res = $B2.js_from_ast(this.body, scopes);
        var positions = scopes[scopes.length - 1].positions;
        if (positions) {
          res = prefix + `(frame.positions = [${positions}], ` + res + ")";
        }
        return res;
      };
      $B2.ast.For.prototype.to_js = function(scopes) {
        compiler_check(this);
        var id = make_id(), iter = $B2.js_from_ast(this.iter, scopes), js = prefix + `frame.$lineno = ${this.lineno}
`;
        var scope = $B2.last(scopes), new_scope = copy_scope(scope, this, id);
        scopes.push(new_scope);
        if (this instanceof $B2.ast.AsyncFor) {
          js += prefix + `var no_break_${id} = true,
` + prefix + tab + tab + `iter_${id} = ${iter},
` + prefix + tab + tab + `type_${id} = _b_.type.$factory(iter_${id})
` + prefix + `iter_${id} = $B.$call($B.$getattr(type_${id}, "__aiter__"))(iter_${id})
` + prefix + `type_${id} = _b_.type.$factory(iter_${id})
` + prefix + `var next_func_${id} = $B.$call($B.$getattr(type_${id}, '__anext__'))
` + prefix + `while(true){
`;
          indent();
          js += prefix + `try{
` + prefix + tab + `var next_${id} = await $B.promise(next_func_${id}(iter_${id}))
` + prefix + `}catch(err){
` + prefix + tab + `if($B.is_exc(err, [_b_.StopAsyncIteration])){
` + prefix + tab + tab + `break
` + prefix + tab + `}else{
` + prefix + tab + tab + `throw err
` + prefix + tab + "}\n" + prefix + `}
`;
          dedent();
        } else {
          js += prefix + `var no_break_${id} = true,
` + prefix + tab + tab + `iterator_${id} = ${iter}
`;
          if (this.iter.inum) {
            js += prefix + tab + tab + `iterator_${id}.$inum = ${this.iter.inum}
`;
          }
          js += prefix + `for(var next_${id} of $B.make_js_iterator(iterator_${id}, frame, ${this.lineno})){
`;
        }
        var name3 = new $B2.ast.Name(`next_${id}`, new $B2.ast.Load());
        copy_position(name3, this.iter);
        name3.to_js = function() {
          return `next_${id}`;
        };
        var assign = new $B2.ast.Assign([this.target], name3);
        assign.$loopvar = true;
        copy_position(assign, this.target);
        indent();
        js += assign.to_js(scopes) + "\n";
        js += add_body(this.body, scopes);
        dedent();
        js += "\n" + prefix + "}\n";
        scopes.pop();
        if (this.orelse.length > 0) {
          js += prefix + `if(no_break_${id}){
`;
          indent();
          js += add_body(this.orelse, scopes) + "\n";
          dedent();
          js += prefix + "}\n";
        }
        return js;
      };
      $B2.ast.FormattedValue.prototype.to_js = function(scopes) {
        var value2 = $B2.js_from_ast(this.value, scopes);
        if (this.conversion == 114) {
          value2 = `_b_.repr(${value2})`;
        } else if (this.conversion == 115) {
          value2 = `_b_.str.$factory(${value2})`;
        } else if (this.conversion == 97) {
          value2 = `_b_.ascii(${value2})`;
        }
        if (this.format_spec) {
          value2 = `_b_.str.format('{0:' + ` + $B2.js_from_ast(this.format_spec, scopes) + ` + '}', ${value2})`;
        } else if (this.conversion == -1) {
          value2 = `_b_.str.$factory(${value2})`;
        }
        return value2;
      };
      function transform_args(scopes) {
        var has_posonlyargs = this.args.posonlyargs.length > 0, _defaults = [], nb_defaults = this.args.defaults.length, positional = this.args.posonlyargs.concat(this.args.args), ix = positional.length - nb_defaults, default_names = [], kw_defaults = [], annotations;
        for (let arg of positional.concat(this.args.kwonlyargs).concat(
          [this.args.vararg, this.args.kwarg]
        )) {
          if (arg && arg.annotation) {
            annotations = annotations || {};
            annotations[arg.arg] = arg.annotation;
          }
        }
        for (var i = ix; i < positional.length; i++) {
          default_names.push(`${positional[i].arg}`);
          _defaults.push(`${positional[i].arg}: ${$B2.js_from_ast(this.args.defaults[i - ix], scopes)}`);
        }
        ix = -1;
        for (let arg of this.args.kwonlyargs) {
          ix++;
          if (this.args.kw_defaults[ix] === _b_2.None) {
            continue;
          }
          if (this.args.kw_defaults[ix] === void 0) {
            _defaults.push(`${arg.arg}: _b_.None`);
          } else {
            var v = $B2.js_from_ast(this.args.kw_defaults[ix], scopes);
            _defaults.push(`${arg.arg}: ` + v);
            kw_defaults.push(`${arg.arg}: ${v}`);
          }
        }
        var kw_default_names = [];
        for (var kw of this.args.kwonlyargs) {
          kw_default_names.push(`'${kw.arg}'`);
        }
        return { default_names, _defaults, positional, has_posonlyargs, kw_defaults, kw_default_names, annotations };
      }
      function type_param_in_def(tp, ref, scopes) {
        var gname = scopes[0].name, globals_name = make_scope_name(scopes, scopes[0]);
        var js = "";
        var name3, param_type2 = tp.constructor.$name;
        if (["TypeVar", "TypeVarTuple", "ParamSpec"].includes(param_type2)) {
          name3 = tp.name;
        } else {
          name3 = tp.name.id;
        }
        bind(name3, scopes);
        if (tp.bound) {
          var typevarscope = new Scope(name3, "typevarbound", tp);
          scopes.push(typevarscope);
          js += `function BOUND_OF_${name3}(){
var current_frame = $B.frame_obj.frame,
frame = ['BOUND_OF_${name3}', {}, '${gname}', ${globals_name}]
$B.enter_frame(frame, __file__, ${tp.bound.lineno})
try{
var res = ${tp.bound.to_js(scopes)}
$B.leave_frame()
return res
}catch(err){
$B.leave_frame()
throw err
}
}
`;
          scopes.pop();
        }
        js += prefix + `locals_${ref}.${name3} = $B.$call(_typing.${param_type2})('${name3}', {$kw: [{infer_variance: true}]})
` + prefix + `type_params.push(locals_${ref}.${name3})
`;
        if (tp.bound) {
          if (!tp.bound.elts) {
            js += `_typing.${param_type2}._set_lazy_eval(locals_${ref}.${name3}, '__bound__', BOUND_OF_${name3})
`;
          } else {
            js += `_typing.${param_type2}._set_lazy_eval(locals_${ref}.${name3}, '__constraints__', BOUND_OF_${name3})
`;
          }
        }
        return js;
      }
      $B2.ast.FunctionDef.prototype.to_js = function(scopes) {
        compiler_check(this);
        var symtable_block = scopes.symtable.table.blocks.get(fast_id(this));
        var in_class = last_scope(scopes).ast instanceof $B2.ast.ClassDef, is_async = this instanceof $B2.ast.AsyncFunctionDef, mangle_arg = (x) => x;
        if (in_class) {
          var class_scope = last_scope(scopes);
          mangle_arg = (x) => mangle(scopes, class_scope, x);
        }
        var func_name_scope = bind(this.name, scopes);
        var gname = scopes[0].name, globals_name = make_scope_name(scopes, scopes[0]);
        var decorators = [], decorated = false, decs_declare = this.decorator_list.length > 0 ? prefix + "// declare decorators\n" : "";
        for (let dec of this.decorator_list) {
          decorated = true;
          var dec_id = "decorator" + make_id();
          decorators.push(dec_id);
          decs_declare += prefix + `$B.set_lineno(frame, ${dec.lineno})
`;
          decs_declare += prefix + `var ${dec_id} = ${$B2.js_from_ast(dec, scopes)}
`;
        }
        var docstring = extract_docstring(this, scopes);
        var parsed_args = transform_args.bind(this)(scopes), positional = parsed_args.positional, kw_defaults = parsed_args.kw_defaults, kw_default_names = parsed_args.kw_default_names;
        var defaults = this.args.defaults.length == 0 ? "_b_.None" : `[${this.args.defaults.map((x) => x.to_js(scopes))}]`;
        kw_defaults = kw_default_names.length == 0 ? "_b_.None" : `{${kw_defaults.join(", ")}}`;
        var id = make_id(), name22 = this.name + id;
        var has_type_params = this.type_params.length > 0, type_params = "";
        if (has_type_params) {
          check_type_params(this);
          var tp_name = `type_params_${name22}`;
          var type_params_scope = new Scope(tp_name, "type_params", this.type_params);
          scopes.push(type_params_scope);
          var type_params_ref = qualified_scope_name(scopes, type_params_scope);
          var type_params_func = `function TYPE_PARAMS_OF_${name22}(){
`;
          type_params = prefix + `$B.$import('_typing')
` + prefix + `var _typing = $B.imported._typing
` + prefix + `var locals_${type_params_ref} = {},
` + prefix + tab + tab + `locals = locals_${type_params_ref},
` + prefix + tab + tab + `frame = ['${type_params_ref}', locals, '${gname}', ${globals_name}],
` + prefix + tab + tab + `type_params = []
` + prefix + `$B.enter_frame(frame, '${scopes.filename}', ${this.lineno})
`;
          for (var item2 of this.type_params) {
            type_params += type_param_in_def(item2, type_params_ref, scopes);
          }
          type_params_func += type_params;
        }
        var func_scope = new Scope(this.name, "def", this);
        scopes.push(func_scope);
        var args = positional.concat(this.args.kwonlyargs), slots = [], arg_names = [];
        for (let arg of args) {
          slots.push(arg.arg + ": null");
          bind(arg.arg, scopes);
        }
        for (let arg of this.args.posonlyargs) {
          arg_names.push(`'${mangle_arg(arg.arg)}'`);
        }
        for (let arg of this.args.args.concat(this.args.kwonlyargs)) {
          arg_names.push(`'${mangle_arg(arg.arg)}'`);
        }
        if (this.args.vararg) {
          bind(mangle_arg(this.args.vararg.arg), scopes);
        }
        if (this.args.kwarg) {
          bind(mangle_arg(this.args.kwarg.arg), scopes);
        }
        var is_generator = symtable_block.generator;
        var function_body;
        indent(is_generator ? 3 : 2);
        if (this.$is_lambda) {
          var _return = new $B2.ast.Return(this.body);
          copy_position(_return, this.body);
          var body = [_return];
          function_body = add_body(body, scopes);
        } else {
          function_body = add_body(this.body, scopes);
        }
        dedent(is_generator ? 3 : 2);
        var parse_args = [name22];
        var js = prefix + `$B.set_lineno(frame, ${this.lineno})
` + prefix;
        if (is_async && !is_generator) {
          js += "async ";
        }
        js += `function ${name22}(){
`;
        indent();
        var locals_name = make_scope_name(scopes, func_scope);
        js += prefix + `var locals
`;
        parse_args.push("arguments");
        var args_vararg = this.args.vararg === void 0 ? "null" : "'" + mangle_arg(this.args.vararg.arg) + "'", args_kwarg = this.args.kwarg === void 0 ? "null" : "'" + mangle_arg(this.args.kwarg.arg) + "'";
        if (positional.length == 0 && slots.length == 0 && this.args.vararg === void 0 && this.args.kwarg === void 0) {
          js += prefix + `var ${locals_name} = locals = {};
`;
          js += prefix + `if(arguments.length !== 0){
` + prefix + tab + `${name22}.$args_parser(${parse_args.join(", ")})
` + prefix + `}
`;
        } else if (this.name == "fxd51jy") {
          js += prefix + `var ${locals_name} = locals = $B.args_parser(${name22}, arguments)
`;
        } else {
          js += prefix + `var ${locals_name} = locals = ${name22}.$args_parser(${parse_args.join(", ")})
`;
        }
        js += prefix + `var frame = ["${this.$is_lambda ? "<lambda>" : this.name}", locals, "${gname}", ${globals_name}, ${name22}]
` + prefix + `$B.enter_frame(frame, __file__, ${this.lineno})
`;
        if (func_scope.positions) {
          js += prefix + `frame.positions = [${func_scope.positions}]
`;
        }
        if (func_scope.needs_stack_length) {
          js += prefix + `var stack_length = $B.count_frames()
`;
        }
        if (func_scope.needs_frames || is_async) {
          js += prefix + `var _frame_obj = $B.frame_obj
`;
        }
        if (is_async) {
          js += prefix + "frame.$async = true\n";
        }
        if (is_generator) {
          js += prefix + `locals.$is_generator = true
`;
          if (is_async) {
            js += prefix + `var gen_${id} = async function*(){
`;
          } else {
            js += prefix + `var gen_${id} = function*(){
`;
          }
          indent();
        }
        js += prefix + `try{
`;
        indent();
        js += prefix + `$B.js_this = this
`;
        if (in_class) {
          var ix = scopes.indexOf(class_scope), parent = scopes[ix - 1];
          var scope_ref = make_scope_name(scopes, parent), class_ref = class_scope.name, refs = class_ref.split(".").map((x) => `'${x}'`);
          bind("__class__", scopes);
          js += prefix + `locals.__class__ =  $B.get_method_class(${name22}, ${scope_ref}, "${class_ref}", [${refs}])
`;
        }
        js += function_body + "\n";
        if (!this.$is_lambda && !($B2.last(this.body) instanceof $B2.ast.Return)) {
          js += prefix + "return $B.trace_return_and_leave(frame, _b_.None)\n";
        }
        dedent();
        js += prefix + `}catch(err){
`;
        indent();
        if (func_scope.needs_frames) {
          js += prefix + `$B.set_exc_and_trace(frame, err)
$B.leave_frame()
throw err
`;
        } else {
          js += prefix + `$B.set_exc_and_leave(frame, err)
`;
        }
        dedent();
        js += prefix + `}
`;
        dedent();
        js += prefix + `}`;
        if (is_generator) {
          js += "\n" + prefix + `gen_${id} = `;
          if (is_async) {
            js += `$B.async_generator.$factory(`;
          } else {
            js += `$B.generator.$factory(`;
          }
          js += `gen_${id}, '${this.name}')
`;
          js += prefix + `var _gen_${id} = gen_${id}()
` + prefix + `_gen_${id}.$frame = frame
` + prefix + `$B.leave_frame()
` + prefix + `return _gen_${id}
`;
          dedent();
          js += prefix + "}\n";
        } else {
          js += "\n";
        }
        scopes.pop();
        var qualname = in_class ? `${func_name_scope.name}.${this.name}` : this.name;
        var flags = $B2.COMPILER_FLAGS.OPTIMIZED | $B2.COMPILER_FLAGS.NEWLOCALS;
        if (this.args.vararg) {
          flags |= $B2.COMPILER_FLAGS.VARARGS;
        }
        if (this.args.kwarg) {
          flags |= $B2.COMPILER_FLAGS.VARKEYWORDS;
        }
        if (is_generator) {
          flags |= $B2.COMPILER_FLAGS.GENERATOR;
        }
        if (is_async) {
          flags |= $B2.COMPILER_FLAGS.COROUTINE;
        }
        var parameters = [], locals = [], identifiers = _b_2.dict.$keys_string(symtable_block.symbols);
        var free_vars = [];
        for (var ident of identifiers) {
          var flag = _b_2.dict.$getitem_string(symtable_block.symbols, ident), _scope = flag >> SF.SCOPE_OFF & SF.SCOPE_MASK;
          if (_scope == SF.FREE) {
            free_vars.push(`'${ident}'`);
          }
          if (flag & SF.DEF_PARAM) {
            parameters.push(`'${ident}'`);
          } else if (flag & SF.DEF_LOCAL) {
            locals.push(`'${ident}'`);
          }
        }
        var varnames = parameters.concat(locals);
        if (in_class) {
          js += prefix + `${name22}.$is_method = true
`;
        }
        var anns, anns_values, anns_strings, postponed;
        if (this.returns || parsed_args.annotations) {
          var features = scopes.symtable.table.future.features, postponed = features & $B2.CO_FUTURE_ANNOTATIONS;
          if (postponed) {
            var src = scopes.src;
            if (src === void 0) {
              console.log("no src, filename", scopes);
            }
          }
          var ann_items_values = [];
          var ann_items_strings = [];
          if (parsed_args.annotations) {
            for (var arg_ann in parsed_args.annotations) {
              var ann_ast = parsed_args.annotations[arg_ann];
              if (in_class) {
                arg_ann = mangle(scopes, class_scope, arg_ann);
              }
              var ann_str = annotation_to_str(ann_ast, scopes);
              ann_items_strings.push(`['${arg_ann}', '${ann_str}']`);
              var value2 = ann_ast.to_js(scopes);
              ann_items_values.push(`['${arg_ann}', ${value2}]`);
            }
          }
          if (this.returns) {
            var ann_str = annotation_to_str(this.returns, scopes);
            ann_items_strings.push(`['return', '${ann_str}']`);
            var ann_value;
            if (scopes.postpone_annotations) {
              ann_value = `'${annotation_to_str(this.returns, scopes)}'`;
            } else {
              ann_value = this.returns.to_js(scopes);
            }
            ann_items_values.push(`['return', ${ann_value}]`);
          }
          anns_values = `[${ann_items_values.join(", ")}]`;
          anns_strings = `[${ann_items_strings.join(", ")}]`;
          anns = ann_items_values.length > 0;
        } else {
          anns = false;
        }
        var annotations = postponed ? anns_strings : "false";
        js += prefix + `${name22}.$function_infos = ['${gname}', '${this.$is_lambda ? "<lambda>" : this.name}', '${this.$is_lambda ? "<lambda>" : qualname}', __file__, ${defaults}, ${kw_defaults}, ${docstring}, [${arg_names}], ${args_vararg}, ${args_kwarg},
` + prefix + tab + `${positional.length}, ${this.lineno}, ${flags}, [${free_vars}], ${this.args.kwonlyargs.length}, ${this.args.posonlyargs.length}, [${varnames}], ${annotations}, ${has_type_params ? "type_params" : "[]"}]
`;
        js += prefix + `${name22}.$args_parser = $B.make_args_parser_and_parse
`;
        if (anns && !postponed) {
          var inum = add_to_positions(scopes, this);
          js += prefix + `${name22}.__annotate__ = function(format){
`;
          indent();
          js += prefix + `var locals = {format}
` + prefix + `var frame = ['__annotate__', locals, '${gname}', ${globals_name}]
` + prefix + `$B.enter_frame(frame, __file__, ${this.lineno})
` + prefix + `frame.positions = $B.frame_obj.prev.frame.positions
` + prefix + `frame.positions.push([${this.lineno}, ${this.end_lineno}, ${this.col_offset}, ${this.end_col_offset}])
` + prefix + "try{\n";
          indent();
          js += prefix + `if(format == 1 || format == 2){
` + prefix + tab + `var res = _b_.dict.$literal(${anns_values})
` + prefix + tab + `return $B.trace_return_and_leave(frame, res)
` + prefix + "}\n" + prefix + `frame.inum = 2 * frame.positions.length - 1
` + prefix + `throw _b_.NotImplementedError.$factory('')
`;
          dedent();
          js += prefix + `}catch(err){
`;
          indent();
          js += prefix + `$B.set_exc_and_leave(frame, err)
`;
          dedent();
          js += prefix + "}\n";
          dedent();
          js += prefix + `}
`;
        } else {
          js += prefix + `${name22}.__annotate__ = _b_.None
`;
        }
        if (is_async && !is_generator) {
          js += prefix + `${name22} = $B.make_async(${name22})
`;
        }
        var mangled = mangle(scopes, func_name_scope, this.name), func_ref = `${make_scope_name(scopes, func_name_scope)}.${mangled}`;
        if (decorated) {
          func_ref = `decorated${make_id()}`;
          js += prefix + "var ";
        } else {
          js += prefix;
        }
        js += `${func_ref} = ${name22}
`;
        if (has_type_params) {
          scopes.pop();
        }
        if (decorated && !has_type_params) {
          js += prefix + `${make_scope_name(scopes, func_name_scope)}.${mangled} = `;
          let decorate = func_ref;
          for (let dec of decorators.reverse()) {
            decorate = `$B.$call(${dec})(${decorate})`;
          }
          js += decorate;
        }
        if (has_type_params) {
          type_params_func += "\n" + js + `
${name22}.__type_params__ = $B.fast_tuple(type_params)
$B.leave_frame()
return ${name22}
}
`;
          js = type_params_func;
          if (decorated) {
            js += `var ${func_ref} = TYPE_PARAMS_OF_${name22}()
${make_scope_name(scopes, func_name_scope)}.${mangled} = `;
            let decorate = func_ref;
            for (let dec of decorators.reverse()) {
              decorate = `$B.$call(${dec})(${decorate})`;
            }
            js += decorate;
          } else {
            js += `var locals_${type_params_ref} = TYPE_PARAMS_OF_${name22}()
`;
          }
        }
        js = decs_declare + js;
        return js;
      };
      $B2.ast.FunctionDef.prototype._check = function() {
        for (var arg of this.args.args) {
          if (arg instanceof $B2.ast.arg) {
            if (arg.arg == "__debug__") {
              compiler_error(arg, "cannot assign to __debug__");
            }
          }
        }
        for (var arg of this.args.kwonlyargs) {
          if (arg instanceof $B2.ast.arg) {
            if (arg.arg == "__debug__") {
              compiler_error(arg, "cannot assign to __debug__");
            }
          }
        }
        if (this.args.kwarg && this.args.kwarg.arg == "__debug__") {
          compiler_error(this.args.kwarg, "cannot assign to __debug__");
        }
      };
      $B2.ast.GeneratorExp.prototype.to_js = function(scopes) {
        var id = make_id(), symtable_block = scopes.symtable.table.blocks.get(fast_id(this)), varnames = symtable_block.varnames.map((x) => `"${x}"`);
        var first_for = this.generators[0], outmost_expr = $B2.js_from_ast(first_for.iter, scopes), nb_paren = 1;
        var comp_scope = new Scope(`genexpr_${id}`, "comprehension", this);
        scopes.push(comp_scope);
        var comp = { ast: this, id, type: "genexpr", varnames, module_name: scopes[0].name, locals_name: make_scope_name(scopes), globals_name: make_scope_name(scopes, scopes[0]) };
        indent();
        var head = init_comprehension(comp, scopes);
        var js = prefix + `var gen${id} = $B.generator.$factory(${has_await ? "async " : ""}function*(expr){
`;
        var first = this.generators[0];
        indent();
        js += prefix + `$B.enter_frame(frame, __file__, ${this.lineno})
` + prefix + `var next_func_${id} = $B.make_js_iterator(expr, frame, ${this.lineno})
` + prefix + `for(var next_${id} of next_func_${id}){
`;
        indent();
        js += prefix + `$B.enter_frame(frame, __file__, ${this.lineno})
`;
        var name3 = new $B2.ast.Name(`next_${id}`, new $B2.ast.Load());
        copy_position(name3, first_for.iter);
        name3.to_js = function() {
          return `next_${id}`;
        };
        var assign = new $B2.ast.Assign([first.target], name3);
        assign.lineno = this.lineno;
        js += assign.to_js(scopes) + "\n";
        for (let _if of first.ifs) {
          nb_paren++;
          js += prefix + `if($B.$bool(${$B2.js_from_ast(_if, scopes)})){
`;
          indent();
        }
        for (var comprehension of this.generators.slice(1)) {
          js += comprehension.to_js(scopes);
          nb_paren++;
          for (let _if of comprehension.ifs) {
            nb_paren++;
          }
        }
        dedent(2);
        var elt = $B2.js_from_ast(this.elt, scopes), has_await = comp_scope.has_await;
        dedent();
        indent(3);
        js += has_await ? prefix + "var save_frame_obj = $B.frame_obj;\n" : "";
        js += prefix + `try{
` + prefix + tab + `yield ${elt}
` + prefix + `}catch(err){
` + (has_await ? prefix + tab + "$B.restore_frame_obj(save_frame_obj, locals)\n" : "") + prefix + tab + `$B.leave_frame()
` + prefix + tab + `throw err
` + prefix + `}
`;
        dedent();
        js += has_await ? prefix + "\n$B.restore_frame_obj(save_frame_obj, locals);" : "";
        for (var i = 0; i < nb_paren - 1; i++) {
          js += prefix + "}\n";
          dedent();
        }
        js += prefix + "$B.leave_frame()\n";
        dedent();
        js += prefix + "}\n";
        js += prefix + "$B.leave_frame()\n";
        js += prefix + '}, "<genexpr>")(expr)\n';
        scopes.pop();
        var func = `${head}
${js}
` + prefix + `return gen${id}`;
        dedent();
        return prefix + `(function(expr){
${func}
` + prefix + `})(${outmost_expr})
`;
      };
      $B2.ast.Global.prototype.to_js = function(scopes) {
        var scope = last_scope(scopes);
        for (var name3 of this.names) {
          scope.globals.add(name3);
        }
        return "";
      };
      $B2.ast.If.prototype.to_js = function(scopes) {
        var scope = $B2.last(scopes), new_scope = copy_scope(scope, this);
        var js = prefix + `if($B.set_lineno(frame, ${this.lineno}) && `;
        if (this.test instanceof $B2.ast.BoolOp) {
          this.test.$dont_evaluate = true;
          js += `${$B2.js_from_ast(this.test, scopes)}){
`;
        } else {
          js += `$B.$bool(${$B2.js_from_ast(this.test, scopes)})){
`;
        }
        scopes.push(new_scope);
        indent();
        js += add_body(this.body, scopes) + "\n";
        dedent();
        js += prefix + "}";
        scopes.pop();
        if (this.orelse.length > 0) {
          if (this.orelse[0] instanceof $B2.ast.If && this.orelse.length == 1) {
            js += "else " + $B2.js_from_ast(this.orelse[0], scopes).trimLeft();
            indent();
            js += add_body(this.orelse.slice(1), scopes);
            dedent();
          } else {
            js += "else{\n";
            scopes.push(copy_scope(scope, this));
            indent();
            js += add_body(this.orelse, scopes);
            dedent();
            scopes.pop();
            js += "\n" + prefix + "}";
          }
        }
        return js;
      };
      $B2.ast.IfExp.prototype.to_js = function(scopes) {
        return "($B.$bool(" + $B2.js_from_ast(this.test, scopes) + ") ? " + $B2.js_from_ast(this.body, scopes) + ": " + $B2.js_from_ast(this.orelse, scopes) + ")";
      };
      $B2.ast.Import.prototype.to_js = function(scopes) {
        var js = prefix + `$B.set_lineno(frame, ${this.lineno})
`;
        var inum = add_to_positions(scopes, this);
        for (var alias of this.names) {
          js += prefix + `$B.$import("${alias.name}", [], `;
          if (alias.asname) {
            var binding_scope = bind(alias.asname, scopes);
            var scope_name = make_scope_name(scopes, binding_scope);
            js += `{'${alias.name}': [${scope_name}, '${alias.asname}']}, `;
          } else {
            js += "{}, ";
            bind(alias.name, scopes);
          }
          var parts = alias.name.split(".");
          for (var i = 0; i < parts.length; i++) {
            scopes.imports[parts.slice(0, i + 1).join(".")] = true;
          }
          js += `locals, ${inum})
`;
        }
        return js.trimRight();
      };
      $B2.ast.ImportFrom.prototype.to_js = function(scopes) {
        if (this.module === "__future__") {
          if (!($B2.last(scopes).ast instanceof $B2.ast.Module)) {
            compiler_error(this, "from __future__ imports must occur at the beginning of the file", $B2.last(this.names));
          }
        }
        var js = prefix + `$B.set_lineno(frame, ${this.lineno})
` + prefix + `$B.$import_from("${this.module || ""}", `;
        var names = this.names.map((x) => `"${x.name}"`).join(", "), aliases = [];
        for (var name3 of this.names) {
          if (name3.asname) {
            var binding_scope = bind(name3.asname, scopes);
            var scope_name = make_scope_name(scopes, binding_scope);
            aliases.push(`${name3.name}: [${scope_name}, '${name3.asname}']`);
          }
        }
        var inum = add_to_positions(scopes, this);
        js += `[${names}], {${aliases.join(", ")}}, ${this.level}, locals, ${inum});`;
        for (var alias of this.names) {
          if (alias.asname) {
          } else if (alias.name == "*") {
            last_scope(scopes).blurred = true;
          } else {
            bind(alias.name, scopes);
          }
        }
        return js;
      };
      $B2.ast.Interactive.prototype.to_js = function(scopes) {
        mark_parents(this);
        var name3 = init_scopes.bind(this)("module", scopes);
        var module_id = name3, global_name = make_scope_name(scopes), mod_name = module_name(scopes);
        var js = `// Javascript code generated from ast
var $B = __BRYTHON__,
_b_ = $B.builtins,
`;
        js += `${global_name} = {}, // $B.imported["${mod_name}"],
locals = ${global_name},
frame = ["${module_id}", locals, "${module_id}", locals]`;
        js += `
var __file__ = '${scopes.filename ?? "<string>"}'
locals.__name__ = '${name3}'
locals.__doc__ = ${extract_docstring(this, scopes)}
`;
        if (!scopes.imported) {
          js += `locals.__annotations__ = locals.__annotations__ || $B.empty_dict()
`;
        }
        js += `$B.enter_frame(frame, __file__, 1)
`;
        js += "\nvar _frame_obj = $B.frame_obj\n";
        js += "var stack_length = $B.count_frames()\n";
        js += `try{
` + add_body(this.body, scopes) + `
$B.leave_frame({locals, value: _b_.None})
}catch(err){
$B.set_exc_and_trace(frame, err)
$B.leave_frame({locals, value: _b_.None})
throw err
}`;
        scopes.pop();
        console.log("Interactive", js);
        return js;
      };
      $B2.ast.Interpolation.prototype.to_js = function(scopes) {
        var conversion = this.conversion == -1 ? "_b_.None" : `'${this.conversion}'`;
        return `[${this.value.to_js(scopes)}, '${this.value.id}', ${conversion}, ${this.format_spec ?? "''"}]`;
      };
      $B2.ast.JoinedStr.prototype.to_js = function(scopes) {
        var items = this.values.map((s) => $B2.js_from_ast(s, scopes));
        if (items.length == 0) {
          return "''";
        }
        return items.join(" + ");
      };
      $B2.ast.Lambda.prototype.to_js = function(scopes) {
        var id = make_id(), name3 = "lambda_" + $B2.lambda_magic + "_" + id;
        var f = new $B2.ast.FunctionDef(name3, this.args, this.body, []);
        f.lineno = this.lineno;
        f.$id = fast_id(this);
        f.$is_lambda = true;
        indent();
        var js = f.to_js(scopes), lambda_ref = reference(scopes, last_scope(scopes), name3);
        js = `(function(){
${js}
` + prefix + `return ${lambda_ref}
`;
        dedent();
        return js + prefix + `})()`;
      };
      function list_or_tuple_to_js(func, scopes) {
        if (this.elts.filter((x) => x instanceof $B2.ast.Starred).length > 0) {
          var parts = [], simple = [];
          for (var elt of this.elts) {
            if (elt instanceof $B2.ast.Starred) {
              elt.$handled = true;
              parts.push(`[${simple.join(", ")}]`);
              simple = [];
              parts.push(`_b_.list.$factory(${$B2.js_from_ast(elt, scopes)})`);
            } else {
              simple.push($B2.js_from_ast(elt, scopes));
            }
          }
          if (simple.length > 0) {
            parts.push(`[${simple.join(", ")}]`);
          }
          var js = parts[0];
          for (var part of parts.slice(1)) {
            js += `.concat(${part})`;
          }
          return `${func}(${js})`;
        }
        var elts = this.elts.map((x) => $B2.js_from_ast(x, scopes));
        return `${func}([${elts.join(", ")}])`;
      }
      $B2.ast.List.prototype.to_js = function(scopes) {
        return list_or_tuple_to_js.bind(this)("$B.$list", scopes);
      };
      $B2.ast.ListComp.prototype.to_js = function(scopes) {
        compiler_check(this);
        return make_comp.bind(this)(scopes);
      };
      $B2.ast.match_case.prototype.to_js = function(scopes) {
        var js = `($B.set_lineno(frame, ${this.lineno}) && $B.pattern_match(subject, {${$B2.js_from_ast(this.pattern, scopes)}})`;
        if (this.guard) {
          js += ` && $B.$bool(${$B2.js_from_ast(this.guard, scopes)})`;
        }
        js += `){
`;
        indent();
        js += add_body(this.body, scopes) + "\n";
        dedent();
        js += prefix + "}";
        return js;
      };
      function is_irrefutable(pattern) {
        switch (pattern.constructor) {
          case $B2.ast.MatchAs:
            if (pattern.pattern === void 0) {
              return pattern;
            } else {
              return is_irrefutable(pattern.pattern);
            }
          case $B2.ast.MatchOr:
            for (var i = 0; i < pattern.patterns.length; i++) {
              if (is_irrefutable(pattern.patterns[i])) {
                if (i == pattern.patterns.length - 1) {
                  return pattern;
                }
                irrefutable_error(pattern.patterns[i]);
              }
            }
            break;
        }
      }
      function irrefutable_error(pattern) {
        var msg = pattern.name ? `name capture '${pattern.name}'` : "wildcard";
        msg += " makes remaining patterns unreachable";
        compiler_error(pattern, msg);
      }
      function pattern_bindings(pattern) {
        var bindings = [];
        switch (pattern.constructor) {
          case $B2.ast.MatchAs:
            if (pattern.name) {
              bindings.push(pattern.name);
            }
            break;
          case $B2.ast.MatchSequence:
            for (var p of pattern.patterns) {
              bindings = bindings.concat(pattern_bindings(p));
            }
            break;
          case $B2.ast.MatchOr:
            bindings = pattern_bindings(pattern.patterns[0]);
            var err_msg = "alternative patterns bind different names";
            for (var i = 1; i < pattern.patterns.length; i++) {
              var _bindings = pattern_bindings(pattern.patterns[i]);
              if (_bindings.length != bindings.length) {
                compiler_error(pattern, err_msg);
              } else {
                for (var j2 = 0; j2 < bindings.length; j2++) {
                  if (bindings[j2] != _bindings[j2]) {
                    compiler_error(pattern, err_msg);
                  }
                }
              }
            }
            break;
        }
        return bindings.sort();
      }
      $B2.ast.Match.prototype.to_js = function(scopes) {
        var irrefutable;
        var js = prefix + `var subject = ${$B2.js_from_ast(this.subject, scopes)}
`, first = true;
        for (var _case of this.cases) {
          if (!_case.guard) {
            if (irrefutable) {
              irrefutable_error(irrefutable);
            }
            irrefutable = is_irrefutable(_case.pattern);
          }
          if (first) {
            js += prefix + "if";
            first = false;
          } else {
            js += "else if";
          }
          js += $B2.js_from_ast(_case, scopes);
        }
        return prefix + `$B.set_lineno(frame, ${this.lineno})
` + js;
      };
      $B2.ast.MatchAs.prototype.to_js = function(scopes) {
        var scope = $B2.last(scopes);
        var name3 = this.name === void 0 ? "_" : this.name, params;
        if (this.pattern === void 0) {
          params = `capture: '${name3}'`;
        } else {
          var pattern = $B2.js_from_ast(this.pattern, scopes);
          if (this.pattern instanceof $B2.ast.MatchAs && this.pattern.name) {
            pattern = `group: [{${pattern}}]`;
          }
          params = `${pattern}, alias: '${name3}'`;
        }
        if (scope.bindings) {
          if (scope.bindings.indexOf(name3) > -1) {
            compiler_error(this, `multiple assignment to name '${name3}' in pattern`);
          }
          scope.bindings.push(name3);
        }
        return params;
      };
      $B2.ast.MatchClass.prototype.to_js = function(scopes) {
        var names = [];
        for (let pattern of this.patterns.concat(this.kwd_patterns)) {
          let name3 = pattern.name;
          if (name3) {
            if (names.indexOf(name3) > -1) {
              compiler_error(pattern, `multiple assignment to name '${name3}' in pattern`);
            }
            names.push(name3);
          }
        }
        names = [];
        for (let i = 0; i < this.kwd_attrs.length; i++) {
          let kwd_attr = this.kwd_attrs[i];
          if (names.indexOf(kwd_attr) > -1) {
            compiler_error(this.kwd_patterns[i], `attribute name repeated in class pattern: ${kwd_attr}`);
          }
          names.push(kwd_attr);
        }
        var cls = $B2.js_from_ast(this.cls, scopes), patterns = this.patterns.map((x) => `{${$B2.js_from_ast(x, scopes)}}`);
        var kw = [];
        for (let i = 0, len = this.kwd_patterns.length; i < len; i++) {
          kw.push(this.kwd_attrs[i] + ": {" + $B2.js_from_ast(this.kwd_patterns[i], scopes) + "}");
        }
        return `class: ${cls}, args: [${patterns}], keywords: {${kw.join(", ")}}`;
      };
      $B2.ast.MatchMapping.prototype.to_js = function(scopes) {
        for (let key3 of this.keys) {
          if (key3 instanceof $B2.ast.Attribute || key3 instanceof $B2.ast.Constant || key3 instanceof $B2.ast.UnaryOp || key3 instanceof $B2.ast.BinOp) {
            continue;
          } else {
            compiler_error(key3, "mapping pattern keys may only match literals and attribute lookups");
          }
        }
        var names = [];
        for (let pattern of this.patterns) {
          if (pattern instanceof $B2.ast.MatchAs && pattern.name) {
            if (names.indexOf(pattern.name) > -1) {
              compiler_error(pattern, `multiple assignments to name '${pattern.name}' in pattern`);
            }
            names.push(pattern.name);
          }
        }
        var items = [];
        for (let i = 0, len = this.keys.length; i < len; i++) {
          let key_prefix = this.keys[i] instanceof $B2.ast.Constant ? "literal: " : "value: ", key3 = $B2.js_from_ast(this.keys[i], scopes), value2 = $B2.js_from_ast(this.patterns[i], scopes);
          items.push(`[{${key_prefix}${key3}}, {${value2}}]`);
        }
        var js = "mapping: [" + items.join(", ") + "]";
        if (this.rest) {
          js += `, rest: '${this.rest}'`;
        }
        return js;
      };
      $B2.ast.MatchOr.prototype.to_js = function(scopes) {
        is_irrefutable(this);
        pattern_bindings(this);
        var items = [];
        for (var alt of this.patterns) {
          items.push(`{${$B2.js_from_ast(alt, scopes)}}`);
        }
        var js = items.join(", ");
        return `or: [${js}]`;
      };
      $B2.ast.MatchSequence.prototype.to_js = function(scopes) {
        var items = [], names = [];
        for (var pattern of this.patterns) {
          if (pattern instanceof $B2.ast.MatchAs && pattern.name) {
            if (names.indexOf(pattern.name) > -1) {
              compiler_error(pattern, `multiple assignments to name '${pattern.name}' in pattern`);
            }
            names.push(pattern.name);
          }
          items.push("{" + $B2.js_from_ast(pattern, scopes) + "}");
        }
        return `sequence: [${items.join(", ")}]`;
      };
      $B2.ast.MatchSingleton.prototype.to_js = function() {
        var value2 = this.value === true ? "_b_.True" : this.value === false ? "_b_.False" : "_b_.None";
        return `literal: ${value2}`;
      };
      $B2.ast.MatchStar.prototype.to_js = function() {
        var name3 = this.name === void 0 ? "_" : this.name;
        return `capture_starred: '${name3}'`;
      };
      $B2.ast.MatchValue.prototype.to_js = function(scopes) {
        if (this.value instanceof $B2.ast.Constant) {
          return `literal: ${$B2.js_from_ast(this.value, scopes)}`;
        } else if (this.value instanceof $B2.ast.Constant || this.value instanceof $B2.ast.UnaryOp || this.value instanceof $B2.ast.BinOp || this.value instanceof $B2.ast.Attribute) {
          return `value: ${$B2.js_from_ast(this.value, scopes)}`;
        } else {
          compiler_error(this, "patterns may only match literals and attribute lookups");
        }
      };
      $B2.ast.Module.prototype.to_js = function(scopes) {
        if (prefix.length != 0) {
          console.log("prefix length at start", prefix.length);
        }
        mark_parents(this);
        var name3 = init_scopes.bind(this)("module", scopes), namespaces = scopes.namespaces;
        var module_id = name3, global_name = make_scope_name(scopes), mod_name = module_name(scopes);
        var js = `var $B = __BRYTHON__,
    _b_ = $B.builtins,
`;
        if (!namespaces) {
          js += `    ${global_name} = $B.imported["${mod_name}"],
    locals = ${global_name},
    frame = ["${module_id}", locals, "${module_id}", locals]`;
        } else {
          js += `    locals = ${namespaces.local_name},
    globals = ${namespaces.global_name}`;
          if (name3) {
            let local_name = ("locals_" + name3).replace(/\./g, "_");
            js += `,
    ${local_name} = locals`;
          }
        }
        js += `
var __file__ = '${scopes.filename ?? "<string>"}'
locals.__name__ = '${name3}'
locals.__doc__ = ${extract_docstring(this, scopes)}
`;
        var insert_positions = js.length;
        if (!namespaces) {
          js += `$B.enter_frame(frame, __file__, 1)
`;
          js += "\nvar _frame_obj = $B.frame_obj\n";
        }
        if (scopes.postpone_annotations) {
          js += `locals.__annotations__ = $B.empty_dict()
`;
        } else {
          js += `locals.$annotations = {}
`;
          bind("__annotate__", scopes);
        }
        js += "var stack_length = $B.count_frames()\n";
        js += `try{
`;
        indent();
        js += add_body(this.body, scopes) + "\n" + prefix + `$B.leave_frame({locals, value: _b_.None})
`;
        dedent();
        js += prefix + `}catch(err){
`;
        indent();
        js += prefix + `$B.set_exc_and_trace(frame, err)
` + prefix + `$B.leave_frame({locals, value: _b_.None})
` + prefix + "throw err\n";
        dedent();
        js += prefix + `}
`;
        var positions = scopes[scopes.length - 1].positions;
        if (positions && positions.length > 0) {
          var rest = js.substr(insert_positions);
          js = js.substr(0, insert_positions) + `frame.positions = [${positions}]
`;
          js += rest;
        }
        scopes.pop();
        if (prefix.length != 0) {
          console.warn("wrong indent !", prefix.length);
          prefix = "";
        }
        return js;
      };
      $B2.ast.Name.prototype.to_js = function(scopes) {
        if (this.ctx instanceof $B2.ast.Store) {
          var scope = bind(this.id, scopes);
          if (scope === $B2.last(scopes) && scope.freevars.has(this.id)) {
            scope.freevars.delete(this.id);
          }
          return reference(scopes, scope, this.id);
        } else if (this.ctx instanceof $B2.ast.Load) {
          if (this.id == "__debug__") {
            return "_b_.__debug__";
          }
          var scope = name_scope(this.id, scopes);
          if (this.id == "xzs") {
            console.log("Name.to_js, scope", scope);
          }
          if (scope.found === $B2.last(scopes)) {
            return "locals." + mangle(scopes, scope.found, this.id);
          }
          var res = name_reference(this.id, scopes, this);
          if (this.id == "__debugger__" && res.startsWith("$B.resolve_in_scopes")) {
            return "debugger";
          }
          return res;
        }
      };
      $B2.ast.NamedExpr.prototype.to_js = function(scopes) {
        compiler_check(this);
        var i = scopes.length - 1;
        while (scopes[i].type == "comprehension") {
          i--;
        }
        var enclosing_scopes = scopes.slice(0, i + 1);
        enclosing_scopes.symtable = scopes.symtable;
        bind(this.target.id, enclosing_scopes);
        return "(" + $B2.js_from_ast(this.target, enclosing_scopes) + " = " + $B2.js_from_ast(this.value, scopes) + ")";
      };
      $B2.ast.NamedExpr.prototype._check = function() {
        check_assign_or_delete(this, this.target);
      };
      $B2.ast.Nonlocal.prototype.to_js = function(scopes) {
        var scope = $B2.last(scopes);
        for (var name3 of this.names) {
          scope.nonlocals.add(name3);
        }
        return "";
      };
      $B2.ast.Pass.prototype.to_js = function() {
        return prefix + `$B.set_lineno(frame, ${this.lineno})
` + prefix + "void(0)";
      };
      $B2.ast.Raise.prototype.to_js = function(scopes) {
        var js = prefix + `$B.set_lineno(frame, ${this.lineno})
` + prefix + "$B.$raise(";
        if (this.exc) {
          js += $B2.js_from_ast(this.exc, scopes);
        }
        if (this.cause) {
          js += ", " + $B2.js_from_ast(this.cause, scopes);
        }
        return js + ")";
      };
      $B2.ast.Return.prototype.to_js = function(scopes) {
        if (last_scope(scopes).type != "def") {
          compiler_error(this, "'return' outside function");
        }
        compiler_check(this);
        var js = prefix + `$B.set_lineno(frame, ${this.lineno})
` + prefix + `return $B.trace_return_and_leave(frame, ` + (this.value ? $B2.js_from_ast(this.value, scopes) : " _b_.None") + ")\n";
        return js;
      };
      function remove_escapes(value2) {
        for (var key3 in $B2.escape2cp) {
          value2 = value2.replace(new RegExp("\\\\" + key3, "g"), $B2.escape2cp[key3]);
        }
        return value2;
      }
      $B2.ast.Set.prototype.to_js = function(scopes) {
        var elts = [];
        for (var elt of this.elts) {
          var js;
          if (elt instanceof $B2.ast.Constant) {
            var v = elt.value;
            if (typeof v == "string") {
              v = remove_escapes(v);
            }
            js = `{constant: [${$B2.js_from_ast(elt, scopes)}, ${$B2.$hash(v)}]}`;
          } else if (elt instanceof $B2.ast.Starred) {
            js = `{starred: ${$B2.js_from_ast(elt.value, scopes)}}`;
          } else {
            js = `{item: ${$B2.js_from_ast(elt, scopes)}}`;
          }
          elts.push(js);
        }
        return `_b_.set.$literal([${elts.join(", ")}])`;
      };
      $B2.ast.SetComp.prototype.to_js = function(scopes) {
        return make_comp.bind(this)(scopes);
      };
      $B2.ast.Slice.prototype.to_js = function(scopes) {
        var lower = this.lower ? $B2.js_from_ast(this.lower, scopes) : "_b_.None", upper = this.upper ? $B2.js_from_ast(this.upper, scopes) : "_b_.None", step = this.step ? $B2.js_from_ast(this.step, scopes) : "_b_.None";
        return `_b_.slice.$fast_slice(${lower}, ${upper}, ${step})`;
      };
      $B2.ast.Starred.prototype.to_js = function(scopes) {
        if (this.$handled) {
          return `_b_.list.$unpack(${$B2.js_from_ast(this.value, scopes)})`;
        }
        if (this.ctx instanceof $B2.ast.Store) {
          compiler_error(this, "starred assignment target must be in a list or tuple");
        } else {
          compiler_error(this, "can't use starred expression here");
        }
      };
      $B2.ast.Subscript.prototype.to_js = function(scopes) {
        var value2 = $B2.js_from_ast(this.value, scopes), slice = $B2.js_from_ast(this.slice, scopes);
        if (this.slice instanceof $B2.ast.Slice) {
          return `$B.getitem_slice(${value2}, ${slice})`;
        } else {
          var inum = add_to_positions(scopes, this);
          return `$B.$getitem(${value2}, ${slice}, ${inum})`;
        }
      };
      $B2.ast.TemplateStr.prototype.to_js = function(scopes) {
        var js = prefix + "$B.Template(";
        var items = [];
        var expect_str = true;
        for (var value2 of this.values) {
          if (value2 instanceof $B2.ast.Constant) {
            items.push(value2.to_js(scopes));
          } else if (value2 instanceof $B2.ast.Interpolation) {
            items.push(value2.to_js(scopes));
          } else {
            throw Error("unexpected type inf temmplate");
          }
        }
        return js + `${items.join(", ")})
`;
      };
      $B2.ast.Try.prototype.to_js = function(scopes) {
        compiler_check(this);
        var id = make_id(), has_except_handlers = this.handlers.length > 0, has_else = this.orelse.length > 0, has_finally = this.finalbody.length > 0;
        var js = prefix + `$B.set_lineno(frame, ${this.lineno})
` + prefix + `try{
`;
        indent();
        js += prefix + `var stack_length_${id} = $B.count_frames()
`;
        js += prefix + `var save_frame_obj_${id} = $B.frame_obj
`;
        if (has_else) {
          js += prefix + `var failed${id} = false
`;
        }
        var try_scope = copy_scope($B2.last(scopes));
        scopes.push(try_scope);
        js += add_body(this.body, scopes) + "\n";
        dedent();
        if (has_except_handlers) {
          var err = "err" + id;
          js += prefix + "}";
          js += `catch(${err}){
`;
          indent();
          js += prefix + `$B.set_exc_and_trace(frame, ${err})
`;
          if (has_else) {
            js += prefix + `failed${id} = true
`;
          }
          var first = true, has_untyped_except = false;
          for (var handler of this.handlers) {
            if (first) {
              js += prefix + "if";
              first = false;
            } else {
              js += prefix + "}else if";
            }
            js += `($B.set_lineno(frame, ${handler.lineno})`;
            if (handler.type) {
              js += ` && $B.is_exc(${err}, `;
              if (handler.type instanceof $B2.ast.Tuple) {
                js += `${$B2.js_from_ast(handler.type, scopes)}`;
              } else {
                js += `[${$B2.js_from_ast(handler.type, scopes)}]`;
              }
              js += `)){
`;
            } else {
              has_untyped_except = true;
              js += "){\n";
            }
            indent();
            if (handler.name) {
              bind(handler.name, scopes);
              var mangled = mangle(scopes, try_scope, handler.name);
              js += prefix + `locals.${mangled} = ${err}
`;
            }
            js += add_body(handler.body, scopes) + "\n";
            if (!($B2.last(handler.body) instanceof $B2.ast.Return)) {
              js += prefix + "$B.del_exc(frame)\n";
              js += prefix + `$B.frame_obj = save_frame_obj_${id}
`;
            }
            dedent();
          }
          if (!has_untyped_except) {
            js += prefix + `}else{
` + prefix + tab + `throw ${err}
`;
          }
          js += prefix + "}\n";
          dedent();
        }
        if (has_else || has_finally) {
          js += prefix + "}";
          js += "finally{\n";
          indent();
          if (has_else && has_finally) {
            indent();
          }
          var finalbody = prefix + `var exit = false
` + prefix + `if($B.count_frames() < stack_length_${id}){
` + prefix + tab + `exit = true
` + prefix + tab + `$B.frame_obj = $B.push_frame(frame)
` + prefix + `}
` + add_body(this.finalbody, scopes);
          if (this.finalbody.length > 0 && !($B2.last(this.finalbody) instanceof $B2.ast.Return)) {
            finalbody += "\n" + prefix + `if(exit){
` + prefix + tab + `$B.leave_frame()
` + prefix + `}`;
          }
          var elsebody = prefix + `if($B.count_frames() == stack_length_${id} && ! failed${id}){
`;
          indent();
          elsebody += add_body(this.orelse, scopes);
          dedent();
          elsebody += "\n" + prefix + "}";
          if (has_else && has_finally) {
            dedent();
            js += prefix + `try{
` + elsebody + "\n" + prefix + `}finally{
` + finalbody + "\n" + prefix + "}\n";
          } else if (has_else && !has_finally) {
            js += elsebody + "\n";
          } else {
            js += finalbody + "\n";
          }
          dedent();
          js += prefix + "}\n";
        } else {
          js += "}\n";
        }
        scopes.pop();
        return js;
      };
      $B2.ast.TryStar.prototype.to_js = function(scopes) {
        var id = make_id(), has_except_handlers = this.handlers.length > 0, has_else = this.orelse.length > 0, has_finally = this.finalbody.length > 0;
        var js = prefix + `$B.set_lineno(frame, ${this.lineno})
` + prefix + `try{
`;
        indent();
        js += prefix + `var stack_length_${id} = $B.count_frames()
`;
        if (has_finally) {
          js += prefix + `var save_frame_obj_${id} = $B.frame_obj
`;
        }
        if (has_else) {
          js += prefix + `var failed${id} = false
`;
        }
        var try_scope = copy_scope($B2.last(scopes));
        scopes.push(try_scope);
        js += add_body(this.body, scopes) + "\n";
        if (has_except_handlers) {
          var err = "err" + id;
          dedent();
          js += prefix + "}";
          js += `catch(${err}){
`;
          indent();
          js += prefix + `$B.set_exc_and_trace(frame, ${err})
` + prefix + `if(! $B.$isinstance(${err}, _b_.BaseExceptionGroup)){
` + prefix + tab + `${err} = _b_.BaseExceptionGroup.$factory(_b_.None, [${err}])
` + prefix + "}\n" + prefix + `function fake_split(exc, condition){
` + prefix + tab + `return condition(exc) ? $B.fast_tuple([exc, _b_.None]) : $B.fast_tuple([_b_.None, exc])
` + prefix + "}\n";
          if (has_else) {
            js += prefix + `failed${id} = true
`;
          }
          for (var handler of this.handlers) {
            js += prefix + `$B.set_lineno(frame, ${handler.lineno})
`;
            if (handler.type) {
              js += prefix + "var condition = function(exc){\n" + prefix + tab + `return $B.$isinstance(exc, ${$B2.js_from_ast(handler.type, scopes)})
` + prefix + "}\n" + prefix + `var klass = $B.get_class(${err}),
`;
              indent();
              js += prefix + `split_method = $B.$getattr(klass, 'split'),
` + prefix + `split = $B.$call(split_method)(${err}, condition),
` + prefix + "matching = split[0],\n" + prefix + "rest = split[1]\n";
              dedent();
              js += prefix + "if(matching.exceptions !== _b_.None){\n";
              indent();
              js += prefix + "for(var err of matching.exceptions){\n";
              indent();
              if (handler.name) {
                bind(handler.name, scopes);
                var mangled = mangle(scopes, try_scope, handler.name);
                js += prefix + `locals.${mangled} = ${err}
`;
              }
              js += add_body(handler.body, scopes) + "\n";
              if (!($B2.last(handler.body) instanceof $B2.ast.Return)) {
                js += prefix + "$B.del_exc(frame)\n";
              }
              dedent();
              js += prefix + "}\n";
              dedent();
              js += prefix + "}\n";
              js += prefix + `${err} = rest
`;
            }
          }
          js += prefix + `if(${err}.exceptions !== _b_.None){
` + prefix + tab + `throw ${err}
` + prefix + "}\n";
          dedent();
        }
        if (has_else || has_finally) {
          js += prefix + "}";
          js += "finally{\n";
          indent();
          if (has_else && has_finally) {
            indent();
          }
          var finalbody = prefix + `var exit = false
` + prefix + `if($B.count_frames() < stack_length_${id}){
` + prefix + tab + `exit = true
` + prefix + tab + `$B.frame_obj = $B.push_frame(frame)
` + prefix + `}
` + add_body(this.finalbody, scopes);
          if (this.finalbody.length > 0 && !($B2.last(this.finalbody) instanceof $B2.ast.Return)) {
            finalbody += "\n" + prefix + `if(exit){
` + prefix + tab + `$B.leave_frame(locals)
` + prefix + `}`;
          }
          var elsebody = prefix + `if($B.count_frames() == stack_length_${id} && ! failed${id}){
`;
          indent();
          elsebody += add_body(this.orelse, scopes);
          dedent();
          elsebody += "\n" + prefix + "}";
          if (has_else && has_finally) {
            dedent();
            js += prefix + `try{
` + elsebody + "\n" + prefix + `}finally{
` + finalbody + "\n" + prefix + "}";
          } else if (has_else && !has_finally) {
            js += elsebody;
          } else {
            js += finalbody;
          }
          dedent();
          js += "\n" + prefix + "}\n";
        } else {
          js += prefix + "}\n";
        }
        scopes.pop();
        return js;
      };
      $B2.ast.Tuple.prototype.to_js = function(scopes) {
        return list_or_tuple_to_js.bind(this)("$B.fast_tuple", scopes);
      };
      $B2.ast.TypeAlias.prototype.to_js = function(scopes) {
        var type_param_scope = new Scope("type_params", "type_params", this.type_params);
        scopes.push(type_param_scope);
        var type_alias_scope = new Scope("type_alias", "type_alias", this);
        scopes.push(type_alias_scope);
        var type_params_names = [];
        check_type_params(this);
        for (var type_param of this.type_params) {
          if (type_param instanceof $B2.ast.TypeVar) {
            type_params_names.push(type_param.name);
          } else if (type_param instanceof $B2.ast.TypeVarTuple || type_param instanceof $B2.ast.ParamSpec) {
            type_params_names.push(type_param.name.id);
          }
        }
        for (var name3 of type_params_names) {
          bind(name3, scopes);
        }
        var qualified_name = qualified_scope_name(scopes, type_alias_scope);
        var value2 = this.value.to_js(scopes);
        scopes.pop();
        scopes.pop();
        var js = prefix + `$B.$import('_typing')
`;
        js += prefix + `var locals_${qualified_scope_name(scopes, type_param_scope)} = {}
`;
        js += prefix + `function TYPE_PARAMS_OF_${this.name.id}(){
`;
        indent();
        js += prefix + `var locals_${qualified_name} = {},
` + prefix + tab + tab + `locals = locals_${qualified_name}, 
` + prefix + tab + tab + `type_params = $B.fast_tuple([])
`;
        for (var i = 0, len = this.type_params.length; i < len; i++) {
          js += prefix + `type_params.push(locals.${type_params_names[i]} = ${this.type_params[i].to_js()})
`;
        }
        js += prefix + `function get_value(){
` + prefix + tab + `return ${value2}
` + prefix + `}
`;
        js += prefix + `var res = $B.$call($B.imported._typing.TypeAliasType)('${this.name.id}', get_value)
` + prefix + `$B.$setattr(res, '__module__', $B.frame_obj.frame[2])
` + prefix + `$B.$setattr(res, '__type_params__', type_params)
` + prefix + `return res
`;
        dedent();
        js += prefix + `}
` + prefix + `locals.${this.name.id} = TYPE_PARAMS_OF_${this.name.id}()`;
        return js;
      };
      $B2.ast.TypeVar.prototype.to_js = function() {
        check_type_params(this);
        return `$B.$call($B.imported._typing.TypeVar)('${this.name}', {$kw: [{infer_variance: true}]})`;
      };
      $B2.ast.TypeVarTuple.prototype.to_js = function() {
        return `$B.$call($B.imported._typing.TypeVarTuple)('${this.name.id}')`;
      };
      $B2.ast.ParamSpec.prototype.to_js = function() {
        return `$B.$call($B.imported._typing.ParamSpec)('${this.name.id}')`;
      };
      $B2.ast.UnaryOp.prototype.to_js = function(scopes) {
        var operand = $B2.js_from_ast(this.operand, scopes);
        if (this.op instanceof $B2.ast.Not) {
          return `! $B.$bool(${operand})`;
        }
        if (typeof operand == "number" || operand instanceof Number) {
          if (this.op instanceof $B2.ast.UAdd) {
            return operand + "";
          } else if (this.op instanceof $B2.ast.USub) {
            return -operand + "";
          }
        }
        var method = opclass2dunder[this.op.constructor.$name];
        return `$B.$getattr($B.get_class(locals.$result = ${operand}), '${method}')(locals.$result)`;
      };
      $B2.ast.While.prototype.to_js = function(scopes) {
        var id = make_id();
        var scope = $B2.last(scopes), new_scope = copy_scope(scope, this, id);
        scopes.push(new_scope);
        var js = prefix + `var no_break_${id} = true
`;
        js += prefix + `while($B.set_lineno(frame, ${this.lineno}) && `;
        if (this.test instanceof $B2.ast.BoolOp) {
          this.test.$dont_evaluate = true;
          js += `${$B2.js_from_ast(this.test, scopes)}){
`;
        } else {
          js += `$B.$bool(${$B2.js_from_ast(this.test, scopes)})){
`;
        }
        indent();
        js += add_body(this.body, scopes);
        dedent();
        js += "\n" + prefix + "}\n";
        scopes.pop();
        if (this.orelse.length > 0) {
          js += prefix + `if(no_break_${id}){
`;
          indent();
          js += add_body(this.orelse, scopes);
          dedent();
          js += "\n" + prefix + "}\n";
        }
        return js;
      };
      $B2.ast.With.prototype.to_js = function(scopes) {
        function add_item(item3, js2) {
          var id = make_id();
          var s = prefix + `var mgr_${id} = ` + $B2.js_from_ast(item3.context_expr, scopes) + ",\n" + prefix + `klass = $B.get_class(mgr_${id})
` + prefix + `try{
`;
          indent();
          s += prefix + `var exit_${id} = $B.$getattr(mgr_${id}, '__exit__'),
` + prefix + tab + `enter_${id} = $B.$getattr(klass, '__enter__')
`;
          dedent();
          s += prefix + `}catch(err){
`;
          indent();
          s += prefix + `var klass_name = $B.class_name(mgr_${id})
` + prefix + `frame.inum = ${inum}
` + prefix + `throw _b_.TypeError.$factory("'" + klass_name + "' object does not support the context manager protocol")
`;
          dedent();
          s += prefix + `}
` + prefix + `var value_${id} = $B.$call(enter_${id})(mgr_${id}),
` + prefix + tab + `exc_${id} = true
`;
          if (in_generator) {
            s += prefix + `locals.$context_managers = locals.$context_managers || []
` + prefix + `locals.$context_managers.push(mgr_${id})
`;
          }
          s += prefix + "try{\n";
          indent();
          s += prefix + "try{\n";
          indent();
          if (item3.optional_vars) {
            var value2 = { to_js: function() {
              return `value_${id}`;
            } };
            copy_position(value2, _with);
            var assign = new $B2.ast.Assign([item3.optional_vars], value2);
            copy_position(assign, _with);
            s += assign.to_js(scopes) + "\n";
          }
          s += js2;
          dedent();
          s += prefix + `}catch(err_${id}){
`;
          indent();
          s += prefix + `frame.$lineno = ${lineno}
` + prefix + `exc_${id} = false
` + prefix + `err_${id} = $B.exception(err_${id}, frame)
` + prefix + `var $b = $B.$call(exit_${id})(err_${id}.__class__, err_${id}, 
` + prefix + tab.repeat(4) + `$B.$getattr(err_${id}, '__traceback__'))
` + prefix + `if(! $B.$bool($b)){
` + prefix + tab + `throw err_${id}
` + prefix + `}
`;
          dedent();
          s += prefix + `}
`;
          dedent();
          s += prefix + `}finally{
`;
          indent();
          s += prefix + `frame.$lineno = ${lineno}
` + (in_generator ? prefix + `locals.$context_managers.pop()
` : "") + prefix + `if(exc_${id}){
`;
          indent();
          s += prefix + `try{
` + prefix + tab + `$B.$call(exit_${id})(_b_.None, _b_.None, _b_.None)
` + prefix + `}catch(err){
`;
          indent();
          s += prefix + `if($B.count_frames() < stack_length){
` + prefix + tab + `$B.frame_obj = $B.push_frame(frame)
` + prefix + `}
` + prefix + `throw err
`;
          dedent();
          s += prefix + `}
`;
          dedent();
          s += prefix + `}
`;
          dedent();
          s += prefix + `}
`;
          return s;
        }
        var _with = this, scope = last_scope(scopes), lineno = this.lineno;
        scope.needs_stack_length = true;
        indent(2);
        var inum = add_to_positions(scopes, this);
        var js = add_body(this.body, scopes) + "\n";
        dedent(2);
        var in_generator = scopes.symtable.table.blocks.get(fast_id(scope.ast)).generator;
        for (var item2 of this.items.slice().reverse()) {
          js = add_item(item2, js);
        }
        return prefix + `$B.set_lineno(frame, ${this.lineno})
` + js;
      };
      $B2.ast.Yield.prototype.to_js = function(scopes) {
        var scope = last_scope(scopes);
        if (scope.type != "def") {
          compiler_error(this, "'yield' outside function");
        }
        last_scope(scopes).is_generator = true;
        var value2 = this.value ? $B2.js_from_ast(this.value, scopes) : "_b_.None";
        return `yield ${value2}`;
      };
      $B2.ast.YieldFrom.prototype.to_js = function(scopes) {
        var scope = last_scope(scopes);
        if (scope.type != "def") {
          compiler_error(this, "'yield' outside function");
        }
        scope.is_generator = true;
        var value2 = $B2.js_from_ast(this.value, scopes);
        var n = make_id();
        var res = `yield* (function* f(){
`;
        indent();
        var js = `
        var _i${n} = _b_.iter(${value2.trimRight()}),
            _r${n}
        var failed${n} = false
        try{
            var _y${n} = _b_.next(_i${n})
        }catch(_e){
            $B.set_exc(_e, frame)
            failed${n} = true
            $B.pmframe = $B.frame_obj.frame
            _e = $B.exception(_e)
            if(_e.__class__ === _b_.StopIteration){
                var _r${n} = $B.$getattr(_e, "value")
            }else{
                throw _e
            }
        }
        if(! failed${n}){
            while(true){
                var failed1${n} = false
                try{
                    $B.leave_frame()
                    var _s${n} = yield _y${n}
                    $B.frame_obj = $B.push_frame(frame)
                }catch(_e){
                    $B.set_exc(_e, frame)
                    if(_e.__class__ === _b_.GeneratorExit){
                        var failed2${n} = false
                        try{
                            var _m${n} = $B.$getattr(_i${n}, "close")
                        }catch(_e1){
                            failed2${n} = true
                            if(_e1.__class__ !== _b_.AttributeError){
                                throw _e1
                            }
                        }
                        if(! failed2${n}){
                            $B.$call(_m${n})()
                        }
                        throw _e
                    }else if($B.is_exc(_e, [_b_.BaseException])){
                        var sys_module = $B.imported._sys,
                            _x${n} = sys_module.exc_info()
                        var failed3${n} = false
                        try{
                            var _m${n} = $B.$getattr(_i${n}, "throw")
                        }catch(err){
                            failed3${n} = true
                            if($B.is_exc(err, [_b_.AttributeError])){
                                throw err
                            }
                        }
                        if(! failed3${n}){
                            try{
                                _y${n} = $B.$call(_m${n}).apply(null,
                                    _b_.list.$factory(_x${n}))
                            }catch(err){
                                if($B.is_exc(err, [_b_.StopIteration])){
                                    _r${n} = $B.$getattr(err, "value")
                                    break
                                }
                                throw err
                            }
                        }
                    }
                }
                if(! failed1${n}){
                    try{
                        if(_s${n} === _b_.None){
                            _y${n} = _b_.next(_i${n})
                        }else{
                            _y${n} = $B.$call($B.$getattr(_i${n}, "send"))(_s${n})
                        }
                    }catch(err){
                        if($B.is_exc(err, [_b_.StopIteration])){
                            _r${n} = $B.$getattr(err, "value")
                            break
                        }
                        throw err
                    }
                }
            }
        }
        return _r${n}`;
        var lines = js.split("\n").slice(1);
        var head = lines[0].length - lines[0].trimLeft().length;
        for (var line of lines) {
          var trimmed = line.trimLeft(), tlen = trimmed.length;
          if (tlen == 0) {
            res += "\n";
            continue;
          }
          var line_head = line.length - tlen;
          var line_indent = (line_head - head) / 4;
          if (line_indent < 0) {
            console.warn("wrong indentation");
            line_indent = 0;
          }
          res += prefix + tab.repeat(line_indent) + trimmed + "\n";
        }
        dedent();
        res += prefix + "})()";
        return res;
      };
      var state = {};
      $B2.js_from_root = function(arg) {
        var ast_root = arg.ast, symtable = arg.symtable, filename = arg.filename, src = arg.src, namespaces = arg.namespaces, imported = arg.imported;
        if ($B2.show_ast_dump) {
          console.log($B2.ast_dump(ast_root));
        }
        if ($B2.compiler_check) {
          $B2.compiler_check(ast_root, symtable);
        }
        var scopes = [];
        state.filename = filename;
        scopes.symtable = symtable;
        scopes.filename = filename;
        scopes.src = src;
        scopes.namespaces = namespaces;
        scopes.imported = imported;
        scopes.imports = {};
        scopes.indent = 0;
        scopes.postpone_annotations = scopes.symtable.table.future.features & $B2.CO_FUTURE_ANNOTATIONS;
        var js_tab = $B2.get_option("js_tab");
        tab = " ".repeat(js_tab);
        var js = ast_root.to_js(scopes);
        return { js, imports: scopes.imports };
      };
      $B2.js_from_ast = function(ast, scopes) {
        if (!scopes.symtable) {
          throw Error("perdu symtable");
        }
        scopes = scopes || [];
        if (ast.to_js !== void 0) {
          if (ast.col_offset === void 0) {
            var klass = ast.constructor.$name;
            if (["match_case"].indexOf(klass) == -1) {
              console.log("no col_offset for", klass);
              console.log(ast);
              throw Error("no col offset");
            }
          }
          return ast.to_js(scopes);
        }
        console.log("unhandled", ast.constructor.$name, ast, typeof ast);
        return "// unhandled class ast." + ast.constructor.$name;
      };
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      var GLOBAL_PARAM = "name '%s' is parameter and global", NONLOCAL_PARAM = "name '%s' is parameter and nonlocal", GLOBAL_AFTER_ASSIGN = "name '%s' is assigned to before global declaration", NONLOCAL_AFTER_ASSIGN = "name '%s' is assigned to before nonlocal declaration", GLOBAL_AFTER_USE = "name '%s' is used prior to global declaration", NONLOCAL_AFTER_USE = "name '%s' is used prior to nonlocal declaration", GLOBAL_ANNOT = "annotated name '%s' can't be global", NONLOCAL_ANNOT = "annotated name '%s' can't be nonlocal", IMPORT_STAR_WARNING = "import * only allowed at module level", NAMED_EXPR_COMP_IN_CLASS = "assignment expression within a comprehension cannot be used in a class body", NAMED_EXPR_COMP_CONFLICT = "assignment expression cannot rebind comprehension iteration variable '%s'", NAMED_EXPR_COMP_INNER_LOOP_CONFLICT = "comprehension inner loop cannot rebind assignment expression target '%s'", NAMED_EXPR_COMP_ITER_EXPR = "assignment expression cannot be used in a comprehension iterable expression", ANNOTATION_NOT_ALLOWED = "'%s' can not be used within an annotation", DUPLICATE_ARGUMENT = "duplicate argument '%s' in function definition", TYPEVAR_BOUND_NOT_ALLOWED = "%s cannot be used within a TypeVar bound", TYPEALIAS_NOT_ALLOWED = "%s cannot be used within a type alias", TYPEPARAM_NOT_ALLOWED = "%s cannot be used within the definition of a generic", DUPLICATE_TYPE_PARAM = "duplicate type parameter '%s'";
      var SF = $B2.SYMBOL_FLAGS;
      var NULL2 = void 0;
      var ModuleBlock = 2, ClassBlock = 1, FunctionBlock = 0, AnnotationBlock = 4, TypeVarBoundBlock = 5, TypeAliasBlock = 6, TypeParamBlock = 7;
      var PyExc_SyntaxError2 = _b_2.SyntaxError;
      function assert(test) {
        if (!$B2.$bool(test)) {
          console.log("test fails", test);
          throw Error("test fails");
        }
      }
      function LOCATION(x) {
        return [x.lineno, x.col_offset, x.end_lineno, x.end_col_offset];
      }
      function ST_LOCATION(x) {
        return [x.lineno, x.col_offset, x.end_lineno, x.end_col_offset];
      }
      function _Py_Mangle(privateobj, ident) {
        var plen, ipriv;
        if (privateobj == NULL2 || !ident.startsWith("__")) {
          return ident;
        }
        plen = privateobj.length;
        if (ident.endsWith("__") || ident.search(/\./) != -1) {
          return ident;
        }
        ipriv = 0;
        while (privateobj[ipriv] == "_") {
          ipriv++;
        }
        if (ipriv == plen) {
          return ident;
        }
        var prefix = privateobj.substr(ipriv);
        return "_" + prefix + ident;
      }
      var lambda = NULL2;
      var NoComprehension = 0, ListComprehension = 1, DictComprehension = 2, SetComprehension = 3, GeneratorExpression = 4;
      function GET_IDENTIFIER(VAR) {
        return VAR;
      }
      function Symtable() {
        this.filename = NULL2;
        this.stack = [];
        this.blocks = /* @__PURE__ */ new Map();
        this.cur = NULL2;
        this.private = NULL2;
      }
      function id(obj) {
        if (obj.$id !== void 0) {
          return obj.$id;
        }
        return obj.$id = $B2.UUID();
      }
      function ste_new(st, name2, block, key2, lineno, col_offset, end_lineno, end_col_offset) {
        var ste;
        ste = {
          table: st,
          id: id(key2),
          name: name2,
          directives: NULL2,
          type: block,
          nested: 0,
          free: 0,
          varargs: 0,
          varkeywords: 0,
          opt_lineno: 0,
          opt_col_offset: 0,
          lineno,
          col_offset,
          end_lineno,
          end_col_offset
        };
        if (st.cur != NULL2 && (st.cur.nested || st.cur.type == FunctionBlock)) {
          ste.nested = 1;
        }
        ste.child_free = 0;
        ste.generator = 0;
        ste.coroutine = 0;
        ste.comprehension = NoComprehension;
        ste.returns_value = 0;
        ste.needs_class_closure = 0;
        ste.comp_inlined = 0;
        ste.comp_iter_target = 0;
        ste.comp_iter_expr = 0;
        ste.symbols = $B2.empty_dict();
        ste.varnames = [];
        ste.children = [];
        st.blocks.set(ste.id, ste);
        return ste;
      }
      $B2._PySymtable_Build = function(mod, filename, future) {
        var st = new Symtable(), seq;
        st.filename = filename;
        st.future = future || {};
        st.type = SF.TYPE_MODULE;
        if (!symtable_enter_block(st, "top", ModuleBlock, mod, 0, 0, 0, 0)) {
          return NULL2;
        }
        st.top = st.cur;
        switch (mod.constructor) {
          case $B2.ast.Module:
            seq = mod.body;
            for (let item2 of seq) {
              visitor.stmt(st, item2);
            }
            break;
          case $B2.ast.Expression:
            visitor.expr(st, mod.body);
            break;
          case $B2.ast.Interactive:
            seq = mod.body;
            for (let item2 of seq) {
              visitor.stmt(st, item2);
            }
            break;
        }
        symtable_analyze(st);
        return st.top;
      };
      function _PyST_GetSymbol(ste, name2) {
        if (!_b_2.dict.$contains_string(ste.symbols, name2)) {
          return 0;
        }
        return _b_2.dict.$getitem_string(ste.symbols, name2);
      }
      function _PyST_GetScope(ste, name2) {
        var symbol = _PyST_GetSymbol(ste, name2);
        return symbol >> SF.SCOPE_OFFSET & SF.SCOPE_MASK;
      }
      function _PyST_IsFunctionLike(ste) {
        return ste.type == FunctionBlock || ste.type == TypeVarBoundBlock || ste.type == TypeAliasBlock || ste.type == TypeParamBlock;
      }
      function PyErr_Format2(exc_type, message, arg) {
        if (arg) {
          message = _b_2.str.__mod__(message, arg);
        }
        return exc_type.$factory(message);
      }
      function PyErr_SetString(exc_type, message) {
        return exc_type.$factory(message);
      }
      function set_exc_info(exc, filename, lineno, offset, end_lineno, end_offset) {
        exc.filename = filename;
        exc.lineno = lineno;
        exc.offset = offset + 1;
        exc.end_lineno = end_lineno;
        exc.end_offset = end_offset + 1;
        var src = $B2.file_cache[filename];
        if (src !== void 0) {
          var lines = src.split("\n");
          exc.text = lines[lineno - 1];
        } else {
          exc.text = "";
        }
        exc.args[1] = [filename, exc.lineno, exc.offset, exc.text, exc.end_lineno, exc.end_offset];
      }
      function error_at_directive(exc, ste, name2) {
        assert(ste.directives);
        for (var data2 of ste.directives) {
          if (data2[0] == name2) {
            set_exc_info(exc, ste.table.filename, data2[1], data2[2], data2[3], data2[4]);
            return 0;
          }
        }
        throw _b_2.RuntimeError.$factory(
          "BUG: internal directive bookkeeping broken"
        );
      }
      function SET_SCOPE(DICT, NAME2, I) {
        DICT[NAME2] = I;
      }
      function is_free_in_any_child(entry, key2) {
        for (var child_ste of entry.ste_children) {
          var scope = _PyST_GetScope(child_ste, key2);
          if (scope == SF.FREE) {
            return 1;
          }
        }
        return 0;
      }
      function inline_comprehension(ste, comp, scopes, comp_free, inlined_cells) {
        for (var item2 of _b_2.dict.$iter_items(comp.symbols)) {
          var k = item2.key, comp_flags = item2.value;
          if (comp_flags & SF.DEF_PARAM) {
            continue;
          }
          var scope = comp_flags >> SF.SCOPE_OFFSET & SF.SCOPE_MASK;
          var only_flags = comp_flags & (1 << SF.SCOPE_OFFSET) - 1;
          if (scope == SF.CELL || only_flags & SF.DEF_COMP_CELL) {
            inlined_cells.add(k);
          }
          var existing = _b_2.dict.$contains_string(ste.symbols, k);
          if (!existing) {
            var v_flags = only_flags;
            _b_2.dict.$setitem(ste.symbols, k, v_flags);
            SET_SCOPE(scopes, k, scope);
          } else {
            if (existing & SF.DEF_BOUND && !is_free_in_any_child(comp, k) && ste.type !== ClassBlock) {
              _b_2.set.remove(comp_free, k);
            }
          }
        }
        return 1;
      }
      function analyze_name(ste, scopes, name2, flags, bound, local, free, global2, type_params, class_entry) {
        if (flags & SF.DEF_GLOBAL) {
          if (flags & SF.DEF_NONLOCAL) {
            let exc = PyErr_Format2(_b_2.SyntaxError, "name '%s' is nonlocal and global", name2);
            error_at_directive(exc, ste, name2);
            throw exc;
          }
          SET_SCOPE(scopes, name2, SF.GLOBAL_EXPLICIT);
          global2.add(name2);
          if (bound) {
            bound.delete(name2);
          }
          return 1;
        }
        if (flags & SF.DEF_NONLOCAL) {
          if (!bound) {
            let exc = PyErr_Format2(_b_2.SyntaxError, "nonlocal declaration not allowed at module level");
            error_at_directive(exc, ste, name2);
            throw exc;
          }
          if (!bound.has(name2)) {
            let exc = PyErr_Format2(_b_2.SyntaxError, "no binding for nonlocal '%s' found", name2);
            error_at_directive(exc, ste, name2);
            throw exc;
          }
          if (type_params.has(name2)) {
            let exc = PyErr_Format2(_b_2.SyntaxError, "nonlocal binding not allowed for type parameter '%s'", name2);
            error_at_directive(exc, ste, name2);
            throw exc;
          }
          SET_SCOPE(scopes, name2, SF.FREE);
          ste.free = 1;
          free.add(name2);
          return 1;
        }
        if (flags & SF.DEF_BOUND) {
          SET_SCOPE(scopes, name2, SF.LOCAL);
          local.add(name2);
          global2.delete(name2);
          if (flags & SF.DEF_TYPE_PARAM) {
            type_params.add(name2);
          } else {
            type_params.delete(name2);
          }
          return 1;
        }
        if (class_entry != NULL2) {
          var class_flags = _PyST_GetSymbol(class_entry, name2);
          if (class_flags & SF.DEF_GLOBAL) {
            SET_SCOPE(scopes, name2, SF.GLOBAL_EXPLICIT);
            return 1;
          } else if (class_flags & SF.DEF_BOUND && !(class_flags & SF.DEF_NONLOCAL)) {
            SET_SCOPE(scopes, name2, SF.GLOBAL_IMPLICIT);
            return 1;
          }
        }
        if (bound && bound.has(name2)) {
          SET_SCOPE(scopes, name2, SF.FREE);
          ste.free = 1;
          free.add(name2);
          return 1;
        }
        if (global2 && global2.has(name2)) {
          SET_SCOPE(scopes, name2, SF.GLOBAL_IMPLICIT);
          return 1;
        }
        if (ste.nested) {
          ste.free = 1;
        }
        SET_SCOPE(scopes, name2, SF.GLOBAL_IMPLICIT);
        return 1;
      }
      function analyze_cells(scopes, free, inlined_cells) {
        var v, v_cell;
        v_cell = SF.CELL;
        if (!v_cell) {
          return 0;
        }
        for (let name2 in scopes) {
          v = scopes[name2];
          var scope = v;
          if (scope != SF.LOCAL) {
            continue;
          }
          if (!free.has(name2) && !inlined_cells.has(name2)) {
            continue;
          }
          scopes[name2] = v_cell;
          free.delete(name2);
        }
        return 1;
      }
      function drop_class_free(ste, free) {
        var res = free.delete("__class__");
        if (res) {
          ste.needs_class_closure = 1;
        }
        res = free.delete("__classdict__");
        if (res) {
          ste.needs_class_classdict = 1;
        }
        return 1;
      }
      function update_symbols(symbols, scopes, bound, free, inlined_cells, classflag) {
        var v, v_scope, v_new, v_free;
        for (let name2 of _b_2.dict.$keys_string(symbols)) {
          var test = false;
          let flags = _b_2.dict.$getitem_string(symbols, name2);
          if (test) {
            console.log("in update symbols, name", name2, "flags", flags, flags & SF.DEF_COMP_CELL);
          }
          if (inlined_cells.has(name2)) {
            flags |= SF.DEF_COMP_CELL;
          }
          v_scope = scopes[name2];
          var scope = v_scope;
          if (test) {
            console.log("name", name2, "scopes[name]", scopes[name2], " flags |=", scope << SF.SCOPE_OFFSET);
          }
          flags |= scope << SF.SCOPE_OFFSET;
          v_new = flags;
          if (!v_new) {
            return 0;
          }
          if (test) {
            console.log("set symbol", name2, "v_new", v_new, "def comp cell", SF.DEF_COMP_CELL, v_new & SF.DEF_COMP_CELL);
          }
          _b_2.dict.$setitem_string(symbols, name2, v_new);
        }
        v_free = SF.FREE << SF.SCOPE_OFFSET;
        for (let name2 of free) {
          v = _b_2.dict.$get_string(symbols, name2);
          if (v !== _b_2.dict.$missing) {
            if (classflag && v & (SF.DEF_BOUND | SF.DEF_GLOBAL)) {
              let flags = v | SF.DEF_FREE_CLASS;
              v_new = flags;
              if (!v_new) {
                return 0;
              }
              _b_2.dict.$setitem_string(symbols, name2, v_new);
            }
            continue;
          }
          if (bound && !bound.has(name2)) {
            continue;
          }
          _b_2.dict.$setitem_string(symbols, name2, v_free);
        }
        return 1;
      }
      function analyze_block(ste, bound, free, global2, typeparams, class_entry) {
        var success = 0;
        let local = /* @__PURE__ */ new Set();
        let scopes = {};
        let newglobal = /* @__PURE__ */ new Set();
        let newfree = /* @__PURE__ */ new Set();
        let newbound = /* @__PURE__ */ new Set();
        let inlined_cells = /* @__PURE__ */ new Set();
        if (ste.type === ClassBlock) {
          Set_Union(newglobal, global2);
          if (bound) {
            Set_Union(newbound, bound);
          }
        }
        for (let name2 of _b_2.dict.$keys_string(ste.symbols)) {
          var flags = _b_2.dict.$getitem_string(ste.symbols, name2);
          if (!analyze_name(ste, scopes, name2, flags, bound, local, free, global2, typeparams, class_entry)) {
            return 0;
          }
        }
        if (ste.type != ClassBlock) {
          if (_PyST_IsFunctionLike(ste)) {
            Set_Union(newbound, local);
          }
          if (bound) {
            Set_Union(newbound, bound);
          }
          Set_Union(newglobal, global2);
        } else {
          newbound.add("__class__");
          newbound.add("__classdict__");
        }
        for (var c of ste.children) {
          var child_free = /* @__PURE__ */ new Set();
          let entry = c;
          var new_class_entry = NULL2;
          if (entry.can_see_class_scope) {
            if (ste.type == ClassBlock) {
              new_class_entry = ste;
            } else if (class_entry) {
              new_class_entry = class_entry;
            }
          }
          var inline_comp = entry.comprehension && !entry.generator;
          if (!analyze_child_block(entry, newbound, newfree, newglobal, typeparams, new_class_entry, child_free)) {
            return 0;
          }
          if (inline_comp) {
            if (!inline_comprehension(ste, entry, scopes, child_free, inlined_cells)) {
            }
            entry.comp_inlined = 1;
          }
          Set_Union(newfree, child_free);
          if (entry.free || entry.child_free) {
            ste.child_free = 1;
          }
        }
        for (let i = ste.children.length - 1; i >= 0; i--) {
          let entry = ste.children[i];
          if (entry.comp_inlined) {
            ste.children.splice(i, 0, ...entry.children);
          }
        }
        if (_PyST_IsFunctionLike(ste) && !analyze_cells(scopes, newfree, inlined_cells)) {
          return 0;
        } else if (ste.type === ClassBlock && !drop_class_free(ste, newfree)) {
          return 0;
        }
        if (!update_symbols(ste.symbols, scopes, bound, newfree, inlined_cells, ste.type === ClassBlock || ste.can_see_class_scope)) {
          return 0;
        }
        Set_Union(free, newfree);
        success = 1;
        return success;
      }
      function PySet_New(arg) {
        if (arg === NULL2) {
          return /* @__PURE__ */ new Set();
        }
        return new Set(arg);
      }
      function Set_Union(setA, setB) {
        for (let elem of setB) {
          setA.add(elem);
        }
      }
      function analyze_child_block(entry, bound, free, global2, typeparams, class_entry, child_free) {
        var temp_bound = PySet_New(bound), temp_free = PySet_New(free), temp_global = PySet_New(global2), temp_typeparams = PySet_New(typeparams);
        if (!analyze_block(entry, temp_bound, temp_free, temp_global, temp_typeparams, class_entry)) {
          return 0;
        }
        Set_Union(child_free, temp_free);
        return 1;
      }
      function symtable_analyze(st) {
        var free = /* @__PURE__ */ new Set(), global2 = /* @__PURE__ */ new Set(), typeparams = /* @__PURE__ */ new Set();
        return analyze_block(st.top, NULL2, free, global2, typeparams, NULL2);
      }
      function symtable_exit_block(st) {
        var size = st.stack.length;
        st.cur = NULL2;
        if (size) {
          st.stack.pop();
          if (--size) {
            st.cur = st.stack[size - 1];
          }
        }
        return 1;
      }
      function symtable_enter_block(st, name2, block, ast, lineno, col_offset, end_lineno, end_col_offset) {
        var prev;
        if (ast === void 0) {
          console.log("call ste new, key undef", st, name2);
        }
        var ste = ste_new(st, name2, block, ast, lineno, col_offset, end_lineno, end_col_offset);
        st.stack.push(ste);
        prev = st.cur;
        if (prev) {
          ste.comp_iter_expr = prev.comp_iter_expr;
        }
        st.cur = ste;
        if (block === AnnotationBlock) {
          return 1;
        }
        if (block === ModuleBlock) {
          st.global = st.cur.symbols;
        }
        if (prev) {
          prev.children.push(ste);
        }
        return 1;
      }
      function symtable_lookup(st, name2) {
        var mangled = _Py_Mangle(st.private, name2);
        if (!mangled) {
          return 0;
        }
        var ret = _PyST_GetSymbol(st.cur, mangled);
        return ret;
      }
      function symtable_add_def_helper(st, name2, flag, ste, _location) {
        var o, dict, val, mangled = _Py_Mangle(st.private, name2);
        if (!mangled) {
          return 0;
        }
        dict = ste.symbols;
        if (_b_2.dict.$contains_string(dict, mangled)) {
          o = _b_2.dict.$getitem_string(dict, mangled);
          val = o;
          if (flag & SF.DEF_PARAM && val & SF.DEF_PARAM) {
            let exc = PyErr_Format2(_b_2.SyntaxError, DUPLICATE_ARGUMENT, name2);
            set_exc_info(exc, st.filename, ..._location);
            throw exc;
          }
          if (flag & SF.DEF_TYPE_PARAM && val & SF.DEF_TYPE_PARAM) {
            let exc = PyErr_Format2(_b_2.SyntaxError, DUPLICATE_TYPE_PARAM, name2);
            set_exc_info(exc, st.filename, ...location);
            throw exc;
          }
          val |= flag;
        } else {
          val = flag;
        }
        if (ste.comp_iter_target) {
          if (val & (SF.DEF_GLOBAL | SF.DEF_NONLOCAL)) {
            let exc = PyErr_Format2(_b_2.SyntaxError, NAMED_EXPR_COMP_INNER_LOOP_CONFLICT, name2);
            set_exc_info(exc, st.filename, ..._location);
            throw exc;
          }
          val |= SF.DEF_COMP_ITER;
        }
        o = val;
        if (o == NULL2) {
          return 0;
        }
        _b_2.dict.$setitem(dict, mangled, o);
        if (flag & SF.DEF_PARAM) {
          ste.varnames.push(mangled);
        } else if (flag & SF.DEF_GLOBAL) {
          val = flag;
          if (st.global.hasOwnProperty(mangled)) {
            val |= st.global[mangled];
          }
          o = val;
          if (o == NULL2) {
            return 0;
          }
          st.global[mangled] = o;
        }
        return 1;
      }
      function symtable_add_def(st, name2, flag, _location) {
        return symtable_add_def_helper(st, name2, flag, st.cur, _location);
      }
      function symtable_enter_type_param_block(st, name2, ast, has_defaults, has_kwdefaults, kind, _location) {
        var prev = st.cur, current_type = st.cur.type;
        if (!symtable_enter_block(st, name2, TypeParamBlock, ast, ..._location)) {
          return 0;
        }
        prev.$type_param = st.cur;
        if (current_type === ClassBlock) {
          st.cur.can_see_class_scope = 1;
          if (!symtable_add_def(st, "__classdict__", SF.USE, _location)) {
            return 0;
          }
        }
        if (kind == $B2.ast.ClassDef) {
          if (!symtable_add_def(st, "type_params", SF.DEF_LOCAL, _location)) {
            return 0;
          }
          if (!symtable_add_def(st, "type_params", SF.USE, _location)) {
            return 0;
          }
          st.st_private = name2;
          var generic_base = ".generic_base";
          if (!symtable_add_def(st, generic_base, SF.DEF_LOCAL, _location)) {
            return 0;
          }
          if (!symtable_add_def(st, generic_base, SF.USE, _location)) {
            return 0;
          }
        }
        if (has_defaults) {
          var defaults = ".defaults";
          if (!symtable_add_def(st, defaults, SF.DEF_PARAM, _location)) {
            return 0;
          }
        }
        if (has_kwdefaults) {
          var kwdefaults = ".kwdefaults";
          if (!symtable_add_def(st, kwdefaults, SF.DEF_PARAM, _location)) {
            return 0;
          }
        }
        return 1;
      }
      function VISIT_QUIT(ST, X) {
        return X;
      }
      function VISIT(ST, TYPE, V) {
        var f = visitor[TYPE];
        if (!f(ST, V)) {
          VISIT_QUIT(ST, 0);
        }
      }
      function VISIT_SEQ(ST, TYPE, SEQ) {
        for (var elt of SEQ) {
          if (!visitor[TYPE](ST, elt)) {
            VISIT_QUIT(ST, 0);
          }
        }
      }
      function VISIT_SEQ_TAIL(ST, TYPE, SEQ, START) {
        for (var i = START, len = SEQ.length; i < len; i++) {
          var elt = SEQ[i];
          if (!visitor[TYPE](ST, elt)) {
            VISIT_QUIT(ST, 0);
          }
        }
      }
      function VISIT_SEQ_WITH_NULL(ST, TYPE, SEQ) {
        for (var elt of SEQ) {
          if (!elt) {
            continue;
          }
          if (!visitor[TYPE](ST, elt)) {
            VISIT_QUIT(ST, 0);
          }
        }
      }
      function symtable_record_directive(st, name2, lineno, col_offset, end_lineno, end_col_offset) {
        var data2, mangled;
        if (!st.cur.directives) {
          st.cur.directives = [];
        }
        mangled = _Py_Mangle(st.private, name2);
        if (!mangled) {
          return 0;
        }
        data2 = $B2.fast_tuple([mangled, lineno, col_offset, end_lineno, end_col_offset]);
        st.cur.directives.push(data2);
        return true;
      }
      function has_kwonlydefaults(kwonlyargs, kw_defaults) {
        for (var i = 0, len = kwonlyargs.length; i < len; i++) {
          if (kw_defaults[i]) {
            return 1;
          }
        }
        return 0;
      }
      var visitor = {};
      visitor.stmt = function(st, s) {
        switch (s.constructor) {
          case $B2.ast.FunctionDef:
            if (!symtable_add_def(st, s.name, SF.DEF_LOCAL, LOCATION(s)))
              VISIT_QUIT(st, 0);
            if (s.args.defaults)
              VISIT_SEQ(st, expr, s.args.defaults);
            if (s.args.kw_defaults)
              VISIT_SEQ_WITH_NULL(st, expr, s.args.kw_defaults);
            if (s.type_params.length > 0) {
              if (!symtable_enter_type_param_block(
                st,
                s.name,
                s.type_params,
                s.args.defaults != NULL2,
                has_kwonlydefaults(s.args.kwonlyargs, s.args.kw_defaults),
                s.constructor,
                LOCATION(s)
              )) {
                VISIT_QUIT(st, 0);
              }
              VISIT_SEQ(st, type_param, s.type_params);
            }
            if (!visitor.annotations(st, s, s.args, s.returns))
              VISIT_QUIT(st, 0);
            if (s.decorator_list) {
              VISIT_SEQ(st, expr, s.decorator_list);
            }
            if (!symtable_enter_block(st, s.name, FunctionBlock, s, ...LOCATION(s))) {
              VISIT_QUIT(st, 0);
            }
            VISIT(st, "arguments", s.args);
            VISIT_SEQ(st, stmt, s.body);
            if (!symtable_exit_block(st)) {
              VISIT_QUIT(st, 0);
            }
            if (s.type_params.length > 0) {
              if (!symtable_exit_block(st)) {
                VISIT_QUIT(st, 0);
              }
            }
            break;
          case $B2.ast.ClassDef:
            var tmp;
            if (!symtable_add_def(st, s.name, SF.DEF_LOCAL, LOCATION(s)))
              VISIT_QUIT(st, 0);
            VISIT_SEQ(st, expr, s.bases);
            VISIT_SEQ(st, keyword, s.keywords);
            if (s.decorator_list)
              VISIT_SEQ(st, expr, s.decorator_list);
            if (s.type_params.length > 0) {
              if (!symtable_enter_type_param_block(st, s.name, s.type_params, false, false, s.constructor, LOCATION(s))) {
                VISIT_QUIT(st, 0);
              }
              VISIT_SEQ(st, type_param, s.type_params);
            }
            VISIT_SEQ(st, expr, s.bases);
            VISIT_SEQ(st, keyword, s.keywords);
            if (!symtable_enter_block(st, s.name, ClassBlock, s, s.lineno, s.col_offset, s.end_lineno, s.end_col_offset))
              VISIT_QUIT(st, 0);
            tmp = st.private;
            st.private = s.name;
            if (s.type_params.length > 0) {
              if (!symtable_add_def(st, "__type_params__", SF.DEF_LOCAL, LOCATION(s))) {
                VISIT_QUIT(st, 0);
              }
              if (!symtable_add_def(st, "type_params", SF.USE, LOCATION(s))) {
                VISIT_QUIT(st, 0);
              }
            }
            VISIT_SEQ(st, stmt, s.body);
            st.private = tmp;
            if (!symtable_exit_block(st))
              VISIT_QUIT(st, 0);
            if (s.type_params.length > 0) {
              if (!symtable_exit_block(st))
                VISIT_QUIT(st, 0);
            }
            break;
          case $B2.ast.TypeAlias:
            VISIT(st, expr, s.name);
            assert(s.name instanceof $B2.ast.Name);
            var name2 = s.name.id, is_in_class = st.cur.type === ClassBlock, is_generic = s.type_params.length > 0;
            if (is_generic) {
              if (!symtable_enter_type_param_block(
                st,
                name2,
                s.type_params,
                false,
                false,
                s.kind,
                LOCATION(s)
              )) {
                VISIT_QUIT(st, 0);
              }
              VISIT_SEQ(st, type_param, s.type_params);
            }
            if (!symtable_enter_block(st, name2, TypeAliasBlock, s, LOCATION(s))) {
              VISIT_QUIT(st, 0);
            }
            st.cur.can_see_class_scope = is_in_class;
            if (is_in_class && !symtable_add_def(st, "__classdict__", SF.USE, LOCATION(s.value))) {
              VISIT_QUIT(st, 0);
            }
            VISIT(st, expr, s.value);
            if (!symtable_exit_block(st)) {
              VISIT_QUIT(st, 0);
            }
            if (is_generic) {
              if (!symtable_exit_block(st))
                VISIT_QUIT(st, 0);
            }
            break;
          case $B2.ast.Return:
            if (s.value) {
              VISIT(st, expr, s.value);
              st.cur.returns_value = 1;
            }
            break;
          case $B2.ast.Delete:
            VISIT_SEQ(st, expr, s.targets);
            break;
          case $B2.ast.Assign:
            VISIT_SEQ(st, expr, s.targets);
            VISIT(st, expr, s.value);
            break;
          case $B2.ast.AnnAssign:
            if (s.target instanceof $B2.ast.Name) {
              var e_name = s.target;
              var cur = symtable_lookup(st, e_name.id);
              if (cur < 0) {
                VISIT_QUIT(st, 0);
              }
              if (cur & (SF.DEF_GLOBAL | SF.DEF_NONLOCAL) && st.cur.symbols != st.global && s.simple) {
                var exc = PyErr_Format2(_b_2.SyntaxError, cur & SF.DEF_GLOBAL ? GLOBAL_ANNOT : NONLOCAL_ANNOT, e_name.id);
                exc.args[1] = [st.filename, s.lineno, s.col_offset + 1, s.end_lineno, s.end_col_offset + 1];
                throw exc;
              }
              if (s.simple && !symtable_add_def(st, e_name.id, SF.DEF_ANNOT | SF.DEF_LOCAL, LOCATION(e_name))) {
                VISIT_QUIT(st, 0);
              } else {
                if (s.value && !symtable_add_def(st, e_name.id, SF.DEF_LOCAL, LOCATION(e_name))) {
                  VISIT_QUIT(st, 0);
                }
              }
            } else {
              VISIT(st, expr, s.target);
            }
            if (!visitor.annotation(st, s.annotation)) {
              VISIT_QUIT(st, 0);
            }
            if (s.value) {
              VISIT(st, expr, s.value);
            }
            break;
          case $B2.ast.AugAssign:
            VISIT(st, expr, s.target);
            VISIT(st, expr, s.value);
            break;
          case $B2.ast.For:
            VISIT(st, expr, s.target);
            VISIT(st, expr, s.iter);
            VISIT_SEQ(st, stmt, s.body);
            if (s.orelse) {
              VISIT_SEQ(st, stmt, s.orelse);
            }
            break;
          case $B2.ast.While:
            VISIT(st, expr, s.test);
            VISIT_SEQ(st, stmt, s.body);
            if (s.orelse) {
              VISIT_SEQ(st, stmt, s.orelse);
            }
            break;
          case $B2.ast.If:
            VISIT(st, expr, s.test);
            VISIT_SEQ(st, stmt, s.body);
            if (s.orelse) {
              VISIT_SEQ(st, stmt, s.orelse);
            }
            break;
          case $B2.ast.Match:
            VISIT(st, expr, s.subject);
            VISIT_SEQ(st, match_case, s.cases);
            break;
          case $B2.ast.Raise:
            if (s.exc) {
              VISIT(st, expr, s.exc);
              if (s.cause) {
                VISIT(st, expr, s.cause);
              }
            }
            break;
          case $B2.ast.Try:
            VISIT_SEQ(st, stmt, s.body);
            VISIT_SEQ(st, excepthandler, s.handlers);
            VISIT_SEQ(st, stmt, s.orelse);
            VISIT_SEQ(st, stmt, s.finalbody);
            break;
          case $B2.ast.TryStar:
            VISIT_SEQ(st, stmt, s.body);
            VISIT_SEQ(st, stmt, s.orelse);
            VISIT_SEQ(st, excepthandler, s.handlers);
            VISIT_SEQ(st, stmt, s.finalbody);
            break;
          case $B2.ast.Assert:
            VISIT(st, expr, s.test);
            if (s.msg) {
              VISIT(st, expr, s.msg);
            }
            break;
          case $B2.ast.Import:
            VISIT_SEQ(st, alias, s.names);
            break;
          case $B2.ast.ImportFrom:
            VISIT_SEQ(st, alias, s.names);
            break;
          case $B2.ast.Global:
            var seq = s.names;
            for (var name2 of seq) {
              var cur = symtable_lookup(st, name2);
              if (cur < 0) {
                VISIT_QUIT(st, 0);
              }
              if (cur & (SF.DEF_PARAM | SF.DEF_LOCAL | SF.USE | SF.DEF_ANNOT)) {
                var msg;
                if (cur & SF.DEF_PARAM) {
                  msg = GLOBAL_PARAM;
                } else if (cur & SF.USE) {
                  msg = GLOBAL_AFTER_USE;
                } else if (cur & SF.DEF_ANNOT) {
                  msg = GLOBAL_ANNOT;
                } else {
                  msg = GLOBAL_AFTER_ASSIGN;
                }
                var exc = PyErr_Format2(_b_2.SyntaxError, msg, name2);
                set_exc_info(exc, st.filename, s.lineno, s.col_offset, s.end_lineno, s.end_col_offset);
                throw exc;
              }
              if (!symtable_add_def(st, name2, SF.DEF_GLOBAL, LOCATION(s)))
                VISIT_QUIT(st, 0);
              if (!symtable_record_directive(st, name2, s.lineno, s.col_offset, s.end_lineno, s.end_col_offset))
                VISIT_QUIT(st, 0);
            }
            break;
          case $B2.ast.Nonlocal:
            var seq = s.names;
            for (var name2 of seq) {
              var cur = symtable_lookup(st, name2);
              if (cur < 0) {
                VISIT_QUIT(st, 0);
              }
              if (cur & (SF.DEF_PARAM | SF.DEF_LOCAL | SF.USE | SF.DEF_ANNOT)) {
                var msg;
                if (cur & SF.DEF_PARAM) {
                  msg = NONLOCAL_PARAM;
                } else if (cur & SF.USE) {
                  msg = NONLOCAL_AFTER_USE;
                } else if (cur & SF.DEF_ANNOT) {
                  msg = NONLOCAL_ANNOT;
                } else {
                  msg = NONLOCAL_AFTER_ASSIGN;
                }
                var exc = PyErr_Format2(_b_2.SyntaxError, msg, name2);
                set_exc_info(exc, st.filename, s.lineno, s.col_offset, s.end_lineno, s.end_col_offset);
                throw exc;
              }
              if (!symtable_add_def(st, name2, SF.DEF_NONLOCAL, LOCATION(s)))
                VISIT_QUIT(st, 0);
              if (!symtable_record_directive(st, name2, s.lineno, s.col_offset, s.end_lineno, s.end_col_offset))
                VISIT_QUIT(st, 0);
            }
            break;
          case $B2.ast.Expr:
            VISIT(st, expr, s.value);
            break;
          case $B2.ast.Pass:
          case $B2.ast.Break:
          case $B2.ast.Continue:
            break;
          case $B2.ast.With:
            VISIT_SEQ(st, "withitem", s.items);
            VISIT_SEQ(st, stmt, s.body);
            break;
          case $B2.ast.AsyncFunctionDef:
            if (!symtable_add_def(st, s.name, SF.DEF_LOCAL, LOCATION(s)))
              VISIT_QUIT(st, 0);
            if (s.args.defaults)
              VISIT_SEQ(st, expr, s.args.defaults);
            if (s.args.kw_defaults)
              VISIT_SEQ_WITH_NULL(st, expr, s.args.kw_defaults);
            if (!visitor.annotations(st, s, s.args, s.returns))
              VISIT_QUIT(st, 0);
            if (s.decorator_list)
              VISIT_SEQ(st, expr, s.decorator_list);
            if (s.type_params.length > 0) {
              if (!symtable_enter_type_param_block(
                st,
                s.name,
                s.type_params,
                s.args.defaults != NULL2,
                has_kwonlydefaults(s.args.kwonlyargs, s.args.kw_defaults),
                s.constructor,
                LOCATION(s)
              )) {
                VISIT_QUIT(st, 0);
              }
              VISIT_SEQ(st, type_param, s.type_params);
            }
            if (!visitor.annotations(st, s, s.args, s.returns))
              VISIT_QUIT(st, 0);
            if (!symtable_enter_block(st, s.name, FunctionBlock, s, s.lineno, s.col_offset, s.end_lineno, s.end_col_offset))
              VISIT_QUIT(st, 0);
            st.cur.coroutine = 1;
            VISIT(st, "arguments", s.args);
            VISIT_SEQ(st, stmt, s.body);
            if (!symtable_exit_block(st))
              VISIT_QUIT(st, 0);
            if (s.type_params.length > 0) {
              if (!symtable_exit_block(st))
                VISIT_QUIT(st, 0);
            }
            break;
          case $B2.ast.AsyncWith:
            VISIT_SEQ(st, withitem, s.items);
            VISIT_SEQ(st, stmt, s.body);
            break;
          case $B2.ast.AsyncFor:
            VISIT(st, expr, s.target);
            VISIT(st, expr, s.iter);
            VISIT_SEQ(st, stmt, s.body);
            if (s.orelse) {
              VISIT_SEQ(st, stmt, s.orelse);
            }
            break;
          default:
            console.log("unhandled", s);
            break;
        }
        VISIT_QUIT(st, 1);
      };
      function symtable_extend_namedexpr_scope(st, e) {
        assert(st.stack);
        assert(e instanceof $B2.ast.Name);
        var target_name = e.id;
        var i, size, ste;
        size = st.stack.length;
        assert(size);
        for (i = size - 1; i >= 0; i--) {
          ste = st.stack[i];
          if (ste.comprehension) {
            let target_in_scope = _PyST_GetSymbol(ste, target_name);
            if (target_in_scope & SF.DEF_COMP_ITER) {
              let exc = PyErr_Format2(_b_2.SyntaxError, NAMED_EXPR_COMP_CONFLICT, target_name);
              set_exc_info(exc, st.filename, e.lineno, e.col_offset, e.ed_lineno, e.end_col_offset);
              throw exc;
            }
            continue;
          }
          if (_PyST_IsFunctionLike(ste)) {
            let target_in_scope = _PyST_GetSymbol(ste, target_name);
            if (target_in_scope & SF.DEF_GLOBAL) {
              if (!symtable_add_def(st, target_name, SF.DEF_GLOBAL, LOCATION(e)))
                VISIT_QUIT(st, 0);
            } else {
              if (!symtable_add_def(st, target_name, SF.DEF_NONLOCAL, LOCATION(e)))
                VISIT_QUIT(st, 0);
            }
            if (!symtable_record_directive(st, target_name, LOCATION(e)))
              VISIT_QUIT(st, 0);
            return symtable_add_def_helper(st, target_name, SF.DEF_LOCAL, ste, LOCATION(e));
          }
          if (ste.type == ModuleBlock) {
            if (!symtable_add_def(st, target_name, SF.DEF_GLOBAL, LOCATION(e)))
              VISIT_QUIT(st, 0);
            if (!symtable_record_directive(st, target_name, LOCATION(e)))
              VISIT_QUIT(st, 0);
            return symtable_add_def_helper(st, target_name, SF.DEF_GLOBAL, ste, LOCATION(e));
          }
          if (ste.type == ClassBlock) {
            let exc = PyErr_Format2(_b_2.SyntaxError, NAMED_EXPR_COMP_IN_CLASS);
            set_exc_info(exc, st.filename, e.lineno, e.col_offset, e.end_lineno, e.end_col_offset);
            throw exc;
          }
        }
        assert(0);
        return 0;
      }
      function symtable_handle_namedexpr(st, e) {
        if (st.cur.comp_iter_expr > 0) {
          var exc = PyErr_Format2(PyExc_SyntaxError2, NAMED_EXPR_COMP_ITER_EXPR);
          set_exc_info(exc, st.filename, e.lineno, e.col_offset, e.end_lineno, e.end_col_offset);
          throw exc;
        }
        if (st.cur.comprehension) {
          if (!symtable_extend_namedexpr_scope(st, e.target))
            return 0;
        }
        VISIT(st, expr, e.value);
        VISIT(st, expr, e.target);
        return 1;
      }
      const alias = "alias", comprehension = "comprehension", excepthandler = "excepthandler", expr = "expr", keyword = "keyword", match_case = "match_case", pattern = "pattern", stmt = "stmt", type_param = "type_param", withitem = "withitem";
      visitor.expr = function(st, e) {
        switch (e.constructor) {
          case $B2.ast.NamedExpr:
            if (!symtable_raise_if_annotation_block(st, "named expression", e)) {
              VISIT_QUIT(st, 0);
            }
            if (!symtable_handle_namedexpr(st, e))
              VISIT_QUIT(st, 0);
            break;
          case $B2.ast.BoolOp:
            VISIT_SEQ(st, expr, e.values);
            break;
          case $B2.ast.BinOp:
            VISIT(st, expr, e.left);
            VISIT(st, expr, e.right);
            break;
          case $B2.ast.UnaryOp:
            VISIT(st, expr, e.operand);
            break;
          case $B2.ast.Lambda: {
            if (!GET_IDENTIFIER("lambda"))
              VISIT_QUIT(st, 0);
            if (e.args.defaults)
              VISIT_SEQ(st, expr, e.args.defaults);
            if (e.args.kw_defaults)
              VISIT_SEQ_WITH_NULL(st, expr, e.args.kw_defaults);
            if (!symtable_enter_block(st, lambda, FunctionBlock, e, e.lineno, e.col_offset, e.end_lineno, e.end_col_offset))
              VISIT_QUIT(st, 0);
            VISIT(st, "arguments", e.args);
            VISIT(st, expr, e.body);
            if (!symtable_exit_block(st))
              VISIT_QUIT(st, 0);
            break;
          }
          case $B2.ast.IfExp:
            VISIT(st, expr, e.test);
            VISIT(st, expr, e.body);
            VISIT(st, expr, e.orelse);
            break;
          case $B2.ast.Dict:
            VISIT_SEQ_WITH_NULL(st, expr, e.keys);
            VISIT_SEQ(st, expr, e.values);
            break;
          case $B2.ast.Set:
            VISIT_SEQ(st, expr, e.elts);
            break;
          case $B2.ast.GeneratorExp:
            if (!visitor.genexp(st, e))
              VISIT_QUIT(st, 0);
            break;
          case $B2.ast.ListComp:
            if (!visitor.listcomp(st, e))
              VISIT_QUIT(st, 0);
            break;
          case $B2.ast.SetComp:
            if (!visitor.setcomp(st, e))
              VISIT_QUIT(st, 0);
            break;
          case $B2.ast.DictComp:
            if (!visitor.dictcomp(st, e))
              VISIT_QUIT(st, 0);
            break;
          case $B2.ast.Yield:
            if (!symtable_raise_if_annotation_block(st, "yield expression", e)) {
              VISIT_QUIT(st, 0);
            }
            if (e.value) {
              VISIT(st, expr, e.value);
            }
            st.cur.generator = 1;
            if (st.cur.comprehension) {
              return symtable_raise_if_comprehension_block(st, e);
            }
            break;
          case $B2.ast.YieldFrom:
            if (!symtable_raise_if_annotation_block(st, "yield expression", e)) {
              VISIT_QUIT(st, 0);
            }
            VISIT(st, expr, e.value);
            st.cur.generator = 1;
            if (st.cur.comprehension) {
              return symtable_raise_if_comprehension_block(st, e);
            }
            break;
          case $B2.ast.Await:
            if (!symtable_raise_if_annotation_block(st, "await expression", e)) {
              VISIT_QUIT(st, 0);
            }
            VISIT(st, expr, e.value);
            st.cur.coroutine = 1;
            break;
          case $B2.ast.Compare:
            VISIT(st, expr, e.left);
            VISIT_SEQ(st, expr, e.comparators);
            break;
          case $B2.ast.Call:
            VISIT(st, expr, e.func);
            VISIT_SEQ(st, expr, e.args);
            VISIT_SEQ_WITH_NULL(st, keyword, e.keywords);
            break;
          case $B2.ast.FormattedValue:
            VISIT(st, expr, e.value);
            if (e.format_spec) {
              VISIT(st, expr, e.format_spec);
            }
            break;
          case $B2.ast.Interpolation:
            VISIT(st, expr, e.value);
            if (e.format_spec) {
              VISIT(st, expr, e.format_spec);
            }
            break;
          case $B2.ast.JoinedStr:
            VISIT_SEQ(st, expr, e.values);
            break;
          case $B2.ast.TemplateStr:
            VISIT_SEQ(st, expr, e.values);
            break;
          case $B2.ast.Constant:
            break;
          case $B2.ast.Attribute:
            VISIT(st, expr, e.value);
            break;
          case $B2.ast.Subscript:
            VISIT(st, expr, e.value);
            VISIT(st, expr, e.slice);
            break;
          case $B2.ast.Starred:
            VISIT(st, expr, e.value);
            break;
          case $B2.ast.Slice:
            if (e.lower)
              VISIT(st, expr, e.lower);
            if (e.upper)
              VISIT(st, expr, e.upper);
            if (e.step)
              VISIT(st, expr, e.step);
            break;
          case $B2.ast.Name:
            var flag = e.ctx instanceof $B2.ast.Load ? SF.USE : SF.DEF_LOCAL;
            if (!symtable_add_def(st, e.id, flag, LOCATION(e)))
              VISIT_QUIT(st, 0);
            if (e.ctx instanceof $B2.ast.Load && _PyST_IsFunctionLike(st.cur) && e.id == "super") {
              if (!GET_IDENTIFIER("__class__") || !symtable_add_def(st, "__class__", SF.USE, LOCATION(e)))
                VISIT_QUIT(st, 0);
            }
            break;
          case $B2.ast.List:
            VISIT_SEQ(st, expr, e.elts);
            break;
          case $B2.ast.Tuple:
            VISIT_SEQ(st, expr, e.elts);
            break;
        }
        VISIT_QUIT(st, 1);
      };
      visitor.type_param_bound_or_default = function(st, e, name2, key2) {
        if (e) {
          var is_in_class = st.cur.can_see_class_scope;
          if (!symtable_enter_block(st, name2, TypeVarBoundBlock, key2, LOCATION(e))) {
            return 0;
          }
          st.cur.can_see_class_scope = is_in_class;
          if (is_in_class && !symtable_add_def(st, "__classdict__", SF.USE, LOCATION(e))) {
            VISIT_QUIT(st, 0);
          }
          VISIT(st, expr, e);
          if (!symtable_exit_block(st)) {
            return 0;
          }
        }
        return 1;
      };
      visitor.type_param = function(st, tp) {
        switch (tp.constructor) {
          case $B2.ast.TypeVar:
            if (!symtable_add_def(st, tp.name, SF.DEF_TYPE_PARAM | SF.DEF_LOCAL, LOCATION(tp))) {
              VISIT_QUIT(st, 0);
            }
            if (!visitor.type_param_bound_or_default(st, tp.bound, tp.name, tp)) {
              VISIT_QUIT(st, 0);
            }
            if (!visitor.type_param_bound_or_default(st, tp.default_value, tp.name, { $id: $B2.UUID() })) {
              VISIT_QUIT(st, 0);
            }
            break;
          case $B2.ast.TypeVarTuple:
            if (!symtable_add_def(st, tp.name, SF.DEF_TYPE_PARAM | SF.DEF_LOCAL, LOCATION(tp))) {
              VISIT_QUIT(st, 0);
            }
            if (!visitor.type_param_bound_or_default(st, tp.default_value, tp.name, tp)) {
              VISIT_QUIT(st, 0);
            }
            break;
          case $B2.ast.ParamSpec:
            if (!symtable_add_def(st, tp.name, SF.DEF_TYPE_PARAM | SF.DEF_LOCAL, LOCATION(tp))) {
              VISIT_QUIT(st, 0);
            }
            if (!visitor.type_param_bound_or_default(st, tp.default_value, tp.name, tp)) {
              VISIT_QUIT(st, 0);
            }
            break;
        }
        VISIT_QUIT(st, 1);
      };
      visitor.pattern = function(st, p) {
        switch (p.constructor) {
          case $B2.ast.MatchValue:
            VISIT(st, expr, p.value);
            break;
          case $B2.ast.MatchSingleton:
            break;
          case $B2.ast.MatchSequence:
            VISIT_SEQ(st, pattern, p.patterns);
            break;
          case $B2.ast.MatchStar:
            if (p.name) {
              symtable_add_def(st, p.name, SF.DEF_LOCAL, LOCATION(p));
            }
            break;
          case $B2.ast.MatchMapping:
            VISIT_SEQ(st, expr, p.keys);
            VISIT_SEQ(st, pattern, p.patterns);
            if (p.rest) {
              symtable_add_def(st, p.rest, SF.DEF_LOCAL, LOCATION(p));
            }
            break;
          case $B2.ast.MatchClass:
            VISIT(st, expr, p.cls);
            VISIT_SEQ(st, pattern, p.patterns);
            VISIT_SEQ(st, pattern, p.kwd_patterns);
            break;
          case $B2.ast.MatchAs:
            if (p.pattern) {
              VISIT(st, pattern, p.pattern);
            }
            if (p.name) {
              symtable_add_def(st, p.name, SF.DEF_LOCAL, LOCATION(p));
            }
            break;
          case $B2.ast.MatchOr:
            VISIT_SEQ(st, pattern, p.patterns);
            break;
        }
        VISIT_QUIT(st, 1);
      };
      function symtable_implicit_arg(st, pos2) {
        var id2 = "." + pos2;
        if (!symtable_add_def(st, id2, SF.DEF_PARAM, ST_LOCATION(st.cur))) {
          return 0;
        }
        return 1;
      }
      visitor.params = function(st, args) {
        if (!args) {
          return -1;
        }
        for (var arg of args) {
          if (!symtable_add_def(st, arg.arg, SF.DEF_PARAM, LOCATION(arg)))
            return 0;
        }
        return 1;
      };
      visitor.annotation = function(st, annotation) {
        var future_annotations = st.future.features & $B2.CO_FUTURE_ANNOTATIONS;
        if (future_annotations && !symtable_enter_block(st, "_annotation", AnnotationBlock, annotation, annotation.lineno, annotation.col_offset, annotation.end_lineno, annotation.end_col_offset)) {
          VISIT_QUIT(st, 0);
        }
        VISIT(st, expr, annotation);
        if (future_annotations && !symtable_exit_block(st)) {
          VISIT_QUIT(st, 0);
        }
        return 1;
      };
      visitor.argannotations = function(st, args) {
        if (!args) {
          return -1;
        }
        for (var arg of args) {
          if (arg.annotation) {
            VISIT(st, expr, arg.annotation);
          }
        }
        return 1;
      };
      visitor.annotations = function(st, o, a, returns) {
        var future_annotations = st.future.ff_features & $B2.CO_FUTURE_ANNOTATIONS;
        if (future_annotations && !symtable_enter_block(st, "_annotation", AnnotationBlock, o, o.lineno, o.col_offset, o.end_lineno, o.end_col_offset)) {
          VISIT_QUIT(st, 0);
        }
        if (a.posonlyargs && !visitor.argannotations(st, a.posonlyargs))
          return 0;
        if (a.args && !visitor.argannotations(st, a.args))
          return 0;
        if (a.vararg && a.vararg.annotation)
          VISIT(st, expr, a.vararg.annotation);
        if (a.kwarg && a.kwarg.annotation)
          VISIT(st, expr, a.kwarg.annotation);
        if (a.kwonlyargs && !visitor.argannotations(st, a.kwonlyargs))
          return 0;
        if (future_annotations && !symtable_exit_block(st)) {
          VISIT_QUIT(st, 0);
        }
        if (returns && !visitor.annotation(st, returns)) {
          VISIT_QUIT(st, 0);
        }
        return 1;
      };
      visitor.arguments = function(st, a) {
        if (a.posonlyargs && !visitor.params(st, a.posonlyargs))
          return 0;
        if (a.args && !visitor.params(st, a.args))
          return 0;
        if (a.kwonlyargs && !visitor.params(st, a.kwonlyargs))
          return 0;
        if (a.vararg) {
          if (!symtable_add_def(st, a.vararg.arg, SF.DEF_PARAM, LOCATION(a.vararg)))
            return 0;
          st.cur.varargs = 1;
        }
        if (a.kwarg) {
          if (!symtable_add_def(st, a.kwarg.arg, SF.DEF_PARAM, LOCATION(a.kwarg)))
            return 0;
          st.cur.varkeywords = 1;
        }
        return 1;
      };
      visitor.excepthandler = function(st, eh) {
        if (eh.type)
          VISIT(st, expr, eh.type);
        if (eh.name) {
          if (!symtable_add_def(st, eh.name, SF.DEF_LOCAL, LOCATION(eh)))
            return 0;
        }
        VISIT_SEQ(st, stmt, eh.body);
        return 1;
      };
      visitor.withitem = function(st, item2) {
        VISIT(st, expr, item2.context_expr);
        if (item2.optional_vars) {
          VISIT(st, expr, item2.optional_vars);
        }
        return 1;
      };
      visitor.match_case = function(st, m) {
        VISIT(st, pattern, m.pattern);
        if (m.guard) {
          VISIT(st, expr, m.guard);
        }
        VISIT_SEQ(st, stmt, m.body);
        return 1;
      };
      visitor.alias = function(st, a) {
        var store_name, name2 = a.asname == NULL2 ? a.name : a.asname;
        var dot = name2.search("\\.");
        if (dot != -1) {
          store_name = name2.substring(0, dot);
          if (!store_name)
            return 0;
        } else {
          store_name = name2;
        }
        if (name2 != "*") {
          var r = symtable_add_def(st, store_name, SF.DEF_IMPORT, LOCATION(a));
          return r;
        } else {
          if (st.cur.type != ModuleBlock) {
            var lineno = a.lineno, col_offset = a.col_offset, end_lineno = a.end_lineno, end_col_offset = a.end_col_offset;
            var exc = PyErr_SetString(PyExc_SyntaxError2, IMPORT_STAR_WARNING);
            set_exc_info(exc, st.filename, lineno, col_offset, end_lineno, end_col_offset);
            throw exc;
          }
          st.cur.$has_import_star = true;
          return 1;
        }
      };
      visitor.comprehension = function(st, lc) {
        st.cur.comp_iter_target = 1;
        VISIT(st, expr, lc.target);
        st.cur.comp_iter_target = 0;
        st.cur.comp_iter_expr++;
        VISIT(st, expr, lc.iter);
        st.cur.comp_iter_expr--;
        VISIT_SEQ(st, expr, lc.ifs);
        if (lc.is_async) {
          st.cur.coroutine = 1;
        }
        return 1;
      };
      visitor.keyword = function(st, k) {
        VISIT(st, expr, k.value);
        return 1;
      };
      function symtable_handle_comprehension(st, e, scope_name, generators, elt, value2) {
        var is_generator = e.constructor === $B2.ast.GeneratorExp;
        var outermost = generators[0];
        st.cur.comp_iter_expr++;
        VISIT(st, expr, outermost.iter);
        st.cur.comp_iter_expr--;
        if (!scope_name || !symtable_enter_block(st, scope_name, FunctionBlock, e, e.lineno, e.col_offset, e.end_lineno, e.end_col_offset)) {
          return 0;
        }
        switch (e.constructor) {
          case $B2.ast.ListComp:
            st.cur.comprehension = ListComprehension;
            break;
          case $B2.ast.SetComp:
            st.cur.comprehension = SetComprehension;
            break;
          case $B2.ast.DictComp:
            st.cur.comprehension = DictComprehension;
            break;
          default:
            st.cur.comprehension = GeneratorExpression;
            break;
        }
        if (outermost.is_async) {
          st.cur.coroutine = 1;
        }
        if (!symtable_implicit_arg(st, 0)) {
          symtable_exit_block(st);
          return 0;
        }
        st.cur.comp_iter_target = 1;
        VISIT(st, expr, outermost.target);
        st.cur.comp_iter_target = 0;
        VISIT_SEQ(st, expr, outermost.ifs);
        VISIT_SEQ_TAIL(st, comprehension, generators, 1);
        if (value2)
          VISIT(st, expr, value2);
        VISIT(st, expr, elt);
        st.cur.generator = is_generator;
        var is_async = st.cur.coroutine && !is_generator;
        if (!symtable_exit_block(st)) {
          return 0;
        }
        if (is_async) {
          st.cur.coroutine = 1;
        }
        return 1;
      }
      visitor.genexp = function(st, e) {
        return symtable_handle_comprehension(st, e, "genexpr", e.generators, e.elt, NULL2);
      };
      visitor.listcomp = function(st, e) {
        return symtable_handle_comprehension(st, e, "listcomp", e.generators, e.elt, NULL2);
      };
      visitor.setcomp = function(st, e) {
        return symtable_handle_comprehension(st, e, "setcomp", e.generators, e.elt, NULL2);
      };
      visitor.dictcomp = function(st, e) {
        return symtable_handle_comprehension(st, e, "dictcomp", e.generators, e.key, e.value);
      };
      function symtable_raise_if_annotation_block(st, name2, e) {
        var type = st.cur.type, exc;
        if (type == AnnotationBlock)
          exc = PyErr_Format2(PyExc_SyntaxError2, ANNOTATION_NOT_ALLOWED, name2);
        else if (type == TypeVarBoundBlock)
          exc = PyErr_Format2(PyExc_SyntaxError2, TYPEVAR_BOUND_NOT_ALLOWED, name2);
        else if (type == TypeAliasBlock)
          exc = PyErr_Format2(PyExc_SyntaxError2, TYPEALIAS_NOT_ALLOWED, name2);
        else if (type == TypeParamBlock)
          exc = PyErr_Format2(PyExc_SyntaxError2, TYPEPARAM_NOT_ALLOWED, name2);
        else
          return 1;
        set_exc_info(exc, st.filename, e.lineno, e.col_offset, e.end_lineno, e.end_col_offset);
        throw exc;
      }
      function symtable_raise_if_comprehension_block(st, e) {
        var type = st.cur.comprehension;
        var exc = PyErr_SetString(PyExc_SyntaxError2, type == ListComprehension ? "'yield' inside list comprehension" : type == SetComprehension ? "'yield' inside set comprehension" : type == DictComprehension ? "'yield' inside dict comprehension" : "'yield' inside generator expression");
        exc.$frame_obj = $B2.frame_obj;
        set_exc_info(exc, st.filename, e.lineno, e.col_offset, e.end_lineno, e.end_col_offset);
        throw exc;
      }
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins, NULL2 = void 0, DOT2 = ".", ELLIPSIS2 = "...";
      const STAR_TARGETS = 1, DEL_TARGETS = 2, FOR_TARGETS = 3;
      function make_string_for_ast_value(value2) {
        value2 = value2.replace(/\n/g, "\\n\\\n");
        value2 = value2.replace(/\r/g, "\\r\\\r");
        if (value2[0] == "'") {
          var unquoted = value2.substr(1, value2.length - 2);
          return unquoted;
        }
        if (value2.indexOf("'") > -1) {
          var s = "", escaped = false;
          for (var char of value2) {
            if (char == "\\") {
              if (escaped) {
                s += "\\\\";
              }
              escaped = !escaped;
            } else {
              if (char == "'" && !escaped) {
                s += "\\";
              } else if (escaped) {
                s += "\\";
              }
              s += char;
              escaped = false;
            }
          }
          value2 = s;
        }
        return value2.substr(1, value2.length - 2);
      }
      var escapeseq = { a: "a", b: "\b", f: "\f", n: "\n", r: "\r", t: "	", v: "\v", '"': '"', "'": "'" };
      function encode_bytestring(s) {
        var s1 = "";
        var escape = false;
        for (var char of s) {
          if (char == "\\") {
            if (escape) {
              s1 += char;
            }
            escape = !escape;
          } else if (escape) {
            var repl = escapeseq[char];
            s1 += repl ?? char;
            escape = false;
          } else {
            s1 += char;
          }
        }
        s = s1;
        var t = [];
        for (var i = 0, len = s1.length; i < len; i++) {
          var cp = s1.codePointAt(i);
          if (cp > 255) {
            throw Error();
          }
          t.push(cp);
        }
        return t;
      }
      function EXTRA_EXPR(head, tail) {
        return {
          lineno: head.lineno,
          col_offset: head.col_offset,
          end_lineno: tail.end_lineno,
          end_col_offset: tail.end_col_offset
        };
      }
      function set_list(list, other) {
        for (var item2 of other) {
          list.push(item2);
        }
      }
      var positions = ["lineno", "col_offset", "end_lineno", "end_col_offset"];
      function set_position_from_list(ast_obj, EXTRA2) {
        for (var i = 0; i < 4; i++) {
          ast_obj[positions[i]] = EXTRA2[i];
        }
      }
      function set_position_from_token(ast_obj, token) {
        ast_obj.lineno = token.lineno;
        ast_obj.col_offset = token.col_offset;
        ast_obj.end_lineno = token.end_lineno;
        ast_obj.end_col_offset = token.end_col_offset;
      }
      function set_position_from_obj(ast_obj, obj) {
        for (var position of positions) {
          ast_obj[position] = obj[position];
        }
      }
      function _get_names(p, names_with_defaults) {
        var seq = [];
        for (var pair of names_with_defaults) {
          seq.push(pair.arg);
        }
        return seq;
      }
      function _get_defaults(p, names_with_defaults) {
        var seq = [];
        for (var pair of names_with_defaults) {
          seq.push(pair.value);
        }
        return seq;
      }
      function _make_posonlyargs(p, slash_without_default, slash_with_default, posonlyargs) {
        if (slash_without_default != NULL2) {
          set_list(posonlyargs, slash_without_default);
        } else if (slash_with_default != NULL2) {
          var slash_with_default_names = _get_names(p, slash_with_default.names_with_defaults);
          if (!slash_with_default_names) {
            return -1;
          }
          set_list(posonlyargs, $B2._PyPegen.join_sequences(
            p,
            slash_with_default.plain_names,
            slash_with_default_names
          ));
        }
        return posonlyargs == NULL2 ? -1 : 0;
      }
      function _make_posargs(p, plain_names, names_with_default, posargs) {
        if (plain_names != NULL2 && names_with_default != NULL2) {
          var names_with_default_names = _get_names(p, names_with_default);
          if (!names_with_default_names) {
            return -1;
          }
          var seqs = $B2._PyPegen.join_sequences(
            p,
            plain_names,
            names_with_default_names
          );
          set_list(posargs, seqs);
        } else if (plain_names == NULL2 && names_with_default != NULL2) {
          set_list(posargs, _get_names(p, names_with_default));
        } else if (plain_names != NULL2 && names_with_default == NULL2) {
          set_list(posargs, plain_names);
        }
        return posargs == NULL2 ? -1 : 0;
      }
      function _make_posdefaults(p, slash_with_default, names_with_default, posdefaults) {
        if (slash_with_default != NULL2 && names_with_default != NULL2) {
          var slash_with_default_values = _get_defaults(p, slash_with_default.names_with_defaults);
          if (!slash_with_default_values) {
            return -1;
          }
          var names_with_default_values = _get_defaults(p, names_with_default);
          if (!names_with_default_values) {
            return -1;
          }
          set_list(posdefaults, $B2._PyPegen.join_sequences(
            p,
            slash_with_default_values,
            names_with_default_values
          ));
        } else if (slash_with_default == NULL2 && names_with_default != NULL2) {
          set_list(posdefaults, _get_defaults(p, names_with_default));
        } else if (slash_with_default != NULL2 && names_with_default == NULL2) {
          set_list(posdefaults, _get_defaults(p, slash_with_default.names_with_defaults));
        }
        return posdefaults == NULL2 ? -1 : 0;
      }
      function _make_kwargs(p, star_etc, kwonlyargs, kwdefaults) {
        if (star_etc != NULL2 && star_etc.kwonlyargs != NULL2) {
          set_list(kwonlyargs, _get_names(p, star_etc.kwonlyargs));
        } else {
          set_list(kwonlyargs, []);
        }
        if (kwonlyargs == NULL2) {
          return -1;
        }
        if (star_etc != NULL2 && star_etc.kwonlyargs != NULL2) {
          set_list(kwdefaults, _get_defaults(p, star_etc.kwonlyargs));
        } else {
          set_list(kwdefaults, []);
        }
        if (kwdefaults == NULL2) {
          return -1;
        }
        return 0;
      }
      function _seq_number_of_starred_exprs(seq) {
        var n = 0;
        for (var k of seq) {
          if (!k.is_keyword) {
            n++;
          }
        }
        return n;
      }
      $B2._PyPegen = {};
      $B2._PyPegen.PyErr_Occurred = function() {
        return false;
      };
      $B2._PyPegen.constant_from_string = function(p, token) {
        var prepared = $B2.prepare_string(p, token);
        var is_bytes = prepared.value.startsWith("b");
        if (!is_bytes) {
          var value2 = make_string_for_ast_value(prepared.value);
        } else {
          var value2 = prepared.value.substr(2, prepared.value.length - 3);
          try {
            value2 = _b_2.bytes.$factory(encode_bytestring(value2));
          } catch (err) {
            $B2._PyPegen.raise_error_known_location(p, _b_2.SyntaxError, token.lineno, token.col_offset, token.end_lineno, token.end_col_offset, "bytes can only contain ASCII literal characters");
          }
        }
        var ast_obj = new $B2.ast.Constant(value2);
        set_position_from_token(ast_obj, token);
        return ast_obj;
      };
      $B2._PyPegen.constant_from_token = function(p, t) {
        var ast_obj = new $B2.ast.Constant(t.string);
        set_position_from_token(ast_obj, t);
        return ast_obj;
      };
      $B2._PyPegen.decoded_constant_from_token = function(p, t) {
        var ast_obj = new $B2.ast.Constant(t.string);
        set_position_from_token(ast_obj, t);
        return ast_obj;
      };
      function is_whitespace(char) {
        return " \n\r	\f".includes(char);
      }
      function _get_interpolation_conversion(p, debug, conversion, format) {
        if (conversion != NULL2) {
          var conversion_expr = conversion.result;
          return conversion_expr.id;
        } else if (debug && !format) {
          return "r";
        }
        return -1;
      }
      function _strip_interpolation_expr(exprstr) {
        var len = exprstr.length;
        for (var c of exprstr) {
          if (is_whitespace(c) || c == "=") {
            len--;
          } else {
            break;
          }
        }
        return exprstr.substr(0, len);
      }
      $B2._PyPegen.interpolation = function(p, expression, debug, conversion, format, closing_brace, position, arena) {
        var lineno = position.lineno, col_offset = position.col_offset, end_lineno = position.end_lineno, end_col_offset = position.end_col_offset;
        var conversion_val = _get_interpolation_conversion(p, debug, conversion, format);
        var debug_end_line, debug_end_offset;
        var debug_metadata;
        var exprstr;
        if (conversion) {
          debug_end_line = conversion.result.lineno;
          debug_end_offset = conversion.result.col_offset;
          debug_metadata = exprstr = conversion.metadata;
        } else if (format) {
          debug_end_line = format.result.lineno;
          debug_end_offset = format.result.col_offset + 1;
          debug_metadata = exprstr = format.metadata;
        } else {
          debug_end_line = end_lineno;
          debug_end_offset = end_col_offset;
          debug_metadata = exprstr = closing_brace.metadata;
        }
        var final_exprstr = _strip_interpolation_expr(exprstr);
        if (final_exprstr) {
          p.arena.a_objects.push(final_exprstr);
        }
        var interpolation = $B2._PyAST.Interpolation(
          expression,
          final_exprstr,
          conversion_val,
          format ? format.result : NULL2
        );
        set_position_from_obj(interpolation, position);
        if (!debug) {
          return interpolation;
        }
        var debug_text = $B2._PyAST.Constant(debug_metadata);
        set_position_from_list(debug_text, [lineno, col_offset + 1, debug_end_line, debug_end_offset - 1]);
        var values = [debug_text, interpolation];
        var ast_obj = $B2._PyAST.JoinedStr(values);
        set_position_from_list(ast_obj, [lineno, col_offset, debug_end_line, debug_end_offset]);
        console.log("JoinedStr", ast_obj);
        return ast_obj;
      };
      $B2._PyPegen.formatted_value = function(p, expression, debug, conversion, format, closing_brace, arena) {
        var conversion_val = -1;
        if (conversion) {
          var conversion_expr = conversion.result, first = conversion_expr.id;
          if (first.length > 1 || !"sra".includes(first)) {
            $B2.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(conversion_expr, `f-string: invalid conversion character {first}: expected 's', 'r', or 'a'`);
          }
          var conversion_val = first.charCodeAt(0);
        }
        var formatted_value = new $B2.ast.FormattedValue(expression, conversion_val, format === void 0 ? format : format.result);
        set_position_from_obj(formatted_value, arena);
        if (debug) {
          var debug_end_line, debug_end_offset, debug_metadata;
          if (conversion) {
            debug_end_line = conversion.result.lineno;
            debug_end_offset = conversion.result.col_offset;
            debug_metadata = conversion.metadata;
          } else if (format) {
            debug_end_line = format.result.lineno;
            debug_end_offset = format.result.col_offset + 1;
            debug_metadata = format.metadata;
          } else {
            debug_end_line = p.end_lineno;
            debug_end_offset = p.end_col_offset;
            debug_metadata = closing_brace.metadata;
          }
          var debug = new $B2.ast.Constant(debug_metadata);
          debug.lineno = p.lineno;
          debug.col_offset = p.col_offset + 1;
          debug.end_lineno = debug_end_line;
          debug.end_col_offset = debug_end_offset;
          var joined_str = new $B2.ast.JoinedStr([debug, formatted_value]);
          set_position_from_obj(joined_str, arena);
          return joined_str;
        }
        return formatted_value;
      };
      $B2._PyPegen.decode_fstring_part = function(p, is_raw, constant, token) {
        var bstr = constant.value;
        var len;
        if (bstr == "{{" || bstr == "}}") {
          len = 1;
        } else {
          len = bstr.length;
        }
        is_raw = is_raw || !bstr.includes("\\");
        var str = bstr;
        if (str == NULL2) {
          _Pypegen_raise_decode_error(p);
          return NULL2;
        }
        p.arena.a_objects.push(str);
        return $B2._PyAST.Constant(str, NULL2, constant.lineno, constant.col_offset, constant.end_lineno, constant.end_col_offset, p.arena);
      };
      function _get_resized_exprs(p, a, raw_expressions, b, string_kind) {
        var n_items = raw_expressions.length;
        var total_items = n_items;
        for (var item2 of raw_expressions) {
          if (item2 instanceof $B2.ast.JoinedStr) {
            total_items += item2.values.length - 1;
          }
        }
        var quote_str = a.bytes;
        if (quote_str == NULL2) {
          return NULL2;
        }
        var is_raw = quote_str.includes("r") || quote_str.includes("R");
        var seq = [];
        var index = 0;
        for (var i = 0; i < n_items; i++) {
          var item2 = raw_expressions[i];
          if (item2 instanceof $B2.ast.JoinedStr) {
            var values = item2.values;
            if (values.length != 2) {
              PyErr_Format(PyExc_SystemError, string_kind == TSTRING ? "unexpected TemplateStr node without debug data in t-string at line %d" : "unexpected JoinedStr node without debug data in f-string at line %d", item2.lineno);
              return NULL2;
            }
            var first = values[0];
            seq[index++] = first;
            var second = values[1];
            seq[index++] = second;
            continue;
          }
          if (item2 instanceof $B2.ast.Constant) {
            item2 = $B2._PyPegen.decode_fstring_part(p, is_raw, item2, b);
            if (item2 == NULL2) {
              return NULL2;
            }
            if (item2.value.length == 0) {
              continue;
            }
          }
          seq[index++] = item2;
        }
        var resized_exprs;
        if (index != total_items) {
          resized_exprs = _Py_asdl_expr_seq_new(index, p.arena);
          if (resized_exprs == NULL2) {
            return NULL2;
          }
          for (var i = 0; i < index; i++) {
            resized_exprs[i] = seq[i];
          }
        } else {
          resized_exprs = seq;
        }
        return resized_exprs;
      }
      $B2._PyPegen.template_str = function(p, a, raw_expressions, b) {
        var resized_exprs = _get_resized_exprs(p, a, raw_expressions, b, "TSTRING");
        var ast_obj = new $B2.ast.TemplateStr(resized_exprs);
        set_position_from_list(ast_obj, [a.lineno, a.col_offset, b.end_lineno, b.end_col_offset]);
        return ast_obj;
      };
      $B2._PyPegen.joined_str = function(p, a, items, c) {
        var ast_obj = new $B2.ast.JoinedStr(items);
        ast_obj.lineno = a.lineno;
        ast_obj.col_offset = a.col_offset;
        ast_obj.end_lineno = c.end_lineno;
        ast_obj.end_col_offset = c.end_col_offset;
        return ast_obj;
      };
      $B2._PyPegen.setup_full_format_spec = function(p, colon, spec, arena) {
        var ast_obj = new $B2.ast.JoinedStr(spec);
        set_position_from_obj(ast_obj, arena);
        return result_token_with_metadata(p, ast_obj, colon.metadata);
      };
      function result_token_with_metadata(p, result, metadata) {
        return { result, metadata };
      }
      $B2._PyPegen.check_fstring_conversion = function(p, conv_token, conv) {
        if (conv_token.lineno != conv.lineno || conv_token.end_col_offset != conv.col_offset) {
          $B2._PyPegen.raise_error_known_location(
            p,
            _b_2.SyntaxError,
            conv.lineno,
            conv.col_offset,
            conv.end_lineno,
            conv.end_col_offset,
            "f-string: conversion type must come right after the exclamanation mark"
          );
        }
        return result_token_with_metadata(p, conv, conv_token.metadata);
      };
      $B2._PyPegen.seq_count_dots = function(seq) {
        if (seq === void 0) {
          return 0;
        }
        var number_of_dots = 0;
        for (var token of seq) {
          if (token.num_type == $B2.py_tokens.DOT) {
            number_of_dots += token.string.length;
          } else if (token.num_type == $B2.py_tokens.ELLIPSIS) {
            number_of_dots += 3;
          }
        }
        return number_of_dots;
      };
      $B2._PyPegen.map_names_to_ids = function(p, seq) {
        return seq.map((e) => e.id);
      };
      $B2._PyPegen.alias_for_star = function(p, lineno, col_offset, end_lineno, end_col_offset, arena) {
        var str = "*";
        return $B2._PyAST.alias(str, NULL2, lineno, col_offset, end_lineno, end_col_offset, arena);
      };
      $B2._PyPegen.cmpop_expr_pair = function(p, cmpop, expr) {
        return { cmpop, expr };
      };
      $B2._PyPegen.get_cmpops = function(p, seq) {
        var new_seq = [];
        for (var pair of seq) {
          new_seq.push(pair.cmpop);
        }
        return new_seq;
      };
      $B2._PyPegen.get_exprs = function(p, seq) {
        var new_seq = [];
        for (var pair of seq) {
          new_seq.push(pair.expr);
        }
        return new_seq;
      };
      function _set_seq_context(p, seq, ctx) {
        var new_seq = [];
        for (var e of seq) {
          new_seq.push($B2._PyPegen.set_expr_context(p, e, ctx));
        }
        return new_seq;
      }
      function _set_name_context(p, e, ctx) {
        return $B2._PyAST.Name(e.id, ctx, EXTRA_EXPR(e, e));
      }
      function _set_tuple_context(p, e, ctx) {
        return $B2._PyAST.Tuple(
          _set_seq_context(p, e.elts, ctx),
          ctx,
          EXTRA_EXPR(e, e)
        );
      }
      function _set_list_context(p, e, ctx) {
        return $B2._PyAST.List(
          _set_seq_context(p, e.elts, ctx),
          ctx,
          EXTRA_EXPR(e, e)
        );
      }
      function _set_subscript_context(p, e, ctx) {
        return $B2._PyAST.Subscript(e.value, e.slice, ctx, EXTRA_EXPR(e, e));
      }
      function _set_attribute_context(p, e, ctx) {
        return $B2._PyAST.Attribute(e.value, e.attr, ctx, EXTRA_EXPR(e, e));
      }
      function _set_starred_context(p, e, ctx) {
        return $B2._PyAST.Starred($B2._PyPegen.set_expr_context(p, e.value, ctx), ctx, EXTRA_EXPR(e, e));
      }
      $B2._PyPegen.set_expr_context = function(p, expr, ctx) {
        var _new = NULL2;
        switch (expr.constructor) {
          case $B2.ast.Name:
            _new = _set_name_context(p, expr, ctx);
            break;
          case $B2.ast.Tuple:
            _new = _set_tuple_context(p, expr, ctx);
            break;
          case $B2.ast.List:
            _new = _set_list_context(p, expr, ctx);
            break;
          case $B2.ast.Subscript:
            _new = _set_subscript_context(p, expr, ctx);
            break;
          case $B2.ast.Attribute:
            _new = _set_attribute_context(p, expr, ctx);
            break;
          case $B2.ast.Starred:
            _new = _set_starred_context(p, expr, ctx);
            break;
          default:
            _new = expr;
        }
        return _new;
      };
      $B2._PyPegen.key_value_pair = function(p, key2, value2) {
        return { key: key2, value: value2 };
      };
      $B2._PyPegen.get_expr_name = function(e) {
        switch (e.constructor.$name) {
          case "Attribute":
          case "Subscript":
          case "Starred":
          case "Name":
          case "List":
          case "Tuple":
          case "Lambda":
            return e.constructor.$name.toLowerCase();
          case "Call":
            return "function call";
          case "BoolOp":
          case "BinOp":
          case "UnaryOp":
            return "expression";
          case "GeneratorExp":
            return "generator expression";
          case "Yield":
          case "YieldFrom":
            return "yield expression";
          case "Await":
            return "await expression";
          case "ListComp":
            return "list comprehension";
          case "SetComp":
            return "set comprehension";
          case "DictComp":
            return "dict comprehension";
          case "Dict":
            return "dict literal";
          case "Set":
            return "set display";
          case "JoinedStr":
          case "FormattedValue":
            return "f-string expression";
          case "Constant":
            var value2 = e.value;
            if (value2 === _b_2.None) {
              return "None";
            }
            if (value2 === false) {
              return "False";
            }
            if (value2 === true) {
              return "True";
            }
            if (value2 === _b_2.Ellipsis) {
              return "ellipsis";
            }
            return "literal";
          case "Compare":
            return "comparison";
          case "IfExp":
            return "conditional expression";
          case "NamedExpr":
            return "named expression";
          default:
            return NULL2;
        }
      };
      $B2._PyPegen.get_keys = function(p, seq) {
        return seq === void 0 ? [] : seq.map((pair) => pair.key);
      };
      $B2._PyPegen.get_values = function(p, seq) {
        return seq === void 0 ? [] : seq.map((pair) => pair.value);
      };
      $B2._PyPegen.key_pattern_pair = function(p, key2, pattern) {
        return { key: key2, pattern };
      };
      $B2._PyPegen.get_pattern_keys = function(p, seq) {
        return seq === void 0 ? [] : seq.map((x) => x.key);
      };
      $B2._PyPegen.get_patterns = function(p, seq) {
        return seq === void 0 ? [] : seq.map((x) => x.pattern);
      };
      $B2._PyPegen.check_legacy_stmt = function(p, name2) {
        return ["print", "exec"].includes(name2);
      };
      $B2._PyPegen.dummy_name = function(p) {
        var cache = NULL2;
        if (cache != NULL2) {
          return cache;
        }
        var id = "dummy" + Math.random().toString(36).substr(2), ast_obj = new $B2.ast.Name(id, new $B2.ast.Load());
        set_position_from_list(ast_obj, [1, 0, 1, 0]);
        return ast_obj;
      };
      $B2._PyPegen.add_type_comment_to_arg = function(p, a, tc) {
        if (tc == NULL2) {
          return a;
        }
        var bytes = _b_2.bytes.$factory(tc), tco = $B2._PyPegen.new_type_comment(p, bytes);
        var ast_obj = $B2._PyAST.arg(a.arg, a.annotation, tco, a.lineno, a.col_offset, a.end_lineno, a.end_col_offset, p.arena);
        console.log("arg with type comment", ast_obj);
        return ast_obj;
      };
      $B2._PyPegen.check_barry_as_flufl = function(p, t) {
        return false;
      };
      $B2._PyPegen.empty_arguments = function(p) {
        return $B2._PyAST.arguments([], [], NULL2, [], [], NULL2, [], p.arena);
      };
      $B2._PyPegen.augoperator = function(p, kind) {
        return { kind };
      };
      $B2._PyPegen.function_def_decorators = function(p, decorators, function_def) {
        var constr = function_def instanceof $B2.ast.AsyncFunctionDef ? $B2.ast.AsyncFunctionDef : $B2.ast.FunctionDef;
        var ast_obj = new constr(
          function_def.name,
          function_def.args,
          function_def.body,
          decorators,
          function_def.returns,
          function_def.type_comment,
          function_def.type_params
        );
        for (var position of positions) {
          ast_obj[position] = function_def[position];
        }
        return ast_obj;
      };
      $B2._PyPegen.class_def_decorators = function(p, decorators, class_def) {
        var ast_obj = $B2._PyAST.ClassDef(
          class_def.name,
          class_def.bases,
          class_def.keywords,
          class_def.body,
          decorators,
          class_def.type_params
        );
        set_position_from_obj(ast_obj, class_def);
        return ast_obj;
      };
      $B2._PyPegen.keyword_or_starred = function(p, element, is_keyword) {
        return {
          element,
          is_keyword
        };
      };
      $B2._PyPegen.make_arguments = function(p, slash_without_default, slash_with_default, plain_names, names_with_default, star_etc) {
        var posonlyargs = [];
        if (_make_posonlyargs(p, slash_without_default, slash_with_default, posonlyargs) == -1) {
          return NULL2;
        }
        var posargs = [];
        if (_make_posargs(p, plain_names, names_with_default, posargs) == -1) {
          return NULL2;
        }
        var posdefaults = [];
        if (_make_posdefaults(p, slash_with_default, names_with_default, posdefaults) == -1) {
          return NULL2;
        }
        var vararg = NULL2;
        if (star_etc != NULL2 && star_etc.vararg != NULL2) {
          vararg = star_etc.vararg;
        }
        var kwonlyargs = [], kwdefaults = [];
        if (_make_kwargs(p, star_etc, kwonlyargs, kwdefaults) == -1) {
          return NULL2;
        }
        var kwarg = NULL2;
        if (star_etc != NULL2 && star_etc.kwarg != NULL2) {
          kwarg = star_etc.kwarg;
        }
        var ast_obj = $B2._PyAST.arguments(posonlyargs, posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults, p.arena);
        if (ast_obj.posonlyargs === void 0) {
          console.log("pas de posonlyargs", ast_bj);
          alert();
        }
        return ast_obj;
      };
      $B2._PyPegen.name_default_pair = function(p, arg, value2, tc) {
        return {
          arg: $B2._PyPegen.add_type_comment_to_arg(p, arg, tc),
          value: value2
        };
      };
      $B2._PyPegen.raise_error = function(p, errtype, errmsg) {
        if (p.fill == 0) {
          var va = [errmsg];
          $B2._PyPegen.raise_error_known_location(p, errtype, 0, 0, 0, -1, errmsg, va);
          return NULL2;
        }
        var t = p.known_err_token != NULL2 ? p.known_err_token : p.tokens[p.fill - 1];
        var va = errmsg;
        $B2._PyPegen.raise_error_known_location(p, errtype, t.lineno, t.col_offset, t.end_lineno, t.end_col_offset, errmsg, va);
      };
      $B2._PyPegen.raise_error_known_location = function(p, errtype, lineno, col_offset, end_lineno, end_col_offset, errmsg, va) {
        var exc = errtype.$factory(errmsg);
        exc.filename = p.filename;
        if (p.known_err_token) {
          var token = p.known_err_token;
          exc.lineno = token.lineno;
          exc.offset = token.col_offset + 1;
          exc.end_lineno = token.end_lineno;
          exc.end_offset = token.end_col_offset;
          exc.text = token.line;
        } else {
          exc.lineno = lineno;
          exc.offset = col_offset + 1;
          exc.end_lineno = end_lineno;
          exc.end_offset = end_col_offset + 1;
          var src = $B2.file_cache[p.filename];
          if (src !== void 0) {
            var lines = src.split("\n"), line = lines[exc.lineno - 1];
            exc.text = line + "\n";
          } else {
            exc.text = _b_2.None;
          }
        }
        exc.args[1] = $B2.fast_tuple([p.filename, exc.lineno, exc.offset, exc.text, exc.end_lineno, exc.end_offset]);
        throw exc;
      };
      $B2._PyPegen.seq_delete_starred_exprs = function(p, kwargs) {
        var len = kwargs.length, new_len = len - _seq_number_of_starred_exprs(kwargs);
        if (new_len == 0) {
          return NULL2;
        }
        var new_seq = [];
        for (var k of kwargs) {
          if (k.is_keyword) {
            new_seq.push(k.element);
          }
        }
        return new_seq;
      };
      $B2._PyPegen.seq_extract_starred_exprs = function(p, kwargs) {
        var new_len = _seq_number_of_starred_exprs(kwargs);
        if (new_len == 0) {
          return NULL2;
        }
        var new_seq = [];
        var idx = 0;
        for (var k of kwargs) {
          if (!k.is_keyword) {
            new_seq[idx++] = k.element;
          }
        }
        return new_seq;
      };
      $B2._PyPegen.slash_with_default = function(p, plain_names, names_with_defaults) {
        return { plain_names, names_with_defaults };
      };
      $B2._PyPegen.star_etc = function(p, vararg, kwonlyargs, kwarg) {
        return { vararg, kwonlyargs, kwarg };
      };
      $B2._PyPegen.collect_call_seqs = function(p, a, b, lineno, col_offset, end_lineno, end_col_offset, arena) {
        var args_len = a.length, total_len = args_len;
        if (b == NULL2) {
          return $B2._PyAST.Call($B2._PyPegen.dummy_name(p), a, [], lineno, col_offset, end_lineno, end_col_offset, arena);
        }
        var starreds = $B2._PyPegen.seq_extract_starred_exprs(p, b), keywords = $B2._PyPegen.seq_delete_starred_exprs(p, b);
        if (starreds) {
          total_len += starreds.length;
        }
        var args = [];
        for (var i = 0; i < args_len; i++) {
          args[i] = a[i];
        }
        for (; i < total_len; i++) {
          args[i] = starreds[i - args_len];
        }
        return $B2._PyAST.Call($B2._PyPegen.dummy_name(p), args, keywords, lineno, col_offset, end_lineno, end_col_offset, arena);
      };
      $B2._PyPegen.join_sequences = function(p, a, b) {
        return a.concat(b);
      };
      function make_conversion_code(conv) {
        switch (conv) {
          case null:
            return -1;
          case "a":
            return 97;
          case "r":
            return 114;
          case "s":
            return 115;
        }
      }
      function make_formatted_value(p, fmt_values) {
        if (!fmt_values) {
          return;
        }
        var seq = [];
        for (var item2 of fmt_values) {
          if (typeof item2 == "string") {
            var fmt_ast = new $B2.ast.Constant(item2);
            set_position_from_obj(fmt_ast, p.arena);
          } else {
            var src = item2.expression.trimStart();
            var _ast = new $B2.Parser(src, p.filename, "eval").parse();
            var raw_value = _ast.body;
            var fmt_ast = new $B2.ast.FormattedValue(raw_value, make_conversion_code(item2.conversion), make_formatted_value(p, item2.fmt));
            set_position_from_obj(fmt_ast, _ast);
          }
          seq.push(fmt_ast);
        }
        var ast_obj = new $B2.ast.JoinedStr(seq);
        set_position_from_obj(ast_obj, p.arena);
        return ast_obj;
      }
      function _build_concatenated_str(p, strings) {
        var len = strings.length;
        var n_flattened_elements = 0;
        for (var elem of strings) {
          if (elem instanceof $B2.ast.JoinedStr || elem instanceof $B2.ast.TemplateStr) {
            n_flattened_elements += elem.values.length;
          } else {
            n_flattened_elements++;
          }
        }
        var flattened = [];
        var current_pos = 0;
        for (var elem of strings) {
          if (elem instanceof $B2.ast.JoinedStr || elem instanceof $B2.ast.TemplateStr) {
            for (var subvalue of elem.values) {
              flattened[current_pos++] = subvalue;
            }
          } else {
            flattened[current_pos++] = elem;
          }
        }
        var n_elements = 0;
        var prev_is_constant = 0;
        for (var elem of flattened) {
          if (elem instanceof $B2.ast.Constant && typeof elem.value == "string" && elem.value.length == 0) {
            continue;
          }
          if (!prev_is_constant || !(elem instanceof $B2.ast.Constant)) {
            n_elements++;
          }
          prev_is_constant = elem instanceof $B2.ast.Constant;
        }
        var values = [];
        current_pos = 0;
        for (var i = 0, len = flattened.length; i < len; i++) {
          var elem = flattened[i];
          if (elem instanceof $B2.ast.Constant) {
            if (i + 1 < n_flattened_elements && flattened[i + 1] instanceof $B2.ast.Constant) {
              var first_elem = elem;
              var kind = elem.__class__;
              var concat_str = "";
              var last_elem = elem;
              var j2;
              for (j2 = i; j2 < n_flattened_elements; j2++) {
                var current_elem = flattened[j2];
                if (current_elem instanceof $B2.ast.Constant) {
                  concat_str += current_elem.value;
                  last_elem = current_elem;
                } else {
                  break;
                }
              }
              i = j2 - 1;
              p.arena.a_objects.push(concat_str);
              elem = new $B2.ast.Constant(concat_str, kind);
              set_position_from_list(elem, [first_elem.lineno, first_elem.col_offset, last_elem.end_lineno, last_elem.end_col_offset]);
            }
            if (elem.value.length == 0) {
              continue;
            }
          }
          values[current_pos++] = elem;
        }
        return values;
      }
      function _build_concatenated_template_str(p, strings) {
        var values = _build_concatenated_str(p, strings);
        var ast_obj = new $B2.ast.TemplateStr(values);
        var last = strings[strings.length - 1];
        set_position_from_list(ast_obj, [strings[0].lineno, strings[0].col_offset, last.end_lineno, last.end_col_offset]);
        return ast_obj;
      }
      function _build_concatenated_joined_str(p, strings) {
        var values = _build_concatenated_str(p, strings);
        var ast_obj = new $B2.ast.JoinedStr(values);
        var last = strings[strings.length - 1];
        set_position_from_list(ast_obj, [strings[0].lineno, strings[0].col_offset, last.end_lineno, last.end_col_offset]);
        return ast_obj;
      }
      $B2._PyPegen.concatenate_strings = function(p, strings) {
        var res = "", first = strings[0], last = $B2.last(strings), type;
        var state = NULL2, value2, values = [];
        function error(message) {
          var a = { lineno: first.start[0], col_offset: first.start[1], end_lineno: last.end[0], end_col_offset: last.end[1] };
          $B2.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, message);
        }
        function set_position_from_list2(ast_obj2, items2) {
          var first2 = items2[0], last2 = items2[items2.length - 1];
          ast_obj2.lineno = first2.lineno;
          ast_obj2.col_offset = first2.col_offset;
          ast_obj2.end_lineno = last2.end_lineno;
          ast_obj2.end_col_offset = last2.end_col_offset;
        }
        function escape_single_quotes(token) {
          for (var fs_item of token.values) {
            if (fs_item instanceof $B2.ast.Constant) {
              var parts = fs_item.value.split("\\'");
              parts = parts.map((x) => x.replace(new RegExp("'", "g"), "\\'"));
              fs_item.value = parts.join("\\'");
              fs_item.value = fs_item.value.replace(/\n/g, "\\n").replace(/\r/g, "\\r");
            }
          }
        }
        var items = [], has_fstring = false, has_tstring = false, state;
        for (var string of strings) {
          if (string instanceof $B2.ast.JoinedStr) {
            has_fstring = true;
            if (state == "bytestring") {
              error("cannot mix bytes and nonbytes literals");
            }
            escape_single_quotes(string);
            state = "string";
          } else if (string instanceof $B2.ast.TemplateStr) {
            has_tstring = true;
            if (state == "bytestring") {
              error("cannot mix bytes and nonbytes literals");
            }
            escape_single_quotes(string);
            state = "string";
          } else {
            items.push(string);
            var is_bytes = string.value.__class__ === _b_2.bytes;
            if (is_bytes && state == "string" || state == "bytestring" && !is_bytes) {
              error("cannot mix bytes and nonbytes literals");
            }
            state = is_bytes ? "bytestring" : "string";
          }
        }
        if (state == "bytestring") {
          var bytes = [];
          for (var item2 of items) {
            bytes = bytes.concat(item2.value.source);
          }
          value2 = _b_2.bytes.$factory(bytes);
          var ast_obj = new $B2.ast.Constant(value2);
          set_position_from_list2(ast_obj, items);
          return ast_obj;
        }
        function group_consec_strings(items2) {
          if (items2.length == 1) {
            return items2[0];
          }
          var values2 = items2.map((x) => x.value);
          let ast_obj2 = new $B2.ast.Constant(values2.join(""));
          set_position_from_list2(ast_obj2, items2);
          return ast_obj2;
        }
        var items1 = [], consec_strs = [], item_type = null;
        for (var i = 0, len = items.length; i < len; i++) {
          item2 = items[i];
          if (item_type === null) {
            item_type = Object.getPrototypeOf(item2);
          }
          if (item2 instanceof $B2.ast.Constant) {
            consec_strs.push(item2);
          } else {
            if (consec_strs.length > 0) {
              items1.push(group_consec_strings(consec_strs));
            }
            consec_strs = [];
            items1.push(item2);
          }
        }
        if (consec_strs.length > 0) {
          items1.push(group_consec_strings(consec_strs));
        }
        if (!has_fstring && !has_tstring) {
          return items1[0];
        }
        if (has_tstring) {
          return _build_concatenated_template_str(p, strings);
        }
        return _build_concatenated_joined_str(p, strings);
      };
      $B2._PyPegen.concatenate_tstrings = $B2._PyPegen.concatenate_strings;
      $B2._PyPegen.checked_future_import = function(p, module2, names, level, lineno, col_offset, end_lineno, end_col_offset, arena) {
        if (level == 0 && module2 == "__future__") {
          for (var i = 0; i < names.length; i++) {
            var alias = names[i];
            if (alias.name == "barry_as_FLUFL") {
              p.flags |= PyPARSE_BARRY_AS_BDFL;
            }
          }
        }
        return $B2._PyAST.ImportFrom(module2, names, level, lineno, col_offset, end_lineno, end_col_offset, arena);
      };
      $B2._PyPegen.register_stmts = function(p, stmts) {
        if (!p.call_invalid_rules) {
          return stmts;
        }
        var len = stmts.length;
        if (len == 0) {
          return stmts;
        }
        var last_stmt = stmts[len - 1];
        p.last_stmt_location.lineno = last_stmt.lineno;
        p.last_stmt_location.col_offset = last_stmt.col_offset;
        p.last_stmt_location.end_lineno = last_stmt.end_lineno;
        p.last_stmt_location.end_col_offset = last_stmt.end_col_offset;
        return stmts;
      };
      $B2._PyPegen.ensure_imaginary = function(p, exp) {
        if (!(exp instanceof $B2.ast.Constant) || exp.value.__class__ != _b_2.complex) {
          $B2.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(exp, "imaginary number required in complex literal");
          return NULL2;
        }
        return exp;
      };
      $B2._PyPegen.ensure_real = function(p, exp) {
        if (!(exp instanceof $B2.ast.Constant) || exp.value.type == "imaginary") {
          $B2.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(
            exp,
            "real number required in complex literal"
          );
          return NULL2;
        }
        return exp;
      };
      $B2._PyPegen.set_expr_context = function(p, a, ctx) {
        a.ctx = ctx;
        return a;
      };
      $B2._PyPegen.singleton_seq = function(p, a) {
        return [a];
      };
      $B2._PyPegen.seq_insert_in_front = function(p, a, seq) {
        return seq ? [a].concat(seq) : [a];
      };
      $B2._PyPegen.seq_flatten = function(p, seqs) {
        var res = [];
        for (var seq of seqs) {
          for (var item2 of seq) {
            res.push(item2);
          }
        }
        return res;
      };
      $B2._PyPegen.join_names_with_dot = function(p, first_name, second_name) {
        var str = first_name.id + "." + second_name.id;
        return $B2._PyAST.Name(str, new $B2.ast.Load(), EXTRA_EXPR(first_name, second_name));
      };
      $B2._PyPegen.make_module = function(p, a) {
        return new $B2.ast.Module(a);
      };
      $B2._PyPegen.new_type_comment = function(p, s) {
        if (s.length === 0) {
          return NULL2;
        }
        return s;
      };
      $B2._PyPegen.get_last_comprehension_item = function(comprehension) {
        if (comprehension.ifs == NULL2 || comprehension.ifs.length == 0) {
          return comprehension.iter;
        }
        return $B2.last(comprehension.ifs);
      };
      $B2._PyPegen.arguments_parsing_error = function(p, e) {
        var kwarg_unpacking = 0;
        for (let keyword of e.keywords) {
          if (!keyword.arg) {
            kwarg_unpacking = 1;
          }
        }
        var msg = NULL2;
        if (kwarg_unpacking) {
          msg = "positional argument follows keyword argument unpacking";
        } else {
          msg = "positional argument follows keyword argument";
        }
        return $B2.helper_functions.RAISE_SYNTAX_ERROR(p, msg);
      };
      $B2._PyPegen.nonparen_genexp_in_call = function(p, args, comprehensions) {
        var len = args.args.length;
        if (len <= 1) {
          return NULL2;
        }
        var last_comprehension = $B2.last(comprehensions);
        return $B2.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(
          p,
          args.args[len - 1],
          $B2._PyPegen.get_last_comprehension_item(last_comprehension),
          "Generator expression must be parenthesized"
        );
      };
      $B2._PyPegen.get_invalid_target = function(e, targets_type) {
        if (e == NULL2) {
          return NULL2;
        }
        function VISIT_CONTAINER(CONTAINER, TYPE) {
          for (var elt of CONTAINER.elts) {
            var child = $B2._PyPegen.get_invalid_target(elt, targets_type);
            if (child != NULL2) {
              return child;
            }
          }
        }
        switch (e.constructor) {
          case $B2.ast.List:
          case $B2.ast.Tuple:
            return VISIT_CONTAINER(e, e.constructor);
          case $B2.ast.Starred:
            if (targets_type == DEL_TARGETS) {
              return e;
            }
            return $B2._PyPegen.get_invalid_target(e.value, targets_type);
          case $B2.ast.Compare:
            if (targets_type == FOR_TARGETS) {
              var cmpop = e.ops[0];
              if (cmpop instanceof $B2.ast.In) {
                return $B2._PyPegen.get_invalid_target(e.left, targets_type);
              }
              return NULL2;
            }
            return e;
          case $B2.ast.Name:
          case $B2.ast.Subscript:
          case $B2.ast.Attribute:
            return NULL2;
          default:
            return e;
        }
      };
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins;
      var s_escaped = `abfnrtvxuU"0123456789'\\`, is_escaped = {};
      for (var i = 0; i < s_escaped.length; i++) {
        is_escaped[s_escaped.charAt(i)] = true;
      }
      function escaped_to_byte(char) {
        var table = { a: 7, b: 8, f: 12, n: 10, r: 13, t: 9, v: 11 };
        if (table[char] !== void 0) {
          return table[char];
        }
        return char.charCodeAt(0);
      }
      function to_bytes(s) {
        var pos2 = 0, bytes = [];
        while (pos2 < s.length) {
          if (s[pos2] == "\\") {
            bytes[bytes.length] = escaped_to_byte(s[pos2 + 1]);
            pos2 += 2;
          } else {
            bytes[bytes.length] = s.charCodeAt(pos2);
            pos2++;
          }
        }
        return bytes;
      }
      function string_error(p, token, msg) {
        $B2.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, token, msg);
      }
      function SurrogatePair(value2) {
        this.value = value2;
      }
      function test_escape(p, token, context, text, string_start, antislash_pos) {
        var seq_end, mo;
        mo = /^[0-7]{1,3}/.exec(text.substr(antislash_pos + 1));
        if (mo) {
          if (mo[0].length == 3 && mo[0][0] >= "4") {
            $B2.warn(_b_2.SyntaxWarning, `invalid octal escape sequence '\\${mo[0]}'`, p.filename, token);
          }
          return [String.fromCharCode(parseInt(mo[0], 8)), 1 + mo[0].length];
        }
        switch (text[antislash_pos + 1]) {
          case "x":
            var mo = /^[0-9A-F]{0,2}/i.exec(text.substr(antislash_pos + 2));
            if (mo[0].length != 2) {
              seq_end = antislash_pos + mo[0].length + 1;
              string_error(p, token, [`(unicode error) 'unicodeescape' codec can't decode bytes in position ${antislash_pos}-${seq_end}: truncated \\xXX escape`]);
            } else {
              return [String.fromCharCode(parseInt(mo[0], 16)), 2 + mo[0].length];
            }
          case "u":
            var mo = /^[0-9A-F]{0,4}/i.exec(text.substr(antislash_pos + 2));
            if (mo[0].length != 4) {
              seq_end = antislash_pos + mo[0].length + 1;
              string_error(p, token, [`(unicode error) 'unicodeescape' codec can't decode bytes in position ${antislash_pos}-${seq_end}: truncated \\uXXXX escape`]);
            } else {
              return [String.fromCharCode(parseInt(mo[0], 16)), 2 + mo[0].length];
            }
          case "U":
            var mo = /^[0-9A-F]{0,8}/i.exec(text.substr(antislash_pos + 2));
            if (mo[0].length != 8) {
              seq_end = antislash_pos + mo[0].length + 1;
              string_error(p, token, [`(unicode error) 'unicodeescape' codec can't decode bytes in position ${antislash_pos}-${seq_end}: truncated \\UXXXXXXXX escape`]);
            } else {
              var value2 = parseInt(mo[0], 16);
              if (value2 > 1114111) {
                string_error(p, token, "invalid unicode escape " + mo[0]);
              } else if (value2 >= 65536) {
                return [new SurrogatePair(value2), 2 + mo[0].length];
              } else {
                return [String.fromCharCode(value2), 2 + mo[0].length];
              }
            }
        }
      }
      $B2.prepare_string = function(p, token) {
        var s = token.string, len = s.length, pos2 = 0, string_modifier, _type = "string", quote, inner, context = { type: "str" };
        while (pos2 < len) {
          if (s[pos2] == '"' || s[pos2] == "'") {
            quote = s[pos2];
            string_modifier = s.substr(0, pos2);
            if (s.substr(pos2, 3) == quote.repeat(3)) {
              _type = "triple_string";
              inner = s.substring(pos2 + 3, s.length - 3);
            } else {
              inner = s.substring(pos2 + quote.length, len - quote.length);
            }
            break;
          }
          pos2++;
        }
        var result = { quote };
        var mods = { r: "raw", f: "fstring", b: "bytes" };
        for (var mod of string_modifier) {
          result[mods[mod]] = true;
        }
        var raw = context.type == "str" && context.raw, string_start = pos2 + 1, bytes = false, fstring = false, sm_length, end = null;
        if (string_modifier) {
          switch (string_modifier) {
            case "r":
              raw = true;
              break;
            case "u":
              break;
            case "b":
              bytes = true;
              break;
            case "rb":
            case "br":
              bytes = true;
              raw = true;
              break;
            case "f":
              fstring = true;
              sm_length = 1;
              break;
            case "fr":
            case "rf":
              fstring = true;
              sm_length = 2;
              raw = true;
              break;
          }
          string_modifier = false;
        }
        var escaped = false, zone = "", end = 0, src = inner;
        if (bytes) {
          var source = [];
        }
        while (end < src.length) {
          if (escaped) {
            if (src.charAt(end) == "a" && !raw) {
              zone = zone.substr(0, zone.length - 1) + "\x07";
            } else {
              zone += src.charAt(end);
              if (raw && src.charAt(end) == "\\") {
                zone += "\\";
              }
            }
            escaped = false;
            end++;
          } else if (src.charAt(end) == "\\") {
            if (raw) {
              if (end < src.length - 1 && src.charAt(end + 1) == quote) {
                zone += "\\\\" + quote;
                end += 2;
              } else {
                zone += "\\\\";
                end++;
              }
              escaped = true;
            } else {
              if (src.charAt(end + 1) == "\n") {
                end += 2;
              } else if (src.substr(end + 1, 2) == "N{") {
                var end_lit = end + 3, re = new RegExp("[-a-zA-Z0-9 ]+"), search = re.exec(src.substr(end_lit));
                if (search === null) {
                  string_error(p, token, "(unicode error) malformed \\N character escape", pos2);
                }
                var end_lit = end_lit + search[0].length;
                if (src.charAt(end_lit) != "}") {
                  string_error(p, token, "(unicode error) malformed \\N character escape");
                }
                var description = search[0].toUpperCase();
                if ($B2.unicodedb === void 0) {
                  var xhr = new XMLHttpRequest();
                  xhr.open("GET", $B2.brython_path + "unicode.txt", false);
                  xhr.onreadystatechange = function() {
                    if (this.readyState == 4) {
                      if (this.status == 200) {
                        $B2.unicodedb = this.responseText;
                      } else {
                        console.log("Warning - could not load unicode.txt");
                      }
                    }
                  };
                  xhr.send();
                }
                if ($B2.unicodedb !== void 0) {
                  var re = new RegExp("^([0-9A-F]+);" + description + ";.*$", "m");
                  search = re.exec($B2.unicodedb);
                  if (search === null) {
                    string_error(p, token, "(unicode error) unknown Unicode character name");
                  }
                  var cp = parseInt(search[1], 16);
                  zone += String.fromCodePoint(cp);
                  end = end_lit + 1;
                } else {
                  end++;
                }
              } else {
                var esc = test_escape(p, token, context, src, string_start, end);
                if (esc) {
                  if (esc[0] == "\\") {
                    zone += "\\\\";
                  } else if (esc[0] instanceof SurrogatePair) {
                    zone += String.fromCodePoint(esc[0].value);
                  } else {
                    zone += esc[0];
                  }
                  end += esc[1];
                } else {
                  if (end < src.length - 1 && is_escaped[src.charAt(end + 1)] === void 0) {
                    zone += "\\";
                  }
                  zone += "\\";
                  escaped = true;
                  end++;
                }
              }
            }
          } else if (src.charAt(end) == "\n" && _type != "triple_string") {
            console.log(pos2, end, src.substring(pos2, end));
            string_error(p, token, ["EOL while scanning string literal"]);
          } else {
            zone += src.charAt(end);
            end++;
          }
        }
        var $string = zone, string = "";
        for (var i2 = 0; i2 < $string.length; i2++) {
          var $car = $string.charAt(i2);
          if ($car == quote) {
            if (raw || (i2 == 0 || $string.charAt(i2 - 1) != "\\")) {
              string += "\\";
            } else if (_type == "triple_string") {
              var j2 = i2 - 1;
              while ($string.charAt(j2) == "\\") {
                j2--;
              }
              if ((i2 - j2 - 1) % 2 == 0) {
                string += "\\";
              }
            }
          }
          string += $car;
        }
        if (fstring) {
          try {
            var re = new RegExp("\\\\" + quote, "g"), string_no_bs = string.replace(re, quote);
            var elts = $B2.parse_fstring(string_no_bs);
          } catch (err) {
            string_error(p, token, err.message);
          }
        }
        if (bytes) {
          result.value = "b" + quote + string + quote;
          result.bytes = to_bytes(string);
        } else if (fstring) {
          result.value = elts;
        } else {
          result.value = quote + string + quote;
        }
        context.raw = raw;
        return result;
      };
    })(__BRYTHON__);
    (function($B2) {
      function test_num(num_lit) {
        var len = num_lit.length, pos2 = 0, char, elt = null, subtypes = { b: "binary", o: "octal", x: "hexadecimal" }, digits_re = /[_\d]/;
        function error(message) {
          throw SyntaxError(message);
        }
        function check(elt2) {
          if (elt2.value.length == 0) {
            var t = subtypes[elt2.subtype] || "decimal";
            error("invalid " + t + " literal");
          } else if (elt2.value[elt2.value.length - 1].match(/[\-+_]/)) {
            var t = subtypes[elt2.subtype] || "decimal";
            error("invalid " + t + " literal");
          } else {
            elt2.value = elt2.value.replace(/_/g, "");
            elt2.length = pos2;
            return elt2;
          }
        }
        while (pos2 < len) {
          var char = num_lit[pos2];
          if (char.match(digits_re)) {
            if (elt === null) {
              elt = { value: char };
            } else {
              if (char == "_" && elt.value.match(/[._+\-]$/)) {
                error("consecutive _ at " + pos2);
              } else if (char == "_" && elt.subtype == "float" && elt.value.match(/e$/i)) {
                error("syntax error");
              } else if (elt.subtype == "b" && !char.match(/[01_]/)) {
                error(`invalid digit '${char}' in binary literal`);
              } else if (elt.subtype == "o" && !char.match(/[0-7_]/)) {
                error(`invalid digit '${char}' in octal literal`);
              } else if (elt.subtype === void 0 && elt.value.startsWith("0") && !char.match(/[0_]/)) {
                error("leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers");
              }
              elt.value += char;
            }
            pos2++;
          } else if (char.match(/[oxb]/i)) {
            if (elt.value == "0") {
              elt.subtype = char.toLowerCase();
              if (elt.subtype == "x") {
                digits_re = /[_\da-fA-F]/;
              }
              elt.value = "";
              pos2++;
            } else {
              error("invalid char " + char);
            }
          } else if (char == ".") {
            if (elt === null) {
              error("invalid char in " + num_lit + " pos " + pos2 + ": " + char);
            } else if (elt.subtype === void 0) {
              elt.subtype = "float";
              if (elt.value.endsWith("_")) {
                error("invalid decimal literal");
              }
              elt.value = elt.value.replace(/_/g, "") + char;
              pos2++;
            } else {
              return check(elt);
            }
          } else if (char.match(/e/i)) {
            if (num_lit[pos2 + 1] === void 0) {
              error("nothing after e");
            } else if (elt && subtypes[elt.subtype] !== void 0) {
              error("syntax error");
            } else if (elt && elt.value.endsWith("_")) {
              error("syntax error");
            } else if (num_lit[pos2 + 1].match(/[+\-0-9_]/)) {
              if (elt && elt.value) {
                if (elt.exp) {
                  elt.length = pos2;
                  return elt;
                }
                elt.subtype = "float";
                elt.value += char;
                elt.exp = true;
                pos2++;
              } else {
                error("unexpected e");
              }
            } else {
              return check(elt);
            }
          } else if (char.match(/[\+\-]/i)) {
            if (elt === null) {
              elt = { value: char };
              pos2++;
            } else if (elt.value.search(/e$/i) > -1) {
              elt.value += char;
              pos2++;
            } else {
              return check(elt);
            }
          } else if (char.match(/j/i)) {
            if (elt && (!elt.subtype || elt.subtype == "float")) {
              elt.imaginary = true;
              check(elt);
              elt.length++;
              return elt;
            } else {
              error("invalid syntax");
            }
          } else {
            break;
          }
        }
        return check(elt);
      }
      $B2.prepare_number = function(n) {
        n = n.replace(/_/g, "");
        if (n.startsWith(".")) {
          if (n.endsWith("j")) {
            return { type: "imaginary", value: $B2.prepare_number(n.substr(0, n.length - 1)) };
          } else {
            return { type: "float", value: n + "" };
          }
          pos = j;
        } else if (n.startsWith("0") && n != "0") {
          var num = test_num(n), base;
          if (num.imaginary) {
            return { type: "imaginary", value: $B2.prepare_number(num.value) };
          }
          if (num.subtype == "float") {
            return { type: num.subtype, value: num.value + "" };
          }
          if (num.subtype === void 0) {
            base = 10;
          } else {
            base = { "b": 2, "o": 8, "x": 16 }[num.subtype];
          }
          if (base !== void 0) {
            return { type: "int", value: [base, num.value] };
          }
        } else {
          var num = test_num(n);
          if (num.subtype == "float") {
            if (num.imaginary) {
              return {
                type: "imaginary",
                value: $B2.prepare_number(num.value)
              };
            } else {
              return {
                type: "float",
                value: num.value + ""
              };
            }
          } else {
            if (num.imaginary) {
              return {
                type: "imaginary",
                value: $B2.prepare_number(num.value)
              };
            } else {
              return {
                type: "int",
                value: [10, num.value]
              };
            }
          }
        }
      };
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = $B2.builtins, debug = 0;
      var p = { feature_version: $B2.version_info[1] };
      $B2.parser_constants = { Store: new $B2.ast.Store(), Load: new $B2.ast.Load(), Del: new $B2.ast.Del(), NULL: void 0, alias_ty: $B2.ast.alias, keyword_ty: $B2.ast.keyword, arguments_ty: $B2.ast.arguments, expr_ty: $B2.ast.expr, asdl_stmt_seq: Array, asdl_int_seq: Array, asdl_expr_seq: Array, asdl_keyword_seq: Array, asdl_identifier_seq: Array, asdl_pattern_seq: Array, asdl_type_param_seq: Array, AugOperator: $B2.ast.AugAssign, IsNot: $B2.ast.IsNot, Py_Ellipsis: _b_2.Ellipsis, Py_False: false, Py_True: true, Py_None: _b_2.None, PyExc_SyntaxError: _b_2.SyntaxError, STAR_TARGETS: 1, DEL_TARGETS: 2, FOR_TARGETS: 3, PyBytes_AS_STRING: (b) => b };
      for (var op_type of $B2.op_types) {
        for (var key2 in op_type) {
          var klass_name = op_type[key2];
          $B2.parser_constants[klass_name] = new $B2.ast[klass_name]();
        }
      }
      var NULL2 = $B2.parser_constants.NULL;
      $B2._PyAST = {};
      for (var ast_class in $B2.ast_classes) {
        var args = $B2.ast_classes[ast_class];
        if (Array.isArray(args)) {
          continue;
        }
        args = args.replace(/\*/g, "").replace(/\?/g, "");
        var arg_names = args.split(",");
        $B2._PyAST[ast_class] = /* @__PURE__ */ (function(ast_name, ast_args) {
          return function() {
            var _args = Array.from(arguments).slice(0, ast_args.length + 1);
            var EXTRA2 = _args.pop();
            var ast_obj = new $B2.ast[ast_name](..._args);
            set_position_from_EXTRA(ast_obj, EXTRA2);
            return ast_obj;
          };
        })(ast_class, arg_names);
      }
      function get_last_token(p2) {
        var last_token = $B2.last(p2.tokens);
        if (last_token.type == "ENDMARKER") {
          var src = $B2.file_cache[p2.filename];
          if (src) {
            for (var token of $B2.tokenizer(src)) {
              if (token.type == "ENDMARKER") {
                break;
              }
              if (token.type != "DEDENT") {
                last_token = token;
              }
            }
          } else {
            last_token = void 0;
          }
        }
        p2.known_err_token = last_token;
      }
      var helper_functions = { CHECK: function(type, obj) {
        if (Array.isArray(type)) {
          var check;
          for (var t of type) {
            check = helper_functions.CHECK(t, obj);
            if (check) {
              return check;
            }
          }
          return void 0;
        }
        if (obj instanceof type) {
          return obj;
        }
        return void 0;
      }, CHECK_VERSION: function(type, version, msg, node) {
        return helper_functions.INVALID_VERSION_CHECK(p, version, msg, node);
      }, CHECK_NULL_ALLOWED: function(type, obj) {
        if (obj !== NULL2) {
          if (type instanceof Array) {
            for (var t of type) {
              if (obj instanceof t) {
                return obj;
              }
            }
            return;
          } else {
            return obj instanceof type ? obj : void 0;
          }
        }
        return obj;
      }, INVALID_VERSION_CHECK: function(p2, version, msg, node) {
        if (node == NULL2) {
          p2.error_indicator = 1;
          return NULL2;
        }
        if (p2.feature_version < version) {
          p2.error_indicator = 1;
          return helper_functions.RAISE_SYNTAX_ERROR("%s only supported in Python 3.%i and greater", msg, version);
        }
        return node;
      }, NEW_TYPE_COMMENT: function(p2, x) {
        return x;
      }, PyErr_Occurred: function() {
        return false;
      }, RAISE_ERROR_KNOWN_LOCATION: function(p2, errtype, lineno, col_offset, end_lineno, end_col_offset, errmsg) {
        var va = [errmsg];
        $B2._PyPegen.raise_error_known_location(p2, errtype, lineno, col_offset, end_lineno, end_col_offset, errmsg, va);
        return NULL2;
      }, RAISE_ERROR: function(p2, errtype, msg) {
        var extra_args = [];
        for (var i = 1, len = arguments.length; i < len; i++) {
          extra_args.push(arguments[i]);
        }
        get_last_token(p2);
        $B2._PyPegen.raise_error(p2, errtype, msg, ...extra_args);
      }, RAISE_SYNTAX_ERROR: function(p2, msg) {
        var extra_args = [];
        for (var i = 1, len = arguments.length; i < len; i++) {
          extra_args.push(arguments[i]);
        }
        get_last_token(p2);
        $B2._PyPegen.raise_error(p2, _b_2.SyntaxError, msg, ...extra_args);
      }, RAISE_INDENTATION_ERROR: function(p2, msg, arg) {
        if (arg !== void 0) {
          msg = _b_2.str.__mod__(msg, arg);
        }
        var last_token = $B2.last(p2.tokens);
        if (last_token.type == "ENDMARKER") {
          var src = $B2.file_cache[p2.filename];
          if (src) {
            for (var token of $B2.tokenizer(src)) {
              if (token.type == "ENDMARKER") {
                break;
              }
              last_token = token;
            }
          }
        }
        get_last_token(p2);
        $B2._PyPegen.raise_error(p2, _b_2.IndentationError, msg);
      }, RAISE_SYNTAX_ERROR_KNOWN_LOCATION: function(p2, a, err_msg, arg) {
        if (arg !== void 0) {
          err_msg = _b_2.str.__mod__(err_msg, arg);
        }
        helper_functions.RAISE_ERROR_KNOWN_LOCATION(p2, _b_2.SyntaxError, a.lineno, a.col_offset, a.end_lineno, a.end_col_offset, err_msg);
      }, RAISE_SYNTAX_ERROR_KNOWN_RANGE: function(p2, a, b, msg) {
        var extra_args = arguments[4];
        if (extra_args) {
          msg = _b_2.str.__mod__(msg, extra_args);
        }
        helper_functions.RAISE_ERROR_KNOWN_LOCATION(p2, _b_2.SyntaxError, a.lineno, a.col_offset, b.end_lineno, b.end_col_offset, msg, extra_args);
      }, RAISE_SYNTAX_ERROR_INVALID_TARGET: function(p2, type, e) {
        return helper_functions._RAISE_SYNTAX_ERROR_INVALID_TARGET(p2, type, e);
      }, _RAISE_SYNTAX_ERROR_INVALID_TARGET(p2, type, e) {
        var invalid_target = $B2.helper_functions.CHECK_NULL_ALLOWED($B2.ast.expr, $B2._PyPegen.get_invalid_target(e, type));
        if (invalid_target != NULL2) {
          var msg;
          if (type == $B2.parser_constants.STAR_TARGETS || type == $B2.parser_constants.FOR_TARGETS) {
            msg = "cannot assign to %s";
          } else {
            msg = "cannot delete %s";
          }
          return helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(
            p2,
            invalid_target,
            msg,
            $B2._PyPegen.get_expr_name(invalid_target)
          );
        }
        return NULL2;
      }, RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN: function(p2, msg) {
        return helper_functions.RAISE_SYNTAX_ERROR(p2, msg);
      }, RAISE_SYNTAX_ERROR_STARTING_FROM: function(p2, a, msg, ...args2) {
        var last = p2.tokens[p2.tokens.length - 1];
        return helper_functions.RAISE_ERROR_KNOWN_LOCATION(p2, _b_2.SyntaxError, a.lineno, a.col_offset, last.end_lineno, last.end_col_offset - 1, msg, ...args2);
      }, asdl_seq_LEN: (t) => t.length, asdl_seq_GET: (t, i) => t[i] };
      $B2.helper_functions = helper_functions;
      function raise_error_known_location2(type, filename, lineno, col_offset, end_lineno, end_col_offset, line, message) {
        var exc = type.$factory(message);
        exc.filename = filename;
        exc.lineno = lineno;
        exc.offset = col_offset + 1;
        exc.end_lineno = end_lineno;
        exc.end_offset = end_col_offset + 1;
        exc.text = line;
        exc.args[1] = $B2.fast_tuple([filename, exc.lineno, exc.offset, exc.text, exc.end_lineno, exc.end_offset]);
        exc.$frame_obj = $B2.frame_obj;
        throw exc;
      }
      $B2.raise_error_known_location = raise_error_known_location2;
      function make_error_known_token(type, filename, token, message) {
        var exc = type.$factory(message);
        exc.filename = filename;
        exc.lineno = token.lineno;
        exc.offset = token.col_offset + 1;
        exc.end_lineno = token.end_lineno;
        exc.end_offset = token.end_col_offset + 1;
        exc.text = token.line;
        exc.args[1] = $B2.fast_tuple([filename, exc.lineno, exc.offset, exc.text, exc.end_lineno, exc.end_offset]);
        exc.$frame_obj = $B2.frame_obj;
        return exc;
      }
      $B2.make_error_known_token = make_error_known_token;
      function set_position_from_EXTRA(ast_obj, EXTRA2) {
        for (var key3 in EXTRA2) {
          ast_obj[key3] = EXTRA2[key3];
        }
      }
      var Parser = $B2.Parser = function(src, filename, mode) {
        this._tokens = $B2.tokenizer(src, filename, mode, this);
        this.pos = 0;
        this.tok = {};
        this.mark = 0;
        this.fill = 0;
        this.level = 0;
        this.size = 1;
        this.starting_lineno = 0;
        this.starting_col_offset = 0;
        this.last_stmt_location = {};
        this.tokens = [];
        this.src = src;
        this.filename = filename;
        this.mode = mode;
        this.memo = {};
        this.arena = { a_objects: [] };
        if (filename) {
          p.filename = filename;
        }
      };
      Parser.prototype.read_token = function() {
        while (true) {
          var next = this._tokens[this.pos++];
          if (next) {
            var value2 = next;
            if (!value2.parser_ignored) {
              if (value2.$error_token) {
                $B2.raise_error_known_location(...value2);
              } else if (value2.$error_token_known_token) {
                throw make_error_known_token(...value2);
              }
              this.tokens[this.tokens.length] = value2;
              return value2;
            }
          } else {
            throw Error("tokenizer exhausted");
          }
        }
      };
    })(__BRYTHON__);
    (function($B2) {
      var _b_2 = __BRYTHON__.builtins;
      const Load2 = new $B2.ast.Load();
      const NULL2 = void 0;
      const ENDMARKER2 = 0, NAME2 = 1, NUMBER2 = 2, STRING2 = 3;
      function strchr(s, char) {
        return s.includes(char);
      }
      function strlen(s) {
        return s.length;
      }
      function strncmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      function PyOS_strtol(s, end, base) {
        return parseFloat(s);
      }
      function PyOS_strtoul(s, end, base) {
        return parseFloat(s);
      }
      function PyOS_string_to_double(s, x, y) {
        return parseFloat(s);
      }
      function PyFloat_FromDouble(x) {
        return x;
      }
      const NSTATISTICS = 2e3, memo_statistics = {}, TYPE_IGNORE2 = "TYPE_IGNORE", ERRORTOKEN2 = "ERRORTOKEN", NEWLINE2 = $B2.py_tokens.NEWLINE, DEDENT2 = $B2.py_tokens.DEDENT, Py_single_input = "py_single_input", PyPARSE_ALLOW_INCOMPLETE_INPUT = 256;
      function PyUnicode_IS_ASCII(char) {
        return char.codePointAt(0) < 128;
      }
      function set_position_from_token(ast_obj, token) {
        for (var attr of ["lineno", "col_offset", "end_lineno", "end_col_offset"]) {
          ast_obj[attr] = token[attr];
        }
      }
      $B2._PyPegen.interactive_exit = function(p) {
        if (p.errcode) {
          p.errcode = E_EOF;
        }
        return NULL2;
      };
      $B2._PyPegen.byte_offset_to_character_offset_raw = function(str, col_offset) {
        var len = str.length;
        if (col_offset > len + 1) {
          col_offset = len + 1;
        }
        var text = PyUnicode_DecodeUTF8(str, col_offset, "replace");
        if (!text) {
          return -1;
        }
        return text.length;
      };
      $B2._PyPegen.calculate_display_width = function(line, character_offset) {
        var segment = line.substring(0, character_offset);
        if (!segment) {
          return -1;
        }
        if (PyUnicode_IS_ASCII(segment)) {
          return character_offset;
        }
        var width_fn = _PyImport_GetModuleAttrString("unicodedata", "east_asian_width");
        if (!width_fn) {
          return -1;
        }
        var width = 0;
        var len = segment.length;
        for (let i = 0; i < len; i++) {
          var chr = segment.substring(i, i + 1);
          if (!chr) {
            Py_DECREF(segment);
            Py_DECREF(width_fn);
            return -1;
          }
          var width_specifier = PyObject_CallOneArg(width_fn, chr);
          if (!width_specifier) {
            Py_DECREF(segment);
            Py_DECREF(width_fn);
            return -1;
          }
          if (width_specifier == "W" || width_specifier == "F") {
            width += 2;
          } else {
            width += 1;
          }
        }
        return width;
      };
      $B2._PyPegen.byte_offset_to_character_offset = function(line, col_offset) {
        var str = line;
        return _PyPegen_byte_offset_to_character_offset_raw(str, col_offset);
      };
      $B2._PyPegen.insert_memo = function(p, mark, type, node) {
        var m = { type, node, mark: p.mark, next: p.tokens[mark].memo };
        p.tokens[mark].memo = m;
        return 0;
      };
      $B2._PyPegen.update_memo = function(p, mark, type, node) {
        for (let m = p.tokens[mark].memo; m != NULL2; m = m.next) {
          if (m.type == type) {
            m.node = node;
            m.mark = p.mark;
            return 0;
          }
        }
        return $B2._PyPegen.insert_memo(p, mark, type, node);
      };
      function init_normalization(p) {
        if (p.normalize) {
          return 1;
        }
        p.normalize = _PyImport_GetModuleAttrString("unicodedata", "normalize");
        if (!p.normalize) {
          return 0;
        }
        return 1;
      }
      function growable_comment_array_init(arr, initial_size) {
        arr.items = new Array(initial_size * arr.items.length);
        arr.size = initial_size;
        arr.num_items = 0;
        return arr.items != NULL2;
      }
      function growable_comment_array_add(arr, lineno, comment) {
        return 1;
      }
      function growable_comment_array_deallocate(arr) {
      }
      function _get_keyword_or_name_type(p, new_token) {
        return p.keywords[new_token.string] ?? NAME2;
      }
      function initialize_token(p, parser_token, new_token, token_type) {
        parser_token.num_type = token_type == NAME2 ? _get_keyword_or_name_type(p, new_token) : token_type;
        if (parser_token.num_type == -1) {
          console.log("bizarre", new_token);
          console.log("keywords", p.keywords);
          alert();
        }
        parser_token.metadata = NULL2;
        if (new_token.metadata != NULL2) {
          parser_token.metadata = new_token.metadata;
          new_token.metadata = NULL2;
        }
        parser_token.level = new_token.level;
        parser_token.lineno = new_token.lineno;
        parser_token.col_offset = p.tok.lineno == p.starting_lineno ? p.starting_col_offset + new_token.col_offset : new_token.col_offset;
        parser_token.end_lineno = new_token.end_lineno;
        parser_token.end_col_offset = p.tok.lineno == p.starting_lineno ? p.starting_col_offset + new_token.end_col_offset : new_token.end_col_offset;
        p.arena.lineno = parser_token.lineno;
        p.fill += 1;
        if (token_type == ERRORTOKEN2 && p.tok.done == E_DECODE) {
          return _Pypegen_raise_decode_error(p);
        }
        return token_type == ERRORTOKEN2 ? _Pypegen_tokenizer_error(p) : 0;
      }
      function _PyToken_Init(token) {
        token.metadata = NULL2;
      }
      function _PyTokenizer_Get(tok, new_token) {
        var token = tok.next().value;
        for (var key2 in token) {
          new_token[key2] = token[key2];
        }
        return token.num_type;
      }
      function get_next_token(p, new_token) {
        var token = p.tokens[p.fill] ?? p.read_token();
        for (var key2 in token) {
          new_token[key2] = token[key2];
        }
        if (token.num_type == $B2.py_tokens.ENDMARKER) {
          if (p.mode == "single") {
            var end_token = p.tokens[p.tokens.length - 2];
            if (end_token.num_type != $B2.py_tokens.NEWLINE) {
              var newline = $B2.clone(end_token);
              newline.num_type = $B2.py_tokens.NEWLINE;
              p.tokens.splice(p.tokens.length - 1, 0, newline);
              token = newline;
            }
          }
        }
        return token.num_type;
      }
      $B2._PyPegen.fill_token = function(p) {
        var new_token = { metadata: NULL2 };
        var type = get_next_token(p, new_token);
        while (type == TYPE_IGNORE2) {
          type = get_next_token(p, new_token);
        }
        if (p.start_rule == Py_single_input && type == ENDMARKER2 && p.parsing_started) {
          type = NEWLINE2;
          p.parsing_started = 0;
          if (p.tok.indent && !(p.flags & PyPARSE_DONT_IMPLY_DEDENT)) {
            p.tok.pendin = -p.tok.indent;
            p.tok.indent = 0;
          }
        } else {
          p.parsing_started = 1;
        }
        var t = p.tokens[p.fill];
        return initialize_token(p, t, new_token, type);
      };
      $B2._PyPegen.clear_memo_statistics = function() {
        for (let i = 0; i < NSTATISTICS; i++) {
          memo_statistics[i] = 0;
        }
      };
      $B2._PyPegen.get_memo_statistics = function() {
        var ret = new Array(NSTATISTICS);
        if (ret == NULL2) {
          return NULL2;
        }
        for (let i = 0; i < NSTATISTICS; i++) {
          var value2 = PyLong_FromLong(memo_statistics[i]);
          if (value2 == NULL2) {
            return NULL2;
          }
          if (PyList_SetItem(ret, i, value2) < 0) {
            Py_DECREF(ret);
            return NULL2;
          }
        }
        return ret;
      };
      $B2._PyPegen.is_memoized = function(p, type, pres) {
        if (p.mark == p.fill) {
          if ($B2._PyPegen.fill_token(p) < 0) {
            p.error_indicator = 1;
            return -1;
          }
        }
        var t = p.tokens[p.mark];
        for (var m = t.memo; m != NULL2; m = m.next) {
          if (m.type == type) {
            p.mark = m.mark;
            pres.value = m.node;
            return 1;
          }
        }
        return 0;
      };
      $B2._PyPegen.lookahead_with_name = function(positive, func, p) {
        var mark = p.mark;
        var res = func(p);
        p.mark = mark;
        return res != NULL2 == positive;
      };
      $B2._PyPegen.lookahead_with_string = function(positive, func, p, arg) {
        var mark = p.mark;
        var res = func(p, arg);
        p.mark = mark;
        return res != NULL2 == positive;
      };
      $B2._PyPegen.lookahead_with_int = function(positive, func, p, arg) {
        var mark = p.mark;
        var res = func(p, arg);
        p.mark = mark;
        return res != NULL2 == positive;
      };
      $B2._PyPegen.lookahead = function(positive, func, p) {
        var mark = p.mark;
        var res = func(p);
        p.mark = mark;
        return res != NULL2 == positive;
      };
      $B2._PyPegen.expect_token = function(p, type) {
        if (p.mark == p.fill) {
          if ($B2._PyPegen.fill_token(p) < 0) {
            p.error_indicator = 1;
            return NULL2;
          }
        }
        var t = p.tokens[p.mark];
        if (t.num_type != type) {
          return NULL2;
        }
        p.mark += 1;
        return t;
      };
      $B2._PyPegen.expect_forced_result = function(p, result, expected) {
        if (p.error_indicator == 1) {
          return NULL2;
        }
        if (result == NULL2) {
          RAISE_SYNTAX_ERROR("expected (%s)", expected);
          return NULL2;
        }
        return result;
      };
      $B2._PyPegen.expect_forced_token = function(p, type, expected) {
        if (p.error_indicator == 1) {
          return NULL2;
        }
        if (p.mark == p.fill) {
          if ($B2._PyPegen.fill_token(p) < 0) {
            p.error_indicator = 1;
            return NULL2;
          }
        }
        var t = p.tokens[p.mark];
        if (t.num_type != type) {
          $B2.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, t, `expected '${expected}'`);
          return NULL2;
        }
        p.mark += 1;
        return t;
      };
      $B2._PyPegen.expect_soft_keyword = function(p, keyword) {
        if (p.mark == p.fill) {
          if ($B2._PyPegen.fill_token(p) < 0) {
            p.error_indicator = 1;
            return NULL2;
          }
        }
        var t = p.tokens[p.mark];
        if (t.num_type != NAME2) {
          return NULL2;
        }
        const s = t.string;
        if (!s) {
          p.error_indicator = 1;
          return NULL2;
        }
        if (strcmp(s, keyword) != 0) {
          return NULL2;
        }
        return $B2._PyPegen.name_token(p);
      };
      $B2._PyPegen.get_last_nonnwhitespace_token = function(p) {
        var token = NULL2;
        for (let m = p.mark - 1; m >= 0; m--) {
          token = p.tokens[m];
          if (token.num_type != ENDMARKER2 && (token.num_type < NEWLINE2 || token.num_type > DEDENT2)) {
            break;
          }
        }
        return token;
      };
      $B2._PyPegen.new_identifier = function(p, n) {
        var id = n;
        if (!PyUnicode_IS_ASCII(id)) {
          var id2;
          if (!init_normalization(p)) {
            return error();
          }
          var form = PyUnicode_InternFromString("NFKC");
          if (form == NULL2) {
            return error();
          }
          var args = { form, id };
          id2 = _PyObject_FastCall(p.normalize, args, 2);
          if (!id2) {
            return error();
          }
          if (!PyUnicode_Check(id2)) {
            PyErr_Format(PyExc_TypeError, "unicodedata.normalize() must return a string, not %.200s", _PyType_Name(Py_TYPE(id2)));
            return error();
          }
          id = id2;
        }
        PyUnicode_InternInPlace(id);
        return id;
        function error() {
          p.error_indicator = 1;
          return NULL2;
        }
      };
      $B2._PyPegen.name_from_token = function(p, t) {
        if (t == NULL2) {
          return NULL2;
        }
        var s = t.string;
        if (!s) {
          p.error_indicator = 1;
          return NULL2;
        }
        var res = new $B2.ast.Name(s, Load2);
        set_position_from_token(res, t);
        return res;
      };
      $B2._PyPegen.name_token = function(p) {
        var t = $B2._PyPegen.expect_token(p, NAME2);
        return $B2._PyPegen.name_from_token(p, t);
      };
      $B2._PyPegen.string_token = function(p) {
        return $B2._PyPegen.expect_token(p, STRING2);
      };
      $B2._PyPegen.soft_keyword_token = function(p) {
        var t = $B2._PyPegen.expect_token(p, NAME2);
        if (t == NULL2) {
          return NULL2;
        }
        var the_token;
        var size;
        the_token = t.string;
        for (let keyword = p.soft_keywords; keyword != NULL2; keyword++) {
          if (strncmp(keyword, the_token, size) == 0) {
            return $B2._PyPegen.name_from_token(p, t);
          }
        }
        return NULL2;
      };
      function prepared_number_value(prepared) {
        switch (prepared.type) {
          case "float":
            return $B2.fast_float(parseFloat(prepared.value));
          case "imaginary":
            return $B2.make_complex(0, prepared_number_value(prepared.value));
          case "int":
            var res = parseInt(prepared.value[1], prepared.value[0]);
            if (!Number.isSafeInteger(res)) {
              var base = prepared.value[0], num_str = prepared.value[1];
              switch (base) {
                case 8:
                  return $B2.fast_long_int(BigInt("0x" + num_str));
                case 10:
                  return $B2.fast_long_int(BigInt(num_str));
                case 16:
                  return $B2.fast_long_int(BigInt("0x" + num_str));
              }
            }
            return res;
        }
      }
      function parsenumber_raw(s) {
        var prepared = $B2.prepare_number(s);
        return prepared_number_value(prepared);
      }
      function parsenumber(s) {
        var dup;
        var end;
        var res = NULL2;
        if (strchr(s, "_") == NULL2) {
          return parsenumber_raw(s);
        }
        dup = s.replace(/_/g, "");
        res = parsenumber_raw(dup);
        return res;
      }
      $B2._PyPegen.number_token = function(p) {
        var t = $B2._PyPegen.expect_token(p, NUMBER2);
        if (t == NULL2) {
          return NULL2;
        }
        var num_raw = t.string;
        if (num_raw == NULL2) {
          p.error_indicator = 1;
          return NULL2;
        }
        if (p.feature_version < 6 && strchr(num_raw, "_") != NULL2) {
          p.error_indicator = 1;
          return RAISE_SYNTAX_ERROR("Underscores in numeric literals are only supported in Python 3.6 and greater");
        }
        var c = parsenumber(num_raw);
        if (c == NULL2) {
          p.error_indicator = 1;
          var tstate = _PyThreadState_GET();
          if (tstate.current_exception != NULL2 && Py_TYPE(tstate.current_exception) == PyExc_ValueError) {
            var exc = PyErr_GetRaisedException();
            RAISE_ERROR_KNOWN_LOCATION(
              p,
              PyExc_SyntaxError,
              t.lineno,
              -1,
              t.end_lineno,
              -1,
              "%S - Consider hexadecimal for huge integer literals to avoid decimal conversion limits.",
              exc
            );
          }
          return NULL2;
        }
        var res = new $B2.ast.Constant(c, NULL2);
        set_position_from_token(res, t);
        return res;
      };
      function bad_single_statement(p) {
        var cur = p.tok.cur;
        var c = cur;
        var pos2 = 0;
        for (; ; ) {
          while (c == " " || c == "	" || c == "\n" || c == "\f") {
            c = cur[pos2++];
          }
          if (!c) {
            return 0;
          }
          if (c != "#") {
            return 1;
          }
          while (c && c != "\n") {
            c = cur[pos2++];
          }
        }
      }
      function compute_parser_flags(flags) {
        var parser_flags = 0;
        if (!flags) {
          return 0;
        }
        if (flags.cf_flags & PyCF_DONT_IMPLY_DEDENT) {
          parser_flags |= PyPARSE_DONT_IMPLY_DEDENT;
        }
        if (flags.cf_flags & PyCF_IGNORE_COOKIE) {
          parser_flags |= PyPARSE_IGNORE_COOKIE;
        }
        if (flags.cf_flags & CO_FUTURE_BARRY_AS_BDFL) {
          parser_flags |= PyPARSE_BARRY_AS_BDFL;
        }
        if (flags.cf_flags & PyCF_TYPE_COMMENTS) {
          parser_flags |= PyPARSE_TYPE_COMMENTS;
        }
        if (flags.cf_flags & PyCF_ONLY_AST && flags.cf_feature_version < 7) {
          parser_flags |= PyPARSE_ASYNC_HACKS;
        }
        if (flags.cf_flags & PyCF_ALLOW_INCOMPLETE_INPUT) {
          parser_flags |= PyPARSE_ALLOW_INCOMPLETE_INPUT;
        }
        return parser_flags;
      }
      $B2._PyPegen.Parser_New = function(tok, start_rule, flags, feature_version, errcode, source, arena) {
        var p = {};
        if (p == NULL2) {
          return PyErr_NoMemory();
        }
        tok.type_comments = (flags & PyPARSE_TYPE_COMMENTS) > 0;
        tok.async_hacks = (flags & PyPARSE_ASYNC_HACKS) > 0;
        p.tok = tok;
        p.keywords = NULL2;
        p.n_keyword_lists = -1;
        p.soft_keywords = NULL2;
        p.tokens = [];
        if (!p.tokens) {
          PyMem_Free(p);
          return PyErr_NoMemory();
        }
        p.tokens[0] = PyMem_Calloc(1, sizeof(Token));
        p.mark = 0;
        p.fill = 0;
        p.size = 1;
        p.errcode = errcode;
        p.arena = arena;
        p.start_rule = start_rule;
        p.parsing_started = 0;
        p.normalize = NULL2;
        p.error_indicator = 0;
        p.starting_lineno = 0;
        p.starting_col_offset = 0;
        p.flags = flags;
        p.feature_version = feature_version;
        p.known_err_token = NULL2;
        p.level = 0;
        p.call_invalid_rules = 0;
        p.debug = _Py_GetConfig().parser_debug;
        return p;
      };
      $B2._PyPegen.Parser_Free = function(p) {
      };
      function reset_parser_state_for_error_pass(p) {
        for (let i = 0; i < p.fill; i++) {
          p.tokens[i].memo = NULL2;
        }
        p.mark = 0;
        p.call_invalid_rules = 1;
      }
      function _is_end_of_source(p) {
        var err = p.tok.done;
        return p.tokens[p.tokens.length - 1].type == $B2.py_tokens.ENDMARKER;
      }
      function inside_fstring(p) {
        var res = false;
        for (var token of p.tokens) {
          if (token.type == $B2.py_tokens.FSTRING_START) {
            res = true;
          } else if (token.type == $B2.py_tokens.FSTRING_END) {
            res = false;
          }
        }
        return res;
      }
      $B2._PyPegen.tokenize_full_source_to_check_for_errors = function(p) {
        var last_token = p.tokens[p.fill - 1];
        $B2.tokenizer(p.src, p.filename, p.mode, p);
        p.tokens = p._tokens;
        if (p.braces.length > 0) {
          var brace = $B2.last(p.braces), err_lineno, msg;
          if ("([{".includes(brace.char)) {
            err_lineno = brace.line_num;
          } else {
            if (p.braces.length > 1) {
              err_lineno = p.braces[p.braces.length - 2].line_num;
            } else {
              err_lineno = brace.line_num;
            }
          }
          if (p.tokens.length == 0 || $B2.last(p.tokens).lineno >= err_lineno) {
            if ("([{".includes(brace.char)) {
              msg = `'${brace.char}' was never closed`;
            } else if (p.braces.length > 1) {
              var closing = brace.char, opening = p.braces[p.braces.length - 2].char;
              if (inside_fstring(p)) {
                msg = `f-string: unmatched '${closing}'`;
              } else {
                msg = `closing parenthesis '${closing}' does not match opening parenthesis '${opening}'`;
              }
            } else {
              msg = `unmatched '${brace.char}'`;
            }
            $B2.raise_error_known_location(_b_2.SyntaxError, p.filename, brace.line_num, brace.pos - brace.line_start, brace.line_num, brace.pos - brace.line_start + 1, brace.line, msg);
          }
        }
      };
      $B2._PyPegen.set_syntax_error = function(p, last_token) {
        if (p.fill == 0) {
          $B2.helper_functions.RAISE_SYNTAX_ERROR(p, "error at start before reading any input");
        }
        $B2._PyPegen.tokenize_full_source_to_check_for_errors(p);
        if (last_token.num_type == ERRORTOKEN2 && p.tok.done == E_EOF) {
          if (p.tok.level) {
            raise_unclosed_parentheses_error(p);
          } else {
            $B2.helper_functions.RAISE_SYNTAX_ERROR(p, "unexpected EOF while parsing");
          }
          return;
        }
        if (last_token.num_type == INDENT || last_token.num_type == DEDENT2) {
          $B2.helper_functions.RAISE_INDENTATION_ERROR(p, last_token.num_type == INDENT ? "unexpected indent" : "unexpected unindent");
          return;
        }
        $B2._PyPegen.tokenize_full_source_to_check_for_errors(p);
        return $B2.make_error_known_token(_b_2.SyntaxError, p.filename, last_token, "invalid syntax");
      };
      $B2._PyPegen.set_syntax_error_metadata = function(p, exc) {
        if (!exc || !$B2.is_exc(exc, [_b_2.SyntaxError])) {
          return;
        }
        var source = NULL2;
        if (p.src != NULL2) {
          source = p.src;
        }
        if (!source && p.tok.fp_interactive && p.tok.interactive_src_start) {
          source = p.tok.interactive_src_start;
        }
        var the_source = NULL2;
        if (source) {
          the_source = source;
        }
        if (!the_source) {
          the_source = _b_2.None;
        }
        var metadata = [
          exc.lineno,
          exc.offset,
          the_source
        ];
        if (!metadata) {
          return;
        }
        exc._metadata = metadata;
      };
      $B2._PyPegen.run_parser = function(p) {
        var res = $B2._PyPegen.parse(p);
        $B2.python_keywords = p.keywords;
        if (res == NULL2) {
          if (p.flags & $B2.PyCF_ALLOW_INCOMPLETE_INPUT && _is_end_of_source(p)) {
            return $B2.helper_functions.RAISE_ERROR(p, _b_2._IncompleteInputError, "incomplete input");
          }
          var last_token = p.tokens[p.fill - 1];
          reset_parser_state_for_error_pass(p);
          try {
            $B2._PyPegen.parse(p);
          } catch (err) {
            last_token = p.tokens[p.fill - 1];
            $B2._PyPegen.tokenize_full_source_to_check_for_errors(p);
            throw err;
          }
          var exc = $B2._PyPegen.set_syntax_error(p, last_token);
          if ($B2.is_exc(exc, [_b_2.SyntaxError])) {
            $B2._PyPegen.set_syntax_error_metadata(p, exc);
          }
          throw exc;
        }
        if (p.start_rule == Py_single_input && bad_single_statement(p)) {
          p.tok.done = E_BADSINGLE;
          return RAISE_SYNTAX_ERROR("multiple statements found while compiling a single statement");
        }
        return res;
      };
      $B2._PyPegen.run_parser_from_file_pointer = function(fp, start_rule, filename_ob, enc, ps1, ps2, flags, errcode, arena) {
        var tok = _PyTokenizer_FromFile(fp, enc, ps1, ps2);
        if (tok == NULL2) {
          if (PyErr_Occurred()) {
            _PyPegen_raise_tokenizer_init_error(filename_ob);
            return NULL2;
          }
          return NULL2;
        }
        if (!tok.fp || ps1 != NULL2 || ps2 != NULL2 || PyUnicode_CompareWithASCIIString(filename_ob, "<stdin>") == 0) {
          tok.fp_interactive = 1;
        }
        tok.filename = Py_NewRef(filename_ob);
        var result = NULL2;
        var parser_flags = compute_parser_flags(flags);
        var p = $B2._PyPegen.Parser_New(tok, start_rule, parser_flags, PY_MINOR_VERSION, errcode, NULL2, arena);
        if (p == NULL2) {
          return error();
        }
        result = _PyPegen_run_parser(p);
        _PyPegen_Parser_Free(p);
        function error() {
          _PyTokenizer_Free(tok);
          return result;
        }
      };
      $B2._PyPegen.run_parser_from_string = function(str, start_rule, filename_ob, flags, arena) {
        var exec_input = start_rule == Py_file_input;
        var tok;
        if (flags != NULL2 && flags.cf_flags & PyCF_IGNORE_COOKIE) {
          tok = _PyTokenizer_FromUTF8(str, exec_input, 0);
        } else {
          tok = _PyTokenizer_FromString(str, exec_input, 0);
        }
        if (tok == NULL2) {
          if (PyErr_Occurred()) {
            _PyPegen_raise_tokenizer_init_error(filename_ob);
          }
          return NULL2;
        }
        tok.filename = Py_NewRef(filename_ob);
        var result = NULL2;
        var parser_flags = compute_parser_flags(flags);
        var feature_version = flags && flags.cf_flags & PyCF_ONLY_AST ? flags.cf_feature_version : PY_MINOR_VERSION;
        var p = $B2._PyPegen.Parser_New(tok, start_rule, parser_flags, feature_version, NULL2, str, arena);
        if (p == NULL2) {
          return error();
        }
        result = _PyPegen_run_parser(p);
        _PyPegen_Parser_Free(p);
        function error() {
          return result;
        }
      };
      $B2.PyPegen = { first_item: function(a, type) {
        return a[0];
      }, last_item: function(a, ptype) {
        return a[a.length - 1];
      } };
    })(__BRYTHON__);
    function fprintf(dest, format) {
      var args = Array.from(arguments).slice(2);
      for (var arg of args) {
        format = format.replace(/%\*?[a-z]/, arg);
      }
      return format;
    }
    var stderr = null;
    function D(x) {
      console.log(x);
    }
    function UNUSED() {
    }
    function strcmp(x, y) {
      return x == y ? 0 : x < y ? -1 : 1;
    }
    var MAXSTACK = 6e3;
    var NULL = void 0;
    function NEW_TYPE_COMMENT() {
    }
    var $B = __BRYTHON__;
    var Store = new $B.ast.Store();
    var Load = new $B.ast.Load();
    var EXTRA = {};
    var ENDMARKER = 0;
    var NAME = 1;
    var NUMBER = 2;
    var STRING = 3;
    var NEWLINE = 4;
    var INDENT = 5;
    var DEDENT = 6;
    var LPAR = 7;
    var RPAR = 8;
    var LSQB = 9;
    var RSQB = 10;
    var COLON = 11;
    var COMMA = 12;
    var SEMI = 13;
    var PLUS = 14;
    var MINUS = 15;
    var STAR = 16;
    var SLASH = 17;
    var VBAR = 18;
    var AMPER = 19;
    var LESS = 20;
    var GREATER = 21;
    var EQUAL = 22;
    var DOT = 23;
    var PERCENT = 24;
    var LBRACE = 25;
    var RBRACE = 26;
    var EQEQUAL = 27;
    var NOTEQUAL = 28;
    var LESSEQUAL = 29;
    var GREATEREQUAL = 30;
    var TILDE = 31;
    var CIRCUMFLEX = 32;
    var LEFTSHIFT = 33;
    var RIGHTSHIFT = 34;
    var DOUBLESTAR = 35;
    var PLUSEQUAL = 36;
    var MINEQUAL = 37;
    var STAREQUAL = 38;
    var SLASHEQUAL = 39;
    var PERCENTEQUAL = 40;
    var AMPEREQUAL = 41;
    var VBAREQUAL = 42;
    var CIRCUMFLEXEQUAL = 43;
    var LEFTSHIFTEQUAL = 44;
    var RIGHTSHIFTEQUAL = 45;
    var DOUBLESTAREQUAL = 46;
    var DOUBLESLASH = 47;
    var DOUBLESLASHEQUAL = 48;
    var AT = 49;
    var ATEQUAL = 50;
    var RARROW = 51;
    var ELLIPSIS = 52;
    var COLONEQUAL = 53;
    var EXCLAMATION = 54;
    var OP = 55;
    var TYPE_IGNORE = 56;
    var TYPE_COMMENT = 57;
    var SOFT_KEYWORD = 58;
    var FSTRING_START = 59;
    var FSTRING_MIDDLE = 60;
    var FSTRING_END = 61;
    var TSTRING_START = 62;
    var TSTRING_MIDDLE = 63;
    var TSTRING_END = 64;
    var COMMENT = 65;
    var NL = 66;
    var ERRORTOKEN = 67;
    var ENCODING = 68;
    var n_keyword_lists = 9;
    var _reserved_keywords = { if: 682, as: 680, in: 695, or: 588, is: 596, del: 625, def: 699, for: 694, try: 656, and: 589, not: 703, from: 633, pass: 526, with: 647, elif: 687, else: 686, None: 623, True: 622, raise: 525, yield: 587, break: 527, async: 698, class: 701, while: 689, False: 624, await: 597, return: 522, import: 634, assert: 532, global: 529, except: 677, lambda: 621, finally: 673, continue: 528, nonlocal: 530 };
    var reserved_keywords = /* @__PURE__ */ Object.create(null);
    for (item of Object.entries(_reserved_keywords)) {
      reserved_keywords[item[0]] = item[1];
    }
    var item;
    var soft_keywords = ["_", "case", "match", "type", NULL];
    var file_type = 1e3;
    var interactive_type = 1001;
    var eval_type = 1002;
    var func_type_type = 1003;
    var statements_type = 1004;
    var statement_type = 1005;
    var single_compound_stmt_type = 1006;
    var statement_newline_type = 1007;
    var simple_stmts_type = 1008;
    var simple_stmt_type = 1009;
    var compound_stmt_type = 1010;
    var assignment_type = 1011;
    var annotated_rhs_type = 1012;
    var augassign_type = 1013;
    var return_stmt_type = 1014;
    var raise_stmt_type = 1015;
    var pass_stmt_type = 1016;
    var break_stmt_type = 1017;
    var continue_stmt_type = 1018;
    var global_stmt_type = 1019;
    var nonlocal_stmt_type = 1020;
    var del_stmt_type = 1021;
    var yield_stmt_type = 1022;
    var assert_stmt_type = 1023;
    var import_stmt_type = 1024;
    var import_name_type = 1025;
    var import_from_type = 1026;
    var import_from_targets_type = 1027;
    var import_from_as_names_type = 1028;
    var import_from_as_name_type = 1029;
    var dotted_as_names_type = 1030;
    var dotted_as_name_type = 1031;
    var dotted_name_type = 1032;
    var block_type = 1033;
    var decorators_type = 1034;
    var class_def_type = 1035;
    var class_def_raw_type = 1036;
    var function_def_type = 1037;
    var function_def_raw_type = 1038;
    var params_type = 1039;
    var parameters_type = 1040;
    var slash_no_default_type = 1041;
    var slash_with_default_type = 1042;
    var star_etc_type = 1043;
    var kwds_type = 1044;
    var param_no_default_type = 1045;
    var param_no_default_star_annotation_type = 1046;
    var param_with_default_type = 1047;
    var param_maybe_default_type = 1048;
    var param_type = 1049;
    var param_star_annotation_type = 1050;
    var annotation_type = 1051;
    var star_annotation_type = 1052;
    var default_type = 1053;
    var if_stmt_type = 1054;
    var elif_stmt_type = 1055;
    var else_block_type = 1056;
    var while_stmt_type = 1057;
    var for_stmt_type = 1058;
    var with_stmt_type = 1059;
    var with_item_type = 1060;
    var try_stmt_type = 1061;
    var except_block_type = 1062;
    var except_star_block_type = 1063;
    var finally_block_type = 1064;
    var match_stmt_type = 1065;
    var subject_expr_type = 1066;
    var case_block_type = 1067;
    var guard_type = 1068;
    var patterns_type = 1069;
    var pattern_type = 1070;
    var as_pattern_type = 1071;
    var or_pattern_type = 1072;
    var closed_pattern_type = 1073;
    var literal_pattern_type = 1074;
    var literal_expr_type = 1075;
    var complex_number_type = 1076;
    var signed_number_type = 1077;
    var signed_real_number_type = 1078;
    var real_number_type = 1079;
    var imaginary_number_type = 1080;
    var capture_pattern_type = 1081;
    var pattern_capture_target_type = 1082;
    var wildcard_pattern_type = 1083;
    var value_pattern_type = 1084;
    var attr_type = 1085;
    var name_or_attr_type = 1086;
    var group_pattern_type = 1087;
    var sequence_pattern_type = 1088;
    var open_sequence_pattern_type = 1089;
    var maybe_sequence_pattern_type = 1090;
    var maybe_star_pattern_type = 1091;
    var star_pattern_type = 1092;
    var mapping_pattern_type = 1093;
    var items_pattern_type = 1094;
    var key_value_pattern_type = 1095;
    var double_star_pattern_type = 1096;
    var class_pattern_type = 1097;
    var positional_patterns_type = 1098;
    var keyword_patterns_type = 1099;
    var keyword_pattern_type = 1100;
    var type_alias_type = 1101;
    var type_params_type = 1102;
    var type_param_seq_type = 1103;
    var type_param_type = 1104;
    var type_param_bound_type = 1105;
    var type_param_default_type = 1106;
    var type_param_starred_default_type = 1107;
    var expressions_type = 1108;
    var expression_type = 1109;
    var yield_expr_type = 1110;
    var star_expressions_type = 1111;
    var star_expression_type = 1112;
    var star_named_expressions_type = 1113;
    var star_named_expression_type = 1114;
    var assignment_expression_type = 1115;
    var named_expression_type = 1116;
    var disjunction_type = 1117;
    var conjunction_type = 1118;
    var inversion_type = 1119;
    var comparison_type = 1120;
    var compare_op_bitwise_or_pair_type = 1121;
    var eq_bitwise_or_type = 1122;
    var noteq_bitwise_or_type = 1123;
    var lte_bitwise_or_type = 1124;
    var lt_bitwise_or_type = 1125;
    var gte_bitwise_or_type = 1126;
    var gt_bitwise_or_type = 1127;
    var notin_bitwise_or_type = 1128;
    var in_bitwise_or_type = 1129;
    var isnot_bitwise_or_type = 1130;
    var is_bitwise_or_type = 1131;
    var bitwise_or_type = 1132;
    var bitwise_xor_type = 1133;
    var bitwise_and_type = 1134;
    var shift_expr_type = 1135;
    var sum_type = 1136;
    var term_type = 1137;
    var factor_type = 1138;
    var power_type = 1139;
    var await_primary_type = 1140;
    var primary_type = 1141;
    var slices_type = 1142;
    var slice_type = 1143;
    var atom_type = 1144;
    var group_type = 1145;
    var lambdef_type = 1146;
    var lambda_params_type = 1147;
    var lambda_parameters_type = 1148;
    var lambda_slash_no_default_type = 1149;
    var lambda_slash_with_default_type = 1150;
    var lambda_star_etc_type = 1151;
    var lambda_kwds_type = 1152;
    var lambda_param_no_default_type = 1153;
    var lambda_param_with_default_type = 1154;
    var lambda_param_maybe_default_type = 1155;
    var lambda_param_type = 1156;
    var fstring_middle_type = 1157;
    var fstring_replacement_field_type = 1158;
    var fstring_conversion_type = 1159;
    var fstring_full_format_spec_type = 1160;
    var fstring_format_spec_type = 1161;
    var fstring_type = 1162;
    var tstring_format_spec_replacement_field_type = 1163;
    var tstring_format_spec_type = 1164;
    var tstring_full_format_spec_type = 1165;
    var tstring_replacement_field_type = 1166;
    var tstring_middle_type = 1167;
    var tstring_type = 1168;
    var string_type = 1169;
    var strings_type = 1170;
    var list_type = 1171;
    var tuple_type = 1172;
    var set_type = 1173;
    var dict_type = 1174;
    var double_starred_kvpairs_type = 1175;
    var double_starred_kvpair_type = 1176;
    var kvpair_type = 1177;
    var for_if_clauses_type = 1178;
    var for_if_clause_type = 1179;
    var listcomp_type = 1180;
    var setcomp_type = 1181;
    var genexp_type = 1182;
    var dictcomp_type = 1183;
    var arguments_type = 1184;
    var args_type = 1185;
    var kwargs_type = 1186;
    var starred_expression_type = 1187;
    var kwarg_or_starred_type = 1188;
    var kwarg_or_double_starred_type = 1189;
    var star_targets_type = 1190;
    var star_targets_list_seq_type = 1191;
    var star_targets_tuple_seq_type = 1192;
    var star_target_type = 1193;
    var target_with_star_atom_type = 1194;
    var star_atom_type = 1195;
    var single_target_type = 1196;
    var single_subscript_attribute_target_type = 1197;
    var t_primary_type = 1198;
    var t_lookahead_type = 1199;
    var del_targets_type = 1200;
    var del_target_type = 1201;
    var del_t_atom_type = 1202;
    var type_expressions_type = 1203;
    var func_type_comment_type = 1204;
    var invalid_arguments_type = 1205;
    var invalid_kwarg_type = 1206;
    var expression_without_invalid_type = 1207;
    var invalid_legacy_expression_type = 1208;
    var invalid_type_param_type = 1209;
    var invalid_expression_type = 1210;
    var invalid_named_expression_type = 1211;
    var invalid_assignment_type = 1212;
    var invalid_ann_assign_target_type = 1213;
    var invalid_del_stmt_type = 1214;
    var invalid_block_type = 1215;
    var invalid_comprehension_type = 1216;
    var invalid_dict_comprehension_type = 1217;
    var invalid_parameters_type = 1218;
    var invalid_default_type = 1219;
    var invalid_star_etc_type = 1220;
    var invalid_kwds_type = 1221;
    var invalid_parameters_helper_type = 1222;
    var invalid_lambda_parameters_type = 1223;
    var invalid_lambda_parameters_helper_type = 1224;
    var invalid_lambda_star_etc_type = 1225;
    var invalid_lambda_kwds_type = 1226;
    var invalid_double_type_comments_type = 1227;
    var invalid_with_item_type = 1228;
    var invalid_for_if_clause_type = 1229;
    var invalid_for_target_type = 1230;
    var invalid_group_type = 1231;
    var invalid_import_type = 1232;
    var invalid_dotted_as_name_type = 1233;
    var invalid_import_from_as_name_type = 1234;
    var invalid_import_from_targets_type = 1235;
    var invalid_with_stmt_type = 1236;
    var invalid_with_stmt_indent_type = 1237;
    var invalid_try_stmt_type = 1238;
    var invalid_except_stmt_type = 1239;
    var invalid_except_star_stmt_type = 1240;
    var invalid_finally_stmt_type = 1241;
    var invalid_except_stmt_indent_type = 1242;
    var invalid_except_star_stmt_indent_type = 1243;
    var invalid_match_stmt_type = 1244;
    var invalid_case_block_type = 1245;
    var invalid_as_pattern_type = 1246;
    var invalid_class_pattern_type = 1247;
    var invalid_class_argument_pattern_type = 1248;
    var invalid_if_stmt_type = 1249;
    var invalid_elif_stmt_type = 1250;
    var invalid_else_stmt_type = 1251;
    var invalid_while_stmt_type = 1252;
    var invalid_for_stmt_type = 1253;
    var invalid_def_raw_type = 1254;
    var invalid_class_def_raw_type = 1255;
    var invalid_double_starred_kvpairs_type = 1256;
    var invalid_kvpair_type = 1257;
    var invalid_starred_expression_unpacking_type = 1258;
    var invalid_starred_expression_type = 1259;
    var invalid_fstring_replacement_field_type = 1260;
    var invalid_fstring_conversion_character_type = 1261;
    var invalid_tstring_replacement_field_type = 1262;
    var invalid_tstring_conversion_character_type = 1263;
    var invalid_string_tstring_concat_type = 1264;
    var invalid_arithmetic_type = 1265;
    var invalid_factor_type = 1266;
    var invalid_type_params_type = 1267;
    var _loop0_1_type = 1268;
    var _loop0_2_type = 1269;
    var _loop1_3_type = 1270;
    var _loop0_5_type = 1271;
    var _gather_4_type = 1272;
    var _tmp_6_type = 1273;
    var _tmp_7_type = 1274;
    var _tmp_8_type = 1275;
    var _tmp_9_type = 1276;
    var _tmp_10_type = 1277;
    var _tmp_11_type = 1278;
    var _tmp_12_type = 1279;
    var _tmp_13_type = 1280;
    var _loop1_14_type = 1281;
    var _tmp_15_type = 1282;
    var _loop0_17_type = 1283;
    var _gather_16_type = 1284;
    var _loop0_19_type = 1285;
    var _gather_18_type = 1286;
    var _tmp_20_type = 1287;
    var _tmp_21_type = 1288;
    var _loop0_22_type = 1289;
    var _loop1_23_type = 1290;
    var _loop0_25_type = 1291;
    var _gather_24_type = 1292;
    var _tmp_26_type = 1293;
    var _loop0_28_type = 1294;
    var _gather_27_type = 1295;
    var _tmp_29_type = 1296;
    var _loop1_30_type = 1297;
    var _tmp_31_type = 1298;
    var _tmp_32_type = 1299;
    var _tmp_33_type = 1300;
    var _loop0_34_type = 1301;
    var _loop0_35_type = 1302;
    var _loop0_36_type = 1303;
    var _loop1_37_type = 1304;
    var _loop0_38_type = 1305;
    var _loop1_39_type = 1306;
    var _loop1_40_type = 1307;
    var _loop1_41_type = 1308;
    var _loop0_42_type = 1309;
    var _loop1_43_type = 1310;
    var _loop0_44_type = 1311;
    var _loop1_45_type = 1312;
    var _loop0_46_type = 1313;
    var _loop0_47_type = 1314;
    var _loop1_48_type = 1315;
    var _loop0_50_type = 1316;
    var _gather_49_type = 1317;
    var _loop0_52_type = 1318;
    var _gather_51_type = 1319;
    var _loop0_54_type = 1320;
    var _gather_53_type = 1321;
    var _loop0_56_type = 1322;
    var _gather_55_type = 1323;
    var _tmp_57_type = 1324;
    var _loop1_58_type = 1325;
    var _loop1_59_type = 1326;
    var _loop1_60_type = 1327;
    var _loop0_62_type = 1328;
    var _gather_61_type = 1329;
    var _tmp_63_type = 1330;
    var _tmp_64_type = 1331;
    var _tmp_65_type = 1332;
    var _tmp_66_type = 1333;
    var _tmp_67_type = 1334;
    var _loop0_69_type = 1335;
    var _gather_68_type = 1336;
    var _loop0_71_type = 1337;
    var _gather_70_type = 1338;
    var _tmp_72_type = 1339;
    var _loop0_74_type = 1340;
    var _gather_73_type = 1341;
    var _loop0_76_type = 1342;
    var _gather_75_type = 1343;
    var _loop0_78_type = 1344;
    var _gather_77_type = 1345;
    var _loop1_79_type = 1346;
    var _loop1_80_type = 1347;
    var _loop0_82_type = 1348;
    var _gather_81_type = 1349;
    var _loop1_83_type = 1350;
    var _loop1_84_type = 1351;
    var _loop1_85_type = 1352;
    var _tmp_86_type = 1353;
    var _loop0_88_type = 1354;
    var _gather_87_type = 1355;
    var _tmp_89_type = 1356;
    var _tmp_90_type = 1357;
    var _tmp_91_type = 1358;
    var _tmp_92_type = 1359;
    var _tmp_93_type = 1360;
    var _tmp_94_type = 1361;
    var _loop0_95_type = 1362;
    var _loop0_96_type = 1363;
    var _loop0_97_type = 1364;
    var _loop1_98_type = 1365;
    var _loop0_99_type = 1366;
    var _loop1_100_type = 1367;
    var _loop1_101_type = 1368;
    var _loop1_102_type = 1369;
    var _loop0_103_type = 1370;
    var _loop1_104_type = 1371;
    var _loop0_105_type = 1372;
    var _loop1_106_type = 1373;
    var _loop0_107_type = 1374;
    var _loop1_108_type = 1375;
    var _loop0_109_type = 1376;
    var _loop0_110_type = 1377;
    var _loop0_111_type = 1378;
    var _loop0_112_type = 1379;
    var _loop1_113_type = 1380;
    var _loop1_114_type = 1381;
    var _tmp_115_type = 1382;
    var _loop0_117_type = 1383;
    var _gather_116_type = 1384;
    var _loop1_118_type = 1385;
    var _loop0_119_type = 1386;
    var _loop0_120_type = 1387;
    var _tmp_121_type = 1388;
    var _loop0_123_type = 1389;
    var _gather_122_type = 1390;
    var _tmp_124_type = 1391;
    var _loop0_126_type = 1392;
    var _gather_125_type = 1393;
    var _loop0_128_type = 1394;
    var _gather_127_type = 1395;
    var _loop0_130_type = 1396;
    var _gather_129_type = 1397;
    var _loop0_132_type = 1398;
    var _gather_131_type = 1399;
    var _loop0_133_type = 1400;
    var _loop0_135_type = 1401;
    var _gather_134_type = 1402;
    var _loop1_136_type = 1403;
    var _tmp_137_type = 1404;
    var _loop0_139_type = 1405;
    var _gather_138_type = 1406;
    var _loop0_141_type = 1407;
    var _gather_140_type = 1408;
    var _loop0_143_type = 1409;
    var _gather_142_type = 1410;
    var _loop0_145_type = 1411;
    var _gather_144_type = 1412;
    var _loop0_147_type = 1413;
    var _gather_146_type = 1414;
    var _tmp_148_type = 1415;
    var _tmp_149_type = 1416;
    var _loop0_151_type = 1417;
    var _gather_150_type = 1418;
    var _tmp_152_type = 1419;
    var _tmp_153_type = 1420;
    var _tmp_154_type = 1421;
    var _tmp_155_type = 1422;
    var _tmp_156_type = 1423;
    var _loop1_157_type = 1424;
    var _tmp_158_type = 1425;
    var _tmp_159_type = 1426;
    var _tmp_160_type = 1427;
    var _tmp_161_type = 1428;
    var _tmp_162_type = 1429;
    var _tmp_163_type = 1430;
    var _loop0_164_type = 1431;
    var _loop0_165_type = 1432;
    var _loop0_166_type = 1433;
    var _tmp_167_type = 1434;
    var _tmp_168_type = 1435;
    var _tmp_169_type = 1436;
    var _tmp_170_type = 1437;
    var _loop0_171_type = 1438;
    var _loop0_172_type = 1439;
    var _loop0_173_type = 1440;
    var _loop1_174_type = 1441;
    var _tmp_175_type = 1442;
    var _loop0_176_type = 1443;
    var _tmp_177_type = 1444;
    var _loop0_178_type = 1445;
    var _loop1_179_type = 1446;
    var _tmp_180_type = 1447;
    var _tmp_181_type = 1448;
    var _tmp_182_type = 1449;
    var _loop0_183_type = 1450;
    var _tmp_184_type = 1451;
    var _tmp_185_type = 1452;
    var _loop1_186_type = 1453;
    var _tmp_187_type = 1454;
    var _loop0_188_type = 1455;
    var _loop0_189_type = 1456;
    var _loop0_190_type = 1457;
    var _loop0_192_type = 1458;
    var _gather_191_type = 1459;
    var _tmp_193_type = 1460;
    var _loop0_194_type = 1461;
    var _tmp_195_type = 1462;
    var _loop0_196_type = 1463;
    var _loop1_197_type = 1464;
    var _loop1_198_type = 1465;
    var _tmp_199_type = 1466;
    var _tmp_200_type = 1467;
    var _loop0_201_type = 1468;
    var _tmp_202_type = 1469;
    var _tmp_203_type = 1470;
    var _tmp_204_type = 1471;
    var _tmp_205_type = 1472;
    var _loop0_207_type = 1473;
    var _gather_206_type = 1474;
    var _tmp_208_type = 1475;
    var _tmp_209_type = 1476;
    var _loop0_211_type = 1477;
    var _gather_210_type = 1478;
    var _loop0_213_type = 1479;
    var _gather_212_type = 1480;
    var _loop0_215_type = 1481;
    var _gather_214_type = 1482;
    var _loop0_217_type = 1483;
    var _gather_216_type = 1484;
    var _tmp_218_type = 1485;
    var _loop0_219_type = 1486;
    var _loop1_220_type = 1487;
    var _tmp_221_type = 1488;
    var _loop0_222_type = 1489;
    var _loop1_223_type = 1490;
    var _tmp_224_type = 1491;
    var _tmp_225_type = 1492;
    var _tmp_226_type = 1493;
    var _tmp_227_type = 1494;
    var _tmp_228_type = 1495;
    var _tmp_229_type = 1496;
    var _tmp_230_type = 1497;
    var _tmp_231_type = 1498;
    var _tmp_232_type = 1499;
    var _tmp_233_type = 1500;
    var _tmp_234_type = 1501;
    var _loop0_236_type = 1502;
    var _gather_235_type = 1503;
    var _tmp_237_type = 1504;
    var _tmp_238_type = 1505;
    var _tmp_239_type = 1506;
    var _tmp_240_type = 1507;
    var _tmp_241_type = 1508;
    var _tmp_242_type = 1509;
    var _tmp_243_type = 1510;
    var _loop0_244_type = 1511;
    var _tmp_245_type = 1512;
    var _tmp_246_type = 1513;
    var _tmp_247_type = 1514;
    var _tmp_248_type = 1515;
    var _tmp_249_type = 1516;
    var _tmp_250_type = 1517;
    var _tmp_251_type = 1518;
    var _loop0_252_type = 1519;
    var _tmp_253_type = 1520;
    var _tmp_254_type = 1521;
    var _loop1_255_type = 1522;
    var _loop1_256_type = 1523;
    var _tmp_257_type = 1524;
    var _tmp_258_type = 1525;
    var _tmp_259_type = 1526;
    var _tmp_260_type = 1527;
    var _tmp_261_type = 1528;
    var _tmp_262_type = 1529;
    var _tmp_263_type = 1530;
    var _tmp_264_type = 1531;
    var _tmp_265_type = 1532;
    var _tmp_266_type = 1533;
    var _tmp_267_type = 1534;
    var _tmp_268_type = 1535;
    var _tmp_269_type = 1536;
    var _tmp_270_type = 1537;
    var _tmp_271_type = 1538;
    var _tmp_272_type = 1539;
    var _tmp_273_type = 1540;
    var _tmp_274_type = 1541;
    var _tmp_275_type = 1542;
    var _tmp_276_type = 1543;
    var _tmp_277_type = 1544;
    var _tmp_278_type = 1545;
    var _tmp_279_type = 1546;
    var _tmp_280_type = 1547;
    var _tmp_281_type = 1548;
    var _loop0_282_type = 1549;
    var _tmp_283_type = 1550;
    var _tmp_284_type = 1551;
    var _tmp_285_type = 1552;
    var _tmp_286_type = 1553;
    var _tmp_287_type = 1554;
    var _tmp_288_type = 1555;
    var _tmp_289_type = 1556;
    var _tmp_290_type = 1557;
    var _tmp_291_type = 1558;
    var _loop0_293_type = 1559;
    var _gather_292_type = 1560;
    var _tmp_294_type = 1561;
    var _tmp_295_type = 1562;
    var _tmp_296_type = 1563;
    var _tmp_297_type = 1564;
    var _tmp_298_type = 1565;
    var _tmp_299_type = 1566;
    var _tmp_300_type = 1567;
    function file_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var endmarker_var;
          if ((a = statements_rule(p), !p.error_indicator) && (endmarker_var = $B._PyPegen.expect_token(p, ENDMARKER))) {
            _res = $B._PyPegen.make_module(p, a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function interactive_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = statement_newline_rule(p)) {
            _res = new $B._PyAST.Interactive(a, p.arena);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function eval_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _loop0_1_var;
          var a;
          var endmarker_var;
          if ((a = expressions_rule(p)) && (_loop0_1_var = _loop0_1_rule(p)) && (endmarker_var = $B._PyPegen.expect_token(p, ENDMARKER))) {
            _res = new $B._PyAST.Expression(a, p.arena);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function func_type_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _literal_2;
          var _loop0_2_var;
          var a;
          var b;
          var endmarker_var;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (a = type_expressions_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8)) && (_literal_2 = $B._PyPegen.expect_token(p, 51)) && (b = expression_rule(p)) && (_loop0_2_var = _loop0_2_rule(p)) && (endmarker_var = $B._PyPegen.expect_token(p, ENDMARKER))) {
            _res = new $B._PyAST.FunctionType(a, b, p.arena);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function statements_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = _loop1_3_rule(p)) {
            _res = $B._PyPegen.seq_flatten(p, a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function statement_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = compound_stmt_rule(p)) {
            _res = $B._PyPegen.register_stmts(p, $B._PyPegen.singleton_seq(p, a));
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = simple_stmts_rule(p)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function single_compound_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = compound_stmt_rule(p)) {
            _res = $B._PyPegen.register_stmts(p, $B._PyPegen.singleton_seq(p, a));
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function statement_newline_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var newline_var;
          if ((a = single_compound_stmt_rule(p)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var simple_stmts_var;
          if (simple_stmts_var = simple_stmts_rule(p)) {
            _res = simple_stmts_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var newline_var;
          if (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B._PyPegen.singleton_seq(p, $B.helper_functions.CHECK($B.ast.stmt, new $B._PyAST.Pass(EXTRA2)));
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var endmarker_var;
          if (endmarker_var = $B._PyPegen.expect_token(p, ENDMARKER)) {
            _res = $B._PyPegen.interactive_exit(p);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function simple_stmts_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var newline_var;
          if ((a = simple_stmt_rule(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 13) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = $B._PyPegen.singleton_seq(p, a);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var newline_var;
          if ((a = _gather_4_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 13), !p.error_indicator) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function simple_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, simple_stmt_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var assignment_var;
          if (assignment_var = assignment_rule(p)) {
            _res = assignment_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var type_alias_var;
          if ($B._PyPegen.lookahead_with_string(1, $B._PyPegen.expect_soft_keyword, p, "type") && (type_alias_var = type_alias_rule(p))) {
            _res = type_alias_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var e;
          if (e = star_expressions_rule(p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Expr(e, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var return_stmt_var;
          if ($B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 522) && (return_stmt_var = return_stmt_rule(p))) {
            _res = return_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var import_stmt_var;
          if ($B._PyPegen.lookahead(1, _tmp_6_rule, p) && (import_stmt_var = import_stmt_rule(p))) {
            _res = import_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var raise_stmt_var;
          if ($B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 525) && (raise_stmt_var = raise_stmt_rule(p))) {
            _res = raise_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var pass_stmt_var;
          if ($B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 526) && (pass_stmt_var = pass_stmt_rule(p))) {
            _res = pass_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var del_stmt_var;
          if ($B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 625) && (del_stmt_var = del_stmt_rule(p))) {
            _res = del_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var yield_stmt_var;
          if ($B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 587) && (yield_stmt_var = yield_stmt_rule(p))) {
            _res = yield_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var assert_stmt_var;
          if ($B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 532) && (assert_stmt_var = assert_stmt_rule(p))) {
            _res = assert_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var break_stmt_var;
          if ($B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 527) && (break_stmt_var = break_stmt_rule(p))) {
            _res = break_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var continue_stmt_var;
          if ($B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 528) && (continue_stmt_var = continue_stmt_rule(p))) {
            _res = continue_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var global_stmt_var;
          if ($B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 529) && (global_stmt_var = global_stmt_rule(p))) {
            _res = global_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var nonlocal_stmt_var;
          if ($B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 530) && (nonlocal_stmt_var = nonlocal_stmt_rule(p))) {
            _res = nonlocal_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, simple_stmt_type, _res);
      return _res;
    }
    function compound_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var function_def_var;
          if ($B._PyPegen.lookahead(1, _tmp_7_rule, p) && (function_def_var = function_def_rule(p))) {
            _res = function_def_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var if_stmt_var;
          if ($B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 682) && (if_stmt_var = if_stmt_rule(p))) {
            _res = if_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var class_def_var;
          if ($B._PyPegen.lookahead(1, _tmp_8_rule, p) && (class_def_var = class_def_rule(p))) {
            _res = class_def_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var with_stmt_var;
          if ($B._PyPegen.lookahead(1, _tmp_9_rule, p) && (with_stmt_var = with_stmt_rule(p))) {
            _res = with_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var for_stmt_var;
          if ($B._PyPegen.lookahead(1, _tmp_10_rule, p) && (for_stmt_var = for_stmt_rule(p))) {
            _res = for_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var try_stmt_var;
          if ($B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 656) && (try_stmt_var = try_stmt_rule(p))) {
            _res = try_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var while_stmt_var;
          if ($B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 689) && (while_stmt_var = while_stmt_rule(p))) {
            _res = while_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var match_stmt_var;
          if (match_stmt_var = match_stmt_rule(p)) {
            _res = match_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function assignment_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          var c;
          if ((a = $B._PyPegen.name_token(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (b = expression_rule(p)) && (c = _tmp_11_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B.helper_functions.CHECK_VERSION($B.ast.stmt, 6, "Variable annotation syntax is", new $B._PyAST.AnnAssign($B.helper_functions.CHECK($B.ast.expr, $B._PyPegen.set_expr_context(p, a, $B.parser_constants.Store)), b, c, 1, EXTRA2));
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          var c;
          if ((a = _tmp_12_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (b = expression_rule(p)) && (c = _tmp_13_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B.helper_functions.CHECK_VERSION($B.ast.stmt, 6, "Variable annotations syntax is", new $B._PyAST.AnnAssign(a, b, c, 0, EXTRA2));
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          var tc;
          if ((a = _loop1_14_rule(p)) && (b = annotated_rhs_rule(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 22) && (tc = $B._PyPegen.expect_token(p, TYPE_COMMENT), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Assign(a, b, $B.helper_functions.NEW_TYPE_COMMENT(p, tc), EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _cut_var = 0;
          var a;
          var b;
          var c;
          if ((a = single_target_rule(p)) && (b = augassign_rule(p)) && (_cut_var = 1) && (c = annotated_rhs_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.AugAssign(a, b.kind, c, EXTRA2);
            break;
          }
          p.mark = _mark;
          if (_cut_var) {
            return NULL;
          }
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_assignment_var;
          if (invalid_assignment_var = invalid_assignment_rule(p)) {
            _res = invalid_assignment_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function annotated_rhs_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var yield_expr_var;
          if (yield_expr_var = yield_expr_rule(p)) {
            _res = yield_expr_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var star_expressions_var;
          if (star_expressions_var = star_expressions_rule(p)) {
            _res = star_expressions_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function augassign_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 36)) {
            _res = $B._PyPegen.augoperator(p, new $B.ast.Add());
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 37)) {
            _res = $B._PyPegen.augoperator(p, new $B.ast.Sub());
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 38)) {
            _res = $B._PyPegen.augoperator(p, new $B.ast.Mult());
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 50)) {
            _res = $B.helper_functions.CHECK_VERSION($B.parser_constants.AugOperator, 5, "The '@' operator is", $B._PyPegen.augoperator(p, new $B.ast.MatMult()));
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 39)) {
            _res = $B._PyPegen.augoperator(p, new $B.ast.Div());
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 40)) {
            _res = $B._PyPegen.augoperator(p, new $B.ast.Mod());
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 41)) {
            _res = $B._PyPegen.augoperator(p, new $B.ast.BitAnd());
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 42)) {
            _res = $B._PyPegen.augoperator(p, new $B.ast.BitOr());
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 43)) {
            _res = $B._PyPegen.augoperator(p, new $B.ast.BitXor());
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 44)) {
            _res = $B._PyPegen.augoperator(p, new $B.ast.LShift());
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 45)) {
            _res = $B._PyPegen.augoperator(p, new $B.ast.RShift());
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 46)) {
            _res = $B._PyPegen.augoperator(p, new $B.ast.Pow());
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 48)) {
            _res = $B._PyPegen.augoperator(p, new $B.ast.FloorDiv());
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function return_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          if ((_keyword = $B._PyPegen.expect_token(p, 522)) && (a = star_expressions_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Return(a, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function raise_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          var b;
          if ((_keyword = $B._PyPegen.expect_token(p, 525)) && (a = expression_rule(p)) && (b = _tmp_15_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Raise(a, b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 525)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Raise($B.parser_constants.NULL, $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function pass_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 526)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Pass(EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function break_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 527)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Break(EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function continue_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 528)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Continue(EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function global_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          if ((_keyword = $B._PyPegen.expect_token(p, 529)) && (a = _gather_16_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Global($B.helper_functions.CHECK($B.parser_constants.asdl_identifier_seq, $B._PyPegen.map_names_to_ids(p, a)), EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function nonlocal_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          if ((_keyword = $B._PyPegen.expect_token(p, 530)) && (a = _gather_18_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Nonlocal($B.helper_functions.CHECK($B.parser_constants.asdl_identifier_seq, $B._PyPegen.map_names_to_ids(p, a)), EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function del_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          if ((_keyword = $B._PyPegen.expect_token(p, 625)) && (a = del_targets_rule(p)) && $B._PyPegen.lookahead(1, _tmp_20_rule, p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Delete(a, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_del_stmt_var;
          if (invalid_del_stmt_var = invalid_del_stmt_rule(p)) {
            _res = invalid_del_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function yield_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var y;
          if (y = yield_expr_rule(p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Expr(y, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function assert_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          var b;
          if ((_keyword = $B._PyPegen.expect_token(p, 532)) && (a = expression_rule(p)) && (b = _tmp_21_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Assert(a, b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function import_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_import_var;
          if (invalid_import_var = invalid_import_rule(p)) {
            _res = invalid_import_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var import_name_var;
          if (import_name_var = import_name_rule(p)) {
            _res = import_name_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var import_from_var;
          if (import_from_var = import_from_rule(p)) {
            _res = import_from_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function import_name_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          if ((_keyword = $B._PyPegen.expect_token(p, 634)) && (a = dotted_as_names_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Import(a, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function import_from_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var a;
          var b;
          var c;
          if ((_keyword = $B._PyPegen.expect_token(p, 633)) && (a = _loop0_22_rule(p)) && (b = dotted_name_rule(p)) && (_keyword_1 = $B._PyPegen.expect_token(p, 634)) && (c = import_from_targets_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B._PyPegen.checked_future_import(p, b.id, c, $B._PyPegen.seq_count_dots(a), EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var a;
          var b;
          if ((_keyword = $B._PyPegen.expect_token(p, 633)) && (a = _loop1_23_rule(p)) && (_keyword_1 = $B._PyPegen.expect_token(p, 634)) && (b = import_from_targets_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.ImportFrom($B.parser_constants.NULL, b, $B._PyPegen.seq_count_dots(a), EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function import_from_targets_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (a = import_from_as_names_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var import_from_as_names_var;
          if ((import_from_as_names_var = import_from_as_names_rule(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 12)) {
            _res = import_from_as_names_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 16)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B._PyPegen.singleton_seq(p, $B.helper_functions.CHECK($B.ast.alias, $B._PyPegen.alias_for_star(p, EXTRA2)));
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_import_from_targets_var;
          if (invalid_import_from_targets_var = invalid_import_from_targets_rule(p)) {
            _res = invalid_import_from_targets_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function import_from_as_names_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = _gather_24_rule(p)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function import_from_as_name_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_import_from_as_name_var;
          if (invalid_import_from_as_name_var = invalid_import_from_as_name_rule(p)) {
            _res = invalid_import_from_as_name_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = $B._PyPegen.name_token(p)) && (b = _tmp_26_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.alias(a.id, b ? b.id : $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function dotted_as_names_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = _gather_27_rule(p)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function dotted_as_name_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_dotted_as_name_var;
          if (invalid_dotted_as_name_var = invalid_dotted_as_name_rule(p)) {
            _res = invalid_dotted_as_name_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = dotted_name_rule(p)) && (b = _tmp_29_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.alias(a.id, b ? b.id : $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function dotted_name_raw() {
    }
    function dotted_name_rule(p) {
      var _res = { value: NULL };
      if ($B._PyPegen.is_memoized(p, dotted_name_type, _res)) {
        return _res.value;
      }
      _res = NULL;
      var _mark = p.mark;
      var _resmark = p.mark;
      while (1) {
        var tmpvar_0 = $B._PyPegen.update_memo(p, _mark, dotted_name_type, _res);
        if (tmpvar_0) {
          return _res;
        }
        p.mark = _mark;
        var _raw = dotted_name_raw(p);
        if (p.error_indicator) {
          return NULL;
        }
        if (_raw == NULL || p.mark <= _resmark)
          break;
        _resmark = p.mark;
        _res = _raw;
      }
      p.mark = _resmark;
      return _res;
    }
    function dotted_name_raw(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = dotted_name_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 23)) && (b = $B._PyPegen.name_token(p))) {
            _res = $B._PyPegen.join_names_with_dot(p, a, b);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var name_var;
          if (name_var = $B._PyPegen.name_token(p)) {
            _res = name_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function block_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, block_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var dedent_var;
          var indent_var;
          var newline_var;
          if ((newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && (indent_var = $B._PyPegen.expect_token(p, INDENT)) && (a = statements_rule(p)) && (dedent_var = $B._PyPegen.expect_token(p, DEDENT))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var simple_stmts_var;
          if (simple_stmts_var = simple_stmts_rule(p)) {
            _res = simple_stmts_var;
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_block_var;
          if (invalid_block_var = invalid_block_rule(p)) {
            _res = invalid_block_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, block_type, _res);
      return _res;
    }
    function decorators_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = _loop1_30_rule(p)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function class_def_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = decorators_rule(p)) && (b = class_def_raw_rule(p))) {
            _res = $B._PyPegen.class_def_decorators(p, a, b);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var class_def_raw_var;
          if (class_def_raw_var = class_def_raw_rule(p)) {
            _res = class_def_raw_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function class_def_raw_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_class_def_raw_var;
          if (invalid_class_def_raw_var = invalid_class_def_raw_rule(p)) {
            _res = invalid_class_def_raw_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var a;
          var b;
          var c;
          var t;
          if ((_keyword = $B._PyPegen.expect_token(p, 701)) && (a = $B._PyPegen.name_token(p)) && (t = type_params_rule(p), !p.error_indicator) && (b = _tmp_31_rule(p), !p.error_indicator) && (_literal = $B._PyPegen.expect_token(p, 11)) && (c = block_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.ClassDef(a.id, b ? b.args : $B.parser_constants.NULL, b ? b.keywords : $B.parser_constants.NULL, c, $B.parser_constants.NULL, t, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function function_def_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var d;
          var f;
          if ((d = decorators_rule(p)) && (f = function_def_raw_rule(p))) {
            _res = $B._PyPegen.function_def_decorators(p, d, f);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var function_def_raw_var;
          if (function_def_raw_var = function_def_raw_rule(p)) {
            _res = function_def_raw_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function function_def_raw_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_def_raw_var;
          if (invalid_def_raw_var = invalid_def_raw_rule(p)) {
            _res = invalid_def_raw_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var _literal_1;
          var _literal_2;
          var a;
          var b;
          var n;
          var params;
          var t;
          var tc;
          if ((_keyword = $B._PyPegen.expect_token(p, 699)) && (n = $B._PyPegen.name_token(p)) && (t = type_params_rule(p), !p.error_indicator) && (_literal = $B._PyPegen.expect_token(p, 7)) && (params = params_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8)) && (a = _tmp_32_rule(p), !p.error_indicator) && (_literal_2 = $B._PyPegen.expect_token(p, 11)) && (tc = func_type_comment_rule(p), !p.error_indicator) && (b = block_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.FunctionDef(n.id, params ? params : $B.helper_functions.CHECK($B.ast.arguments, $B._PyPegen.empty_arguments(p)), b, $B.parser_constants.NULL, a, $B.helper_functions.NEW_TYPE_COMMENT(p, tc), t, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var _literal;
          var _literal_1;
          var _literal_2;
          var a;
          var b;
          var n;
          var params;
          var t;
          var tc;
          if ((_keyword = $B._PyPegen.expect_token(p, 698)) && (_keyword_1 = $B._PyPegen.expect_token(p, 699)) && (n = $B._PyPegen.name_token(p)) && (t = type_params_rule(p), !p.error_indicator) && (_literal = $B._PyPegen.expect_token(p, 7)) && (params = params_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8)) && (a = _tmp_33_rule(p), !p.error_indicator) && (_literal_2 = $B._PyPegen.expect_token(p, 11)) && (tc = func_type_comment_rule(p), !p.error_indicator) && (b = block_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B.helper_functions.CHECK_VERSION($B.ast.stmt, 5, "Async functions are", new $B._PyAST.AsyncFunctionDef(n.id, params ? params : $B.helper_functions.CHECK($B.ast.arguments, $B._PyPegen.empty_arguments(p)), b, $B.parser_constants.NULL, a, $B.helper_functions.NEW_TYPE_COMMENT(p, tc), t, EXTRA2));
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function params_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_parameters_var;
          if (invalid_parameters_var = invalid_parameters_rule(p)) {
            _res = invalid_parameters_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var parameters_var;
          if (parameters_var = parameters_rule(p)) {
            _res = parameters_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function parameters_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          var c;
          var d;
          if ((a = slash_no_default_rule(p)) && (b = _loop0_34_rule(p)) && (c = _loop0_35_rule(p)) && (d = star_etc_rule(p), !p.error_indicator)) {
            _res = $B.helper_functions.CHECK_VERSION($B.ast.arguments, 8, "Positional-only parameters are", $B._PyPegen.make_arguments(p, a, $B.parser_constants.NULL, b, c, d));
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          var c;
          if ((a = slash_with_default_rule(p)) && (b = _loop0_36_rule(p)) && (c = star_etc_rule(p), !p.error_indicator)) {
            _res = $B.helper_functions.CHECK_VERSION($B.ast.arguments, 8, "Positional-only parameters are", $B._PyPegen.make_arguments(p, $B.parser_constants.NULL, a, $B.parser_constants.NULL, b, c));
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          var c;
          if ((a = _loop1_37_rule(p)) && (b = _loop0_38_rule(p)) && (c = star_etc_rule(p), !p.error_indicator)) {
            _res = $B._PyPegen.make_arguments(p, $B.parser_constants.NULL, $B.parser_constants.NULL, a, b, c);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = _loop1_39_rule(p)) && (b = star_etc_rule(p), !p.error_indicator)) {
            _res = $B._PyPegen.make_arguments(p, $B.parser_constants.NULL, $B.parser_constants.NULL, $B.parser_constants.NULL, a, b);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = star_etc_rule(p)) {
            _res = $B._PyPegen.make_arguments(p, $B.parser_constants.NULL, $B.parser_constants.NULL, $B.parser_constants.NULL, $B.parser_constants.NULL, a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function slash_no_default_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          if ((a = _loop1_40_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 17)) && (_literal_1 = $B._PyPegen.expect_token(p, 12))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((a = _loop1_41_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 17)) && $B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 8)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function slash_with_default_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var b;
          if ((a = _loop0_42_rule(p)) && (b = _loop1_43_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 17)) && (_literal_1 = $B._PyPegen.expect_token(p, 12))) {
            _res = $B._PyPegen.slash_with_default(p, a, b);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = _loop0_44_rule(p)) && (b = _loop1_45_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 17)) && $B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 8)) {
            _res = $B._PyPegen.slash_with_default(p, a, b);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function star_etc_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_star_etc_var;
          if (invalid_star_etc_var = invalid_star_etc_rule(p)) {
            _res = invalid_star_etc_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          var c;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (a = param_no_default_rule(p)) && (b = _loop0_46_rule(p)) && (c = kwds_rule(p), !p.error_indicator)) {
            _res = $B._PyPegen.star_etc(p, a, b, c);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          var c;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (a = param_no_default_star_annotation_rule(p)) && (b = _loop0_47_rule(p)) && (c = kwds_rule(p), !p.error_indicator)) {
            _res = $B._PyPegen.star_etc(p, a, b, c);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var b;
          var c;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (_literal_1 = $B._PyPegen.expect_token(p, 12)) && (b = _loop1_48_rule(p)) && (c = kwds_rule(p), !p.error_indicator)) {
            _res = $B._PyPegen.star_etc(p, $B.parser_constants.NULL, b, c);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = kwds_rule(p)) {
            _res = $B._PyPegen.star_etc(p, $B.parser_constants.NULL, $B.parser_constants.NULL, a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function kwds_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_kwds_var;
          if (invalid_kwds_var = invalid_kwds_rule(p)) {
            _res = invalid_kwds_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 35)) && (a = param_no_default_rule(p))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function param_no_default_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var tc;
          if ((a = param_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (tc = $B._PyPegen.expect_token(p, TYPE_COMMENT), !p.error_indicator)) {
            _res = $B._PyPegen.add_type_comment_to_arg(p, a, tc);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var tc;
          if ((a = param_rule(p)) && (tc = $B._PyPegen.expect_token(p, TYPE_COMMENT), !p.error_indicator) && $B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 8)) {
            _res = $B._PyPegen.add_type_comment_to_arg(p, a, tc);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function param_no_default_star_annotation_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var tc;
          if ((a = param_star_annotation_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (tc = $B._PyPegen.expect_token(p, TYPE_COMMENT), !p.error_indicator)) {
            _res = $B._PyPegen.add_type_comment_to_arg(p, a, tc);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var tc;
          if ((a = param_star_annotation_rule(p)) && (tc = $B._PyPegen.expect_token(p, TYPE_COMMENT), !p.error_indicator) && $B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 8)) {
            _res = $B._PyPegen.add_type_comment_to_arg(p, a, tc);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function param_with_default_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var c;
          var tc;
          if ((a = param_rule(p)) && (c = default_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (tc = $B._PyPegen.expect_token(p, TYPE_COMMENT), !p.error_indicator)) {
            _res = $B._PyPegen.name_default_pair(p, a, c, tc);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var c;
          var tc;
          if ((a = param_rule(p)) && (c = default_rule(p)) && (tc = $B._PyPegen.expect_token(p, TYPE_COMMENT), !p.error_indicator) && $B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 8)) {
            _res = $B._PyPegen.name_default_pair(p, a, c, tc);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function param_maybe_default_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var c;
          var tc;
          if ((a = param_rule(p)) && (c = default_rule(p), !p.error_indicator) && (_literal = $B._PyPegen.expect_token(p, 12)) && (tc = $B._PyPegen.expect_token(p, TYPE_COMMENT), !p.error_indicator)) {
            _res = $B._PyPegen.name_default_pair(p, a, c, tc);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var c;
          var tc;
          if ((a = param_rule(p)) && (c = default_rule(p), !p.error_indicator) && (tc = $B._PyPegen.expect_token(p, TYPE_COMMENT), !p.error_indicator) && $B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 8)) {
            _res = $B._PyPegen.name_default_pair(p, a, c, tc);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function param_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = $B._PyPegen.name_token(p)) && (b = annotation_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.arg(a.id, b, $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function param_star_annotation_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = $B._PyPegen.name_token(p)) && (b = star_annotation_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.arg(a.id, b, $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function annotation_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 11)) && (a = expression_rule(p))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function star_annotation_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 11)) && (a = star_expression_rule(p))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function default_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 22)) && (a = expression_rule(p))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_default_var;
          if (invalid_default_var = invalid_default_rule(p)) {
            _res = invalid_default_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function if_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_if_stmt_var;
          if (invalid_if_stmt_var = invalid_if_stmt_rule(p)) {
            _res = invalid_if_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var a;
          var b;
          var c;
          if ((_keyword = $B._PyPegen.expect_token(p, 682)) && (a = named_expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (b = block_rule(p)) && (c = elif_stmt_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.If(a, b, $B.helper_functions.CHECK($B.parser_constants.asdl_stmt_seq, $B._PyPegen.singleton_seq(p, c)), EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var a;
          var b;
          var c;
          if ((_keyword = $B._PyPegen.expect_token(p, 682)) && (a = named_expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (b = block_rule(p)) && (c = else_block_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.If(a, b, c, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function elif_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_elif_stmt_var;
          if (invalid_elif_stmt_var = invalid_elif_stmt_rule(p)) {
            _res = invalid_elif_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var a;
          var b;
          var c;
          if ((_keyword = $B._PyPegen.expect_token(p, 687)) && (a = named_expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (b = block_rule(p)) && (c = elif_stmt_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.If(a, b, $B.helper_functions.CHECK($B.parser_constants.asdl_stmt_seq, $B._PyPegen.singleton_seq(p, c)), EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var a;
          var b;
          var c;
          if ((_keyword = $B._PyPegen.expect_token(p, 687)) && (a = named_expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (b = block_rule(p)) && (c = else_block_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.If(a, b, c, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function else_block_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_else_stmt_var;
          if (invalid_else_stmt_var = invalid_else_stmt_rule(p)) {
            _res = invalid_else_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var b;
          if ((_keyword = $B._PyPegen.expect_token(p, 686)) && (_literal = $B._PyPegen.expect_forced_token(p, 11, ":")) && (b = block_rule(p))) {
            _res = b;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function while_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_while_stmt_var;
          if (invalid_while_stmt_var = invalid_while_stmt_rule(p)) {
            _res = invalid_while_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var a;
          var b;
          var c;
          if ((_keyword = $B._PyPegen.expect_token(p, 689)) && (a = named_expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (b = block_rule(p)) && (c = else_block_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.While(a, b, c, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function for_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_for_stmt_var;
          if (invalid_for_stmt_var = invalid_for_stmt_rule(p)) {
            _res = invalid_for_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _cut_var = 0;
          var _keyword;
          var _keyword_1;
          var _literal;
          var b;
          var el;
          var ex;
          var t;
          var tc;
          if ((_keyword = $B._PyPegen.expect_token(p, 694)) && (t = star_targets_rule(p)) && (_keyword_1 = $B._PyPegen.expect_token(p, 695)) && (_cut_var = 1) && (ex = star_expressions_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (tc = $B._PyPegen.expect_token(p, TYPE_COMMENT), !p.error_indicator) && (b = block_rule(p)) && (el = else_block_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.For(t, ex, b, el, $B.helper_functions.NEW_TYPE_COMMENT(p, tc), EXTRA2);
            break;
          }
          p.mark = _mark;
          if (_cut_var) {
            return NULL;
          }
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _cut_var = 0;
          var _keyword;
          var _keyword_1;
          var _keyword_2;
          var _literal;
          var b;
          var el;
          var ex;
          var t;
          var tc;
          if ((_keyword = $B._PyPegen.expect_token(p, 698)) && (_keyword_1 = $B._PyPegen.expect_token(p, 694)) && (t = star_targets_rule(p)) && (_keyword_2 = $B._PyPegen.expect_token(p, 695)) && (_cut_var = 1) && (ex = star_expressions_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (tc = $B._PyPegen.expect_token(p, TYPE_COMMENT), !p.error_indicator) && (b = block_rule(p)) && (el = else_block_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B.helper_functions.CHECK_VERSION($B.ast.stmt, 5, "Async for loops are", new $B._PyAST.AsyncFor(t, ex, b, el, $B.helper_functions.NEW_TYPE_COMMENT(p, tc), EXTRA2));
            break;
          }
          p.mark = _mark;
          if (_cut_var) {
            return NULL;
          }
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_for_target_var;
          if (invalid_for_target_var = invalid_for_target_rule(p)) {
            _res = invalid_for_target_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function with_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_with_stmt_indent_var;
          if (invalid_with_stmt_indent_var = invalid_with_stmt_indent_rule(p)) {
            _res = invalid_with_stmt_indent_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var _literal_1;
          var _literal_2;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var b;
          var tc;
          if ((_keyword = $B._PyPegen.expect_token(p, 647)) && (_literal = $B._PyPegen.expect_token(p, 7)) && (a = _gather_49_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8)) && (_literal_2 = $B._PyPegen.expect_token(p, 11)) && (tc = $B._PyPegen.expect_token(p, TYPE_COMMENT), !p.error_indicator) && (b = block_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.With(a, b, $B.helper_functions.NEW_TYPE_COMMENT(p, tc), EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var a;
          var b;
          var tc;
          if ((_keyword = $B._PyPegen.expect_token(p, 647)) && (a = _gather_51_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (tc = $B._PyPegen.expect_token(p, TYPE_COMMENT), !p.error_indicator) && (b = block_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.With(a, b, $B.helper_functions.NEW_TYPE_COMMENT(p, tc), EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var _literal;
          var _literal_1;
          var _literal_2;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var b;
          if ((_keyword = $B._PyPegen.expect_token(p, 698)) && (_keyword_1 = $B._PyPegen.expect_token(p, 647)) && (_literal = $B._PyPegen.expect_token(p, 7)) && (a = _gather_53_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8)) && (_literal_2 = $B._PyPegen.expect_token(p, 11)) && (b = block_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B.helper_functions.CHECK_VERSION($B.ast.stmt, 5, "Async with statements are", new $B._PyAST.AsyncWith(a, b, $B.parser_constants.NULL, EXTRA2));
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var _literal;
          var a;
          var b;
          var tc;
          if ((_keyword = $B._PyPegen.expect_token(p, 698)) && (_keyword_1 = $B._PyPegen.expect_token(p, 647)) && (a = _gather_55_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (tc = $B._PyPegen.expect_token(p, TYPE_COMMENT), !p.error_indicator) && (b = block_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B.helper_functions.CHECK_VERSION($B.ast.stmt, 5, "Async with statements are", new $B._PyAST.AsyncWith(a, b, $B.helper_functions.NEW_TYPE_COMMENT(p, tc), EXTRA2));
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_with_stmt_var;
          if (invalid_with_stmt_var = invalid_with_stmt_rule(p)) {
            _res = invalid_with_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function with_item_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var e;
          var t;
          if ((e = expression_rule(p)) && (_keyword = $B._PyPegen.expect_token(p, 680)) && (t = star_target_rule(p)) && $B._PyPegen.lookahead(1, _tmp_57_rule, p)) {
            _res = new $B._PyAST.withitem(e, t, p.arena);
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_with_item_var;
          if (invalid_with_item_var = invalid_with_item_rule(p)) {
            _res = invalid_with_item_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var e;
          if (e = expression_rule(p)) {
            _res = new $B._PyAST.withitem(e, $B.parser_constants.NULL, p.arena);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function try_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_try_stmt_var;
          if (invalid_try_stmt_var = invalid_try_stmt_rule(p)) {
            _res = invalid_try_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var b;
          var f;
          if ((_keyword = $B._PyPegen.expect_token(p, 656)) && (_literal = $B._PyPegen.expect_forced_token(p, 11, ":")) && (b = block_rule(p)) && (f = finally_block_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Try(b, $B.parser_constants.NULL, $B.parser_constants.NULL, f, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var b;
          var el;
          var ex;
          var f;
          if ((_keyword = $B._PyPegen.expect_token(p, 656)) && (_literal = $B._PyPegen.expect_forced_token(p, 11, ":")) && (b = block_rule(p)) && (ex = _loop1_58_rule(p)) && (el = else_block_rule(p), !p.error_indicator) && (f = finally_block_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Try(b, ex, el, f, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var b;
          var el;
          var ex;
          var f;
          if ((_keyword = $B._PyPegen.expect_token(p, 656)) && (_literal = $B._PyPegen.expect_forced_token(p, 11, ":")) && (b = block_rule(p)) && (ex = _loop1_59_rule(p)) && (el = else_block_rule(p), !p.error_indicator) && (f = finally_block_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B.helper_functions.CHECK_VERSION($B.ast.stmt, 11, "Exception groups are", new $B._PyAST.TryStar(b, ex, el, f, EXTRA2));
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function except_block_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_except_stmt_indent_var;
          if (invalid_except_stmt_indent_var = invalid_except_stmt_indent_rule(p)) {
            _res = invalid_except_stmt_indent_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var b;
          var e;
          if ((_keyword = $B._PyPegen.expect_token(p, 677)) && (e = expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (b = block_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.ExceptHandler(e, $B.parser_constants.NULL, b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var _literal;
          var b;
          var e;
          var t;
          if ((_keyword = $B._PyPegen.expect_token(p, 677)) && (e = expression_rule(p)) && (_keyword_1 = $B._PyPegen.expect_token(p, 680)) && (t = $B._PyPegen.name_token(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (b = block_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.ExceptHandler(e, t.id, b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var b;
          var e;
          if ((_keyword = $B._PyPegen.expect_token(p, 677)) && (e = expressions_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (b = block_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B.helper_functions.CHECK_VERSION($B.ast.excepthandler, 14, "except expressions without parentheses are", new $B._PyAST.ExceptHandler(e, $B.parser_constants.NULL, b, EXTRA2));
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var b;
          if ((_keyword = $B._PyPegen.expect_token(p, 677)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (b = block_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.ExceptHandler($B.parser_constants.NULL, $B.parser_constants.NULL, b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_except_stmt_var;
          if (invalid_except_stmt_var = invalid_except_stmt_rule(p)) {
            _res = invalid_except_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function except_star_block_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_except_star_stmt_indent_var;
          if (invalid_except_star_stmt_indent_var = invalid_except_star_stmt_indent_rule(p)) {
            _res = invalid_except_star_stmt_indent_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var _literal_1;
          var b;
          var e;
          if ((_keyword = $B._PyPegen.expect_token(p, 677)) && (_literal = $B._PyPegen.expect_token(p, 16)) && (e = expression_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 11)) && (b = block_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.ExceptHandler(e, $B.parser_constants.NULL, b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var _literal;
          var _literal_1;
          var b;
          var e;
          var t;
          if ((_keyword = $B._PyPegen.expect_token(p, 677)) && (_literal = $B._PyPegen.expect_token(p, 16)) && (e = expression_rule(p)) && (_keyword_1 = $B._PyPegen.expect_token(p, 680)) && (t = $B._PyPegen.name_token(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 11)) && (b = block_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.ExceptHandler(e, t.id, b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var _literal_1;
          var b;
          var e;
          if ((_keyword = $B._PyPegen.expect_token(p, 677)) && (_literal = $B._PyPegen.expect_token(p, 16)) && (e = expressions_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 11)) && (b = block_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B.helper_functions.CHECK_VERSION($B.ast.excepthandler, 14, "except expressions without parentheses are", new $B._PyAST.ExceptHandler(e, $B.parser_constants.NULL, b, EXTRA2));
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_except_star_stmt_var;
          if (invalid_except_star_stmt_var = invalid_except_star_stmt_rule(p)) {
            _res = invalid_except_star_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function finally_block_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_finally_stmt_var;
          if (invalid_finally_stmt_var = invalid_finally_stmt_rule(p)) {
            _res = invalid_finally_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var a;
          if ((_keyword = $B._PyPegen.expect_token(p, 673)) && (_literal = $B._PyPegen.expect_forced_token(p, 11, ":")) && (a = block_rule(p))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function match_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var cases;
          var dedent_var;
          var indent_var;
          var newline_var;
          var subject;
          if ((_keyword = $B._PyPegen.expect_soft_keyword(p, "match")) && (subject = subject_expr_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && (indent_var = $B._PyPegen.expect_token(p, INDENT)) && (cases = _loop1_60_rule(p)) && (dedent_var = $B._PyPegen.expect_token(p, DEDENT))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B.helper_functions.CHECK_VERSION($B.ast.stmt, 10, "Pattern matching is", new $B._PyAST.Match(subject, cases, EXTRA2));
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_match_stmt_var;
          if (invalid_match_stmt_var = invalid_match_stmt_rule(p)) {
            _res = invalid_match_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function subject_expr_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var value2;
          var values;
          if ((value2 = star_named_expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (values = star_named_expressions_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Tuple($B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.seq_insert_in_front(p, value2, values)), $B.parser_constants.Load, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var named_expression_var;
          if (named_expression_var = named_expression_rule(p)) {
            _res = named_expression_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function case_block_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_case_block_var;
          if (invalid_case_block_var = invalid_case_block_rule(p)) {
            _res = invalid_case_block_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var body;
          var guard;
          var pattern;
          if ((_keyword = $B._PyPegen.expect_soft_keyword(p, "case")) && (pattern = patterns_rule(p)) && (guard = guard_rule(p), !p.error_indicator) && (_literal = $B._PyPegen.expect_token(p, 11)) && (body = block_rule(p))) {
            _res = new $B._PyAST.match_case(pattern, guard, body, p.arena);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function guard_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var guard;
          if ((_keyword = $B._PyPegen.expect_token(p, 682)) && (guard = named_expression_rule(p))) {
            _res = guard;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function patterns_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var patterns;
          if (patterns = open_sequence_pattern_rule(p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchSequence(patterns, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var pattern_var;
          if (pattern_var = pattern_rule(p)) {
            _res = pattern_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var as_pattern_var;
          if (as_pattern_var = as_pattern_rule(p)) {
            _res = as_pattern_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var or_pattern_var;
          if (or_pattern_var = or_pattern_rule(p)) {
            _res = or_pattern_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function as_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var pattern;
          var target;
          if ((pattern = or_pattern_rule(p)) && (_keyword = $B._PyPegen.expect_token(p, 680)) && (target = pattern_capture_target_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchAs(pattern, target.id, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_as_pattern_var;
          if (invalid_as_pattern_var = invalid_as_pattern_rule(p)) {
            _res = invalid_as_pattern_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function or_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var patterns;
          if (patterns = _gather_61_rule(p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B.helper_functions.asdl_seq_LEN(patterns) == 1 ? $B.helper_functions.asdl_seq_GET(patterns, 0) : new $B._PyAST.MatchOr(patterns, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function closed_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, closed_pattern_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var literal_pattern_var;
          if (literal_pattern_var = literal_pattern_rule(p)) {
            _res = literal_pattern_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var capture_pattern_var;
          if (capture_pattern_var = capture_pattern_rule(p)) {
            _res = capture_pattern_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var wildcard_pattern_var;
          if (wildcard_pattern_var = wildcard_pattern_rule(p)) {
            _res = wildcard_pattern_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var value_pattern_var;
          if (value_pattern_var = value_pattern_rule(p)) {
            _res = value_pattern_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var group_pattern_var;
          if (group_pattern_var = group_pattern_rule(p)) {
            _res = group_pattern_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var sequence_pattern_var;
          if (sequence_pattern_var = sequence_pattern_rule(p)) {
            _res = sequence_pattern_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var mapping_pattern_var;
          if (mapping_pattern_var = mapping_pattern_rule(p)) {
            _res = mapping_pattern_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var class_pattern_var;
          if (class_pattern_var = class_pattern_rule(p)) {
            _res = class_pattern_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, closed_pattern_type, _res);
      return _res;
    }
    function literal_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var value2;
          if ((value2 = signed_number_rule(p)) && $B._PyPegen.lookahead(0, _tmp_63_rule, p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchValue(value2, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var value2;
          if (value2 = complex_number_rule(p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchValue(value2, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var value2;
          if (value2 = strings_rule(p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchValue(value2, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 623)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchSingleton($B.parser_constants.Py_None, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 622)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchSingleton($B.parser_constants.Py_True, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 624)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchSingleton($B.parser_constants.Py_False, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function literal_expr_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var signed_number_var;
          if ((signed_number_var = signed_number_rule(p)) && $B._PyPegen.lookahead(0, _tmp_64_rule, p)) {
            _res = signed_number_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var complex_number_var;
          if (complex_number_var = complex_number_rule(p)) {
            _res = complex_number_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var strings_var;
          if ($B._PyPegen.lookahead(1, _tmp_65_rule, p) && (strings_var = strings_rule(p))) {
            _res = strings_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 623)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Constant($B.parser_constants.Py_None, $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 622)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Constant($B.parser_constants.Py_True, $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 624)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Constant($B.parser_constants.Py_False, $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function complex_number_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var imag;
          var real;
          if ((real = signed_real_number_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 14)) && (imag = imaginary_number_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.BinOp(real, new $B.ast.Add(), imag, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var imag;
          var real;
          if ((real = signed_real_number_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 15)) && (imag = imaginary_number_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.BinOp(real, new $B.ast.Sub(), imag, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function signed_number_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var number_var;
          if (number_var = $B._PyPegen.number_token(p)) {
            _res = number_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var number;
          if ((_literal = $B._PyPegen.expect_token(p, 15)) && (number = $B._PyPegen.number_token(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.UnaryOp(new $B.ast.USub(), number, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function signed_real_number_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var real_number_var;
          if (real_number_var = real_number_rule(p)) {
            _res = real_number_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var real;
          if ((_literal = $B._PyPegen.expect_token(p, 15)) && (real = real_number_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.UnaryOp(new $B.ast.USub(), real, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function real_number_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var real;
          if (real = $B._PyPegen.number_token(p)) {
            _res = $B._PyPegen.ensure_real(p, real);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function imaginary_number_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var imag;
          if (imag = $B._PyPegen.number_token(p)) {
            _res = $B._PyPegen.ensure_imaginary(p, imag);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function capture_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var target;
          if (target = pattern_capture_target_rule(p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchAs($B.parser_constants.NULL, target.id, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function pattern_capture_target_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var name2;
          if ($B._PyPegen.lookahead_with_string(0, $B._PyPegen.expect_soft_keyword, p, "_") && (name2 = $B._PyPegen.name_token(p)) && $B._PyPegen.lookahead(0, _tmp_66_rule, p)) {
            _res = $B._PyPegen.set_expr_context(p, name2, $B.parser_constants.Store);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function wildcard_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_soft_keyword(p, "_")) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchAs($B.parser_constants.NULL, $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function value_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var attr;
          if ((attr = attr_rule(p)) && $B._PyPegen.lookahead(0, _tmp_67_rule, p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchValue(attr, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function attr_raw() {
    }
    function attr_rule(p) {
      var _res = { value: NULL };
      if ($B._PyPegen.is_memoized(p, attr_type, _res)) {
        return _res.value;
      }
      _res = NULL;
      var _mark = p.mark;
      var _resmark = p.mark;
      while (1) {
        var tmpvar_1 = $B._PyPegen.update_memo(p, _mark, attr_type, _res);
        if (tmpvar_1) {
          return _res;
        }
        p.mark = _mark;
        var _raw = attr_raw(p);
        if (p.error_indicator) {
          return NULL;
        }
        if (_raw == NULL || p.mark <= _resmark)
          break;
        _resmark = p.mark;
        _res = _raw;
      }
      p.mark = _resmark;
      return _res;
    }
    function attr_raw(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var attr;
          var value2;
          if ((value2 = name_or_attr_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 23)) && (attr = $B._PyPegen.name_token(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Attribute(value2, attr.id, $B.parser_constants.Load, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function name_or_attr_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var attr_var;
          if (attr_var = attr_rule(p)) {
            _res = attr_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var name_var;
          if (name_var = $B._PyPegen.name_token(p)) {
            _res = name_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function group_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var pattern;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (pattern = pattern_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            _res = pattern;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function sequence_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var patterns;
          if ((_literal = $B._PyPegen.expect_token(p, 9)) && (patterns = maybe_sequence_pattern_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 10))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchSequence(patterns, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var patterns;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (patterns = open_sequence_pattern_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchSequence(patterns, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function open_sequence_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var pattern;
          var patterns;
          if ((pattern = maybe_star_pattern_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (patterns = maybe_sequence_pattern_rule(p), !p.error_indicator)) {
            _res = $B._PyPegen.seq_insert_in_front(p, pattern, patterns);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function maybe_sequence_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var patterns;
          if ((patterns = _gather_68_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator)) {
            _res = patterns;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function maybe_star_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var star_pattern_var;
          if (star_pattern_var = star_pattern_rule(p)) {
            _res = star_pattern_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var pattern_var;
          if (pattern_var = pattern_rule(p)) {
            _res = pattern_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function star_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, star_pattern_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var target;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (target = pattern_capture_target_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchStar(target.id, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var wildcard_pattern_var;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (wildcard_pattern_var = wildcard_pattern_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchStar($B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, star_pattern_type, _res);
      return _res;
    }
    function mapping_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (_literal_1 = $B._PyPegen.expect_token(p, 26))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchMapping($B.parser_constants.NULL, $B.parser_constants.NULL, $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _opt_var;
          UNUSED(_opt_var);
          var rest;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (rest = double_star_pattern_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 26))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchMapping($B.parser_constants.NULL, $B.parser_constants.NULL, rest.id, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _literal_2;
          var _opt_var;
          UNUSED(_opt_var);
          var items;
          var rest;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (items = items_pattern_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 12)) && (rest = double_star_pattern_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator) && (_literal_2 = $B._PyPegen.expect_token(p, 26))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchMapping($B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.get_pattern_keys(p, items)), $B.helper_functions.CHECK($B.parser_constants.asdl_pattern_seq, $B._PyPegen.get_patterns(p, items)), rest.id, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _opt_var;
          UNUSED(_opt_var);
          var items;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (items = items_pattern_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 26))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchMapping($B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.get_pattern_keys(p, items)), $B.helper_functions.CHECK($B.parser_constants.asdl_pattern_seq, $B._PyPegen.get_patterns(p, items)), $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function items_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _gather_70_var;
          if (_gather_70_var = _gather_70_rule(p)) {
            _res = _gather_70_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function key_value_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var key2;
          var pattern;
          if ((key2 = _tmp_72_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (pattern = pattern_rule(p))) {
            _res = $B._PyPegen.key_pattern_pair(p, key2, pattern);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function double_star_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var target;
          if ((_literal = $B._PyPegen.expect_token(p, 35)) && (target = pattern_capture_target_rule(p))) {
            _res = target;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function class_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var cls;
          if ((cls = name_or_attr_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 7)) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchClass(cls, $B.parser_constants.NULL, $B.parser_constants.NULL, $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _opt_var;
          UNUSED(_opt_var);
          var cls;
          var patterns;
          if ((cls = name_or_attr_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 7)) && (patterns = positional_patterns_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchClass(cls, patterns, $B.parser_constants.NULL, $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _opt_var;
          UNUSED(_opt_var);
          var cls;
          var keywords;
          if ((cls = name_or_attr_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 7)) && (keywords = keyword_patterns_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchClass(cls, $B.parser_constants.NULL, $B.helper_functions.CHECK($B.parser_constants.asdl_identifier_seq, $B._PyPegen.map_names_to_ids(p, $B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.get_pattern_keys(p, keywords)))), $B.helper_functions.CHECK($B.parser_constants.asdl_pattern_seq, $B._PyPegen.get_patterns(p, keywords)), EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _literal_2;
          var _opt_var;
          UNUSED(_opt_var);
          var cls;
          var keywords;
          var patterns;
          if ((cls = name_or_attr_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 7)) && (patterns = positional_patterns_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 12)) && (keywords = keyword_patterns_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator) && (_literal_2 = $B._PyPegen.expect_token(p, 8))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.MatchClass(cls, patterns, $B.helper_functions.CHECK($B.parser_constants.asdl_identifier_seq, $B._PyPegen.map_names_to_ids(p, $B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.get_pattern_keys(p, keywords)))), $B.helper_functions.CHECK($B.parser_constants.asdl_pattern_seq, $B._PyPegen.get_patterns(p, keywords)), EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_class_pattern_var;
          if (invalid_class_pattern_var = invalid_class_pattern_rule(p)) {
            _res = invalid_class_pattern_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function positional_patterns_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var args;
          if (args = _gather_73_rule(p)) {
            _res = args;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function keyword_patterns_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _gather_75_var;
          if (_gather_75_var = _gather_75_rule(p)) {
            _res = _gather_75_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function keyword_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var arg;
          var value2;
          if ((arg = $B._PyPegen.name_token(p)) && (_literal = $B._PyPegen.expect_token(p, 22)) && (value2 = pattern_rule(p))) {
            _res = $B._PyPegen.key_pattern_pair(p, arg, value2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function type_alias_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var b;
          var n;
          var t;
          if ((_keyword = $B._PyPegen.expect_soft_keyword(p, "type")) && (n = $B._PyPegen.name_token(p)) && (t = type_params_rule(p), !p.error_indicator) && (_literal = $B._PyPegen.expect_token(p, 22)) && (b = expression_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B.helper_functions.CHECK_VERSION($B.ast.stmt, 12, "Type statement is", new $B._PyAST.TypeAlias($B.helper_functions.CHECK($B.ast.expr, $B._PyPegen.set_expr_context(p, n, $B.parser_constants.Store)), t, b, EXTRA2));
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function type_params_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_type_params_var;
          if (invalid_type_params_var = invalid_type_params_rule(p)) {
            _res = invalid_type_params_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var t;
          if ((_literal = $B._PyPegen.expect_token(p, 9)) && (t = type_param_seq_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 10))) {
            _res = $B.helper_functions.CHECK_VERSION($B.parser_constants.asdl_type_param_seq, 12, "Type parameter lists are", t);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function type_param_seq_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          if ((a = _gather_77_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function type_param_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, type_param_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          var c;
          if ((a = $B._PyPegen.name_token(p)) && (b = type_param_bound_rule(p), !p.error_indicator) && (c = type_param_default_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.TypeVar(a.id, b, c, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_type_param_var;
          if (invalid_type_param_var = invalid_type_param_rule(p)) {
            _res = invalid_type_param_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (a = $B._PyPegen.name_token(p)) && (b = type_param_starred_default_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.TypeVarTuple(a.id, b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((_literal = $B._PyPegen.expect_token(p, 35)) && (a = $B._PyPegen.name_token(p)) && (b = type_param_default_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.ParamSpec(a.id, b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, type_param_type, _res);
      return _res;
    }
    function type_param_bound_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var e;
          if ((_literal = $B._PyPegen.expect_token(p, 11)) && (e = expression_rule(p))) {
            _res = e;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function type_param_default_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var e;
          if ((_literal = $B._PyPegen.expect_token(p, 22)) && (e = expression_rule(p))) {
            _res = $B.helper_functions.CHECK_VERSION($B.ast.expr, 13, "Type parameter defaults are", e);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function type_param_starred_default_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var e;
          if ((_literal = $B._PyPegen.expect_token(p, 22)) && (e = star_expression_rule(p))) {
            _res = $B.helper_functions.CHECK_VERSION($B.ast.expr, 13, "Type parameter defaults are", e);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function expressions_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var b;
          if ((a = expression_rule(p)) && (b = _loop1_79_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Tuple($B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.seq_insert_in_front(p, a, b)), $B.parser_constants.Load, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((a = expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Tuple($B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.singleton_seq(p, a)), $B.parser_constants.Load, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var expression_var;
          if (expression_var = expression_rule(p)) {
            _res = expression_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function expression_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, expression_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_expression_var;
          if (invalid_expression_var = invalid_expression_rule(p)) {
            _res = invalid_expression_var;
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_legacy_expression_var;
          if (invalid_legacy_expression_var = invalid_legacy_expression_rule(p)) {
            _res = invalid_legacy_expression_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var a;
          var b;
          var c;
          if ((a = disjunction_rule(p)) && (_keyword = $B._PyPegen.expect_token(p, 682)) && (b = disjunction_rule(p)) && (_keyword_1 = $B._PyPegen.expect_token(p, 686)) && (c = expression_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.IfExp(b, a, c, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var disjunction_var;
          if (disjunction_var = disjunction_rule(p)) {
            _res = disjunction_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var lambdef_var;
          if (lambdef_var = lambdef_rule(p)) {
            _res = lambdef_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, expression_type, _res);
      return _res;
    }
    function yield_expr_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var a;
          if ((_keyword = $B._PyPegen.expect_token(p, 587)) && (_keyword_1 = $B._PyPegen.expect_token(p, 633)) && (a = expression_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.YieldFrom(a, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          if ((_keyword = $B._PyPegen.expect_token(p, 587)) && (a = star_expressions_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Yield(a, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function star_expressions_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var b;
          if ((a = star_expression_rule(p)) && (b = _loop1_80_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Tuple($B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.seq_insert_in_front(p, a, b)), $B.parser_constants.Load, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((a = star_expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Tuple($B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.singleton_seq(p, a)), $B.parser_constants.Load, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var star_expression_var;
          if (star_expression_var = star_expression_rule(p)) {
            _res = star_expression_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function star_expression_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, star_expression_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (a = bitwise_or_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Starred(a, $B.parser_constants.Load, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var expression_var;
          if (expression_var = expression_rule(p)) {
            _res = expression_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, star_expression_type, _res);
      return _res;
    }
    function star_named_expressions_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          if ((a = _gather_81_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function star_named_expression_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (a = bitwise_or_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Starred(a, $B.parser_constants.Load, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var named_expression_var;
          if (named_expression_var = named_expression_rule(p)) {
            _res = named_expression_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function assignment_expression_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _cut_var = 0;
          var _literal;
          var a;
          var b;
          if ((a = $B._PyPegen.name_token(p)) && (_literal = $B._PyPegen.expect_token(p, 53)) && (_cut_var = 1) && (b = expression_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B.helper_functions.CHECK_VERSION($B.ast.expr, 8, "Assignment expressions are", new $B._PyAST.NamedExpr($B.helper_functions.CHECK($B.ast.expr, $B._PyPegen.set_expr_context(p, a, $B.parser_constants.Store)), b, EXTRA2));
            break;
          }
          p.mark = _mark;
          if (_cut_var) {
            return NULL;
          }
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function named_expression_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var assignment_expression_var;
          if (assignment_expression_var = assignment_expression_rule(p)) {
            _res = assignment_expression_var;
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_named_expression_var;
          if (invalid_named_expression_var = invalid_named_expression_rule(p)) {
            _res = invalid_named_expression_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var expression_var;
          if ((expression_var = expression_rule(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 53)) {
            _res = expression_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function disjunction_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, disjunction_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = conjunction_rule(p)) && (b = _loop1_83_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.BoolOp(new $B.ast.Or(), $B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.seq_insert_in_front(p, a, b)), EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var conjunction_var;
          if (conjunction_var = conjunction_rule(p)) {
            _res = conjunction_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, disjunction_type, _res);
      return _res;
    }
    function conjunction_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, conjunction_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = inversion_rule(p)) && (b = _loop1_84_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.BoolOp(new $B.ast.And(), $B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.seq_insert_in_front(p, a, b)), EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var inversion_var;
          if (inversion_var = inversion_rule(p)) {
            _res = inversion_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, conjunction_type, _res);
      return _res;
    }
    function inversion_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, inversion_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          if ((_keyword = $B._PyPegen.expect_token(p, 703)) && (a = inversion_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.UnaryOp(new $B.ast.Not(), a, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var comparison_var;
          if (comparison_var = comparison_rule(p)) {
            _res = comparison_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, inversion_type, _res);
      return _res;
    }
    function comparison_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = bitwise_or_rule(p)) && (b = _loop1_85_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Compare(a, $B.helper_functions.CHECK($B.parser_constants.asdl_int_seq, $B._PyPegen.get_cmpops(p, b)), $B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.get_exprs(p, b)), EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var bitwise_or_var;
          if (bitwise_or_var = bitwise_or_rule(p)) {
            _res = bitwise_or_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function compare_op_bitwise_or_pair_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var eq_bitwise_or_var;
          if (eq_bitwise_or_var = eq_bitwise_or_rule(p)) {
            _res = eq_bitwise_or_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var noteq_bitwise_or_var;
          if (noteq_bitwise_or_var = noteq_bitwise_or_rule(p)) {
            _res = noteq_bitwise_or_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var lte_bitwise_or_var;
          if (lte_bitwise_or_var = lte_bitwise_or_rule(p)) {
            _res = lte_bitwise_or_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var lt_bitwise_or_var;
          if (lt_bitwise_or_var = lt_bitwise_or_rule(p)) {
            _res = lt_bitwise_or_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var gte_bitwise_or_var;
          if (gte_bitwise_or_var = gte_bitwise_or_rule(p)) {
            _res = gte_bitwise_or_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var gt_bitwise_or_var;
          if (gt_bitwise_or_var = gt_bitwise_or_rule(p)) {
            _res = gt_bitwise_or_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var notin_bitwise_or_var;
          if (notin_bitwise_or_var = notin_bitwise_or_rule(p)) {
            _res = notin_bitwise_or_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var in_bitwise_or_var;
          if (in_bitwise_or_var = in_bitwise_or_rule(p)) {
            _res = in_bitwise_or_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var isnot_bitwise_or_var;
          if (isnot_bitwise_or_var = isnot_bitwise_or_rule(p)) {
            _res = isnot_bitwise_or_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var is_bitwise_or_var;
          if (is_bitwise_or_var = is_bitwise_or_rule(p)) {
            _res = is_bitwise_or_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function eq_bitwise_or_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 27)) && (a = bitwise_or_rule(p))) {
            _res = $B._PyPegen.cmpop_expr_pair(p, new $B.ast.Eq(), a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function noteq_bitwise_or_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _tmp_86_var;
          var a;
          if ((_tmp_86_var = _tmp_86_rule(p)) && (a = bitwise_or_rule(p))) {
            _res = $B._PyPegen.cmpop_expr_pair(p, new $B.ast.NotEq(), a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function lte_bitwise_or_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 29)) && (a = bitwise_or_rule(p))) {
            _res = $B._PyPegen.cmpop_expr_pair(p, new $B.ast.LtE(), a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function lt_bitwise_or_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 20)) && (a = bitwise_or_rule(p))) {
            _res = $B._PyPegen.cmpop_expr_pair(p, new $B.ast.Lt(), a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function gte_bitwise_or_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 30)) && (a = bitwise_or_rule(p))) {
            _res = $B._PyPegen.cmpop_expr_pair(p, new $B.ast.GtE(), a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function gt_bitwise_or_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 21)) && (a = bitwise_or_rule(p))) {
            _res = $B._PyPegen.cmpop_expr_pair(p, new $B.ast.Gt(), a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function notin_bitwise_or_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var a;
          if ((_keyword = $B._PyPegen.expect_token(p, 703)) && (_keyword_1 = $B._PyPegen.expect_token(p, 695)) && (a = bitwise_or_rule(p))) {
            _res = $B._PyPegen.cmpop_expr_pair(p, new $B.ast.NotIn(), a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function in_bitwise_or_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          if ((_keyword = $B._PyPegen.expect_token(p, 695)) && (a = bitwise_or_rule(p))) {
            _res = $B._PyPegen.cmpop_expr_pair(p, new $B.ast.In(), a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function isnot_bitwise_or_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var a;
          if ((_keyword = $B._PyPegen.expect_token(p, 596)) && (_keyword_1 = $B._PyPegen.expect_token(p, 703)) && (a = bitwise_or_rule(p))) {
            _res = $B._PyPegen.cmpop_expr_pair(p, new $B.ast.IsNot(), a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function is_bitwise_or_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          if ((_keyword = $B._PyPegen.expect_token(p, 596)) && (a = bitwise_or_rule(p))) {
            _res = $B._PyPegen.cmpop_expr_pair(p, new $B.ast.Is(), a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function bitwise_or_raw() {
    }
    function bitwise_or_rule(p) {
      var _res = { value: NULL };
      if ($B._PyPegen.is_memoized(p, bitwise_or_type, _res)) {
        return _res.value;
      }
      _res = NULL;
      var _mark = p.mark;
      var _resmark = p.mark;
      while (1) {
        var tmpvar_2 = $B._PyPegen.update_memo(p, _mark, bitwise_or_type, _res);
        if (tmpvar_2) {
          return _res;
        }
        p.mark = _mark;
        var _raw = bitwise_or_raw(p);
        if (p.error_indicator) {
          return NULL;
        }
        if (_raw == NULL || p.mark <= _resmark)
          break;
        _resmark = p.mark;
        _res = _raw;
      }
      p.mark = _resmark;
      return _res;
    }
    function bitwise_or_raw(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = bitwise_or_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 18)) && (b = bitwise_xor_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.BinOp(a, new $B.ast.BitOr(), b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var bitwise_xor_var;
          if (bitwise_xor_var = bitwise_xor_rule(p)) {
            _res = bitwise_xor_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function bitwise_xor_raw() {
    }
    function bitwise_xor_rule(p) {
      var _res = { value: NULL };
      if ($B._PyPegen.is_memoized(p, bitwise_xor_type, _res)) {
        return _res.value;
      }
      _res = NULL;
      var _mark = p.mark;
      var _resmark = p.mark;
      while (1) {
        var tmpvar_3 = $B._PyPegen.update_memo(p, _mark, bitwise_xor_type, _res);
        if (tmpvar_3) {
          return _res;
        }
        p.mark = _mark;
        var _raw = bitwise_xor_raw(p);
        if (p.error_indicator) {
          return NULL;
        }
        if (_raw == NULL || p.mark <= _resmark)
          break;
        _resmark = p.mark;
        _res = _raw;
      }
      p.mark = _resmark;
      return _res;
    }
    function bitwise_xor_raw(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = bitwise_xor_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 32)) && (b = bitwise_and_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.BinOp(a, new $B.ast.BitXor(), b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var bitwise_and_var;
          if (bitwise_and_var = bitwise_and_rule(p)) {
            _res = bitwise_and_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function bitwise_and_raw() {
    }
    function bitwise_and_rule(p) {
      var _res = { value: NULL };
      if ($B._PyPegen.is_memoized(p, bitwise_and_type, _res)) {
        return _res.value;
      }
      _res = NULL;
      var _mark = p.mark;
      var _resmark = p.mark;
      while (1) {
        var tmpvar_4 = $B._PyPegen.update_memo(p, _mark, bitwise_and_type, _res);
        if (tmpvar_4) {
          return _res;
        }
        p.mark = _mark;
        var _raw = bitwise_and_raw(p);
        if (p.error_indicator) {
          return NULL;
        }
        if (_raw == NULL || p.mark <= _resmark)
          break;
        _resmark = p.mark;
        _res = _raw;
      }
      p.mark = _resmark;
      return _res;
    }
    function bitwise_and_raw(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = bitwise_and_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 19)) && (b = shift_expr_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.BinOp(a, new $B.ast.BitAnd(), b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var shift_expr_var;
          if (shift_expr_var = shift_expr_rule(p)) {
            _res = shift_expr_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function shift_expr_raw() {
    }
    function shift_expr_rule(p) {
      var _res = { value: NULL };
      if ($B._PyPegen.is_memoized(p, shift_expr_type, _res)) {
        return _res.value;
      }
      _res = NULL;
      var _mark = p.mark;
      var _resmark = p.mark;
      while (1) {
        var tmpvar_5 = $B._PyPegen.update_memo(p, _mark, shift_expr_type, _res);
        if (tmpvar_5) {
          return _res;
        }
        p.mark = _mark;
        var _raw = shift_expr_raw(p);
        if (p.error_indicator) {
          return NULL;
        }
        if (_raw == NULL || p.mark <= _resmark)
          break;
        _resmark = p.mark;
        _res = _raw;
      }
      p.mark = _resmark;
      return _res;
    }
    function shift_expr_raw(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = shift_expr_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 33)) && (b = sum_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.BinOp(a, new $B.ast.LShift(), b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = shift_expr_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 34)) && (b = sum_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.BinOp(a, new $B.ast.RShift(), b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_arithmetic_var;
          if (invalid_arithmetic_var = invalid_arithmetic_rule(p)) {
            _res = invalid_arithmetic_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var sum_var;
          if (sum_var = sum_rule(p)) {
            _res = sum_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function sum_raw() {
    }
    function sum_rule(p) {
      var _res = { value: NULL };
      if ($B._PyPegen.is_memoized(p, sum_type, _res)) {
        return _res.value;
      }
      _res = NULL;
      var _mark = p.mark;
      var _resmark = p.mark;
      while (1) {
        var tmpvar_6 = $B._PyPegen.update_memo(p, _mark, sum_type, _res);
        if (tmpvar_6) {
          return _res;
        }
        p.mark = _mark;
        var _raw = sum_raw(p);
        if (p.error_indicator) {
          return NULL;
        }
        if (_raw == NULL || p.mark <= _resmark)
          break;
        _resmark = p.mark;
        _res = _raw;
      }
      p.mark = _resmark;
      return _res;
    }
    function sum_raw(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = sum_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 14)) && (b = term_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.BinOp(a, new $B.ast.Add(), b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = sum_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 15)) && (b = term_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.BinOp(a, new $B.ast.Sub(), b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var term_var;
          if (term_var = term_rule(p)) {
            _res = term_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function term_raw() {
    }
    function term_rule(p) {
      var _res = { value: NULL };
      if ($B._PyPegen.is_memoized(p, term_type, _res)) {
        return _res.value;
      }
      _res = NULL;
      var _mark = p.mark;
      var _resmark = p.mark;
      while (1) {
        var tmpvar_7 = $B._PyPegen.update_memo(p, _mark, term_type, _res);
        if (tmpvar_7) {
          return _res;
        }
        p.mark = _mark;
        var _raw = term_raw(p);
        if (p.error_indicator) {
          return NULL;
        }
        if (_raw == NULL || p.mark <= _resmark)
          break;
        _resmark = p.mark;
        _res = _raw;
      }
      p.mark = _resmark;
      return _res;
    }
    function term_raw(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = term_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 16)) && (b = factor_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.BinOp(a, new $B.ast.Mult(), b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = term_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 17)) && (b = factor_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.BinOp(a, new $B.ast.Div(), b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = term_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 47)) && (b = factor_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.BinOp(a, new $B.ast.FloorDiv(), b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = term_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 24)) && (b = factor_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.BinOp(a, new $B.ast.Mod(), b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = term_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 49)) && (b = factor_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B.helper_functions.CHECK_VERSION($B.ast.expr, 5, "The '@' operator is", new $B._PyAST.BinOp(a, new $B.ast.MatMult(), b, EXTRA2));
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_factor_var;
          if (invalid_factor_var = invalid_factor_rule(p)) {
            _res = invalid_factor_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var factor_var;
          if (factor_var = factor_rule(p)) {
            _res = factor_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function factor_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, factor_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 14)) && (a = factor_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.UnaryOp(new $B.ast.UAdd(), a, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 15)) && (a = factor_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.UnaryOp(new $B.ast.USub(), a, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 31)) && (a = factor_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.UnaryOp(new $B.ast.Invert(), a, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var power_var;
          if (power_var = power_rule(p)) {
            _res = power_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, factor_type, _res);
      return _res;
    }
    function power_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = await_primary_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 35)) && (b = factor_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.BinOp(a, new $B.ast.Pow(), b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var await_primary_var;
          if (await_primary_var = await_primary_rule(p)) {
            _res = await_primary_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function await_primary_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, await_primary_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          if ((_keyword = $B._PyPegen.expect_token(p, 597)) && (a = primary_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B.helper_functions.CHECK_VERSION($B.ast.expr, 5, "Await expressions are", new $B._PyAST.Await(a, EXTRA2));
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var primary_var;
          if (primary_var = primary_rule(p)) {
            _res = primary_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, await_primary_type, _res);
      return _res;
    }
    function primary_raw() {
    }
    function primary_rule(p) {
      var _res = { value: NULL };
      if ($B._PyPegen.is_memoized(p, primary_type, _res)) {
        return _res.value;
      }
      _res = NULL;
      var _mark = p.mark;
      var _resmark = p.mark;
      while (1) {
        var tmpvar_8 = $B._PyPegen.update_memo(p, _mark, primary_type, _res);
        if (tmpvar_8) {
          return _res;
        }
        p.mark = _mark;
        var _raw = primary_raw(p);
        if (p.error_indicator) {
          return NULL;
        }
        if (_raw == NULL || p.mark <= _resmark)
          break;
        _resmark = p.mark;
        _res = _raw;
      }
      p.mark = _resmark;
      return _res;
    }
    function primary_raw(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = primary_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 23)) && (b = $B._PyPegen.name_token(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Attribute(a, b.id, $B.parser_constants.Load, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = primary_rule(p)) && (b = genexp_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Call(a, $B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.singleton_seq(p, b)), $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var b;
          if ((a = primary_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 7)) && (b = arguments_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Call(a, b ? b.args : $B.parser_constants.NULL, b ? b.keywords : $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var b;
          if ((a = primary_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 9)) && (b = slices_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 10))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Subscript(a, b, $B.parser_constants.Load, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var atom_var;
          if (atom_var = atom_rule(p)) {
            _res = atom_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function slices_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if ((a = slice_rule(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 12)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          if ((a = _gather_87_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Tuple(a, $B.parser_constants.Load, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function slice_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          var c;
          if ((a = expression_rule(p), !p.error_indicator) && (_literal = $B._PyPegen.expect_token(p, 11)) && (b = expression_rule(p), !p.error_indicator) && (c = _tmp_89_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Slice(a, b, c, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = named_expression_rule(p)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function atom_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var name_var;
          if (name_var = $B._PyPegen.name_token(p)) {
            _res = name_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 622)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Constant($B.parser_constants.Py_True, $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 624)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Constant($B.parser_constants.Py_False, $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 623)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Constant($B.parser_constants.Py_None, $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var strings_var;
          if ($B._PyPegen.lookahead(1, _tmp_90_rule, p) && (strings_var = strings_rule(p))) {
            _res = strings_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var number_var;
          if (number_var = $B._PyPegen.number_token(p)) {
            _res = number_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _tmp_91_var;
          if ($B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 7) && (_tmp_91_var = _tmp_91_rule(p))) {
            _res = _tmp_91_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _tmp_92_var;
          if ($B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 9) && (_tmp_92_var = _tmp_92_rule(p))) {
            _res = _tmp_92_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _tmp_93_var;
          if ($B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 25) && (_tmp_93_var = _tmp_93_rule(p))) {
            _res = _tmp_93_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 52)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Constant($B.parser_constants.Py_Ellipsis, $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function group_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (a = _tmp_94_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_group_var;
          if (invalid_group_var = invalid_group_rule(p)) {
            _res = invalid_group_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function lambdef_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var a;
          var b;
          if ((_keyword = $B._PyPegen.expect_token(p, 621)) && (a = lambda_params_rule(p), !p.error_indicator) && (_literal = $B._PyPegen.expect_token(p, 11)) && (b = expression_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Lambda(a ? a : $B.helper_functions.CHECK($B.ast.arguments, $B._PyPegen.empty_arguments(p)), b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function lambda_params_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_lambda_parameters_var;
          if (invalid_lambda_parameters_var = invalid_lambda_parameters_rule(p)) {
            _res = invalid_lambda_parameters_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var lambda_parameters_var;
          if (lambda_parameters_var = lambda_parameters_rule(p)) {
            _res = lambda_parameters_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function lambda_parameters_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          var c;
          var d;
          if ((a = lambda_slash_no_default_rule(p)) && (b = _loop0_95_rule(p)) && (c = _loop0_96_rule(p)) && (d = lambda_star_etc_rule(p), !p.error_indicator)) {
            _res = $B.helper_functions.CHECK_VERSION($B.ast.arguments, 8, "Positional-only parameters are", $B._PyPegen.make_arguments(p, a, $B.parser_constants.NULL, b, c, d));
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          var c;
          if ((a = lambda_slash_with_default_rule(p)) && (b = _loop0_97_rule(p)) && (c = lambda_star_etc_rule(p), !p.error_indicator)) {
            _res = $B.helper_functions.CHECK_VERSION($B.ast.arguments, 8, "Positional-only parameters are", $B._PyPegen.make_arguments(p, $B.parser_constants.NULL, a, $B.parser_constants.NULL, b, c));
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          var c;
          if ((a = _loop1_98_rule(p)) && (b = _loop0_99_rule(p)) && (c = lambda_star_etc_rule(p), !p.error_indicator)) {
            _res = $B._PyPegen.make_arguments(p, $B.parser_constants.NULL, $B.parser_constants.NULL, a, b, c);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = _loop1_100_rule(p)) && (b = lambda_star_etc_rule(p), !p.error_indicator)) {
            _res = $B._PyPegen.make_arguments(p, $B.parser_constants.NULL, $B.parser_constants.NULL, $B.parser_constants.NULL, a, b);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = lambda_star_etc_rule(p)) {
            _res = $B._PyPegen.make_arguments(p, $B.parser_constants.NULL, $B.parser_constants.NULL, $B.parser_constants.NULL, $B.parser_constants.NULL, a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function lambda_slash_no_default_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          if ((a = _loop1_101_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 17)) && (_literal_1 = $B._PyPegen.expect_token(p, 12))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((a = _loop1_102_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 17)) && $B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 11)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function lambda_slash_with_default_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var b;
          if ((a = _loop0_103_rule(p)) && (b = _loop1_104_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 17)) && (_literal_1 = $B._PyPegen.expect_token(p, 12))) {
            _res = $B._PyPegen.slash_with_default(p, a, b);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = _loop0_105_rule(p)) && (b = _loop1_106_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 17)) && $B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 11)) {
            _res = $B._PyPegen.slash_with_default(p, a, b);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function lambda_star_etc_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_lambda_star_etc_var;
          if (invalid_lambda_star_etc_var = invalid_lambda_star_etc_rule(p)) {
            _res = invalid_lambda_star_etc_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          var c;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (a = lambda_param_no_default_rule(p)) && (b = _loop0_107_rule(p)) && (c = lambda_kwds_rule(p), !p.error_indicator)) {
            _res = $B._PyPegen.star_etc(p, a, b, c);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var b;
          var c;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (_literal_1 = $B._PyPegen.expect_token(p, 12)) && (b = _loop1_108_rule(p)) && (c = lambda_kwds_rule(p), !p.error_indicator)) {
            _res = $B._PyPegen.star_etc(p, $B.parser_constants.NULL, b, c);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = lambda_kwds_rule(p)) {
            _res = $B._PyPegen.star_etc(p, $B.parser_constants.NULL, $B.parser_constants.NULL, a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function lambda_kwds_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_lambda_kwds_var;
          if (invalid_lambda_kwds_var = invalid_lambda_kwds_rule(p)) {
            _res = invalid_lambda_kwds_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 35)) && (a = lambda_param_no_default_rule(p))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function lambda_param_no_default_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((a = lambda_param_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if ((a = lambda_param_rule(p)) && $B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 11)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function lambda_param_with_default_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var c;
          if ((a = lambda_param_rule(p)) && (c = default_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12))) {
            _res = $B._PyPegen.name_default_pair(p, a, c, $B.parser_constants.NULL);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var c;
          if ((a = lambda_param_rule(p)) && (c = default_rule(p)) && $B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 11)) {
            _res = $B._PyPegen.name_default_pair(p, a, c, $B.parser_constants.NULL);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function lambda_param_maybe_default_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var c;
          if ((a = lambda_param_rule(p)) && (c = default_rule(p), !p.error_indicator) && (_literal = $B._PyPegen.expect_token(p, 12))) {
            _res = $B._PyPegen.name_default_pair(p, a, c, $B.parser_constants.NULL);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var c;
          if ((a = lambda_param_rule(p)) && (c = default_rule(p), !p.error_indicator) && $B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 11)) {
            _res = $B._PyPegen.name_default_pair(p, a, c, $B.parser_constants.NULL);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function lambda_param_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = $B._PyPegen.name_token(p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.arg(a.id, $B.parser_constants.NULL, $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function fstring_middle_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var fstring_replacement_field_var;
          if (fstring_replacement_field_var = fstring_replacement_field_rule(p)) {
            _res = fstring_replacement_field_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var t;
          if (t = $B._PyPegen.expect_token(p, FSTRING_MIDDLE)) {
            _res = $B._PyPegen.constant_from_token(p, t);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function fstring_replacement_field_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var conversion;
          var debug_expr;
          var format;
          var rbrace;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (a = annotated_rhs_rule(p)) && (debug_expr = $B._PyPegen.expect_token(p, 22), !p.error_indicator) && (conversion = fstring_conversion_rule(p), !p.error_indicator) && (format = fstring_full_format_spec_rule(p), !p.error_indicator) && (rbrace = $B._PyPegen.expect_token(p, 26))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B._PyPegen.formatted_value(p, a, debug_expr, conversion, format, rbrace, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_fstring_replacement_field_var;
          if (invalid_fstring_replacement_field_var = invalid_fstring_replacement_field_rule(p)) {
            _res = invalid_fstring_replacement_field_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function fstring_conversion_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var conv;
          var conv_token;
          if ((conv_token = $B._PyPegen.expect_token(p, 54)) && (conv = $B._PyPegen.name_token(p))) {
            _res = $B._PyPegen.check_fstring_conversion(p, conv_token, conv);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function fstring_full_format_spec_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var colon;
          var spec;
          if ((colon = $B._PyPegen.expect_token(p, 11)) && (spec = _loop0_109_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B._PyPegen.setup_full_format_spec(p, colon, spec, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function fstring_format_spec_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var t;
          if (t = $B._PyPegen.expect_token(p, FSTRING_MIDDLE)) {
            _res = $B._PyPegen.decoded_constant_from_token(p, t);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var fstring_replacement_field_var;
          if (fstring_replacement_field_var = fstring_replacement_field_rule(p)) {
            _res = fstring_replacement_field_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function fstring_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          var c;
          if ((a = $B._PyPegen.expect_token(p, FSTRING_START)) && (b = _loop0_110_rule(p)) && (c = $B._PyPegen.expect_token(p, FSTRING_END))) {
            _res = $B._PyPegen.joined_str(p, a, b, c);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function tstring_format_spec_replacement_field_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var conversion;
          var debug_expr;
          var format;
          var rbrace;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (a = annotated_rhs_rule(p)) && (debug_expr = $B._PyPegen.expect_token(p, 22), !p.error_indicator) && (conversion = fstring_conversion_rule(p), !p.error_indicator) && (format = tstring_full_format_spec_rule(p), !p.error_indicator) && (rbrace = $B._PyPegen.expect_token(p, 26))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B._PyPegen.formatted_value(p, a, debug_expr, conversion, format, rbrace, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_tstring_replacement_field_var;
          if (invalid_tstring_replacement_field_var = invalid_tstring_replacement_field_rule(p)) {
            _res = invalid_tstring_replacement_field_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function tstring_format_spec_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var t;
          if (t = $B._PyPegen.expect_token(p, TSTRING_MIDDLE)) {
            _res = $B._PyPegen.decoded_constant_from_token(p, t);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var tstring_format_spec_replacement_field_var;
          if (tstring_format_spec_replacement_field_var = tstring_format_spec_replacement_field_rule(p)) {
            _res = tstring_format_spec_replacement_field_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function tstring_full_format_spec_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var colon;
          var spec;
          if ((colon = $B._PyPegen.expect_token(p, 11)) && (spec = _loop0_111_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B._PyPegen.setup_full_format_spec(p, colon, spec, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function tstring_replacement_field_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var conversion;
          var debug_expr;
          var format;
          var rbrace;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (a = annotated_rhs_rule(p)) && (debug_expr = $B._PyPegen.expect_token(p, 22), !p.error_indicator) && (conversion = fstring_conversion_rule(p), !p.error_indicator) && (format = tstring_full_format_spec_rule(p), !p.error_indicator) && (rbrace = $B._PyPegen.expect_token(p, 26))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B._PyPegen.interpolation(p, a, debug_expr, conversion, format, rbrace, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_tstring_replacement_field_var;
          if (invalid_tstring_replacement_field_var = invalid_tstring_replacement_field_rule(p)) {
            _res = invalid_tstring_replacement_field_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function tstring_middle_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var tstring_replacement_field_var;
          if (tstring_replacement_field_var = tstring_replacement_field_rule(p)) {
            _res = tstring_replacement_field_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var t;
          if (t = $B._PyPegen.expect_token(p, TSTRING_MIDDLE)) {
            _res = $B._PyPegen.constant_from_token(p, t);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function tstring_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, tstring_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          var c;
          if ((a = $B._PyPegen.expect_token(p, TSTRING_START)) && (b = _loop0_112_rule(p)) && (c = $B._PyPegen.expect_token(p, TSTRING_END))) {
            _res = $B.helper_functions.CHECK_VERSION($B.ast.expr, 14, "t-strings are", $B._PyPegen.template_str(p, a, b, c));
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, tstring_type, _res);
      return _res;
    }
    function string_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var s;
          if (s = $B._PyPegen.string_token(p)) {
            _res = $B._PyPegen.constant_from_string(p, s);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function strings_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, strings_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_string_tstring_concat_var;
          if (invalid_string_tstring_concat_var = invalid_string_tstring_concat_rule(p)) {
            _res = invalid_string_tstring_concat_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = _loop1_113_rule(p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B._PyPegen.concatenate_strings(p, a, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = _loop1_114_rule(p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B._PyPegen.concatenate_tstrings(p, a, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, strings_type, _res);
      return _res;
    }
    function list_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 9)) && (a = star_named_expressions_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 10))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.List(a, $B.parser_constants.Load, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function tuple_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (a = _tmp_115_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Tuple(a, $B.parser_constants.Load, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function set_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (a = star_named_expressions_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 26))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Set(a, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function dict_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (a = double_starred_kvpairs_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 26))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Dict($B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.get_keys(p, a)), $B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.get_values(p, a)), EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var invalid_double_starred_kvpairs_var;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (invalid_double_starred_kvpairs_var = invalid_double_starred_kvpairs_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 26))) {
            _res = $B._PyPegen.dummy_name(p, _literal, invalid_double_starred_kvpairs_var, _literal_1);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function double_starred_kvpairs_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          if ((a = _gather_116_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function double_starred_kvpair_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 35)) && (a = bitwise_or_rule(p))) {
            _res = $B._PyPegen.key_value_pair(p, $B.parser_constants.NULL, a);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var kvpair_var;
          if (kvpair_var = kvpair_rule(p)) {
            _res = kvpair_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function kvpair_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (b = expression_rule(p))) {
            _res = $B._PyPegen.key_value_pair(p, a, b);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function for_if_clauses_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = _loop1_118_rule(p)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function for_if_clause_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _cut_var = 0;
          var _keyword;
          var _keyword_1;
          var _keyword_2;
          var a;
          var b;
          var c;
          if ((_keyword = $B._PyPegen.expect_token(p, 698)) && (_keyword_1 = $B._PyPegen.expect_token(p, 694)) && (a = star_targets_rule(p)) && (_keyword_2 = $B._PyPegen.expect_token(p, 695)) && (_cut_var = 1) && (b = disjunction_rule(p)) && (c = _loop0_119_rule(p))) {
            _res = $B.helper_functions.CHECK_VERSION($B.ast.comprehension, 6, "Async comprehensions are", new $B._PyAST.comprehension(a, b, c, 1, p.arena));
            break;
          }
          p.mark = _mark;
          if (_cut_var) {
            return NULL;
          }
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _cut_var = 0;
          var _keyword;
          var _keyword_1;
          var a;
          var b;
          var c;
          if ((_keyword = $B._PyPegen.expect_token(p, 694)) && (a = star_targets_rule(p)) && (_keyword_1 = $B._PyPegen.expect_token(p, 695)) && (_cut_var = 1) && (b = disjunction_rule(p)) && (c = _loop0_120_rule(p))) {
            _res = new $B._PyAST.comprehension(a, b, c, 0, p.arena);
            break;
          }
          p.mark = _mark;
          if (_cut_var) {
            return NULL;
          }
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_for_if_clause_var;
          if (invalid_for_if_clause_var = invalid_for_if_clause_rule(p)) {
            _res = invalid_for_if_clause_var;
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_for_target_var;
          if (invalid_for_target_var = invalid_for_target_rule(p)) {
            _res = invalid_for_target_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function listcomp_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var b;
          if ((_literal = $B._PyPegen.expect_token(p, 9)) && (a = named_expression_rule(p)) && (b = for_if_clauses_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 10))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.ListComp(a, b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_comprehension_var;
          if (invalid_comprehension_var = invalid_comprehension_rule(p)) {
            _res = invalid_comprehension_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function setcomp_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var b;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (a = named_expression_rule(p)) && (b = for_if_clauses_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 26))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.SetComp(a, b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_comprehension_var;
          if (invalid_comprehension_var = invalid_comprehension_rule(p)) {
            _res = invalid_comprehension_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function genexp_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var b;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (a = _tmp_121_rule(p)) && (b = for_if_clauses_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.GeneratorExp(a, b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_comprehension_var;
          if (invalid_comprehension_var = invalid_comprehension_rule(p)) {
            _res = invalid_comprehension_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function dictcomp_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var b;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (a = kvpair_rule(p)) && (b = for_if_clauses_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 26))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.DictComp(a.key, a.value, b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_dict_comprehension_var;
          if (invalid_dict_comprehension_var = invalid_dict_comprehension_rule(p)) {
            _res = invalid_dict_comprehension_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function arguments_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, arguments_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          if ((a = args_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator) && $B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, 8)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_arguments_var;
          if (invalid_arguments_var = invalid_arguments_rule(p)) {
            _res = invalid_arguments_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, arguments_type, _res);
      return _res;
    }
    function args_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = _gather_122_rule(p)) && (b = _tmp_124_rule(p), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B._PyPegen.collect_call_seqs(p, a, b, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = kwargs_rule(p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Call($B._PyPegen.dummy_name(p), $B.helper_functions.CHECK_NULL_ALLOWED($B.parser_constants.asdl_expr_seq, $B._PyPegen.seq_extract_starred_exprs(p, a)), $B.helper_functions.CHECK_NULL_ALLOWED($B.parser_constants.asdl_keyword_seq, $B._PyPegen.seq_delete_starred_exprs(p, a)), EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function kwargs_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = _gather_125_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (b = _gather_127_rule(p))) {
            _res = $B._PyPegen.join_sequences(p, a, b);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _gather_129_var;
          if (_gather_129_var = _gather_129_rule(p)) {
            _res = _gather_129_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _gather_131_var;
          if (_gather_131_var = _gather_131_rule(p)) {
            _res = _gather_131_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function starred_expression_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_starred_expression_unpacking_var;
          if (invalid_starred_expression_unpacking_var = invalid_starred_expression_unpacking_rule(p)) {
            _res = invalid_starred_expression_unpacking_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (a = expression_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Starred(a, $B.parser_constants.Load, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_starred_expression_var;
          if (invalid_starred_expression_var = invalid_starred_expression_rule(p)) {
            _res = invalid_starred_expression_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function kwarg_or_starred_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_kwarg_var;
          if (invalid_kwarg_var = invalid_kwarg_rule(p)) {
            _res = invalid_kwarg_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = $B._PyPegen.name_token(p)) && (_literal = $B._PyPegen.expect_token(p, 22)) && (b = expression_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B._PyPegen.keyword_or_starred(p, $B.helper_functions.CHECK($B.ast.keyword, new $B._PyAST.keyword(a.id, b, EXTRA2)), 1);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = starred_expression_rule(p)) {
            _res = $B._PyPegen.keyword_or_starred(p, a, 0);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function kwarg_or_double_starred_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_kwarg_var;
          if (invalid_kwarg_var = invalid_kwarg_rule(p)) {
            _res = invalid_kwarg_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = $B._PyPegen.name_token(p)) && (_literal = $B._PyPegen.expect_token(p, 22)) && (b = expression_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B._PyPegen.keyword_or_starred(p, $B.helper_functions.CHECK($B.ast.keyword, new $B._PyAST.keyword(a.id, b, EXTRA2)), 1);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 35)) && (a = expression_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = $B._PyPegen.keyword_or_starred(p, $B.helper_functions.CHECK($B.ast.keyword, new $B._PyAST.keyword($B.parser_constants.NULL, a, EXTRA2)), 1);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function star_targets_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if ((a = star_target_rule(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 12)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var b;
          if ((a = star_target_rule(p)) && (b = _loop0_133_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Tuple($B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.seq_insert_in_front(p, a, b)), $B.parser_constants.Store, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function star_targets_list_seq_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          if ((a = _gather_134_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function star_targets_tuple_seq_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var b;
          if ((a = star_target_rule(p)) && (b = _loop1_136_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator)) {
            _res = $B._PyPegen.seq_insert_in_front(p, a, b);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((a = star_target_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12))) {
            _res = $B._PyPegen.singleton_seq(p, a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function star_target_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, star_target_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (a = _tmp_137_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Starred($B.helper_functions.CHECK($B.ast.expr, $B._PyPegen.set_expr_context(p, a, $B.parser_constants.Store)), $B.parser_constants.Store, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var target_with_star_atom_var;
          if (target_with_star_atom_var = target_with_star_atom_rule(p)) {
            _res = target_with_star_atom_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, star_target_type, _res);
      return _res;
    }
    function target_with_star_atom_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, target_with_star_atom_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = t_primary_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 23)) && (b = $B._PyPegen.name_token(p)) && $B._PyPegen.lookahead(0, t_lookahead_rule, p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Attribute(a, b.id, $B.parser_constants.Store, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var b;
          if ((a = t_primary_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 9)) && (b = slices_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 10)) && $B._PyPegen.lookahead(0, t_lookahead_rule, p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Subscript(a, b, $B.parser_constants.Store, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var star_atom_var;
          if (star_atom_var = star_atom_rule(p)) {
            _res = star_atom_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, target_with_star_atom_type, _res);
      return _res;
    }
    function star_atom_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = $B._PyPegen.name_token(p)) {
            _res = $B._PyPegen.set_expr_context(p, a, $B.parser_constants.Store);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (a = target_with_star_atom_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            _res = $B._PyPegen.set_expr_context(p, a, $B.parser_constants.Store);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (a = star_targets_tuple_seq_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Tuple(a, $B.parser_constants.Store, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 9)) && (a = star_targets_list_seq_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 10))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.List(a, $B.parser_constants.Store, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function single_target_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var single_subscript_attribute_target_var;
          if (single_subscript_attribute_target_var = single_subscript_attribute_target_rule(p)) {
            _res = single_subscript_attribute_target_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = $B._PyPegen.name_token(p)) {
            _res = $B._PyPegen.set_expr_context(p, a, $B.parser_constants.Store);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (a = single_target_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function single_subscript_attribute_target_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = t_primary_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 23)) && (b = $B._PyPegen.name_token(p)) && $B._PyPegen.lookahead(0, t_lookahead_rule, p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Attribute(a, b.id, $B.parser_constants.Store, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var b;
          if ((a = t_primary_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 9)) && (b = slices_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 10)) && $B._PyPegen.lookahead(0, t_lookahead_rule, p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Subscript(a, b, $B.parser_constants.Store, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function t_primary_raw() {
    }
    function t_primary_rule(p) {
      var _res = { value: NULL };
      if ($B._PyPegen.is_memoized(p, t_primary_type, _res)) {
        return _res.value;
      }
      _res = NULL;
      var _mark = p.mark;
      var _resmark = p.mark;
      while (1) {
        var tmpvar_9 = $B._PyPegen.update_memo(p, _mark, t_primary_type, _res);
        if (tmpvar_9) {
          return _res;
        }
        p.mark = _mark;
        var _raw = t_primary_raw(p);
        if (p.error_indicator) {
          return NULL;
        }
        if (_raw == NULL || p.mark <= _resmark)
          break;
        _resmark = p.mark;
        _res = _raw;
      }
      p.mark = _resmark;
      return _res;
    }
    function t_primary_raw(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = t_primary_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 23)) && (b = $B._PyPegen.name_token(p)) && $B._PyPegen.lookahead(1, t_lookahead_rule, p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Attribute(a, b.id, $B.parser_constants.Load, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var b;
          if ((a = t_primary_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 9)) && (b = slices_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 10)) && $B._PyPegen.lookahead(1, t_lookahead_rule, p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Subscript(a, b, $B.parser_constants.Load, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = t_primary_rule(p)) && (b = genexp_rule(p)) && $B._PyPegen.lookahead(1, t_lookahead_rule, p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Call(a, $B.helper_functions.CHECK($B.parser_constants.asdl_expr_seq, $B._PyPegen.singleton_seq(p, b)), $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var b;
          if ((a = t_primary_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 7)) && (b = arguments_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8)) && $B._PyPegen.lookahead(1, t_lookahead_rule, p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Call(a, b ? b.args : $B.parser_constants.NULL, b ? b.keywords : $B.parser_constants.NULL, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if ((a = atom_rule(p)) && $B._PyPegen.lookahead(1, t_lookahead_rule, p)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function t_lookahead_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 7)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 9)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 23)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function del_targets_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          if ((a = _gather_138_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function del_target_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, del_target_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = t_primary_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 23)) && (b = $B._PyPegen.name_token(p)) && $B._PyPegen.lookahead(0, t_lookahead_rule, p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Attribute(a, b.id, $B.parser_constants.Del, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var b;
          if ((a = t_primary_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 9)) && (b = slices_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 10)) && $B._PyPegen.lookahead(0, t_lookahead_rule, p)) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Subscript(a, b, $B.parser_constants.Del, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var del_t_atom_var;
          if (del_t_atom_var = del_t_atom_rule(p)) {
            _res = del_t_atom_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, del_target_type, _res);
      return _res;
    }
    function del_t_atom_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = $B._PyPegen.name_token(p)) {
            _res = $B._PyPegen.set_expr_context(p, a, $B.parser_constants.Del);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (a = del_target_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            _res = $B._PyPegen.set_expr_context(p, a, $B.parser_constants.Del);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (a = del_targets_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.Tuple(a, $B.parser_constants.Del, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 9)) && (a = del_targets_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 10))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.List(a, $B.parser_constants.Del, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function type_expressions_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _literal_2;
          var _literal_3;
          var a;
          var b;
          var c;
          if ((a = _gather_140_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (_literal_1 = $B._PyPegen.expect_token(p, 16)) && (b = expression_rule(p)) && (_literal_2 = $B._PyPegen.expect_token(p, 12)) && (_literal_3 = $B._PyPegen.expect_token(p, 35)) && (c = expression_rule(p))) {
            _res = $B._PyPegen.seq_append_to_end(p, $B.helper_functions.CHECK(asdl_seq, $B._PyPegen.seq_append_to_end(p, a, b)), c);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var b;
          if ((a = _gather_142_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (_literal_1 = $B._PyPegen.expect_token(p, 16)) && (b = expression_rule(p))) {
            _res = $B._PyPegen.seq_append_to_end(p, a, b);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var b;
          if ((a = _gather_144_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (_literal_1 = $B._PyPegen.expect_token(p, 35)) && (b = expression_rule(p))) {
            _res = $B._PyPegen.seq_append_to_end(p, a, b);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _literal_2;
          var a;
          var b;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (a = expression_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 12)) && (_literal_2 = $B._PyPegen.expect_token(p, 35)) && (b = expression_rule(p))) {
            _res = $B._PyPegen.seq_append_to_end(p, $B.helper_functions.CHECK(asdl_seq, $B._PyPegen.singleton_seq(p, a)), b);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (a = expression_rule(p))) {
            _res = $B._PyPegen.singleton_seq(p, a);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 35)) && (a = expression_rule(p))) {
            _res = $B._PyPegen.singleton_seq(p, a);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = _gather_146_rule(p)) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function func_type_comment_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var newline_var;
          var t;
          if ((newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && (t = $B._PyPegen.expect_token(p, TYPE_COMMENT)) && $B._PyPegen.lookahead(1, _tmp_148_rule, p)) {
            _res = t;
            break;
          }
          p.mark = _mark;
        }
        if (p.call_invalid_rules) {
          if (p.error_indicator) {
            return NULL;
          }
          var invalid_double_type_comments_var;
          if (invalid_double_type_comments_var = invalid_double_type_comments_rule(p)) {
            _res = invalid_double_type_comments_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var type_comment_var;
          if (type_comment_var = $B._PyPegen.expect_token(p, TYPE_COMMENT)) {
            _res = type_comment_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_arguments_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _gather_150_var;
          var _tmp_149_var;
          var a;
          if ((_tmp_149_var = _tmp_149_rule(p)) && (a = $B._PyPegen.expect_token(p, 12)) && (_gather_150_var = _gather_150_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_STARTING_FROM(p, a, "iterable argument unpacking follows keyword argument unpacking");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var b;
          if ((a = expression_rule(p)) && (b = for_if_clauses_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (_opt_var = _tmp_152_rule(p), !p.error_indicator)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, $B._PyPegen.get_last_comprehension_item($B.PyPegen.last_item(b, $B.ast.comprehension)), "Generator expression must be parenthesized");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          var expression_var;
          var for_if_clauses_var;
          if ((a = $B._PyPegen.name_token(p)) && (b = $B._PyPegen.expect_token(p, 22)) && (expression_var = expression_rule(p)) && (for_if_clauses_var = for_if_clauses_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "invalid syntax. Maybe you meant '==' or ':=' instead of '='?");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var b;
          if ((_opt_var = _tmp_153_rule(p), !p.error_indicator) && (a = $B._PyPegen.name_token(p)) && (b = $B._PyPegen.expect_token(p, 22)) && $B._PyPegen.lookahead(1, _tmp_154_rule, p)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "expected argument value expression");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = args_rule(p)) && (b = for_if_clauses_rule(p))) {
            _res = $B._PyPegen.nonparen_genexp_in_call(p, a, b);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var args_var;
          var b;
          if ((args_var = args_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (a = expression_rule(p)) && (b = for_if_clauses_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, $B._PyPegen.get_last_comprehension_item($B.PyPegen.last_item(b, $B.ast.comprehension)), "Generator expression must be parenthesized");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var args_var;
          if ((a = args_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (args_var = args_rule(p))) {
            _res = $B._PyPegen.arguments_parsing_error(p, a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_kwarg_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = _tmp_155_rule(p)) && (b = $B._PyPegen.expect_token(p, 22))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "cannot assign to %s", $B.parser_constants.PyBytes_AS_STRING(a.bytes));
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          var expression_var;
          var for_if_clauses_var;
          if ((a = $B._PyPegen.name_token(p)) && (b = $B._PyPegen.expect_token(p, 22)) && (expression_var = expression_rule(p)) && (for_if_clauses_var = for_if_clauses_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "invalid syntax. Maybe you meant '==' or ':=' instead of '='?");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ($B._PyPegen.lookahead(0, _tmp_156_rule, p) && (a = expression_rule(p)) && (b = $B._PyPegen.expect_token(p, 22))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, 'expression cannot contain assignment, perhaps you meant "=="?');
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          var expression_var;
          if ((a = $B._PyPegen.expect_token(p, 35)) && (expression_var = expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 22)) && (b = expression_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "cannot assign to keyword argument unpacking");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function expression_without_invalid_rule(p) {
      var _prev_call_invalid = p.call_invalid_rules;
      p.call_invalid_rules = 0;
      if (p.error_indicator) {
        p.call_invalid_rules = _prev_call_invalid;
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        if (p.mark == p.fill && $B._PyPegen.fill_token(p) < 0) {
          p.error_indicator = 1;
          p.call_invalid_rules = _prev_call_invalid;
          return NULL;
        }
        var EXTRA2 = { lineno: p.tokens[_mark].lineno, col_offset: p.tokens[_mark].col_offset };
        {
          if (p.error_indicator) {
            p.call_invalid_rules = _prev_call_invalid;
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var a;
          var b;
          var c;
          if ((a = disjunction_rule(p)) && (_keyword = $B._PyPegen.expect_token(p, 682)) && (b = disjunction_rule(p)) && (_keyword_1 = $B._PyPegen.expect_token(p, 686)) && (c = expression_rule(p))) {
            var _token = $B._PyPegen.get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
              p.call_invalid_rules = _prev_call_invalid;
              return NULL;
            }
            EXTRA2.end_lineno = _token.end_lineno;
            EXTRA2.end_col_offset = _token.end_col_offset;
            _res = new $B._PyAST.IfExp(b, a, c, EXTRA2);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            p.call_invalid_rules = _prev_call_invalid;
            return NULL;
          }
          var disjunction_var;
          if (disjunction_var = disjunction_rule(p)) {
            _res = disjunction_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            p.call_invalid_rules = _prev_call_invalid;
            return NULL;
          }
          var lambdef_var;
          if (lambdef_var = lambdef_rule(p)) {
            _res = lambdef_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      p.call_invalid_rules = _prev_call_invalid;
      return _res;
    }
    function invalid_legacy_expression_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = $B._PyPegen.name_token(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 7) && (b = star_expressions_rule(p))) {
            _res = $B._PyPegen.check_legacy_stmt(p, a) ? $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "Missing parentheses in call to '%U'. Did you mean %U(...)?", a.id, a.id) : $B.parser_constants.NULL;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_type_param_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var colon;
          var e;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (a = $B._PyPegen.name_token(p)) && (colon = $B._PyPegen.expect_token(p, 11)) && (e = expression_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_STARTING_FROM(p, colon, e.kind == Tuple_kind ? "cannot use bound with TypeVarTuple" : "cannot use constraints with TypeVarTuple");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var colon;
          var e;
          if ((_literal = $B._PyPegen.expect_token(p, 35)) && (a = $B._PyPegen.name_token(p)) && (colon = $B._PyPegen.expect_token(p, 11)) && (e = expression_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_STARTING_FROM(p, colon, e.kind == Tuple_kind ? "cannot use bound with ParamSpec" : "cannot use constraints with ParamSpec");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_expression_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var string_var;
          var string_var_1;
          if ((string_var = $B._PyPegen.string_token(p)) && (a = _loop1_157_rule(p)) && (string_var_1 = $B._PyPegen.string_token(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, $B.PyPegen.first_item(a, $B.ast.expr), $B.PyPegen.last_item(a, $B.ast.expr), "invalid syntax. Is this intended to be part of the string?");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ($B._PyPegen.lookahead(0, _tmp_158_rule, p) && (a = disjunction_rule(p)) && (b = expression_without_invalid_rule(p))) {
            _res = $B._PyPegen.check_legacy_stmt(p, a) ? $B.parser_constants.NULL : p.tokens[p.mark - 1].level == 0 ? $B.parser_constants.NULL : $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "invalid syntax. Perhaps you forgot a comma?");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          var b;
          if ((a = disjunction_rule(p)) && (_keyword = $B._PyPegen.expect_token(p, 682)) && (b = disjunction_rule(p)) && $B._PyPegen.lookahead(0, _tmp_159_rule, p)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "expected 'else' after 'if' expression");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var a;
          var b;
          if ((a = disjunction_rule(p)) && (_keyword = $B._PyPegen.expect_token(p, 682)) && (b = disjunction_rule(p)) && (_keyword_1 = $B._PyPegen.expect_token(p, 686)) && $B._PyPegen.lookahead(0, expression_rule, p)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "expected expression after 'else', but statement is given");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var a;
          var b;
          var c;
          if ((a = _tmp_160_rule(p)) && (_keyword = $B._PyPegen.expect_token(p, 682)) && (b = disjunction_rule(p)) && (_keyword_1 = $B._PyPegen.expect_token(p, 686)) && (c = simple_stmt_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "expected expression before 'if', but statement is given");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var b;
          if ((a = $B._PyPegen.expect_token(p, 621)) && (_opt_var = lambda_params_rule(p), !p.error_indicator) && (b = $B._PyPegen.expect_token(p, 11)) && $B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, FSTRING_MIDDLE)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "f-string: lambda expressions are not allowed without parentheses");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var b;
          if ((a = $B._PyPegen.expect_token(p, 621)) && (_opt_var = lambda_params_rule(p), !p.error_indicator) && (b = $B._PyPegen.expect_token(p, 11)) && $B._PyPegen.lookahead_with_int(1, $B._PyPegen.expect_token, p, TSTRING_MIDDLE)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "t-string: lambda expressions are not allowed without parentheses");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_named_expression_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = { value: NULL };
        if ($B._PyPegen.is_memoized(p, invalid_named_expression_type, _res)) {
          return _res.value;
        }
        _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var expression_var;
          if ((a = expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 53)) && (expression_var = expression_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "cannot use assignment expressions with %s", $B._PyPegen.get_expr_name(a));
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          if ((a = $B._PyPegen.name_token(p)) && (_literal = $B._PyPegen.expect_token(p, 22)) && (b = bitwise_or_rule(p)) && $B._PyPegen.lookahead(0, _tmp_161_rule, p)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "invalid syntax. Maybe you meant '==' or ':=' instead of '='?");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          var bitwise_or_var;
          if ($B._PyPegen.lookahead(0, _tmp_162_rule, p) && (a = bitwise_or_rule(p)) && (b = $B._PyPegen.expect_token(p, 22)) && (bitwise_or_var = bitwise_or_rule(p)) && $B._PyPegen.lookahead(0, _tmp_163_rule, p)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "cannot assign to %s here. Maybe you meant '==' instead of '='?", $B._PyPegen.get_expr_name(a));
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      $B._PyPegen.insert_memo(p, _mark, invalid_named_expression_type, _res);
      return _res;
    }
    function invalid_assignment_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var expression_var;
          if ((a = invalid_ann_assign_target_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (expression_var = expression_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "only single target (not %s) can be annotated", $B._PyPegen.get_expr_name(a));
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _loop0_164_var;
          var a;
          var expression_var;
          if ((a = star_named_expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (_loop0_164_var = _loop0_164_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 11)) && (expression_var = expression_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "only single target (not tuple) can be annotated");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var expression_var;
          if ((a = expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (expression_var = expression_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "illegal target for annotation");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _loop0_165_var;
          var a;
          if ((_loop0_165_var = _loop0_165_rule(p)) && (a = star_expressions_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 22))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_INVALID_TARGET(p, $B.parser_constants.STAR_TARGETS, a);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _loop0_166_var;
          var a;
          if ((_loop0_166_var = _loop0_166_rule(p)) && (a = yield_expr_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 22))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "assignment to yield expression not possible");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var annotated_rhs_var;
          var augassign_var;
          if ((a = star_expressions_rule(p)) && (augassign_var = augassign_rule(p)) && (annotated_rhs_var = annotated_rhs_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "'%s' is an illegal expression for augmented assignment", $B._PyPegen.get_expr_name(a));
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_ann_assign_target_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var list_var;
          if (list_var = list_rule(p)) {
            _res = list_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var tuple_var;
          if (tuple_var = tuple_rule(p)) {
            _res = tuple_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (a = invalid_ann_assign_target_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_del_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          if ((_keyword = $B._PyPegen.expect_token(p, 625)) && (a = star_expressions_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_INVALID_TARGET(p, $B.parser_constants.DEL_TARGETS, a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_block_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var newline_var;
          if ((newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_comprehension_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _tmp_167_var;
          var a;
          var for_if_clauses_var;
          if ((_tmp_167_var = _tmp_167_rule(p)) && (a = starred_expression_rule(p)) && (for_if_clauses_var = for_if_clauses_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "iterable unpacking cannot be used in comprehension");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _tmp_168_var;
          var a;
          var b;
          var for_if_clauses_var;
          if ((_tmp_168_var = _tmp_168_rule(p)) && (a = star_named_expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (b = star_named_expressions_rule(p)) && (for_if_clauses_var = for_if_clauses_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, $B.PyPegen.last_item(b, $B.ast.expr), "did you forget parentheses around the comprehension target?");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _tmp_169_var;
          var a;
          var b;
          var for_if_clauses_var;
          if ((_tmp_169_var = _tmp_169_rule(p)) && (a = star_named_expression_rule(p)) && (b = $B._PyPegen.expect_token(p, 12)) && (for_if_clauses_var = for_if_clauses_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "did you forget parentheses around the comprehension target?");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_dict_comprehension_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var bitwise_or_var;
          var for_if_clauses_var;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (a = $B._PyPegen.expect_token(p, 35)) && (bitwise_or_var = bitwise_or_rule(p)) && (for_if_clauses_var = for_if_clauses_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 26))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "dict unpacking cannot be used in dict comprehension");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_parameters_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((a = $B._PyPegen.expect_token(p, 17)) && (_literal = $B._PyPegen.expect_token(p, 12))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "at least one argument must precede /");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _loop0_171_var;
          var _tmp_170_var;
          var a;
          if ((_tmp_170_var = _tmp_170_rule(p)) && (_loop0_171_var = _loop0_171_rule(p)) && (a = $B._PyPegen.expect_token(p, 17))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "/ may appear only once");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _loop0_172_var;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var invalid_parameters_helper_var;
          if ((_opt_var = slash_no_default_rule(p), !p.error_indicator) && (_loop0_172_var = _loop0_172_rule(p)) && (invalid_parameters_helper_var = invalid_parameters_helper_rule(p)) && (a = param_no_default_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "parameter without a default follows parameter with a default");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _loop0_173_var;
          var _loop1_174_var;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var b;
          if ((_loop0_173_var = _loop0_173_rule(p)) && (a = $B._PyPegen.expect_token(p, 7)) && (_loop1_174_var = _loop1_174_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator) && (b = $B._PyPegen.expect_token(p, 8))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "Function parameters cannot be parenthesized");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _loop0_176_var;
          var _loop0_178_var;
          var _opt_var;
          UNUSED(_opt_var);
          var _tmp_177_var;
          var a;
          if ((_opt_var = _tmp_175_rule(p), !p.error_indicator) && (_loop0_176_var = _loop0_176_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 16)) && (_tmp_177_var = _tmp_177_rule(p)) && (_loop0_178_var = _loop0_178_rule(p)) && (a = $B._PyPegen.expect_token(p, 17))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "/ must be ahead of *");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _loop1_179_var;
          var a;
          if ((_loop1_179_var = _loop1_179_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 17)) && (a = $B._PyPegen.expect_token(p, 16))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "expected comma between / and *");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_default_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if ((a = $B._PyPegen.expect_token(p, 22)) && $B._PyPegen.lookahead(1, _tmp_180_rule, p)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "expected default value expression");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_star_etc_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _tmp_181_var;
          var a;
          if ((a = $B._PyPegen.expect_token(p, 16)) && (_tmp_181_var = _tmp_181_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "named arguments must follow bare *");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var type_comment_var;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (_literal_1 = $B._PyPegen.expect_token(p, 12)) && (type_comment_var = $B._PyPegen.expect_token(p, TYPE_COMMENT))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "bare * has associated type comment");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var param_var;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (param_var = param_rule(p)) && (a = $B._PyPegen.expect_token(p, 22))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "var-positional argument cannot have default value");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _loop0_183_var;
          var _tmp_182_var;
          var _tmp_184_var;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (_tmp_182_var = _tmp_182_rule(p)) && (_loop0_183_var = _loop0_183_rule(p)) && (a = $B._PyPegen.expect_token(p, 16)) && (_tmp_184_var = _tmp_184_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "* argument may appear only once");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_kwds_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var param_var;
          if ((_literal = $B._PyPegen.expect_token(p, 35)) && (param_var = param_rule(p)) && (a = $B._PyPegen.expect_token(p, 22))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "var-keyword argument cannot have default value");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var param_var;
          if ((_literal = $B._PyPegen.expect_token(p, 35)) && (param_var = param_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 12)) && (a = param_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "arguments cannot follow var-keyword argument");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var param_var;
          if ((_literal = $B._PyPegen.expect_token(p, 35)) && (param_var = param_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 12)) && (a = _tmp_185_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "arguments cannot follow var-keyword argument");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_parameters_helper_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = slash_with_default_rule(p)) {
            _res = $B._PyPegen.singleton_seq(p, a);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _loop1_186_var;
          if (_loop1_186_var = _loop1_186_rule(p)) {
            _res = _loop1_186_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_lambda_parameters_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((a = $B._PyPegen.expect_token(p, 17)) && (_literal = $B._PyPegen.expect_token(p, 12))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "at least one argument must precede /");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _loop0_188_var;
          var _tmp_187_var;
          var a;
          if ((_tmp_187_var = _tmp_187_rule(p)) && (_loop0_188_var = _loop0_188_rule(p)) && (a = $B._PyPegen.expect_token(p, 17))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "/ may appear only once");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _loop0_189_var;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var invalid_lambda_parameters_helper_var;
          if ((_opt_var = lambda_slash_no_default_rule(p), !p.error_indicator) && (_loop0_189_var = _loop0_189_rule(p)) && (invalid_lambda_parameters_helper_var = invalid_lambda_parameters_helper_rule(p)) && (a = lambda_param_no_default_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "parameter without a default follows parameter with a default");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _gather_191_var;
          var _loop0_190_var;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var b;
          if ((_loop0_190_var = _loop0_190_rule(p)) && (a = $B._PyPegen.expect_token(p, 7)) && (_gather_191_var = _gather_191_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator) && (b = $B._PyPegen.expect_token(p, 8))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "Lambda expression parameters cannot be parenthesized");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _loop0_194_var;
          var _loop0_196_var;
          var _opt_var;
          UNUSED(_opt_var);
          var _tmp_195_var;
          var a;
          if ((_opt_var = _tmp_193_rule(p), !p.error_indicator) && (_loop0_194_var = _loop0_194_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 16)) && (_tmp_195_var = _tmp_195_rule(p)) && (_loop0_196_var = _loop0_196_rule(p)) && (a = $B._PyPegen.expect_token(p, 17))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "/ must be ahead of *");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _loop1_197_var;
          var a;
          if ((_loop1_197_var = _loop1_197_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 17)) && (a = $B._PyPegen.expect_token(p, 16))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "expected comma between / and *");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_lambda_parameters_helper_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if (a = lambda_slash_with_default_rule(p)) {
            _res = $B._PyPegen.singleton_seq(p, a);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _loop1_198_var;
          if (_loop1_198_var = _loop1_198_rule(p)) {
            _res = _loop1_198_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_lambda_star_etc_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _tmp_199_var;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (_tmp_199_var = _tmp_199_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "named arguments must follow bare *");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var lambda_param_var;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (lambda_param_var = lambda_param_rule(p)) && (a = $B._PyPegen.expect_token(p, 22))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "var-positional argument cannot have default value");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _loop0_201_var;
          var _tmp_200_var;
          var _tmp_202_var;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 16)) && (_tmp_200_var = _tmp_200_rule(p)) && (_loop0_201_var = _loop0_201_rule(p)) && (a = $B._PyPegen.expect_token(p, 16)) && (_tmp_202_var = _tmp_202_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "* argument may appear only once");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_lambda_kwds_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var lambda_param_var;
          if ((_literal = $B._PyPegen.expect_token(p, 35)) && (lambda_param_var = lambda_param_rule(p)) && (a = $B._PyPegen.expect_token(p, 22))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "var-keyword argument cannot have default value");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var lambda_param_var;
          if ((_literal = $B._PyPegen.expect_token(p, 35)) && (lambda_param_var = lambda_param_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 12)) && (a = lambda_param_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "arguments cannot follow var-keyword argument");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var lambda_param_var;
          if ((_literal = $B._PyPegen.expect_token(p, 35)) && (lambda_param_var = lambda_param_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 12)) && (a = _tmp_203_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "arguments cannot follow var-keyword argument");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_double_type_comments_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var indent_var;
          var newline_var;
          var newline_var_1;
          var type_comment_var;
          var type_comment_var_1;
          if ((type_comment_var = $B._PyPegen.expect_token(p, TYPE_COMMENT)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && (type_comment_var_1 = $B._PyPegen.expect_token(p, TYPE_COMMENT)) && (newline_var_1 = $B._PyPegen.expect_token(p, NEWLINE)) && (indent_var = $B._PyPegen.expect_token(p, INDENT))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "Cannot have two type comments on def");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_with_item_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          var expression_var;
          if ((expression_var = expression_rule(p)) && (_keyword = $B._PyPegen.expect_token(p, 680)) && (a = expression_rule(p)) && $B._PyPegen.lookahead(1, _tmp_204_rule, p)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_INVALID_TARGET(p, $B.parser_constants.STAR_TARGETS, a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_for_if_clause_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _opt_var;
          UNUSED(_opt_var);
          var _tmp_205_var;
          if ((_opt_var = $B._PyPegen.expect_token(p, 698), !p.error_indicator) && (_keyword = $B._PyPegen.expect_token(p, 694)) && (_tmp_205_var = _tmp_205_rule(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 695)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "'in' expected after for-loop variables");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_for_target_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          if ((_opt_var = $B._PyPegen.expect_token(p, 698), !p.error_indicator) && (_keyword = $B._PyPegen.expect_token(p, 694)) && (a = star_expressions_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_INVALID_TARGET(p, $B.parser_constants.FOR_TARGETS, a);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_group_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (a = starred_expression_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "cannot use starred expression here");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var a;
          var expression_var;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (a = $B._PyPegen.expect_token(p, 35)) && (expression_var = expression_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "cannot use double starred expression here");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_import_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _gather_206_var;
          var _keyword;
          var a;
          var dotted_name_var;
          if ((a = $B._PyPegen.expect_token(p, 634)) && (_gather_206_var = _gather_206_rule(p)) && (_keyword = $B._PyPegen.expect_token(p, 633)) && (dotted_name_var = dotted_name_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_STARTING_FROM(p, a, "Did you mean to use 'from ... import ...' instead?");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var token;
          if ((_keyword = $B._PyPegen.expect_token(p, 634)) && (token = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_STARTING_FROM(p, token, "Expected one or more names after 'import'");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_dotted_as_name_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          var dotted_name_var;
          if ((dotted_name_var = dotted_name_rule(p)) && (_keyword = $B._PyPegen.expect_token(p, 680)) && $B._PyPegen.lookahead(0, _tmp_208_rule, p) && (a = expression_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "cannot use %s as import target", $B._PyPegen.get_expr_name(a));
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_import_from_as_name_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          var name_var;
          if ((name_var = $B._PyPegen.name_token(p)) && (_keyword = $B._PyPegen.expect_token(p, 680)) && $B._PyPegen.lookahead(0, _tmp_209_rule, p) && (a = expression_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "cannot use %s as import target", $B._PyPegen.get_expr_name(a));
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_import_from_targets_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var import_from_as_names_var;
          var newline_var;
          if ((import_from_as_names_var = import_from_as_names_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "trailing comma not allowed without surrounding parentheses");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var token;
          if (token = $B._PyPegen.expect_token(p, NEWLINE)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_STARTING_FROM(p, token, "Expected one or more names after 'import'");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_with_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _gather_210_var;
          var _keyword;
          var _opt_var;
          UNUSED(_opt_var);
          var newline_var;
          if ((_opt_var = $B._PyPegen.expect_token(p, 698), !p.error_indicator) && (_keyword = $B._PyPegen.expect_token(p, 647)) && (_gather_210_var = _gather_210_rule(p)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "expected ':'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _gather_212_var;
          var _keyword;
          var _literal;
          var _literal_1;
          var _opt_var;
          UNUSED(_opt_var);
          var _opt_var_1;
          UNUSED(_opt_var_1);
          var newline_var;
          if ((_opt_var = $B._PyPegen.expect_token(p, 698), !p.error_indicator) && (_keyword = $B._PyPegen.expect_token(p, 647)) && (_literal = $B._PyPegen.expect_token(p, 7)) && (_gather_212_var = _gather_212_rule(p)) && (_opt_var_1 = $B._PyPegen.expect_token(p, 12), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "expected ':'");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_with_stmt_indent_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _gather_214_var;
          var _literal;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var newline_var;
          if ((_opt_var = $B._PyPegen.expect_token(p, 698), !p.error_indicator) && (a = $B._PyPegen.expect_token(p, 647)) && (_gather_214_var = _gather_214_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block after 'with' statement on line %d", a.lineno);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _gather_216_var;
          var _literal;
          var _literal_1;
          var _literal_2;
          var _opt_var;
          UNUSED(_opt_var);
          var _opt_var_1;
          UNUSED(_opt_var_1);
          var a;
          var newline_var;
          if ((_opt_var = $B._PyPegen.expect_token(p, 698), !p.error_indicator) && (a = $B._PyPegen.expect_token(p, 647)) && (_literal = $B._PyPegen.expect_token(p, 7)) && (_gather_216_var = _gather_216_rule(p)) && (_opt_var_1 = $B._PyPegen.expect_token(p, 12), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8)) && (_literal_2 = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block after 'with' statement on line %d", a.lineno);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_try_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var newline_var;
          if ((a = $B._PyPegen.expect_token(p, 656)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block after 'try' statement on line %d", a.lineno);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var block_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 656)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (block_var = block_rule(p)) && $B._PyPegen.lookahead(0, _tmp_218_rule, p)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "expected 'except' or 'finally' block");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var _literal_1;
          var _loop0_219_var;
          var _loop1_220_var;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var b;
          var expression_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 656)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (_loop0_219_var = _loop0_219_rule(p)) && (_loop1_220_var = _loop1_220_rule(p)) && (a = $B._PyPegen.expect_token(p, 677)) && (b = $B._PyPegen.expect_token(p, 16)) && (expression_var = expression_rule(p)) && (_opt_var = _tmp_221_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 11))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "cannot have both 'except' and 'except*' on the same 'try'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var _literal_1;
          var _loop0_222_var;
          var _loop1_223_var;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          if ((_keyword = $B._PyPegen.expect_token(p, 656)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (_loop0_222_var = _loop0_222_rule(p)) && (_loop1_223_var = _loop1_223_rule(p)) && (a = $B._PyPegen.expect_token(p, 677)) && (_opt_var = _tmp_224_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 11))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "cannot have both 'except' and 'except*' on the same 'try'");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_except_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var _literal;
          var _literal_1;
          var a;
          var expressions_var;
          var name_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 677)) && (a = expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (expressions_var = expressions_rule(p)) && (_keyword_1 = $B._PyPegen.expect_token(p, 680)) && (name_var = $B._PyPegen.name_token(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 11))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_STARTING_FROM(p, a, "multiple exception types must be parenthesized when using 'as'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var expression_var;
          var newline_var;
          if ((a = $B._PyPegen.expect_token(p, 677)) && (expression_var = expression_rule(p)) && (_opt_var = _tmp_225_rule(p), !p.error_indicator) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "expected ':'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var newline_var;
          if ((a = $B._PyPegen.expect_token(p, 677)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "expected ':'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var _literal;
          var a;
          var block_var;
          var expression_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 677)) && (expression_var = expression_rule(p)) && (_keyword_1 = $B._PyPegen.expect_token(p, 680)) && (a = expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (block_var = block_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "cannot use except statement with %s", $B._PyPegen.get_expr_name(a));
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_except_star_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var _literal;
          var _literal_1;
          var _literal_2;
          var a;
          var expressions_var;
          var name_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 677)) && (_literal = $B._PyPegen.expect_token(p, 16)) && (a = expression_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 12)) && (expressions_var = expressions_rule(p)) && (_keyword_1 = $B._PyPegen.expect_token(p, 680)) && (name_var = $B._PyPegen.name_token(p)) && (_literal_2 = $B._PyPegen.expect_token(p, 11))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_STARTING_FROM(p, a, "multiple exception types must be parenthesized when using 'as'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var expression_var;
          var newline_var;
          if ((a = $B._PyPegen.expect_token(p, 677)) && (_literal = $B._PyPegen.expect_token(p, 16)) && (expression_var = expression_rule(p)) && (_opt_var = _tmp_226_rule(p), !p.error_indicator) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "expected ':'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _tmp_227_var;
          var a;
          if ((a = $B._PyPegen.expect_token(p, 677)) && (_literal = $B._PyPegen.expect_token(p, 16)) && (_tmp_227_var = _tmp_227_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "expected one or more exception types");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var _literal;
          var _literal_1;
          var a;
          var block_var;
          var expression_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 677)) && (_literal = $B._PyPegen.expect_token(p, 16)) && (expression_var = expression_rule(p)) && (_keyword_1 = $B._PyPegen.expect_token(p, 680)) && (a = expression_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 11)) && (block_var = block_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "cannot use except* statement with %s", $B._PyPegen.get_expr_name(a));
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_finally_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var newline_var;
          if ((a = $B._PyPegen.expect_token(p, 673)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block after 'finally' statement on line %d", a.lineno);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_except_stmt_indent_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var expression_var;
          var newline_var;
          if ((a = $B._PyPegen.expect_token(p, 677)) && (expression_var = expression_rule(p)) && (_opt_var = _tmp_228_rule(p), !p.error_indicator) && (_literal = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block after 'except' statement on line %d", a.lineno);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var newline_var;
          if ((a = $B._PyPegen.expect_token(p, 677)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block after 'except' statement on line %d", a.lineno);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_except_star_stmt_indent_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var expression_var;
          var newline_var;
          if ((a = $B._PyPegen.expect_token(p, 677)) && (_literal = $B._PyPegen.expect_token(p, 16)) && (expression_var = expression_rule(p)) && (_opt_var = _tmp_229_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block after 'except*' statement on line %d", a.lineno);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_match_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var newline_var;
          var subject_expr_var;
          if ((_keyword = $B._PyPegen.expect_soft_keyword(p, "match")) && (subject_expr_var = subject_expr_rule(p)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = $B.helper_functions.CHECK_VERSION(NULL, 10, "expected ':'", $B.helper_functions.RAISE_SYNTAX_ERROR(p, "Pattern matching is"));
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var newline_var;
          var subject;
          if ((a = $B._PyPegen.expect_soft_keyword(p, "match")) && (subject = subject_expr_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block after 'match' statement on line %d", a.lineno);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_case_block_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _opt_var;
          UNUSED(_opt_var);
          var newline_var;
          var patterns_var;
          if ((_keyword = $B._PyPegen.expect_soft_keyword(p, "case")) && (patterns_var = patterns_rule(p)) && (_opt_var = guard_rule(p), !p.error_indicator) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "expected ':'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var newline_var;
          var patterns_var;
          if ((a = $B._PyPegen.expect_soft_keyword(p, "case")) && (patterns_var = patterns_rule(p)) && (_opt_var = guard_rule(p), !p.error_indicator) && (_literal = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block after 'case' statement on line %d", a.lineno);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_as_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          var or_pattern_var;
          if ((or_pattern_var = or_pattern_rule(p)) && (_keyword = $B._PyPegen.expect_token(p, 680)) && (a = $B._PyPegen.expect_soft_keyword(p, "_"))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "cannot use '_' as a target");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var a;
          var or_pattern_var;
          if ((or_pattern_var = or_pattern_rule(p)) && (_keyword = $B._PyPegen.expect_token(p, 680)) && (a = expression_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "cannot use %s as pattern target", $B._PyPegen.get_expr_name(a));
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_class_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var name_or_attr_var;
          if ((name_or_attr_var = name_or_attr_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 7)) && (a = invalid_class_argument_pattern_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, $B.PyPegen.first_item(a, $B.ast.pattern), $B.PyPegen.last_item(a, $B.ast.pattern), "positional patterns follow keyword patterns");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_class_argument_pattern_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var keyword_patterns_var;
          if ((_opt_var = _tmp_230_rule(p), !p.error_indicator) && (keyword_patterns_var = keyword_patterns_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (a = positional_patterns_rule(p))) {
            _res = a;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_if_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var named_expression_var;
          var newline_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 682)) && (named_expression_var = named_expression_rule(p)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "expected ':'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var a_1;
          var newline_var;
          if ((a = $B._PyPegen.expect_token(p, 682)) && (a_1 = named_expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block after 'if' statement on line %d", a.lineno);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_elif_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var named_expression_var;
          var newline_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 687)) && (named_expression_var = named_expression_rule(p)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "expected ':'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var named_expression_var;
          var newline_var;
          if ((a = $B._PyPegen.expect_token(p, 687)) && (named_expression_var = named_expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block after 'elif' statement on line %d", a.lineno);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_else_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var newline_var;
          if ((a = $B._PyPegen.expect_token(p, 686)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block after 'else' statement on line %d", a.lineno);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var _literal;
          var block_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 686)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (block_var = block_rule(p)) && (_keyword_1 = $B._PyPegen.expect_token(p, 687))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "'elif' block follows an 'else' block");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_while_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var named_expression_var;
          var newline_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 689)) && (named_expression_var = named_expression_rule(p)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "expected ':'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var named_expression_var;
          var newline_var;
          if ((a = $B._PyPegen.expect_token(p, 689)) && (named_expression_var = named_expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block after 'while' statement on line %d", a.lineno);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_for_stmt_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _keyword_1;
          var _opt_var;
          UNUSED(_opt_var);
          var newline_var;
          var star_expressions_var;
          var star_targets_var;
          if ((_opt_var = $B._PyPegen.expect_token(p, 698), !p.error_indicator) && (_keyword = $B._PyPegen.expect_token(p, 694)) && (star_targets_var = star_targets_rule(p)) && (_keyword_1 = $B._PyPegen.expect_token(p, 695)) && (star_expressions_var = star_expressions_rule(p)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "expected ':'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var _opt_var;
          UNUSED(_opt_var);
          var a;
          var newline_var;
          var star_expressions_var;
          var star_targets_var;
          if ((_opt_var = $B._PyPegen.expect_token(p, 698), !p.error_indicator) && (a = $B._PyPegen.expect_token(p, 694)) && (star_targets_var = star_targets_rule(p)) && (_keyword = $B._PyPegen.expect_token(p, 695)) && (star_expressions_var = star_expressions_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block after 'for' statement on line %d", a.lineno);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_def_raw_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _literal_2;
          var _opt_var;
          UNUSED(_opt_var);
          var _opt_var_1;
          UNUSED(_opt_var_1);
          var _opt_var_2;
          UNUSED(_opt_var_2);
          var _opt_var_3;
          UNUSED(_opt_var_3);
          var a;
          var name_var;
          var newline_var;
          if ((_opt_var = $B._PyPegen.expect_token(p, 698), !p.error_indicator) && (a = $B._PyPegen.expect_token(p, 699)) && (name_var = $B._PyPegen.name_token(p)) && (_opt_var_1 = type_params_rule(p), !p.error_indicator) && (_literal = $B._PyPegen.expect_token(p, 7)) && (_opt_var_2 = params_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8)) && (_opt_var_3 = _tmp_231_rule(p), !p.error_indicator) && (_literal_2 = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block after function definition on line %d", a.lineno);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _literal;
          var _literal_1;
          var _literal_2;
          var _opt_var;
          UNUSED(_opt_var);
          var _opt_var_1;
          UNUSED(_opt_var_1);
          var _opt_var_2;
          UNUSED(_opt_var_2);
          var _opt_var_3;
          UNUSED(_opt_var_3);
          var _opt_var_4;
          UNUSED(_opt_var_4);
          var block_var;
          var name_var;
          if ((_opt_var = $B._PyPegen.expect_token(p, 698), !p.error_indicator) && (_keyword = $B._PyPegen.expect_token(p, 699)) && (name_var = $B._PyPegen.name_token(p)) && (_opt_var_1 = type_params_rule(p), !p.error_indicator) && (_literal = $B._PyPegen.expect_forced_token(p, 7, "(")) && (_opt_var_2 = params_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8)) && (_opt_var_3 = _tmp_232_rule(p), !p.error_indicator) && (_literal_2 = $B._PyPegen.expect_forced_token(p, 11, ":")) && (_opt_var_4 = func_type_comment_rule(p), !p.error_indicator) && (block_var = block_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, _opt_var, _keyword, name_var, _opt_var_1, _literal, _opt_var_2, _literal_1, _opt_var_3, _literal_2, _opt_var_4, block_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_class_def_raw_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var _opt_var;
          UNUSED(_opt_var);
          var _opt_var_1;
          UNUSED(_opt_var_1);
          var name_var;
          var newline_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 701)) && (name_var = $B._PyPegen.name_token(p)) && (_opt_var = type_params_rule(p), !p.error_indicator) && (_opt_var_1 = _tmp_233_rule(p), !p.error_indicator) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "expected ':'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _opt_var;
          UNUSED(_opt_var);
          var _opt_var_1;
          UNUSED(_opt_var_1);
          var a;
          var name_var;
          var newline_var;
          if ((a = $B._PyPegen.expect_token(p, 701)) && (name_var = $B._PyPegen.name_token(p)) && (_opt_var = type_params_rule(p), !p.error_indicator) && (_opt_var_1 = _tmp_234_rule(p), !p.error_indicator) && (_literal = $B._PyPegen.expect_token(p, 11)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, INDENT)) {
            _res = $B.helper_functions.RAISE_INDENTATION_ERROR(p, "expected an indented block after class definition on line %d", a.lineno);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_double_starred_kvpairs_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _gather_235_var;
          var _literal;
          var invalid_kvpair_var;
          if ((_gather_235_var = _gather_235_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (invalid_kvpair_var = invalid_kvpair_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, _gather_235_var, _literal, invalid_kvpair_var);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var bitwise_or_var;
          var expression_var;
          if ((expression_var = expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (a = $B._PyPegen.expect_token(p, 16)) && (bitwise_or_var = bitwise_or_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_STARTING_FROM(p, a, "cannot use a starred expression in a dictionary value");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var expression_var;
          if ((expression_var = expression_rule(p)) && (a = $B._PyPegen.expect_token(p, 11)) && $B._PyPegen.lookahead(1, _tmp_237_rule, p)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "expression expected after dictionary key and ':'");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_kvpair_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          if ((a = expression_rule(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 11)) {
            _res = $B.helper_functions.RAISE_ERROR_KNOWN_LOCATION(p, $B.parser_constants.PyExc_SyntaxError, a.lineno, a.end_col_offset - 1, a.end_lineno, -1, "':' expected after dictionary key");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var bitwise_or_var;
          var expression_var;
          if ((expression_var = expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 11)) && (a = $B._PyPegen.expect_token(p, 16)) && (bitwise_or_var = bitwise_or_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_STARTING_FROM(p, a, "cannot use a starred expression in a dictionary value");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var expression_var;
          if ((expression_var = expression_rule(p)) && (a = $B._PyPegen.expect_token(p, 11)) && $B._PyPegen.lookahead(1, _tmp_238_rule, p)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "expression expected after dictionary key and ':'");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_starred_expression_unpacking_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          var b;
          var expression_var;
          if ((a = $B._PyPegen.expect_token(p, 16)) && (expression_var = expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 22)) && (b = expression_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "cannot assign to iterable argument unpacking");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_starred_expression_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 16)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR(p, "Invalid star expression");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_fstring_replacement_field_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (a = $B._PyPegen.expect_token(p, 22))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "f-string: valid expression required before '='");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (a = $B._PyPegen.expect_token(p, 54))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "f-string: valid expression required before '!'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (a = $B._PyPegen.expect_token(p, 11))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "f-string: valid expression required before ':'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (a = $B._PyPegen.expect_token(p, 26))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "f-string: valid expression required before '}'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && $B._PyPegen.lookahead(0, annotated_rhs_rule, p)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "f-string: expecting a valid expression after '{'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var annotated_rhs_var;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (annotated_rhs_var = annotated_rhs_rule(p)) && $B._PyPegen.lookahead(0, _tmp_239_rule, p)) {
            _res = $B.helper_functions.$B._PyPegen.PyErr_Occurred() ? $B.parser_constants.NULL : $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "f-string: expecting '=', or '!', or ':', or '}'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var annotated_rhs_var;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (annotated_rhs_var = annotated_rhs_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 22)) && $B._PyPegen.lookahead(0, _tmp_240_rule, p)) {
            _res = $B.helper_functions.$B._PyPegen.PyErr_Occurred() ? $B.parser_constants.NULL : $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "f-string: expecting '!', or ':', or '}'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _opt_var;
          UNUSED(_opt_var);
          var annotated_rhs_var;
          var invalid_fstring_conversion_character_var;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (annotated_rhs_var = annotated_rhs_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 22), !p.error_indicator) && (invalid_fstring_conversion_character_var = invalid_fstring_conversion_character_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, _literal, annotated_rhs_var, _opt_var, invalid_fstring_conversion_character_var);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _opt_var;
          UNUSED(_opt_var);
          var _opt_var_1;
          UNUSED(_opt_var_1);
          var annotated_rhs_var;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (annotated_rhs_var = annotated_rhs_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 22), !p.error_indicator) && (_opt_var_1 = _tmp_241_rule(p), !p.error_indicator) && $B._PyPegen.lookahead(0, _tmp_242_rule, p)) {
            _res = $B.helper_functions.$B._PyPegen.PyErr_Occurred() ? $B.parser_constants.NULL : $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "f-string: expecting ':' or '}'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _loop0_244_var;
          var _opt_var;
          UNUSED(_opt_var);
          var _opt_var_1;
          UNUSED(_opt_var_1);
          var annotated_rhs_var;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (annotated_rhs_var = annotated_rhs_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 22), !p.error_indicator) && (_opt_var_1 = _tmp_243_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 11)) && (_loop0_244_var = _loop0_244_rule(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 26)) {
            _res = $B.helper_functions.$B._PyPegen.PyErr_Occurred() ? $B.parser_constants.NULL : $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "f-string: expecting '}', or format specs");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _opt_var;
          UNUSED(_opt_var);
          var _opt_var_1;
          UNUSED(_opt_var_1);
          var annotated_rhs_var;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (annotated_rhs_var = annotated_rhs_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 22), !p.error_indicator) && (_opt_var_1 = _tmp_245_rule(p), !p.error_indicator) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 26)) {
            _res = $B.helper_functions.$B._PyPegen.PyErr_Occurred() ? $B.parser_constants.NULL : $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "f-string: expecting '}'");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_fstring_conversion_character_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if ((_literal = $B._PyPegen.expect_token(p, 54)) && $B._PyPegen.lookahead(1, _tmp_246_rule, p)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "f-string: missing conversion character");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if ((_literal = $B._PyPegen.expect_token(p, 54)) && $B._PyPegen.lookahead_with_name(0, $B._PyPegen.name_token, p)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "f-string: invalid conversion character");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_tstring_replacement_field_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (a = $B._PyPegen.expect_token(p, 22))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "t-string: valid expression required before '='");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (a = $B._PyPegen.expect_token(p, 54))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "t-string: valid expression required before '!'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (a = $B._PyPegen.expect_token(p, 11))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "t-string: valid expression required before ':'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var a;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (a = $B._PyPegen.expect_token(p, 26))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(p, a, "t-string: valid expression required before '}'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && $B._PyPegen.lookahead(0, annotated_rhs_rule, p)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "t-string: expecting a valid expression after '{'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var annotated_rhs_var;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (annotated_rhs_var = annotated_rhs_rule(p)) && $B._PyPegen.lookahead(0, _tmp_247_rule, p)) {
            _res = $B.helper_functions.$B._PyPegen.PyErr_Occurred() ? $B.parser_constants.NULL : $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "t-string: expecting '=', or '!', or ':', or '}'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var annotated_rhs_var;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (annotated_rhs_var = annotated_rhs_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 22)) && $B._PyPegen.lookahead(0, _tmp_248_rule, p)) {
            _res = $B.helper_functions.$B._PyPegen.PyErr_Occurred() ? $B.parser_constants.NULL : $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "t-string: expecting '!', or ':', or '}'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _opt_var;
          UNUSED(_opt_var);
          var annotated_rhs_var;
          var invalid_tstring_conversion_character_var;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (annotated_rhs_var = annotated_rhs_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 22), !p.error_indicator) && (invalid_tstring_conversion_character_var = invalid_tstring_conversion_character_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, _literal, annotated_rhs_var, _opt_var, invalid_tstring_conversion_character_var);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _opt_var;
          UNUSED(_opt_var);
          var _opt_var_1;
          UNUSED(_opt_var_1);
          var annotated_rhs_var;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (annotated_rhs_var = annotated_rhs_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 22), !p.error_indicator) && (_opt_var_1 = _tmp_249_rule(p), !p.error_indicator) && $B._PyPegen.lookahead(0, _tmp_250_rule, p)) {
            _res = $B.helper_functions.$B._PyPegen.PyErr_Occurred() ? $B.parser_constants.NULL : $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "t-string: expecting ':' or '}'");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _loop0_252_var;
          var _opt_var;
          UNUSED(_opt_var);
          var _opt_var_1;
          UNUSED(_opt_var_1);
          var annotated_rhs_var;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (annotated_rhs_var = annotated_rhs_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 22), !p.error_indicator) && (_opt_var_1 = _tmp_251_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 11)) && (_loop0_252_var = _loop0_252_rule(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 26)) {
            _res = $B.helper_functions.$B._PyPegen.PyErr_Occurred() ? $B.parser_constants.NULL : $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "t-string: expecting '}', or format specs");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _opt_var;
          UNUSED(_opt_var);
          var _opt_var_1;
          UNUSED(_opt_var_1);
          var annotated_rhs_var;
          if ((_literal = $B._PyPegen.expect_token(p, 25)) && (annotated_rhs_var = annotated_rhs_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 22), !p.error_indicator) && (_opt_var_1 = _tmp_253_rule(p), !p.error_indicator) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 26)) {
            _res = $B.helper_functions.$B._PyPegen.PyErr_Occurred() ? $B.parser_constants.NULL : $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "t-string: expecting '}'");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_tstring_conversion_character_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if ((_literal = $B._PyPegen.expect_token(p, 54)) && $B._PyPegen.lookahead(1, _tmp_254_rule, p)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "t-string: missing conversion character");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if ((_literal = $B._PyPegen.expect_token(p, 54)) && $B._PyPegen.lookahead_with_name(0, $B._PyPegen.name_token, p)) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN(p, "t-string: invalid conversion character");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_string_tstring_concat_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = _loop1_255_rule(p)) && (b = tstring_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, $B.PyPegen.last_item(a, $B.ast.expr), b, "cannot mix t-string literals with string or bytes literals");
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var a;
          var b;
          if ((a = _loop1_256_rule(p)) && (b = _tmp_257_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, $B.PyPegen.last_item(a, $B.ast.expr), b, "cannot mix t-string literals with string or bytes literals");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_arithmetic_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _tmp_258_var;
          var a;
          var b;
          var sum_var;
          if ((sum_var = sum_rule(p)) && (_tmp_258_var = _tmp_258_rule(p)) && (a = $B._PyPegen.expect_token(p, 703)) && (b = inversion_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "'not' after an operator must be parenthesized");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_factor_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _tmp_259_var;
          var a;
          var b;
          if ((_tmp_259_var = _tmp_259_rule(p)) && (a = $B._PyPegen.expect_token(p, 703)) && (b = factor_rule(p))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_KNOWN_RANGE(p, a, b, "'not' after an operator must be parenthesized");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function invalid_type_params_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var token;
          if ((_literal = $B._PyPegen.expect_token(p, 9)) && (token = $B._PyPegen.expect_token(p, 10))) {
            _res = $B.helper_functions.RAISE_SYNTAX_ERROR_STARTING_FROM(p, token, "Type parameter list cannot be empty");
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_1_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var newline_var;
        while (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) {
          _res = newline_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_2_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var newline_var;
        while (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) {
          _res = newline_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_3_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var statement_var;
        while (statement_var = statement_rule(p)) {
          _res = statement_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop0_5_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 13)) && (elem = simple_stmt_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_4_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = simple_stmt_rule(p)) && (seq = _loop0_5_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_6_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 634)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 633)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_7_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 699)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 49)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 698)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_8_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 701)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 49)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_9_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 647)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 698)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_10_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 694)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 698)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_11_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var d;
          if ((_literal = $B._PyPegen.expect_token(p, 22)) && (d = annotated_rhs_rule(p))) {
            _res = d;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_12_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var b;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (b = single_target_rule(p)) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            _res = b;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var single_subscript_attribute_target_var;
          if (single_subscript_attribute_target_var = single_subscript_attribute_target_rule(p)) {
            _res = single_subscript_attribute_target_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_13_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var d;
          if ((_literal = $B._PyPegen.expect_token(p, 22)) && (d = annotated_rhs_rule(p))) {
            _res = d;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop1_14_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_260_var;
        while (_tmp_260_var = _tmp_260_rule(p)) {
          _res = _tmp_260_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _tmp_15_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var z;
          if ((_keyword = $B._PyPegen.expect_token(p, 633)) && (z = expression_rule(p))) {
            _res = z;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_17_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = $B._PyPegen.name_token(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_16_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = $B._PyPegen.name_token(p)) && (seq = _loop0_17_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_19_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = $B._PyPegen.name_token(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_18_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = $B._PyPegen.name_token(p)) && (seq = _loop0_19_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_20_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 13)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var newline_var;
          if (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) {
            _res = newline_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_21_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var z;
          if ((_literal = $B._PyPegen.expect_token(p, 12)) && (z = expression_rule(p))) {
            _res = z;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_22_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_261_var;
        while (_tmp_261_var = _tmp_261_rule(p)) {
          _res = _tmp_261_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_23_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_262_var;
        while (_tmp_262_var = _tmp_262_rule(p)) {
          _res = _tmp_262_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop0_25_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = import_from_as_name_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_24_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = import_from_as_name_rule(p)) && (seq = _loop0_25_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_26_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var z;
          if ((_keyword = $B._PyPegen.expect_token(p, 680)) && (z = $B._PyPegen.name_token(p))) {
            _res = z;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_28_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = dotted_as_name_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_27_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = dotted_as_name_rule(p)) && (seq = _loop0_28_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_29_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var z;
          if ((_keyword = $B._PyPegen.expect_token(p, 680)) && (z = $B._PyPegen.name_token(p))) {
            _res = z;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop1_30_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_263_var;
        while (_tmp_263_var = _tmp_263_rule(p)) {
          _res = _tmp_263_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _tmp_31_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var z;
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (z = arguments_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            _res = z;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_32_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var z;
          if ((_literal = $B._PyPegen.expect_token(p, 51)) && (z = expression_rule(p))) {
            _res = z;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_33_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var z;
          if ((_literal = $B._PyPegen.expect_token(p, 51)) && (z = expression_rule(p))) {
            _res = z;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_34_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_no_default_var;
        while (param_no_default_var = param_no_default_rule(p)) {
          _res = param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_35_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_with_default_var;
        while (param_with_default_var = param_with_default_rule(p)) {
          _res = param_with_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_36_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_with_default_var;
        while (param_with_default_var = param_with_default_rule(p)) {
          _res = param_with_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_37_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_no_default_var;
        while (param_no_default_var = param_no_default_rule(p)) {
          _res = param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop0_38_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_with_default_var;
        while (param_with_default_var = param_with_default_rule(p)) {
          _res = param_with_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_39_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_with_default_var;
        while (param_with_default_var = param_with_default_rule(p)) {
          _res = param_with_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop1_40_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_no_default_var;
        while (param_no_default_var = param_no_default_rule(p)) {
          _res = param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop1_41_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_no_default_var;
        while (param_no_default_var = param_no_default_rule(p)) {
          _res = param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop0_42_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_no_default_var;
        while (param_no_default_var = param_no_default_rule(p)) {
          _res = param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_43_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_with_default_var;
        while (param_with_default_var = param_with_default_rule(p)) {
          _res = param_with_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop0_44_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_no_default_var;
        while (param_no_default_var = param_no_default_rule(p)) {
          _res = param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_45_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_with_default_var;
        while (param_with_default_var = param_with_default_rule(p)) {
          _res = param_with_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop0_46_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_maybe_default_var;
        while (param_maybe_default_var = param_maybe_default_rule(p)) {
          _res = param_maybe_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_47_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_maybe_default_var;
        while (param_maybe_default_var = param_maybe_default_rule(p)) {
          _res = param_maybe_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_48_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_maybe_default_var;
        while (param_maybe_default_var = param_maybe_default_rule(p)) {
          _res = param_maybe_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop0_50_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = with_item_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_49_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = with_item_rule(p)) && (seq = _loop0_50_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_52_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = with_item_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_51_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = with_item_rule(p)) && (seq = _loop0_52_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_54_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = with_item_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_53_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = with_item_rule(p)) && (seq = _loop0_54_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_56_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = with_item_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_55_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = with_item_rule(p)) && (seq = _loop0_56_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_57_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 12)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 8)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 11)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop1_58_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var except_block_var;
        while (except_block_var = except_block_rule(p)) {
          _res = except_block_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop1_59_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var except_star_block_var;
        while (except_star_block_var = except_star_block_rule(p)) {
          _res = except_star_block_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop1_60_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var case_block_var;
        while (case_block_var = case_block_rule(p)) {
          _res = case_block_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop0_62_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 18)) && (elem = closed_pattern_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_61_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = closed_pattern_rule(p)) && (seq = _loop0_62_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_63_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 14)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 15)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_64_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 14)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 15)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_65_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var string_var;
          if (string_var = $B._PyPegen.string_token(p)) {
            _res = string_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var fstring_start_var;
          if (fstring_start_var = $B._PyPegen.expect_token(p, FSTRING_START)) {
            _res = fstring_start_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var tstring_start_var;
          if (tstring_start_var = $B._PyPegen.expect_token(p, TSTRING_START)) {
            _res = tstring_start_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_66_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 23)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 7)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 22)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_67_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 23)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 7)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 22)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_69_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = maybe_star_pattern_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_68_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = maybe_star_pattern_rule(p)) && (seq = _loop0_69_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_71_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = key_value_pattern_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_70_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = key_value_pattern_rule(p)) && (seq = _loop0_71_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_72_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var literal_expr_var;
          if (literal_expr_var = literal_expr_rule(p)) {
            _res = literal_expr_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var attr_var;
          if (attr_var = attr_rule(p)) {
            _res = attr_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_74_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = pattern_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_73_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = pattern_rule(p)) && (seq = _loop0_74_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_76_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = keyword_pattern_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_75_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = keyword_pattern_rule(p)) && (seq = _loop0_76_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_78_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = type_param_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_77_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = type_param_rule(p)) && (seq = _loop0_78_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop1_79_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_264_var;
        while (_tmp_264_var = _tmp_264_rule(p)) {
          _res = _tmp_264_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop1_80_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_265_var;
        while (_tmp_265_var = _tmp_265_rule(p)) {
          _res = _tmp_265_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop0_82_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = star_named_expression_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_81_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = star_named_expression_rule(p)) && (seq = _loop0_82_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop1_83_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_266_var;
        while (_tmp_266_var = _tmp_266_rule(p)) {
          _res = _tmp_266_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop1_84_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_267_var;
        while (_tmp_267_var = _tmp_267_rule(p)) {
          _res = _tmp_267_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop1_85_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var compare_op_bitwise_or_pair_var;
        while (compare_op_bitwise_or_pair_var = compare_op_bitwise_or_pair_rule(p)) {
          _res = compare_op_bitwise_or_pair_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _tmp_86_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var tok;
          if (tok = $B._PyPegen.expect_token(p, 28)) {
            _res = $B._PyPegen.check_barry_as_flufl(p, tok) ? $B.parser_constants.NULL : tok;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_88_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = _tmp_268_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_87_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = _tmp_268_rule(p)) && (seq = _loop0_88_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_89_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var d;
          if ((_literal = $B._PyPegen.expect_token(p, 11)) && (d = expression_rule(p), !p.error_indicator)) {
            _res = d;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_90_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var string_var;
          if (string_var = $B._PyPegen.string_token(p)) {
            _res = string_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var fstring_start_var;
          if (fstring_start_var = $B._PyPegen.expect_token(p, FSTRING_START)) {
            _res = fstring_start_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var tstring_start_var;
          if (tstring_start_var = $B._PyPegen.expect_token(p, TSTRING_START)) {
            _res = tstring_start_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_91_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var tuple_var;
          if (tuple_var = tuple_rule(p)) {
            _res = tuple_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var group_var;
          if (group_var = group_rule(p)) {
            _res = group_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var genexp_var;
          if (genexp_var = genexp_rule(p)) {
            _res = genexp_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_92_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var list_var;
          if (list_var = list_rule(p)) {
            _res = list_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var listcomp_var;
          if (listcomp_var = listcomp_rule(p)) {
            _res = listcomp_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_93_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var dict_var;
          if (dict_var = dict_rule(p)) {
            _res = dict_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var set_var;
          if (set_var = set_rule(p)) {
            _res = set_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var dictcomp_var;
          if (dictcomp_var = dictcomp_rule(p)) {
            _res = dictcomp_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var setcomp_var;
          if (setcomp_var = setcomp_rule(p)) {
            _res = setcomp_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_94_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var yield_expr_var;
          if (yield_expr_var = yield_expr_rule(p)) {
            _res = yield_expr_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var named_expression_var;
          if (named_expression_var = named_expression_rule(p)) {
            _res = named_expression_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_95_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_no_default_var;
        while (lambda_param_no_default_var = lambda_param_no_default_rule(p)) {
          _res = lambda_param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_96_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_with_default_var;
        while (lambda_param_with_default_var = lambda_param_with_default_rule(p)) {
          _res = lambda_param_with_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_97_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_with_default_var;
        while (lambda_param_with_default_var = lambda_param_with_default_rule(p)) {
          _res = lambda_param_with_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_98_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_no_default_var;
        while (lambda_param_no_default_var = lambda_param_no_default_rule(p)) {
          _res = lambda_param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop0_99_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_with_default_var;
        while (lambda_param_with_default_var = lambda_param_with_default_rule(p)) {
          _res = lambda_param_with_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_100_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_with_default_var;
        while (lambda_param_with_default_var = lambda_param_with_default_rule(p)) {
          _res = lambda_param_with_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop1_101_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_no_default_var;
        while (lambda_param_no_default_var = lambda_param_no_default_rule(p)) {
          _res = lambda_param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop1_102_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_no_default_var;
        while (lambda_param_no_default_var = lambda_param_no_default_rule(p)) {
          _res = lambda_param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop0_103_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_no_default_var;
        while (lambda_param_no_default_var = lambda_param_no_default_rule(p)) {
          _res = lambda_param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_104_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_with_default_var;
        while (lambda_param_with_default_var = lambda_param_with_default_rule(p)) {
          _res = lambda_param_with_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop0_105_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_no_default_var;
        while (lambda_param_no_default_var = lambda_param_no_default_rule(p)) {
          _res = lambda_param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_106_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_with_default_var;
        while (lambda_param_with_default_var = lambda_param_with_default_rule(p)) {
          _res = lambda_param_with_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop0_107_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_maybe_default_var;
        while (lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p)) {
          _res = lambda_param_maybe_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_108_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_maybe_default_var;
        while (lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p)) {
          _res = lambda_param_maybe_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop0_109_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var fstring_format_spec_var;
        while (fstring_format_spec_var = fstring_format_spec_rule(p)) {
          _res = fstring_format_spec_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_110_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var fstring_middle_var;
        while (fstring_middle_var = fstring_middle_rule(p)) {
          _res = fstring_middle_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_111_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var tstring_format_spec_var;
        while (tstring_format_spec_var = tstring_format_spec_rule(p)) {
          _res = tstring_format_spec_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_112_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var tstring_middle_var;
        while (tstring_middle_var = tstring_middle_rule(p)) {
          _res = tstring_middle_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_113_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_269_var;
        while (_tmp_269_var = _tmp_269_rule(p)) {
          _res = _tmp_269_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop1_114_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var tstring_var;
        while (tstring_var = tstring_rule(p)) {
          _res = tstring_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _tmp_115_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var y;
          var z;
          if ((y = star_named_expression_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (z = star_named_expressions_rule(p), !p.error_indicator)) {
            _res = $B._PyPegen.seq_insert_in_front(p, y, z);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_117_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = double_starred_kvpair_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_116_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = double_starred_kvpair_rule(p)) && (seq = _loop0_117_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop1_118_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var for_if_clause_var;
        while (for_if_clause_var = for_if_clause_rule(p)) {
          _res = for_if_clause_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop0_119_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_270_var;
        while (_tmp_270_var = _tmp_270_rule(p)) {
          _res = _tmp_270_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_120_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_271_var;
        while (_tmp_271_var = _tmp_271_rule(p)) {
          _res = _tmp_271_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _tmp_121_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var assignment_expression_var;
          if (assignment_expression_var = assignment_expression_rule(p)) {
            _res = assignment_expression_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var expression_var;
          if ((expression_var = expression_rule(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 53)) {
            _res = expression_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_123_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = _tmp_272_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_122_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = _tmp_272_rule(p)) && (seq = _loop0_123_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_124_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var k;
          if ((_literal = $B._PyPegen.expect_token(p, 12)) && (k = kwargs_rule(p))) {
            _res = k;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_126_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = kwarg_or_starred_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_125_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = kwarg_or_starred_rule(p)) && (seq = _loop0_126_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_128_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = kwarg_or_double_starred_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_127_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = kwarg_or_double_starred_rule(p)) && (seq = _loop0_128_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_130_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = kwarg_or_starred_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_129_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = kwarg_or_starred_rule(p)) && (seq = _loop0_130_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_132_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = kwarg_or_double_starred_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_131_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = kwarg_or_double_starred_rule(p)) && (seq = _loop0_132_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_133_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_273_var;
        while (_tmp_273_var = _tmp_273_rule(p)) {
          _res = _tmp_273_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_135_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = star_target_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_134_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = star_target_rule(p)) && (seq = _loop0_135_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop1_136_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_274_var;
        while (_tmp_274_var = _tmp_274_rule(p)) {
          _res = _tmp_274_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _tmp_137_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var star_target_var;
          if ($B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 16) && (star_target_var = star_target_rule(p))) {
            _res = star_target_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_139_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = del_target_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_138_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = del_target_rule(p)) && (seq = _loop0_139_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_141_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = expression_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_140_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = expression_rule(p)) && (seq = _loop0_141_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_143_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = expression_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_142_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = expression_rule(p)) && (seq = _loop0_143_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_145_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = expression_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_144_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = expression_rule(p)) && (seq = _loop0_145_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_147_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = expression_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_146_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = expression_rule(p)) && (seq = _loop0_147_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_148_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var indent_var;
          var newline_var;
          if ((newline_var = $B._PyPegen.expect_token(p, NEWLINE)) && (indent_var = $B._PyPegen.expect_token(p, INDENT))) {
            _res = $B._PyPegen.dummy_name(p, newline_var, indent_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_149_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _tmp_275_var;
          if (_tmp_275_var = _tmp_275_rule(p)) {
            _res = _tmp_275_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var kwargs_var;
          if (kwargs_var = kwargs_rule(p)) {
            _res = kwargs_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_151_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = _tmp_276_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_150_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = _tmp_276_rule(p)) && (seq = _loop0_151_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_152_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var args_var;
          if (args_var = args_rule(p)) {
            _res = args_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var expression_var;
          var for_if_clauses_var;
          if ((expression_var = expression_rule(p)) && (for_if_clauses_var = for_if_clauses_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, expression_var, for_if_clauses_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_153_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var args_var;
          if ((args_var = args_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12))) {
            _res = $B._PyPegen.dummy_name(p, args_var, _literal);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_154_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 12)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 8)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_155_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 622)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 624)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 623)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_156_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var name_var;
          if ((name_var = $B._PyPegen.name_token(p)) && (_literal = $B._PyPegen.expect_token(p, 22))) {
            _res = $B._PyPegen.dummy_name(p, name_var, _literal);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop1_157_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_277_var;
        while (_tmp_277_var = _tmp_277_rule(p)) {
          _res = _tmp_277_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _tmp_158_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var name_var;
          var string_var;
          if ((name_var = $B._PyPegen.name_token(p)) && (string_var = $B._PyPegen.string_token(p))) {
            _res = $B._PyPegen.dummy_name(p, name_var, string_var);
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var soft_keyword_var;
          if (soft_keyword_var = $B._PyPegen.soft_keyword_token(p)) {
            _res = soft_keyword_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_159_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 686)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 11)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_160_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var pass_stmt_var;
          if (pass_stmt_var = pass_stmt_rule(p)) {
            _res = pass_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var break_stmt_var;
          if (break_stmt_var = break_stmt_rule(p)) {
            _res = break_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var continue_stmt_var;
          if (continue_stmt_var = continue_stmt_rule(p)) {
            _res = continue_stmt_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_161_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 22)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 53)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_162_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var list_var;
          if (list_var = list_rule(p)) {
            _res = list_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var tuple_var;
          if (tuple_var = tuple_rule(p)) {
            _res = tuple_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var genexp_var;
          if (genexp_var = genexp_rule(p)) {
            _res = genexp_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 622)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 623)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 624)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_163_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 22)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 53)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_164_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var star_named_expressions_var;
        while (star_named_expressions_var = star_named_expressions_rule(p)) {
          _res = star_named_expressions_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_165_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_278_var;
        while (_tmp_278_var = _tmp_278_rule(p)) {
          _res = _tmp_278_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_166_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_279_var;
        while (_tmp_279_var = _tmp_279_rule(p)) {
          _res = _tmp_279_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _tmp_167_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 9)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 7)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 25)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_168_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 9)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 25)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_169_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 9)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 25)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_170_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var slash_no_default_var;
          if (slash_no_default_var = slash_no_default_rule(p)) {
            _res = slash_no_default_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var slash_with_default_var;
          if (slash_with_default_var = slash_with_default_rule(p)) {
            _res = slash_with_default_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_171_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_maybe_default_var;
        while (param_maybe_default_var = param_maybe_default_rule(p)) {
          _res = param_maybe_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_172_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_no_default_var;
        while (param_no_default_var = param_no_default_rule(p)) {
          _res = param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_173_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_no_default_var;
        while (param_no_default_var = param_no_default_rule(p)) {
          _res = param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_174_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_no_default_var;
        while (param_no_default_var = param_no_default_rule(p)) {
          _res = param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _tmp_175_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var slash_no_default_var;
          if (slash_no_default_var = slash_no_default_rule(p)) {
            _res = slash_no_default_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var slash_with_default_var;
          if (slash_with_default_var = slash_with_default_rule(p)) {
            _res = slash_with_default_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_176_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_maybe_default_var;
        while (param_maybe_default_var = param_maybe_default_rule(p)) {
          _res = param_maybe_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _tmp_177_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 12)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var param_no_default_var;
          if (param_no_default_var = param_no_default_rule(p)) {
            _res = param_no_default_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_178_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_maybe_default_var;
        while (param_maybe_default_var = param_maybe_default_rule(p)) {
          _res = param_maybe_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_179_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_maybe_default_var;
        while (param_maybe_default_var = param_maybe_default_rule(p)) {
          _res = param_maybe_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _tmp_180_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 8)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 12)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_181_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 8)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _tmp_280_var;
          if ((_literal = $B._PyPegen.expect_token(p, 12)) && (_tmp_280_var = _tmp_280_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, _literal, _tmp_280_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_182_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var param_no_default_var;
          if (param_no_default_var = param_no_default_rule(p)) {
            _res = param_no_default_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 12)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_183_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_maybe_default_var;
        while (param_maybe_default_var = param_maybe_default_rule(p)) {
          _res = param_maybe_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _tmp_184_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var param_no_default_var;
          if (param_no_default_var = param_no_default_rule(p)) {
            _res = param_no_default_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 12)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_185_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 16)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 35)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 17)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop1_186_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var param_with_default_var;
        while (param_with_default_var = param_with_default_rule(p)) {
          _res = param_with_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _tmp_187_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var lambda_slash_no_default_var;
          if (lambda_slash_no_default_var = lambda_slash_no_default_rule(p)) {
            _res = lambda_slash_no_default_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var lambda_slash_with_default_var;
          if (lambda_slash_with_default_var = lambda_slash_with_default_rule(p)) {
            _res = lambda_slash_with_default_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_188_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_maybe_default_var;
        while (lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p)) {
          _res = lambda_param_maybe_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_189_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_no_default_var;
        while (lambda_param_no_default_var = lambda_param_no_default_rule(p)) {
          _res = lambda_param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_190_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_no_default_var;
        while (lambda_param_no_default_var = lambda_param_no_default_rule(p)) {
          _res = lambda_param_no_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop0_192_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = lambda_param_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_191_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = lambda_param_rule(p)) && (seq = _loop0_192_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_193_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var lambda_slash_no_default_var;
          if (lambda_slash_no_default_var = lambda_slash_no_default_rule(p)) {
            _res = lambda_slash_no_default_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var lambda_slash_with_default_var;
          if (lambda_slash_with_default_var = lambda_slash_with_default_rule(p)) {
            _res = lambda_slash_with_default_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_194_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_maybe_default_var;
        while (lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p)) {
          _res = lambda_param_maybe_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _tmp_195_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 12)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var lambda_param_no_default_var;
          if (lambda_param_no_default_var = lambda_param_no_default_rule(p)) {
            _res = lambda_param_no_default_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_196_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_maybe_default_var;
        while (lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p)) {
          _res = lambda_param_maybe_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_197_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_maybe_default_var;
        while (lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p)) {
          _res = lambda_param_maybe_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop1_198_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_with_default_var;
        while (lambda_param_with_default_var = lambda_param_with_default_rule(p)) {
          _res = lambda_param_with_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _tmp_199_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 11)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _tmp_281_var;
          if ((_literal = $B._PyPegen.expect_token(p, 12)) && (_tmp_281_var = _tmp_281_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, _literal, _tmp_281_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_200_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var lambda_param_no_default_var;
          if (lambda_param_no_default_var = lambda_param_no_default_rule(p)) {
            _res = lambda_param_no_default_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 12)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_201_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var lambda_param_maybe_default_var;
        while (lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p)) {
          _res = lambda_param_maybe_default_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _tmp_202_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var lambda_param_no_default_var;
          if (lambda_param_no_default_var = lambda_param_no_default_rule(p)) {
            _res = lambda_param_no_default_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 12)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_203_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 16)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 35)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 17)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_204_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 12)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 8)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 11)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_205_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _loop0_282_var;
          var _opt_var;
          UNUSED(_opt_var);
          var bitwise_or_var;
          if ((bitwise_or_var = bitwise_or_rule(p)) && (_loop0_282_var = _loop0_282_rule(p)) && (_opt_var = $B._PyPegen.expect_token(p, 12), !p.error_indicator)) {
            _res = $B._PyPegen.dummy_name(p, bitwise_or_var, _loop0_282_var, _opt_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_207_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = dotted_name_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_206_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = dotted_name_rule(p)) && (seq = _loop0_207_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_208_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _tmp_283_var;
          var name_var;
          if ((name_var = $B._PyPegen.name_token(p)) && (_tmp_283_var = _tmp_283_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, name_var, _tmp_283_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_209_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _tmp_284_var;
          var name_var;
          if ((name_var = $B._PyPegen.name_token(p)) && (_tmp_284_var = _tmp_284_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, name_var, _tmp_284_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_211_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = _tmp_285_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_210_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = _tmp_285_rule(p)) && (seq = _loop0_211_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_213_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = _tmp_286_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_212_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = _tmp_286_rule(p)) && (seq = _loop0_213_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_215_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = _tmp_287_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_214_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = _tmp_287_rule(p)) && (seq = _loop0_215_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_217_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = _tmp_288_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_216_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = _tmp_288_rule(p)) && (seq = _loop0_217_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_218_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 677)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          if (_keyword = $B._PyPegen.expect_token(p, 673)) {
            _res = _keyword;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_219_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var block_var;
        while (block_var = block_rule(p)) {
          _res = block_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_220_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var except_block_var;
        while (except_block_var = except_block_rule(p)) {
          _res = except_block_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _tmp_221_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var name_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 680)) && (name_var = $B._PyPegen.name_token(p))) {
            _res = $B._PyPegen.dummy_name(p, _keyword, name_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_222_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var block_var;
        while (block_var = block_rule(p)) {
          _res = block_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _loop1_223_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var except_star_block_var;
        while (except_star_block_var = except_star_block_rule(p)) {
          _res = except_star_block_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _tmp_224_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var expression_var;
          if ((expression_var = expression_rule(p)) && (_opt_var = _tmp_289_rule(p), !p.error_indicator)) {
            _res = $B._PyPegen.dummy_name(p, expression_var, _opt_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_225_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var name_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 680)) && (name_var = $B._PyPegen.name_token(p))) {
            _res = $B._PyPegen.dummy_name(p, _keyword, name_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_226_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var name_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 680)) && (name_var = $B._PyPegen.name_token(p))) {
            _res = $B._PyPegen.dummy_name(p, _keyword, name_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_227_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var newline_var;
          if (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) {
            _res = newline_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 11)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_228_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var name_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 680)) && (name_var = $B._PyPegen.name_token(p))) {
            _res = $B._PyPegen.dummy_name(p, _keyword, name_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_229_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var name_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 680)) && (name_var = $B._PyPegen.name_token(p))) {
            _res = $B._PyPegen.dummy_name(p, _keyword, name_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_230_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var positional_patterns_var;
          if ((positional_patterns_var = positional_patterns_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12))) {
            _res = $B._PyPegen.dummy_name(p, positional_patterns_var, _literal);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_231_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var expression_var;
          if ((_literal = $B._PyPegen.expect_token(p, 51)) && (expression_var = expression_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, _literal, expression_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_232_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var expression_var;
          if ((_literal = $B._PyPegen.expect_token(p, 51)) && (expression_var = expression_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, _literal, expression_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_233_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _opt_var;
          UNUSED(_opt_var);
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (_opt_var = arguments_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            _res = $B._PyPegen.dummy_name(p, _literal, _opt_var, _literal_1);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_234_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var _literal_1;
          var _opt_var;
          UNUSED(_opt_var);
          if ((_literal = $B._PyPegen.expect_token(p, 7)) && (_opt_var = arguments_rule(p), !p.error_indicator) && (_literal_1 = $B._PyPegen.expect_token(p, 8))) {
            _res = $B._PyPegen.dummy_name(p, _literal, _opt_var, _literal_1);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_236_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = double_starred_kvpair_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_235_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = double_starred_kvpair_rule(p)) && (seq = _loop0_236_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_237_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 26)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 12)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_238_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 26)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 12)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_239_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 22)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 54)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 11)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 26)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_240_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 54)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 11)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 26)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_241_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var name_var;
          if ((_literal = $B._PyPegen.expect_token(p, 54)) && (name_var = $B._PyPegen.name_token(p))) {
            _res = $B._PyPegen.dummy_name(p, _literal, name_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_242_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 11)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 26)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_243_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var name_var;
          if ((_literal = $B._PyPegen.expect_token(p, 54)) && (name_var = $B._PyPegen.name_token(p))) {
            _res = $B._PyPegen.dummy_name(p, _literal, name_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_244_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var fstring_format_spec_var;
        while (fstring_format_spec_var = fstring_format_spec_rule(p)) {
          _res = fstring_format_spec_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _tmp_245_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var name_var;
          if ((_literal = $B._PyPegen.expect_token(p, 54)) && (name_var = $B._PyPegen.name_token(p))) {
            _res = $B._PyPegen.dummy_name(p, _literal, name_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_246_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 11)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 26)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_247_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 22)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 54)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 11)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 26)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_248_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 54)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 11)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 26)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_249_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var name_var;
          if ((_literal = $B._PyPegen.expect_token(p, 54)) && (name_var = $B._PyPegen.name_token(p))) {
            _res = $B._PyPegen.dummy_name(p, _literal, name_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_250_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 11)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 26)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_251_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var name_var;
          if ((_literal = $B._PyPegen.expect_token(p, 54)) && (name_var = $B._PyPegen.name_token(p))) {
            _res = $B._PyPegen.dummy_name(p, _literal, name_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_252_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var fstring_format_spec_var;
        while (fstring_format_spec_var = fstring_format_spec_rule(p)) {
          _res = fstring_format_spec_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _tmp_253_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var name_var;
          if ((_literal = $B._PyPegen.expect_token(p, 54)) && (name_var = $B._PyPegen.name_token(p))) {
            _res = $B._PyPegen.dummy_name(p, _literal, name_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_254_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 11)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 26)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop1_255_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_290_var;
        while (_tmp_290_var = _tmp_290_rule(p)) {
          _res = _tmp_290_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _loop1_256_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var tstring_var;
        while (tstring_var = tstring_rule(p)) {
          _res = tstring_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      if (_n == 0 || p.error_indicator) {
        return NULL;
      }
      return _children;
    }
    function _tmp_257_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var fstring_var;
          if (fstring_var = fstring_rule(p)) {
            _res = fstring_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var string_var;
          if (string_var = string_rule(p)) {
            _res = string_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_258_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 14)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 15)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 16)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 17)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 24)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 47)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 49)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_259_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 14)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 15)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 31)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_260_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var z;
          if ((z = star_targets_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 22))) {
            _res = z;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_261_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 23)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 52)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_262_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 23)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 52)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_263_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var f;
          var newline_var;
          if ((_literal = $B._PyPegen.expect_token(p, 49)) && (f = named_expression_rule(p)) && (newline_var = $B._PyPegen.expect_token(p, NEWLINE))) {
            _res = f;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_264_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var c;
          if ((_literal = $B._PyPegen.expect_token(p, 12)) && (c = expression_rule(p))) {
            _res = c;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_265_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var c;
          if ((_literal = $B._PyPegen.expect_token(p, 12)) && (c = star_expression_rule(p))) {
            _res = c;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_266_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var c;
          if ((_keyword = $B._PyPegen.expect_token(p, 588)) && (c = conjunction_rule(p))) {
            _res = c;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_267_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var c;
          if ((_keyword = $B._PyPegen.expect_token(p, 589)) && (c = inversion_rule(p))) {
            _res = c;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_268_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var slice_var;
          if (slice_var = slice_rule(p)) {
            _res = slice_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var starred_expression_var;
          if (starred_expression_var = starred_expression_rule(p)) {
            _res = starred_expression_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_269_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var fstring_var;
          if (fstring_var = fstring_rule(p)) {
            _res = fstring_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var string_var;
          if (string_var = string_rule(p)) {
            _res = string_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_270_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var z;
          if ((_keyword = $B._PyPegen.expect_token(p, 682)) && (z = disjunction_rule(p))) {
            _res = z;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_271_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var z;
          if ((_keyword = $B._PyPegen.expect_token(p, 682)) && (z = disjunction_rule(p))) {
            _res = z;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_272_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var starred_expression_var;
          if (starred_expression_var = starred_expression_rule(p)) {
            _res = starred_expression_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _tmp_291_var;
          if ((_tmp_291_var = _tmp_291_rule(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 22)) {
            _res = _tmp_291_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_273_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var c;
          if ((_literal = $B._PyPegen.expect_token(p, 12)) && (c = star_target_rule(p))) {
            _res = c;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_274_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var c;
          if ((_literal = $B._PyPegen.expect_token(p, 12)) && (c = star_target_rule(p))) {
            _res = c;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_275_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _gather_292_var;
          var _literal;
          var kwargs_var;
          if ((_gather_292_var = _gather_292_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 12)) && (kwargs_var = kwargs_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, _gather_292_var, _literal, kwargs_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_276_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var starred_expression_var;
          if ((starred_expression_var = starred_expression_rule(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 22)) {
            _res = starred_expression_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_277_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var expression_without_invalid_var;
          if ($B._PyPegen.lookahead(0, $B._PyPegen.string_token, p) && (expression_without_invalid_var = expression_without_invalid_rule(p))) {
            _res = expression_without_invalid_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_278_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var star_targets_var;
          if ((star_targets_var = star_targets_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 22))) {
            _res = $B._PyPegen.dummy_name(p, star_targets_var, _literal);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_279_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var star_targets_var;
          if ((star_targets_var = star_targets_rule(p)) && (_literal = $B._PyPegen.expect_token(p, 22))) {
            _res = $B._PyPegen.dummy_name(p, star_targets_var, _literal);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_280_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 8)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 35)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_281_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 11)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 35)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_282_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _tmp_294_var;
        while (_tmp_294_var = _tmp_294_rule(p)) {
          _res = _tmp_294_var;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _tmp_283_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 12)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 8)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var newline_var;
          if (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) {
            _res = newline_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_284_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 12)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          if (_literal = $B._PyPegen.expect_token(p, 8)) {
            _res = _literal;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var newline_var;
          if (newline_var = $B._PyPegen.expect_token(p, NEWLINE)) {
            _res = newline_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_285_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var expression_var;
          if ((expression_var = expression_rule(p)) && (_opt_var = _tmp_295_rule(p), !p.error_indicator)) {
            _res = $B._PyPegen.dummy_name(p, expression_var, _opt_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_286_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var expressions_var;
          if ((expressions_var = expressions_rule(p)) && (_opt_var = _tmp_296_rule(p), !p.error_indicator)) {
            _res = $B._PyPegen.dummy_name(p, expressions_var, _opt_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_287_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var expression_var;
          if ((expression_var = expression_rule(p)) && (_opt_var = _tmp_297_rule(p), !p.error_indicator)) {
            _res = $B._PyPegen.dummy_name(p, expression_var, _opt_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_288_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _opt_var;
          UNUSED(_opt_var);
          var expressions_var;
          if ((expressions_var = expressions_rule(p)) && (_opt_var = _tmp_298_rule(p), !p.error_indicator)) {
            _res = $B._PyPegen.dummy_name(p, expressions_var, _opt_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_289_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var name_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 680)) && (name_var = $B._PyPegen.name_token(p))) {
            _res = $B._PyPegen.dummy_name(p, _keyword, name_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_290_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var fstring_var;
          if (fstring_var = fstring_rule(p)) {
            _res = fstring_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var string_var;
          if (string_var = string_rule(p)) {
            _res = string_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_291_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var assignment_expression_var;
          if (assignment_expression_var = assignment_expression_rule(p)) {
            _res = assignment_expression_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var expression_var;
          if ((expression_var = expression_rule(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 53)) {
            _res = expression_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _loop0_293_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      var _res = { value: NULL };
      _res = NULL;
      var _mark = p.mark;
      var _children = [];
      var _children_capacity = 1;
      var _n = 0;
      {
        if (p.error_indicator) {
          return NULL;
        }
        var _literal;
        var elem;
        while ((_literal = $B._PyPegen.expect_token(p, 12)) && (elem = _tmp_299_rule(p))) {
          _res = elem;
          _children[_n++] = _res;
          _mark = p.mark;
        }
        p.mark = _mark;
      }
      return _children;
    }
    function _gather_292_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var elem;
          var seq;
          if ((elem = _tmp_299_rule(p)) && (seq = _loop0_293_rule(p))) {
            _res = $B._PyPegen.seq_insert_in_front(p, elem, seq);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_294_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _literal;
          var bitwise_or_var;
          if ((_literal = $B._PyPegen.expect_token(p, 12)) && (bitwise_or_var = bitwise_or_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, _literal, bitwise_or_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_295_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var star_target_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 680)) && (star_target_var = star_target_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, _keyword, star_target_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_296_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var star_target_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 680)) && (star_target_var = star_target_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, _keyword, star_target_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_297_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var star_target_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 680)) && (star_target_var = star_target_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, _keyword, star_target_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_298_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _keyword;
          var star_target_var;
          if ((_keyword = $B._PyPegen.expect_token(p, 680)) && (star_target_var = star_target_rule(p))) {
            _res = $B._PyPegen.dummy_name(p, _keyword, star_target_var);
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_299_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var starred_expression_var;
          if (starred_expression_var = starred_expression_rule(p)) {
            _res = starred_expression_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var _tmp_300_var;
          if ((_tmp_300_var = _tmp_300_rule(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 22)) {
            _res = _tmp_300_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    function _tmp_300_rule(p) {
      if (p.error_indicator) {
        return NULL;
      }
      while (1) {
        var _res = NULL;
        var _mark = p.mark;
        {
          if (p.error_indicator) {
            return NULL;
          }
          var assignment_expression_var;
          if (assignment_expression_var = assignment_expression_rule(p)) {
            _res = assignment_expression_var;
            break;
          }
          p.mark = _mark;
        }
        {
          if (p.error_indicator) {
            return NULL;
          }
          var expression_var;
          if ((expression_var = expression_rule(p)) && $B._PyPegen.lookahead_with_int(0, $B._PyPegen.expect_token, p, 53)) {
            _res = expression_var;
            break;
          }
          p.mark = _mark;
        }
        _res = NULL;
        break;
      }
      return _res;
    }
    $B._PyPegen.parse = function(p) {
      p.keywords = reserved_keywords;
      p.n_keyword_lists = n_keyword_lists;
      p.soft_keywords = soft_keywords;
      switch (p.mode) {
        case "file":
          return file_rule(p);
        case "eval":
          return eval_rule(p);
        case "single":
          return interactive_rule(p);
        default:
          console.log("unknown mode", p.mode);
          throw Error(`unknown parse mode: ${p.mode}`);
      }
    };
    (function($B2) {
      $B2.whenReady = new Promise(function(resolve, reject) {
        resolve();
      });
    })(__BRYTHON__);
  }
});
export default require_brython();
//# sourceMappingURL=brython.js.map
